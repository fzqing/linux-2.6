#! /usr/bin/env bash
# Patch: -pro_mips_cavium_octeon
# Date: Tue Feb  6 08:14:22 2007
# Source: MontaVista Software, Inc.
# MR:16864 
# Type: Integration
# Disposition: needs submitting to linux-mips community
# Signed-off-by: Yadviga Grigorieva<yadviga@ru.mvista.com>
# Description: Cavium Octeon support
# 

PATCHNUM=1049
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR:16864 
Type: Integration
Disposition: needs submitting to linux-mips community
Signed-off-by: Yadviga Grigorieva<yadviga@ru.mvista.com>
Description: Cavium Octeon support

Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -1034,6 +1034,24 @@ if TOSHIBA_RBTX4939
 	source "arch/mips/tx4939/Kconfig"
 endif
 
+config CAVIUM_OCTEON_EBT3000
+	bool "Support for the Cavium Networks Octeon EBT3000 development board"
+	select MIPS64
+	select CPU_CAVIUM_OCTEON
+	select DMA_COHERENT
+	help
+	  The EBT3000 supports:
+	  Cavium Networks Octeon
+	  2 DDR1 or DDR2 dimms
+	  1 SPI4 port
+	  4 Gigabit RGMII.
+	  Low latency memory interface
+	  Say Y here to support this machine type.
+
+if CAVIUM_OCTEON_EBT3000
+	source "arch/mips/cavium-octeon/Kconfig"
+endif
+
 source "lib/Kconfig.RT"
 
 config RWSEM_GENERIC_SPINLOCK
@@ -1109,7 +1127,7 @@ config MIPS_DISABLE_OBSOLETE_IDE
 config CPU_LITTLE_ENDIAN
 	bool "Generate little endian code"
 	default y if ACER_PICA_61 || CASIO_E55 || DDB5074 || DDB5476 || DDB5477 || MACH_DECSTATION || IBM_WORKPAD || LASAT || MIPS_COBALT || MIPS_ITE8172 || MIPS_IVR || SOC_AU1X00 || NEC_OSPREY || OLIVETTI_M700 || SNI_RM200_PCI || VICTOR_MPC30X || ZAO_CAPCELLA || MIPS_AVALANCHE_SOC
-	default n if MIPS_EV64120 || MIPS_EV96100 || MOMENCO_OCELOT || MOMENCO_OCELOT_G || SGI_IP22 || SGI_IP27 || SGI_IP32 || TOSHIBA_JMR3927 || MARKEINS
+	default n if MIPS_EV64120 || MIPS_EV96100 || MOMENCO_OCELOT || MOMENCO_OCELOT_G || SGI_IP22 || SGI_IP27 || SGI_IP32 || TOSHIBA_JMR3927 || MARKEINS || CAVIUM_OCTEON_EBT3000
 	help
 	  Some MIPS machines can be configured for either little or big endian
 	  byte order. These modes require different kernels. Say Y if your
@@ -1127,6 +1145,9 @@ config IRQ_CPU_RM9K
 config IRQ_MV64340
 	bool
 
+config IRQ_CPU_OCTEON
+	bool
+
 config DDB5XXX_COMMON
 	bool
 	depends on DDB5074 || DDB5476 || DDB5477
@@ -1225,7 +1246,7 @@ config BOOT_ELF32
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION
-	default "7" if SGI_IP27
+	default "7" if SGI_IP27 || CPU_CAVIUM_OCTEON
 	default "5"
 
 config HAVE_STD_PC_SERIAL_PORT
@@ -1370,6 +1391,17 @@ config CPU_RM9000
 config CPU_SB1
 	bool "SB1"
 
+config CPU_CAVIUM_OCTEON
+	bool "Cavium Octeon processor"
+	select IRQ_CPU_OCTEON
+	select CPU_HAS_PREFETCH
+	select CPU_MIPS64
+	help
+	  The Cavium Octeon processor is a highly integrated chip containing
+	  many ethernet hardware widgets for networking tasks. The processor
+	  can have up to 16 Mips64v2 cores and 8 integrated gigabit ethernets.
+	  Full details can be found at http://www.caviumnetworks.com.
+
 endchoice
 
 choice
@@ -1526,7 +1558,7 @@ config HIGHMEM
 
 config SMP
 	bool "Multi-Processing support"
-	depends on (CPU_RM9000 || (SIBYTE_SB1250 && !SIBYTE_STANDALONE) || SGI_IP27) && CPU_HAS_LLSC
+	depends on (CPU_RM9000 || (SIBYTE_SB1250 && !SIBYTE_STANDALONE) || SGI_IP27 || CPU_CAVIUM_OCTEON) && CPU_HAS_LLSC
 	---help---
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -1551,6 +1583,7 @@ config NR_CPUS
 	range 2 64
 	depends on SMP
 	default "64" if SGI_IP27
+	default "16" if CPU_CAVIUM_OCTEON
 	default "2"
 	help
 	  This allows you to specify the maximum number of CPUs which this
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -215,6 +215,10 @@ cflags-$(CONFIG_CPU_R10000)	+= \
 			$(call set_gccflags,r10000,mips4,r8000,mips4,mips2) \
 			-Wa,--trap
 
+cflags-$(CONFIG_CPU_CAVIUM_OCTEON)	+= \
+			-mabi=64 -march=octeon \
+			-Wa,--trap
+
 ifdef CONFIG_CPU_SB1
 ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
 MODFLAGS	+= -msb1-pass1-workarounds
@@ -724,6 +728,13 @@ core-$(CONFIG_TOSHIBA_RBTX4939) += arch/
 cflags-$(CONFIG_TOSHIBA_RBTX4939) += -Iinclude/asm-mips/tx4939
 load-$(CONFIG_TOSHIBA_RBTX4939) += 0xffffffff80100000
 
+#
+# Cavium Octeon
+#
+core-$(CONFIG_CPU_CAVIUM_OCTEON)      += arch/mips/cavium-octeon/
+cflags-$(CONFIG_CPU_CAVIUM_OCTEON)    += -Iinclude/asm-mips/mach-cavium-octeon
+load-$(CONFIG_CPU_CAVIUM_OCTEON)      += 0xffffffff81100000
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
Index: linux-2.6.10/arch/mips/cavium-octeon/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/Kconfig
@@ -0,0 +1,82 @@
+config CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	bool "Enable Octeon specific options"
+	depends on CPU_CAVIUM_OCTEON
+	default "y"
+
+config CAVIUM_OCTEON_HW_FIX_UNALIGNED
+	bool "Enable hardware fixups of unaligned loads and stores"
+	depends on CPU_CAVIUM_OCTEON
+	default "y"
+	help
+	  Configure the Octeon hardware to automatically fix unaligned loads
+	  and stores. Normally unaligned accesses are fixed using a kernel
+	  exception handler. This option enables the hardware automatic fixups,
+	  which requires only an extra 3 cycles. Disable this option if you
+	  are running code that relies on address exceptions on unaligned
+	  accesses.
+
+config CAVIUM_OCTEON_CVMSEG_SIZE
+	int "Number of L1 cache lines reserved for CVMSEG memory"
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	range 0 54
+	default 0
+	help
+          CVMSEG LM is a segment that accesses portions of the dcache as a
+	  local memory; the larger CVMSEG is, the smaller the cache is.
+	  This selects the size of CVMSEG LM, which is in cache blocks. The
+	  legally range is from zero to 54 cache blocks (i.e. CVMSEG LM is
+	  between zero and 6192 bytes).
+
+config CAVIUM_OCTEON_USER_IO
+	bool "Allow User space to access hardware IO directly"
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	help
+	  Allows user applications to directly access the Octeon hardware
+	  IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
+	  performance networking applications to run in user space with minimal
+	  performance penalties. This also means a user application can bring
+	  down the entire system. Only use this option on embedded devices
+	  where all user applications are strictly controlled.
+
+config CAVIUM_OCTEON_USER_MEM
+	bool "Allow User space to access memory directly"
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	depends on CAVIUM_OCTEON_USER_IO
+	help
+	  Allows user applications to use XKPHYS addresses directly to memory.
+	  This allows user space direct access to shared memory not in use by
+	  Linux. This memory is suitable for use with the Octeon hardware.
+	  Cavium simple executive applications also share this memory. Since
+	  this bypass all of the Linux memory protection, only use this option
+	  on embedded devices where all user applications are strictly
+	  controlled.
+
+config CAVIUM_RESERVE32
+	int "Memory to reserve for user processes shared region (MB)"
+	range 0 1024
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	depends on CAVIUM_OCTEON_USER_IO
+	default "0"
+	help
+	  Reserve shared memory area for user processes locked in the TLB
+	  for fast access. This memory is accessable from all user processes.
+	  The address range for the region is from 0x80000000-reserved to
+	  0x80000000-1. The size must be a multiple of 512 (0, 512, or 1024)..
+
+config CAVIUM_OCTEON_NUM_PACKET_BUFFERS
+	int "Number of packet buffers (and work queue entries) for shared access"
+	range 0 8192
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	depends on CAVIUM_OCTEON_USER_IO
+	default "0"
+	help
+	  Number of packet buffers (and work queue entries) to allocate from
+	  reserved user memory. These buffers are in the userspace address
+	  range and may be used for zero copy access to ethernet packets from
+	  userspace. Normal kernel ethernet performance will suffer since
+	  received ethernet packets will need to be copied from these buffers
+	  into the normal kernel skbuf structures. Only use this option if
+	  high performance ethernet is need in userspace, bypassing the kernel.
+	  This will reduce the userspace shared region by
+	  (2048 + 128) * (number of buffers).
+
Index: linux-2.6.10/arch/mips/cavium-octeon/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the Cavium Octeon specific kernel interface routines
+# under Linux.
+#
+
+obj-y                                 := setup.o serial.o int_handler.o hal.o adel_workaround.o perf_counters.o octeon_info.o
+obj-$(CONFIG_SMP)                     += smp.o
+obj-$(CONFIG_CAVIUM_OCTEON_USER_IO)   += userio.o
+obj-$(CONFIG_CAVIUM_OCTEON_EBT3000)   += ebt3000_cf.o
+
Index: linux-2.6.10/arch/mips/cavium-octeon/adel_workaround.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/adel_workaround.S
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2005 Cavium Networks
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This code is a workaround for a bug in the first two batches of Octeon
+ * Pass 1. The bug sometimes causes bus errors in userspace if a kernel
+ * address is in the internal return stack used for code prefetching. This
+ * workaround is mapped into a userspace address and called at the end of
+ * interrupt or exception processing. It performs four "jal" calls to make
+ * sure kernel addresses are flushed out of the internal return stack. A
+ * fix has already been sent, so all these chips will be recalled june 2005.
+ * This code assumes it was called with a "jal k0" instruction.
+ */
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	.text
+	.set	noat
+	.set 	noreorder
+	.align  12
+	NESTED(octeon_adel_workaround, PT_SIZE, sp)
+	or	k0, ra, ra
+	bgezal	$0, 1f
+	nop
+1:	bgezal	$0, 2f
+	nop
+2:	bgezal	$0, 3f
+	nop
+3:	bgezal	$0, 4f
+	nop
+4:	jr	k0
+	nop
+	.align	12
+	END(octeon_adel_workaround)
+
Index: linux-2.6.10/arch/mips/cavium-octeon/cvmx-bootmem-shared.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/cvmx-bootmem-shared.c
@@ -0,0 +1,602 @@
+/*************************************************************************
+Copyright (c) 2004-2005 Cavium Networks (support@cavium.com). All rights
+reserved.
+
+This file is subject to the terms and conditions of the GNU General Public
+License.  See the file "COPYING" in the main directory of this archive
+for more details.
+
+*************************************************************************/
+
+/**
+ * @file
+ * Simple allocate only memory allocator.  Used by the bootloader and applications
+ *
+ * Note: Simple executive applications should only use the cvmx_bootmem_* functions,
+ * as the functions in this file are not meant to be used directly.
+ *
+ * $Id: pro_mips_cavium_octeon.patch,v 1.1.2.7 2007/01/27 05:20:47 cminyard Exp $
+ *
+ */
+
+
+/* Note:  This file is also #included by the bootloader, as the memory alloc routine is
+shared between programs.
+*/
+
+#if !defined(CONFIG_OCTEON_U_BOOT) && !defined(__KERNEL__)
+#include <cvmx.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#endif
+
+#include "cvmx-bootmem-shared.h"
+
+#undef	MAX
+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+
+#undef	MIN
+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
+
+#define ALIGN_ADDR_UP(addr, align)     (((addr) + (~(align))) & (align))
+
+
+void octeon_write64(uint64_t addr, uint64_t val);
+uint64_t octeon_read64(uint64_t addr);
+void octeon_phy_mem_set_size(uint64_t addr, uint64_t size);
+void octeon_phy_mem_set_next(uint64_t addr, uint64_t next);
+uint64_t octeon_phy_mem_get_size(uint64_t addr);
+uint64_t octeon_phy_mem_get_next(uint64_t addr);
+
+
+/**
+ * Allocates a block of physical memory from the free list, at (optional) requested address and alignment.
+ *
+ * @param bootmem_desc_ptr   Pointer to the CVMX bootmem descriptor.
+ * @param req_size      size of region to allocate.  All requests are rounded up to 8 byte size
+ * @param address_min   Minimum address that block can occupy.
+ * @param address_max   Specifies the maximum address_min (inclusive) that the allocation can use.
+ * @param alignment Requested alignment of the block.  If this alignment cannot be met, the allocation fails.
+ *                  This must be a power of 2.
+ *                  (Note: Alignment of 8 bytes is required, and internally enforced.  Requested alignments of
+ *                  less than 8 are set to 8.)
+ *
+ * @return address_min of block allocated, or 0 on failure
+ */
+uint64_t octeon_phy_mem_block_alloc(cvmx_bootmem_desc_t *bootmem_desc_ptr, uint64_t req_size, uint64_t address_min, uint64_t address_max, uint64_t alignment)
+{
+
+    uint64_t head_addr = bootmem_desc_ptr->head_addr;
+    uint64_t ent_addr;
+    uint64_t prev_addr = 0;  /* points to previous list entry, NULL current entry is head of list */
+    uint64_t new_ent_addr = 0;
+    uint64_t desired_min_addr;
+    uint64_t alignment_mask = ~(alignment - 1);
+
+#ifdef DEBUG
+    printf("block alloc called: req_size: 0x%qx, min_addr: 0x%qx, max_addr: 0x%qx, align: 0x%qx\n",
+	   (unsigned long long)req_size, (unsigned long long)address_min, (unsigned long long)address_max, (unsigned long long)alignment);
+#endif
+
+    if (bootmem_desc_ptr->major_version > 3)
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n", bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+	return(0);
+    }
+
+    /* Do a variety of checks to validate the arguments.  The allocator code will later assume
+    ** that these checks have been made.  We validate that the requested constraints are not
+    ** self-contradictory before we look through the list of available memory
+    */
+
+    /* 0 is not a valid req_size for this allocator */
+    if (!req_size)
+	return(0);
+
+    /* Convert !0 address_min and 0 address_max to special case of range that specifies an exact
+    ** memory block to allocate.  Do this before other checks and adjustments so that this tranformation will be validated */
+    if (address_min && !address_max)
+	address_max = address_min + req_size;
+    else if (!address_min && !address_max)
+	address_max = ~0ull;   /* If no limits given, use max limits */
+
+
+#if defined(__linux__) && defined(CVMX_ABI_N32) && !defined(CONFIG_OCTEON_U_BOOT)
+    extern uint64_t linux_mem32_min;
+    extern uint64_t linux_mem32_max;
+    printf("min: 0x%llx, max: 0x%llx\n", linux_mem32_min, linux_mem32_max);
+    /* For 32 bit Linux apps, we need to restrict the allocations to the range
+    ** of memory configured for access from userspace.  Also, we need to add mappings
+    ** for the data structures that we access.*/
+
+    /* Reject specific location requests that are not fully within bounds */
+    if (req_size == address_max - address_min && ((address_min > linux_mem32_max || address_min < linux_mem32_min)))
+	return(0);
+
+    /* Narrow range requests to be bounded by the 32 bit limits.  octeon_phy_mem_block_alloc()
+    ** will reject inconsistent req_size/range requests, so we don't repeat those checks here.
+    ** If max unspecified, set to 32 bit maximum. */
+    address_min = MIN(MAX(address_min, linux_mem32_min), linux_mem32_max);
+    if (!address_max)
+	address_max = linux_mem32_max;
+    else
+	address_max = MAX(MIN(address_max, linux_mem32_max), linux_mem32_min);
+#endif
+
+
+    /* Round req_size up to mult of minimum alignment bytes */
+    req_size = (req_size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) & ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
+
+    /* Verify that requested minimum address meets minimum alignment requirements */
+    if (address_min & (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1))
+	return(0);
+
+    /* Adjust address minimum based on requested alignment (round up to meet alignment).  Do this here so we can
+    ** reject impossible requests up front. (NOP for address_min == 0) */
+    if (alignment)
+	address_min = (address_min + (alignment - 1)) & ~(alignment - 1);
+
+
+    /* Reject inconsistent args.  We have adjusted these, so this may fail due to our internal changes
+    ** even if this check would pass for the values the user supplied. */
+    if (req_size > address_max - address_min)
+	return(0);
+
+
+    /* Enforce minimum alignment (this also keeps the minimum free block
+    ** req_size the same as the alignment req_size */
+    if (alignment < CVMX_BOOTMEM_ALIGNMENT_SIZE)
+    {
+	alignment = CVMX_BOOTMEM_ALIGNMENT_SIZE;
+    }
+    alignment_mask = ~(alignment - 1);
+
+
+    /* Walk through the list entries - first fit found is returned */
+    ent_addr = head_addr;
+    while (ent_addr)
+    {
+	uint64_t usable_base, usable_max;
+	uint64_t ent_size = octeon_phy_mem_get_size(ent_addr);
+
+	if (octeon_phy_mem_get_next(ent_addr) && ent_addr > octeon_phy_mem_get_next(ent_addr))
+	{
+	    printf("Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx\n",
+		   (unsigned long long)ent_addr, (unsigned long long)octeon_phy_mem_get_next(ent_addr));
+	    return(0);
+	}
+
+	/* Determine if this is an entry that can satisify the request */
+	/* Check to make sure entry is large enough to satisfy request */
+	usable_base = ALIGN_ADDR_UP(MAX(address_min, ent_addr), alignment_mask);
+	usable_max = MIN(address_max, ent_addr + ent_size);
+	/* We should be able to allocate block at address usable_base */
+
+	desired_min_addr = usable_base;
+
+	/* Determine if request can be satisfied from the current entry */
+	if ((((ent_addr + ent_size) > usable_base && ent_addr < address_max))
+	    && req_size <= usable_max - usable_base)
+	{
+	    /* We have found an entry for the request, so allocate from the entry as
+	    ** required.
+	    */
+
+	    /* Match at start of entry */
+	    if (desired_min_addr == ent_addr)
+	    {
+		if (req_size < ent_size)
+		{
+		    /* big enough to create a new block from top portion of block */
+		    new_ent_addr = ent_addr + req_size;
+		    octeon_phy_mem_set_next(new_ent_addr, octeon_phy_mem_get_next(ent_addr));
+		    octeon_phy_mem_set_size(new_ent_addr, ent_size - req_size);
+
+		    /* Adjust next pointer as following code uses this */
+		    octeon_phy_mem_set_next(ent_addr, new_ent_addr);
+		}
+
+		/* adjust prev ptr or head to remove this entry from list */
+		if (prev_addr)
+		{
+		    octeon_phy_mem_set_next(prev_addr, octeon_phy_mem_get_next(ent_addr));
+		}
+		else
+		{
+		    /* head of list being returned, so update head ptr */
+		    bootmem_desc_ptr->head_addr = octeon_phy_mem_get_next(ent_addr);
+		}
+		return(desired_min_addr);
+	    }
+
+
+	    /* block returned doesn't start at beginning of entry, so we know
+	    ** that we will be splitting a block off the front of this one.  Create a new block
+	    ** from the beginning, add to list, and go to top of loop again.
+	    **
+	    ** create new block from high portion of block, so that top block
+	    ** starts at desired addr
+	    **/
+	    new_ent_addr = desired_min_addr;
+	    octeon_phy_mem_set_next(new_ent_addr, octeon_phy_mem_get_next(ent_addr));
+	    octeon_phy_mem_set_size(new_ent_addr, octeon_phy_mem_get_size(ent_addr) - (desired_min_addr - ent_addr));
+	    octeon_phy_mem_set_size(ent_addr, desired_min_addr - ent_addr);
+	    octeon_phy_mem_set_next(ent_addr, new_ent_addr);
+	    /* Loop again to handle actual alloc from new block */
+	}
+
+	prev_addr = ent_addr;
+	ent_addr = octeon_phy_mem_get_next(ent_addr);
+    }
+
+    /* We didn't find anything, so return error */
+    return(0);
+}
+
+
+/**
+ * Frees a block to the bootmem allocator list.  This must
+ * be used with care, as the size provided must match the size
+ * of the block that was allocated, or the list will become
+ * corrupted.
+ * NOTE:  This allocator is not intended to be a generic replacement
+ * for malloc.
+ * @param bootmem_desc_ptr pointer to the bootmem descriptor block
+ * @param phy_addr   physical address of block
+ * @param size   size of block in bytes.
+ *
+ * @return 1 on success,
+ *         0 on failure
+ */
+int octeon_phy_mem_block_free(cvmx_bootmem_desc_t *bootmem_desc_ptr, uint64_t phy_addr, uint64_t size)
+{
+    uint64_t cur_addr = bootmem_desc_ptr->head_addr;
+    uint64_t prev_addr = 0;  /* zero is invalid */
+
+    if (bootmem_desc_ptr->major_version > 3)
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n", bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+	return(0);
+    }
+
+    /* 0 is not a valid size for this allocator */
+    if (!size)
+	return(0);
+
+
+    if (cur_addr == 0 || phy_addr < cur_addr)
+    {
+	/* add at front of list - special case with changing head ptr */
+	if (cur_addr && phy_addr + size > cur_addr)
+	    return(0); /* error, overlapping section */
+	else if (phy_addr + size == cur_addr)
+	{
+	    /* Add to front of existing first block */
+	    octeon_phy_mem_set_next(phy_addr, octeon_phy_mem_get_next(cur_addr));
+	    octeon_phy_mem_set_size(phy_addr, octeon_phy_mem_get_size(cur_addr) + size);
+	    bootmem_desc_ptr->head_addr = phy_addr;
+
+	}
+	else
+	{
+	    /* New block before first block */
+	    octeon_phy_mem_set_next(phy_addr, cur_addr);  /* OK if cur_addr is 0 */
+	    octeon_phy_mem_set_size(phy_addr, size);
+	    bootmem_desc_ptr->head_addr = phy_addr;
+	}
+	return(1);
+    }
+
+    /* Find place in list to add block */
+    while (cur_addr && phy_addr > cur_addr)
+    {
+	prev_addr = cur_addr;
+	cur_addr = octeon_phy_mem_get_next(cur_addr);
+    }
+
+    if (!cur_addr)
+    {
+	/* We have reached the end of the list, add on to end, checking
+	** to see if we need to combine with last block
+	**/
+	if (prev_addr +  octeon_phy_mem_get_size(prev_addr) == phy_addr)
+	{
+	    octeon_phy_mem_set_size(prev_addr, octeon_phy_mem_get_size(prev_addr) + size);
+	}
+	else
+	{
+	    octeon_phy_mem_set_next(prev_addr, phy_addr);
+	    octeon_phy_mem_set_size(phy_addr, size);
+	    octeon_phy_mem_set_next(phy_addr, 0);
+	}
+	return(1);
+    }
+    else
+    {
+	/* insert between prev and cur nodes, checking for merge with either/both */
+
+	if (prev_addr +  octeon_phy_mem_get_size(prev_addr) == phy_addr)
+	{
+	    /* Merge with previous */
+	    octeon_phy_mem_set_size(prev_addr, octeon_phy_mem_get_size(prev_addr) + size);
+	    if (phy_addr + size == cur_addr)
+	    {
+		/* Also merge with current */
+		octeon_phy_mem_set_size(prev_addr, octeon_phy_mem_get_size(cur_addr) + octeon_phy_mem_get_size(prev_addr));
+		octeon_phy_mem_set_next(prev_addr, octeon_phy_mem_get_next(cur_addr));
+	    }
+	    return(1);
+	}
+	else if (phy_addr + size == cur_addr)
+	{
+	    /* Merge with current */
+	    octeon_phy_mem_set_size(phy_addr, octeon_phy_mem_get_size(cur_addr) + size);
+	    octeon_phy_mem_set_next(phy_addr, octeon_phy_mem_get_next(cur_addr));
+	    octeon_phy_mem_set_next(prev_addr, phy_addr);
+	    return(1);
+	}
+
+	/* It is a standalone block, add in between prev and cur */
+	octeon_phy_mem_set_size(phy_addr, size);
+	octeon_phy_mem_set_next(phy_addr, cur_addr);
+	octeon_phy_mem_set_next(prev_addr, phy_addr);
+
+
+    }
+    return(1);
+
+}
+
+/**
+ * Prints the list of available memory.
+ *
+ * @param bootmem_desc_ptr
+ *               pointer to bootmem descriptor block
+ */
+void octeon_phy_mem_list_print(cvmx_bootmem_desc_t *bootmem_desc_ptr)
+{
+    uint64_t addr;
+
+    addr = bootmem_desc_ptr->head_addr;
+    printf("\n\n\nPrinting bootmem block list, descriptor: %p,  head is 0x%qx\n",
+	   bootmem_desc_ptr, (unsigned long long)addr);
+    printf("Descriptor version: %d.%d\n", bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+    if (bootmem_desc_ptr->major_version > 3)
+    {
+	printf("Warning: Bootmem descriptor version is newer than expected\n");
+    }
+    if (!addr)
+    {
+	printf("mem list is empty!\n");
+    }
+    while (addr)
+    {
+	printf("Block address: 0x%08qx, size: 0x%08qx, next: 0x%08qx\n",
+	       (unsigned long long)addr,
+	       (unsigned long long)octeon_phy_mem_get_size(addr),
+	       (unsigned long long)octeon_phy_mem_get_next(addr));
+	addr = octeon_phy_mem_get_next(addr);
+    }
+    printf("\n\n");
+
+}
+
+/**
+ * Returns the size of available memory in bytes, only
+ * counting blocks that are at least as big as the minimum block
+ * size.
+ *
+ * @param bootmem_desc_ptr
+ *               pointer to bootmem descriptor block
+ * @param min_block_size
+ *               Minimum block size to count in total.
+ *
+ * @return Number of bytes available for allocation that meet the block size requirement
+ */
+uint64_t octeon_phy_mem_list_available_mem(cvmx_bootmem_desc_t *bootmem_desc_ptr, uint64_t min_block_size)
+{
+    uint64_t addr;
+
+    uint64_t available_mem = 0;
+    addr = bootmem_desc_ptr->head_addr;
+    while (addr)
+    {
+	if (octeon_phy_mem_get_size(addr) >= min_block_size)
+	    available_mem += octeon_phy_mem_get_size(addr);
+	addr = octeon_phy_mem_get_next(addr);
+    }
+    return(available_mem);
+
+}
+
+/**
+ * Internal version of named block find - Finds a named memory block by name.
+ *
+ * @param bootmem_desc_ptr
+ *               Pointer to bootmem memory descriptor block (cvmx_bootmem_desc_t).
+ * @param name   Name of memory block to find.
+ *               If NULL pointer given, then finds unused descriptor, if available.
+ *
+ * @return Pointer to memory block descriptor, NULL if not found.
+ *         If NULL returned when name parameter is NULL, then no memory
+ *         block descriptors are available.
+ */
+static cvmx_bootmem_named_block_desc_t * octeon_phy_mem_named_block_find_internal(cvmx_bootmem_desc_t *bootmem_desc_ptr, char *name)
+{
+    unsigned int i;
+
+    /* Need to use mmapped named block pointer in 32 bit linux apps */
+#if defined(__linux__) && defined(CVMX_ABI_N32) && !defined(CONFIG_OCTEON_U_BOOT)
+extern cvmx_bootmem_named_block_desc_t *linux32_named_block_array_ptr;
+    cvmx_bootmem_named_block_desc_t *named_block_array_ptr = linux32_named_block_array_ptr;
+#else
+    cvmx_bootmem_named_block_desc_t *named_block_array_ptr = (cvmx_bootmem_named_block_desc_t *)cvmx_phys_to_ptr(bootmem_desc_ptr->named_block_array_addr);
+#endif
+
+    if (bootmem_desc_ptr->major_version == 3)
+    {
+	for (i = 0; i < bootmem_desc_ptr->named_block_num_blocks; i++)
+	{
+	    if ((name && named_block_array_ptr[i].size && !strncmp(name, named_block_array_ptr[i].name, bootmem_desc_ptr->named_block_name_len - 1))
+		|| (!name && !named_block_array_ptr[i].size))
+	    {
+
+		return(&(named_block_array_ptr[i]));
+	    }
+	}
+    }
+    else
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n",
+	       bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+    }
+    return(NULL);
+
+
+}
+/**
+ * Finds a named memory block by name.
+ *
+ * @param bootmem_desc_ptr
+ *               Pointer to bootmem memory descriptor block (cvmx_bootmem_desc_t).
+ * @param name   Name of memory block to find.
+ *               If NULL pointer given, then finds unused descriptor, if available.
+ *
+ * @return Pointer to memory block descriptor, NULL if not found.
+ *         If NULL returned when name parameter is NULL, then no memory
+ *         block descriptors are available.
+ */
+cvmx_bootmem_named_block_desc_t * octeon_phy_mem_named_block_find(cvmx_bootmem_desc_t *bootmem_desc_ptr, char *name)
+{
+    cvmx_bootmem_named_block_desc_t *block_ptr;
+
+    /* Lock the structure to make sure that it is not being changed while we are
+    ** examining it.
+    */
+    octeon_lock(CAST64(&(bootmem_desc_ptr->lock)));
+    block_ptr = octeon_phy_mem_named_block_find_internal(bootmem_desc_ptr, name);
+    octeon_unlock(CAST64(&(bootmem_desc_ptr->lock)));
+    return(block_ptr);
+
+}
+int octeon_phy_mem_named_block_free(cvmx_bootmem_desc_t *bootmem_desc_ptr, char *name)
+{
+    cvmx_bootmem_named_block_desc_t *named_block_ptr;
+
+
+    if (bootmem_desc_ptr->major_version != 3)
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n",
+	       bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+	return(0);
+    }
+    /* Take lock here, as name lookup/block free/name free need to be atomic */
+    octeon_lock(CAST64(&(bootmem_desc_ptr->lock)));
+    named_block_ptr = octeon_phy_mem_named_block_find_internal(bootmem_desc_ptr, name);
+    if (named_block_ptr)
+    {
+	octeon_phy_mem_block_free(bootmem_desc_ptr, named_block_ptr->base_addr, named_block_ptr->size);
+	named_block_ptr->size = 0;
+	/* Set size to zero to indicate block not used. */
+
+
+    }
+    octeon_unlock(CAST64(&(bootmem_desc_ptr->lock)));
+    return(!!named_block_ptr);  /* 0 on failure, 1 on success */
+
+}
+void octeon_phy_mem_named_block_print(cvmx_bootmem_desc_t *bootmem_desc_ptr)
+{
+    unsigned int i;
+    int printed = 0;
+
+    /* Need to use mmapped named block pointer in 32 bit linux apps */
+#if defined(__linux__) && defined(CVMX_ABI_N32) && !defined(CONFIG_OCTEON_U_BOOT)
+extern cvmx_bootmem_named_block_desc_t *linux32_named_block_array_ptr;
+    cvmx_bootmem_named_block_desc_t *named_block_array_ptr = linux32_named_block_array_ptr;
+#else
+    cvmx_bootmem_named_block_desc_t *named_block_array_ptr = (cvmx_bootmem_named_block_desc_t *)cvmx_phys_to_ptr(bootmem_desc_ptr->named_block_array_addr);
+#endif
+
+    if (bootmem_desc_ptr->major_version != 3)
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n",
+	       bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+	return;
+    }
+    printf("List of currently allocated named bootmem blocks:\n");
+    for (i = 0; i < bootmem_desc_ptr->named_block_num_blocks; i++)
+    {
+	if (named_block_array_ptr[i].size)
+	{
+	    printed++;
+	    printf("Name: %s, address: 0x%08qx, size: 0x%08qx, index: %d\n",
+		   named_block_array_ptr[i].name,
+		   (unsigned long long)named_block_array_ptr[i].base_addr,
+		   (unsigned long long)named_block_array_ptr[i].size,
+		   i);
+
+	}
+    }
+    if (!printed)
+    {
+	printf("No named bootmem blocks exist.\n");
+    }
+
+}
+uint64_t octeon_phy_mem_named_block_alloc(cvmx_bootmem_desc_t *bootmem_desc_ptr, uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t alignment, char *name)
+{
+    uint64_t addr_allocated;
+    cvmx_bootmem_named_block_desc_t *named_block_desc_ptr;
+
+    if (bootmem_desc_ptr->major_version != 3)
+    {
+	printf("ERROR: Incompatible bootmem descriptor version: %d.%d\n",
+	       bootmem_desc_ptr->major_version, bootmem_desc_ptr->minor_version);
+	return(0);
+    }
+
+
+    /* Take lock here, as name lookup/block alloc/name add need to be atomic */
+    octeon_lock(CAST64(&(bootmem_desc_ptr->lock)));
+
+
+    /* Get pointer to first available named block descriptor */
+    named_block_desc_ptr = octeon_phy_mem_named_block_find_internal(bootmem_desc_ptr, NULL);
+
+    /* Check to see if name already in use, return error if name
+    ** not available or no more room for blocks.
+    */
+    if (octeon_phy_mem_named_block_find_internal(bootmem_desc_ptr, name) || !named_block_desc_ptr)
+    {
+	octeon_unlock(CAST64(&(bootmem_desc_ptr->lock)));
+	return(0);
+    }
+
+
+    /* Round size up to mult of minimum alignment bytes
+    ** We need the actual size allocated to allow for blocks to be coallesced
+    ** when they are freed.  The alloc routine does the same rounding up
+    ** on all allocations. */
+    size = (size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) & ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
+
+    addr_allocated = octeon_phy_mem_block_alloc(bootmem_desc_ptr, size, min_addr, max_addr, alignment);
+    if (addr_allocated)
+    {
+	named_block_desc_ptr->base_addr = addr_allocated;
+	named_block_desc_ptr->size = size;
+	strncpy(named_block_desc_ptr->name, name, bootmem_desc_ptr->named_block_name_len);
+	named_block_desc_ptr->name[bootmem_desc_ptr->named_block_name_len - 1] = 0;
+    }
+    else
+    {
+	printf("octeon_phy_mem_named_block_alloc: alloc failed!\n");
+    }
+
+
+    octeon_unlock(CAST64(&(bootmem_desc_ptr->lock)));
+    return(addr_allocated);
+
+}
+
Index: linux-2.6.10/arch/mips/cavium-octeon/ebt3000_cf.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -0,0 +1,476 @@
+/*
+ * Extra-simple block driver for the Octeon EBT3000 compact flash. This
+ * driver is based on the excellent article and example code from LWM.
+ * http://lwn.net/Articles/58719/
+ *
+ * Copyright 2005 Cavium Networks, Inc.  Redistributable under the terms
+ * of the GNU GPL.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include <linux/completion.h>
+
+#include <hal.h>
+
+#define VERSION "1.0"
+#define DEVICE_NAME "cf"
+MODULE_LICENSE("GPL");
+
+/*
+ * We can tweak our hardware sector size, but the kernel talks to us
+ * in terms of small sectors, always.
+ */
+#define KERNEL_SECTOR_SIZE 512
+
+/*
+ * The internal representation of our device.
+ */
+
+typedef struct {
+	volatile unsigned char *ata_command;
+	unsigned long num_sectors;
+	unsigned long sector_size;
+	struct gendisk *gd;
+	spinlock_t lock;
+	request_queue_t *queue;
+	struct completion comp;
+} cf_device_t;
+
+static cf_device_t STATIC_DEVICE;
+
+/**
+ * Check if the Compact flash is idle and doesn't have any
+ * errors.
+ *
+ * @param cf     Device to check
+ * @return Zero on success
+ */
+static inline int ata_wait_idle(cf_device_t * cf)
+{
+	unsigned char status;
+	cycles_t start_time = get_cycles();
+
+	octeon_led_set(0, 30);
+	status = cf->ata_command[7];
+	while (status & 0x80) {
+		if (unlikely(get_cycles() - start_time > mips_hpt_frequency))
+			break;
+
+		udelay(5);
+		status = cf->ata_command[7];
+	}
+	octeon_led_clear(0, 30);
+
+	if (unlikely(status & 0x80)) {
+		if (cf->gd)
+			printk("%s: Timeout\n", cf->gd->disk_name);
+		return -1;
+	} else if (unlikely(status & 1)) {
+		if (cf->gd)
+			printk("%s: Error\n", cf->gd->disk_name);
+		return -1;
+	} else
+		return 0;
+}
+
+/**
+ * Send low level ATA command to the device
+ *
+ * @param cf      Device to send commadn to
+ * @param sectors Number of sectors for access
+ * @param lba     Logical block address
+ * @param command ATA command
+ * @return Zero on success
+ */
+static int ata_command(cf_device_t * cf, int sectors, unsigned long lba,
+		       int command)
+{
+	/* Wait to not be busy before we start */
+	if (ata_wait_idle(cf))
+		return -1;
+
+	cf->ata_command[2] = sectors;
+	cf->ata_command[3] = (lba & 0xff);
+	cf->ata_command[4] = ((lba >> 8) & 0xff);
+	cf->ata_command[5] = ((lba >> 16) & 0xff);
+	cf->ata_command[6] = ((lba >> 24) & 0xff) | 0xe0;	// LBA | Drive 0
+	cf->ata_command[7] = command;
+
+	return 0;
+}
+
+/**
+ * Identify the compact flash
+ *
+ * @param cf         Device to access
+ * @param drive_info IDE drive information
+ * @return Zero on success
+ */
+static int ata_identify(cf_device_t * cf, struct hd_driveid *drive_info)
+{
+	unsigned char *ptr;
+	int count;
+
+	if (ata_command(cf, 0, 0, WIN_IDENTIFY))
+		return -1;
+
+	/* Wait for read to complete (BSY clear) */
+	if (ata_wait_idle(cf))
+		return -1;
+
+	ptr = (unsigned char *)drive_info;
+	for (count = 0; count < sizeof(*drive_info); count++)
+		*ptr++ = cf->ata_command[0];
+
+	ide_fix_driveid(drive_info);
+	ide_fixstring(drive_info->model, sizeof(drive_info->model), 0);
+	ide_fixstring(drive_info->fw_rev, sizeof(drive_info->fw_rev), 0);
+	ide_fixstring(drive_info->serial_no, sizeof(drive_info->serial_no), 0);
+	return 0;
+}
+
+/**
+ * Read sectors from the device
+ *
+ * @param cf        Device to read from
+ * @param lba_start Start sector
+ * @param num_sectors
+ *                  Number of sectors to read
+ * @param buffer    Buffer to put the results in
+ * @return Number of sectors read
+ */
+static int ata_read(cf_device_t * cf, unsigned long lba_start,
+		    unsigned long num_sectors, char *buffer)
+{
+	int sectors_read = 0;
+
+	octeon_led_set(0, 31);
+	while (num_sectors--) {
+		int count;
+
+		if (ata_command(cf, 1, lba_start++, WIN_READ))
+			break;
+
+		/* Wait for read to complete (BSY clear) */
+		if (ata_wait_idle(cf))
+			break;
+
+		sectors_read++;
+		for (count = 0; count < cf->sector_size; count++)
+			*buffer++ = cf->ata_command[0];
+	}
+	octeon_led_clear(0, 31);
+
+	return sectors_read;
+}
+
+/**
+ * Write sectors to the device
+ *
+ * @param cf        Device to write to
+ * @param lba_start Starting sector number
+ * @param num_sectors
+ *                  Number of sectors to write
+ * @param buffer    Data buffer to write
+ * @return Number of sectors written
+ */
+static int ata_write(cf_device_t * cf, unsigned long lba_start,
+		     unsigned long num_sectors, const char *buffer)
+{
+	int sectors_written = 0;
+
+	octeon_led_set(1, 31);
+	while (num_sectors--) {
+		int count;
+
+		if (ata_command(cf, 1, lba_start++, WIN_WRITE))
+			break;
+
+		/* Wait for write command to be ready for data (BSY clear) */
+		if (ata_wait_idle(cf))
+			break;
+
+		for (count = 0; count < cf->sector_size; count++) {
+			cf->ata_command[0] = *buffer++;
+			/* Every 16 writes do a read so the bootbus FIFO doesn't fill up */
+			if ((count & 0xf) == 0)
+				cf->ata_command[7];
+		}
+
+		/* Wait for write to complete (BSY clear) */
+		if (ata_wait_idle(cf))
+			break;
+
+		sectors_written++;
+	}
+	octeon_led_clear(1, 31);
+
+	return sectors_written;
+}
+
+/**
+ * Identify a compact flash disk
+ *
+ * @param cf     Device to check and update
+ * @return Zero on success. Failure will result in a device of zero
+ *         size and a -1 return code.
+ */
+static int ebt3000cf_identify(cf_device_t * cf)
+{
+	struct hd_driveid drive_info;
+	int result;
+
+	memset(&drive_info, 0, sizeof(drive_info));
+
+	result = ata_identify(cf, &drive_info);
+	if (result == 0) {
+		/* Sandisk 1G reports the wrong sector size */
+		drive_info.sector_bytes = 512;
+		printk("%s: %s Serial %s (%u sectors, %u bytes/sector)\n",
+		       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
+		       drive_info.model, drive_info.serial_no,
+		       drive_info.lba_capacity, (int)drive_info.sector_bytes);
+		cf->num_sectors = drive_info.lba_capacity;
+		cf->sector_size = drive_info.sector_bytes;
+	} else {
+		cf->num_sectors = 0;
+		cf->sector_size = KERNEL_SECTOR_SIZE;
+	}
+
+	return result;
+}
+
+/**
+ * Handle an I/O request.
+ *
+ * @param cf         Device to access
+ * @param lba_sector Starting sector
+ * @param num_sectors
+ *                   Number of sectors to transfer
+ * @param buffer     Data buffer
+ * @param write      Is the a write. Default to a read
+ */
+static int ebt3000_cf_transfer(cf_device_t * cf, unsigned long lba_sector,
+			       unsigned long num_sectors, char *buffer,
+			       int write)
+{
+	if ((lba_sector + num_sectors) > cf->num_sectors) {
+		printk
+		    ("%s: Attempt to access beyond end of device (%ld > %ld)\n",
+		     cf->gd->disk_name, lba_sector + num_sectors - 1,
+		     cf->num_sectors - 1);
+		num_sectors = cf->num_sectors - lba_sector;
+		if (num_sectors <= 0)
+			return 0;
+	}
+
+	if (write)
+		return ata_write(cf, lba_sector, num_sectors, buffer);
+	else
+		return ata_read(cf, lba_sector, num_sectors, buffer);
+}
+
+/**
+ * Handle queued IO requests
+ *
+ * @param q      queue of requests
+ */
+static void ebt3000_cf_request(request_queue_t * q)
+{
+	/* For some unknown reason, sometimes the kernel calls us with
+	   interrupts disabled. Since the CF is very slow, we just use
+	   the kernel call to wakeup a thread. This way we never block
+	   for long periods of time */
+	struct request *req = elv_next_request(q);
+	if (req) {
+		cf_device_t *cf = req->rq_disk->private_data;
+		complete(&cf->comp);
+	}
+}
+
+/**
+ * Ioctl.
+ *
+ * @param inode
+ * @param filp
+ * @param cmd
+ * @param arg
+ * @return
+ */
+int ebt3000_cf_ioctl(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg)
+{
+	/* Not implemented yet */
+#if 0
+	long size;
+	struct hd_geometry geo;
+
+	switch (cmd) {
+		/*
+		 * The only command we need to interpret is HDIO_GETGEO, since
+		 * we can't partition the drive otherwise.  We have no real
+		 * geometry, of course, so make something up.
+		 */
+	case HDIO_GETGEO:
+		printk("%s HDIO_GETGEO\n", __FUNCTION__);
+		size = 1024;
+		geo.cylinders = (size & ~0x3f) >> 6;
+		geo.heads = 4;
+		geo.sectors = 16;
+		geo.start = 4;
+		if (copy_to_user((void *)arg, &geo, sizeof(geo)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+	return -ENOTTY;		/* unknown command */
+}
+
+/**
+ * Kernel thread that does the actual IO operations
+ *
+ * @param cf_obj The compact flash device
+ * @return Never returns
+ */
+int ebt3000_cf_work(void *cf_obj)
+{
+	cf_device_t *cf = cf_obj;
+	struct request *req;
+	int count;
+
+	/* Give ourself a nice name and become a daemon */
+	daemonize("ebt3000_%s", cf->gd->disk_name);
+
+	/* Identify the compact flash. We need its size */
+	ebt3000cf_identify(cf);
+	set_capacity(cf->gd,
+		     cf->num_sectors * (cf->sector_size / KERNEL_SECTOR_SIZE));
+
+	/* Loop forever waiting for IO requests */
+	while (1) {
+		/* Wait for the queue request handler to signal us there are requests
+		   available */
+		wait_for_completion(&cf->comp);
+
+		/* We need the queue lock */
+		spin_lock(&cf->lock);
+
+		/* Loop through all the pending requests */
+		while ((req = elv_next_request(cf->queue)) != NULL) {
+			if (!blk_fs_request(req)) {
+				printk("%s: Skip non-CMD request\n",
+				       req->rq_disk->disk_name);
+				end_request(req, 0);
+			} else {
+				/* Give away the lock while we're doing the slow IOs */
+				spin_unlock(&cf->lock);
+				count =
+				    ebt3000_cf_transfer(cf, req->sector,
+							req->current_nr_sectors,
+							req->buffer,
+							rq_data_dir(req));
+				/* We need the lock again to signal completion */
+				spin_lock(&cf->lock);
+				if (count == req->current_nr_sectors)
+					end_request(req, 1);
+				else
+					end_request(req, -EIO);
+			}
+		}
+		spin_unlock(&cf->lock);
+	}
+	return 0;
+}
+
+/*
+ * The device operations structure.
+ */
+static struct block_device_operations ebt3000_cf_ops = {
+	.owner = THIS_MODULE,
+	.ioctl = ebt3000_cf_ioctl
+};
+
+/**
+ * Initialization
+ *
+ * @return
+ */
+static int __init ebt3000_cf_init(void)
+{
+	cf_device_t *cf;
+	int major_num;
+
+	printk(KERN_NOTICE DEVICE_NAME
+	       ": EBT3000 compact flash driver version %s\n", VERSION);
+
+	cf = &STATIC_DEVICE;
+
+	memset(cf, 0, sizeof(*cf));
+
+	cf->ata_command = (unsigned char *)0x800000001d000800;
+	spin_lock_init(&cf->lock);
+	init_completion(&cf->comp);
+
+	/* Get a request queue. */
+	cf->queue = blk_init_queue(ebt3000_cf_request, &cf->lock);
+	if (cf->queue == NULL) {
+		printk(DEVICE_NAME
+		       ": unable to allocate block request queue\n");
+		goto out;
+	}
+	blk_queue_hardsect_size(cf->queue, KERNEL_SECTOR_SIZE);
+
+	/* Get registered. */
+	major_num = register_blkdev(0, DEVICE_NAME);
+	if (major_num <= 0) {
+		printk(DEVICE_NAME ": unable to get major number\n");
+		goto out;
+	}
+
+	/* And the gendisk structure. */
+	cf->gd = alloc_disk(64);
+	if (cf->gd == NULL) {
+		printk(DEVICE_NAME ": unable to allocate disk\n");
+		goto out_unregister;
+	}
+
+	cf->gd->major = major_num;
+	cf->gd->first_minor = 0;
+	cf->gd->fops = &ebt3000_cf_ops;
+	cf->gd->private_data = cf;
+	cf->gd->queue = cf->queue;
+	strcpy(cf->gd->disk_name, DEVICE_NAME "a");
+	strcpy(cf->gd->devfs_name, cf->gd->disk_name);
+
+	/* Set a size to make sure the kernel trys to find partitions. The real
+	   size will be set when the thread starts processing */
+	set_capacity(cf->gd, 16);
+
+	/* Create a kernel thread for doing the real IO operations */
+	kernel_thread(ebt3000_cf_work, cf, 0);
+
+	add_disk(cf->gd);
+
+	return 0;
+
+      out_unregister:
+	unregister_blkdev(major_num, DEVICE_NAME);
+      out:
+	return -ENOMEM;
+}
+
+late_initcall(ebt3000_cf_init);
Index: linux-2.6.10/arch/mips/cavium-octeon/hal.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/hal.c
@@ -0,0 +1,164 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+
+#include <hal.h>
+#include <cvmx-bootmem-shared.h>
+
+/* These are for GPL compatable modules to get memory outside of Linux's
+    control */
+EXPORT_SYMBOL(octeon_bootmem_alloc_range);
+EXPORT_SYMBOL(octeon_bootmem_alloc);
+
+/* This must not be static since inline functions access it */
+spinlock_t octeon_led_lock;
+
+void octeon_write_lcd(const char *s)
+{
+#ifndef CONFIG_CAVIUM_OCTEON_SIMULATOR
+	extern octeon_bootinfo_t *octeon_bootinfo;
+
+	if (octeon_bootinfo->board_rev_major < 2) {
+		volatile char *lcd_address =
+		    (volatile char *)0x800000001d020004ull;
+		int i;
+		for (i = 0; i < 4; i++) {
+			if (*s)
+				lcd_address[3 - i] = *s++;
+			else
+				lcd_address[3 - i] = ' ';
+		}
+	} else {
+		volatile char *lcd_address =
+		    (volatile char *)0x800000001d0200f8ull;
+		int i;
+		for (i = 0; i < 8; i++) {
+			if (*s)
+				lcd_address[i] = *s++;
+			else
+				lcd_address[i] = ' ';
+		}
+	}
+#endif
+}
+
+void octeon_check_cpu_bist(void)
+{
+	const int coreid = octeon_get_core_num();
+	uint64_t mask;
+	uint64_t bist_val;
+
+	/* Check BIST results for COP0 registers */
+	mask = 0x1f00000000ull;
+	bist_val = __read_64bit_c0_register($27, 0);
+	if (bist_val & mask)
+		printk("Core%d BIST Failure: CacheErr(icache) = 0x%lx\n",
+		       coreid, bist_val);
+
+	bist_val = __read_64bit_c0_register($27, 1);
+	if (bist_val & 1)
+		printk
+		    ("Core%d L1 Dcache parity error: CacheErr(dcache) = 0x%lx\n",
+		     coreid, bist_val);
+
+	mask = 0xfc00000000000000ull;
+	bist_val = __read_64bit_c0_register($11, 7);
+	if (bist_val & mask)
+		printk("Core%d BIST Failure: COP0_CVM_MEM_CTL = 0x%lx\n",
+		       coreid, bist_val);
+
+	__write_64bit_c0_register($27, 1, 0);
+
+	mask = 0x18ull;
+	bist_val = octeon_read_csr(OCTEON_L2D_ERR);
+	octeon_write_csr(OCTEON_L2D_ERR, mask);	/* Clear error bits */
+	if (bist_val & mask)
+		printk("Core%d L2 Parity error: L2D_ERR = 0x%lx\n", coreid,
+		       bist_val);
+}
+
+void octeon_led_init(void)
+{
+	spin_lock_init(&octeon_led_lock);
+	octeon_write_csr(OCTEON_LED_EN, 0);
+	octeon_write_csr(OCTEON_LED_PRT, 0);
+	octeon_write_csr(OCTEON_LED_DBG, 0);
+	octeon_write_csr(OCTEON_LED_PRT_FMT, 0);
+	octeon_write_csr(OCTEON_LED_UDD_CNTX(0), 32);
+	octeon_write_csr(OCTEON_LED_UDD_CNTX(1), 32);
+	octeon_write_csr(OCTEON_LED_UDD_DATX(0), 0);
+	octeon_write_csr(OCTEON_LED_UDD_DATX(1), 0);
+	octeon_write_csr(OCTEON_LED_EN, 1);
+}
+
+void *octeon_bootmem_alloc(uint64_t size, uint64_t alignment)
+{
+	return octeon_bootmem_alloc_range(size, alignment, 0, 0);
+}
+
+void *octeon_bootmem_alloc_range(uint64_t size, uint64_t alignment,
+				 uint64_t min_addr, uint64_t max_addr)
+{
+	extern octeon_bootinfo_t *octeon_bootinfo;
+	cvmx_bootmem_desc_t *bootmem_desc =
+	    octeon_phys_to_ptr(octeon_bootinfo->phy_mem_desc_addr);
+
+	uint64_t address;
+	octeon_lock(CAST64(&(bootmem_desc->lock)));
+	address =
+	    octeon_phy_mem_block_alloc(bootmem_desc, size, min_addr, max_addr,
+				       alignment);
+	octeon_unlock(CAST64(&(bootmem_desc->lock)));
+
+	if (address)
+		return octeon_phys_to_ptr(address);
+	else
+		return NULL;
+}
+
+static inline void octeon_phy_mem_set_size(uint64_t addr, uint64_t size)
+{
+	*(uint64_t *) octeon_xkphys(addr + 8) = size;
+}
+
+static inline void octeon_phy_mem_set_next(uint64_t addr, uint64_t next)
+{
+	*(uint64_t *) octeon_xkphys(addr) = next;
+}
+
+static inline uint64_t octeon_phy_mem_get_size(uint64_t addr)
+{
+	return *(uint64_t *) octeon_xkphys(addr + 8);
+}
+
+static inline uint64_t octeon_phy_mem_get_next(uint64_t addr)
+{
+	return *(uint64_t *) octeon_xkphys(addr);
+}
+
+#define printf printk
+#define cvmx_phys_to_ptr octeon_phys_to_ptr
+#include "cvmx-bootmem-shared.c"
+
+/* These are aliases for the above function for easy use by CVMX based
+    modules. They shouldn't be called by any statically linked code */
+static void *cvmx_bootmem_alloc(uint64_t size, uint64_t alignment)
+{
+	return octeon_bootmem_alloc(size, alignment);
+}
+
+static void *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,
+				      uint64_t min_addr, uint64_t max_addr)
+{
+	return octeon_bootmem_alloc_range(size, alignment, min_addr, max_addr);
+}
+
+EXPORT_SYMBOL(cvmx_bootmem_alloc_range);
+EXPORT_SYMBOL(cvmx_bootmem_alloc);
Index: linux-2.6.10/arch/mips/cavium-octeon/int_handler.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/int_handler.S
@@ -0,0 +1,138 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Cavium Networks
+ */
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	.text
+	.set	noat
+	.set	noreorder
+	.align  5
+        NESTED(octeon_handle_irq, PT_SIZE, sp)
+        SAVE_ALL
+        CLI
+        .set    at
+        .set    noreorder
+        mfc0    t0, CP0_CAUSE
+        mfc0    t2, CP0_STATUS
+
+        and     t0, t2
+
+        andi    t1, t0, STATUSF_IP7     /* cpu timer */
+        bnez    t1, ll_cputimer_irq
+        andi    t1, t0, STATUSF_IP2
+        bnez    t1, ll_ciu_interrupt_check
+        andi    t1, t0, STATUSF_IP3
+        bnez    t1, ll_cpu_ip3
+        andi    t1, t0, STATUSF_IP4
+        bnez    t1, ll_cpu_ip4
+        andi    t1, t0, STATUSF_IP5
+        bnez    t1, ll_cpu_ip5
+        andi    t1, t0, STATUSF_IP6
+        bnez    t1, ll_cpu_ip6
+        andi    t1, t0, STATUSF_IP0     /* software int 0 */
+        bnez    t1, ll_cpu_ip0
+        andi    t1, t0, STATUSF_IP1     /* software int 1 */
+        bnez    t1, ll_cpu_ip1
+        nop
+
+        /* wrong alarm or masked ... */
+        j       spurious_interrupt
+	nop
+
+ll_cputimer_irq:
+        li      a0, 7
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+
+ll_cpu_ip0:
+        li      a0, 0
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_cpu_ip1:
+        li      a0, 1
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_cpu_ip3:
+        li      a0, 3
+#ifdef CONFIG_SMP
+        jal     mailbox_interrupt
+#else
+        jal     do_IRQ
+#endif
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_cpu_ip4:
+        li      a0, 4
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_cpu_ip5:
+        li      a0, 5
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_cpu_ip6:
+        li      a0, 6
+        jal     do_IRQ
+        move    a1, sp
+        j       ret_from_irq
+	nop
+
+ll_ciu_interrupt_check:
+	dli	t0, 0x8001070000000000	// OCTEON_CIU_INTX_SUM0
+	rdhwr	t1, $0			// Get the core id
+	li	a0, 8			// Start at interrupt 8
+	dsll	t1, 4			// core id * 2 * 8
+	or	t0, t0, t1		// OCTEON_CIU_INTX_SUM0 + core id * 2 * 8
+	ld	t2, 0(t0)
+	dli	t0, 0x8001070000000200	// OCTEON_CIU_INTX_EN0
+	dsll	t1, 1			// (core id * 2 * 8) * 2
+	or	t0, t0, t1		// OCTEON_CIU_INTX_EN0 + core id * 2 * 16
+	ld	t0, 0(t0)
+	and	t0, t0, t2		// OCTEON_CIU_INTX_SUM0 and OCTEON_CIU_INTX_EN0
+
+ll_ciu_interrupt_check_loop:
+#ifdef __OCTEON__
+	bbit1	t0, 0, ll_ciu_interrupt
+#else
+	and	t1, t0, 1
+	bnez	t1, ll_ciu_interrupt
+#endif
+	dsrl	t0, t0, 1
+	bne	t0, 0, ll_ciu_interrupt_check_loop
+	add	a0, 1
+        j       spurious_interrupt
+	nop
+
+ll_ciu_interrupt:
+        jal     do_IRQ
+	move	a1, sp
+        j       ret_from_irq
+	nop
+
+        END(octeon_handle_irq)
+
Index: linux-2.6.10/arch/mips/cavium-octeon/octeon_info.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/octeon_info.c
@@ -0,0 +1,116 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ *
+ * Simple /proc interface to Octeon Information
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <hal.h>
+
+extern void *octeon_reserve32_memory;
+
+/**
+ * User is reading /proc/octeon_info
+ *
+ * @param m
+ * @param v
+ * @return
+ */
+static int octeon_info_show(struct seq_file *m, void *v)
+{
+	extern octeon_bootinfo_t *octeon_bootinfo;
+
+	seq_printf(m, "boot_flags:          0x%x\n", octeon_bootinfo->flags);
+	seq_printf(m, "dram_size:           %u\n", octeon_bootinfo->dram_size);
+	seq_printf(m, "phy_mem_desc_addr:   0x%x\n",
+		   octeon_bootinfo->phy_mem_desc_addr);
+	seq_printf(m, "eclock_hz:           %u\n", octeon_bootinfo->eclock_hz);
+	seq_printf(m, "dclock_hz:           %u\n", octeon_bootinfo->dclock_hz);
+	seq_printf(m, "spi_clock_hz:        %u\n",
+		   octeon_bootinfo->spi_clock_hz);
+	seq_printf(m, "board_type:          %u\n", octeon_bootinfo->board_type);
+	seq_printf(m, "board_rev_major:     %u\n",
+		   octeon_bootinfo->board_rev_major);
+	seq_printf(m, "board_rev_minor:     %u\n",
+		   octeon_bootinfo->board_rev_minor);
+	seq_printf(m, "chip_type:           %u\n", octeon_bootinfo->chip_type);
+	seq_printf(m, "chip_rev_major:      %u\n",
+		   octeon_bootinfo->chip_rev_major);
+	seq_printf(m, "chip_rev_minor:      %u\n",
+		   octeon_bootinfo->chip_rev_minor);
+	seq_printf(m, "board_serial_number: %s\n",
+		   octeon_bootinfo->board_serial_number);
+	seq_printf(m, "mac_addr_base:       %02x:%02x:%02x:%02x:%02x:%02x\n",
+		   (int)octeon_bootinfo->mac_addr_base[0],
+		   (int)octeon_bootinfo->mac_addr_base[1],
+		   (int)octeon_bootinfo->mac_addr_base[2],
+		   (int)octeon_bootinfo->mac_addr_base[3],
+		   (int)octeon_bootinfo->mac_addr_base[4],
+		   (int)octeon_bootinfo->mac_addr_base[5]);
+	seq_printf(m, "mac_addr_count:      %u\n",
+		   octeon_bootinfo->mac_addr_count);
+	seq_printf(m, "32bit_shared_mem_base: 0x%llx\n",
+		   (unsigned long long)octeon_reserve32_memory & 0xffffffff);
+	seq_printf(m, "32bit_shared_mem_size: 0x%x\n",
+		   octeon_reserve32_memory ? CONFIG_CAVIUM_RESERVE32 << 20 : 0);
+	return 0;
+}
+
+/**
+ * /proc/octeon_info was openned. Use the single_open iterator
+ *
+ * @param inode
+ * @param file
+ * @return
+ */
+static int octeon_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, octeon_info_show, NULL);
+}
+
+static struct file_operations octeon_info_operations = {
+	.open = octeon_info_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+/**
+ * Module initialization
+ *
+ * @return
+ */
+static int __init octeon_info_init(void)
+{
+	struct proc_dir_entry *entry =
+	    create_proc_entry("octeon_info", 0, NULL);
+	if (entry == NULL)
+		return -1;
+
+	entry->proc_fops = &octeon_info_operations;
+	return 0;
+}
+
+/**
+ * Module cleanup
+ *
+ * @return
+ */
+static void __exit octeon_info_cleanup(void)
+{
+	remove_proc_entry("octeon_info", NULL);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks Octeon information interface.");
+module_init(octeon_info_init);
+module_exit(octeon_info_cleanup);
Index: linux-2.6.10/arch/mips/cavium-octeon/perf_counters.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/perf_counters.c
@@ -0,0 +1,685 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ *
+ * Simple /proc interface to the Octeon Performance Counters
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <asm/ioctl.h>
+#include <asm/mach-cavium-octeon/perf_counters.h>
+#include <hal.h>
+
+/**
+ * The types of counters supported per cpu
+ */
+typedef enum {
+	PROC_PERF_CORE_NONE = 0,     /**< Turn off the performance counter */
+	PROC_PERF_CORE_CLK = 1,	     /**< Conditionally clocked cycles (as opposed to count/cvm_count which count even with no clocks) */
+	PROC_PERF_CORE_ISSUE = 2,    /**< Instructions issued but not retired */
+	PROC_PERF_CORE_RET = 3,	     /**< Instructions retired */
+	PROC_PERF_CORE_NISSUE = 4,   /**< Cycles no issue */
+	PROC_PERF_CORE_SISSUE = 5,   /**< Cycles single issue */
+	PROC_PERF_CORE_DISSUE = 6,   /**< Cycles dual issue */
+	PROC_PERF_CORE_IFI = 7,	     /**< Cycle ifetch issued (but not necessarily commit to pp_mem) */
+	PROC_PERF_CORE_BR = 8,	     /**< Branches retired */
+	PROC_PERF_CORE_BRMIS = 9,    /**< Branch mispredicts */
+	PROC_PERF_CORE_J = 10,	     /**< Jumps retired */
+	PROC_PERF_CORE_JMIS = 11,    /**< Jumps mispredicted */
+	PROC_PERF_CORE_REPLAY = 12,  /**< Mem Replays */
+	PROC_PERF_CORE_IUNA = 13,    /**< Cycles idle due to unaligned_replays */
+	PROC_PERF_CORE_TRAP = 14,    /**< trap_6a signal */
+	PROC_PERF_CORE_UULOAD = 16,  /**< Unexpected unaligned loads (REPUN=1) */
+	PROC_PERF_CORE_UUSTORE = 17, /**< Unexpected unaligned store (REPUN=1) */
+	PROC_PERF_CORE_ULOAD = 18,   /**< Unaligned loads (REPUN=1 or USEUN=1) */
+	PROC_PERF_CORE_USTORE = 19,  /**< Unaligned store (REPUN=1 or USEUN=1) */
+	PROC_PERF_CORE_EC = 20,	     /**< Exec clocks(must set CvmCtl[DISCE] for accurate timing) */
+	PROC_PERF_CORE_MC = 21,	     /**< Mul clocks(must set CvmCtl[DISCE] for accurate timing) */
+	PROC_PERF_CORE_CC = 22,	     /**< Crypto clocks(must set CvmCtl[DISCE] for accurate timing) */
+	PROC_PERF_CORE_CSRC = 23,    /**< Issue_csr clocks(must set CvmCtl[DISCE] for accurate timing) */
+	PROC_PERF_CORE_CFETCH = 24,  /**< Icache committed fetches (demand+prefetch) */
+	PROC_PERF_CORE_CPREF = 25,   /**< Icache committed prefetches */
+	PROC_PERF_CORE_ICA = 26,     /**< Icache aliases */
+	PROC_PERF_CORE_II = 27,	     /**< Icache invalidates */
+	PROC_PERF_CORE_IP = 28,	     /**< Icache parity error */
+	PROC_PERF_CORE_CIMISS = 29,  /**< Cycles idle due to imiss (must set CvmCtl[DISCE] for accurate timing) */
+	PROC_PERF_CORE_WBUF = 32,    /**< Number of write buffer entries created */
+	PROC_PERF_CORE_WDAT = 33,    /**< Number of write buffer data cycles used (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_WBUFLD = 34,  /**< Number of write buffer entries forced out by loads */
+	PROC_PERF_CORE_WBUFFL = 35,  /**< Number of cycles that there was no available write buffer entry (may need to set CvmCtl[DISCE] and CvmMemCtl[MCLK] for accurate counts) */
+	PROC_PERF_CORE_WBUFTR = 36,  /**< Number of stores that found no available write buffer entries */
+	PROC_PERF_CORE_BADD = 37,    /**< Number of address bus cycles used (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_BADDL2 = 38,  /**< Number of address bus cycles not reflected (i.e. destined for L2) (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_BFILL = 39,   /**< Number of fill bus cycles used (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_DDIDS = 40,   /**< Number of Dstream DIDs created */
+	PROC_PERF_CORE_IDIDS = 41,   /**< Number of Istream DIDs created */
+	PROC_PERF_CORE_DIDNA = 42,   /**< Number of cycles that no DIDs were available (may need to set CvmCtl[DISCE] and CvmMemCtl[MCLK] for accurate counts) */
+	PROC_PERF_CORE_LDS = 43,     /**< Number of load issues */
+	PROC_PERF_CORE_LMLDS = 44,   /**< Number of local memory load */
+	PROC_PERF_CORE_IOLDS = 45,   /**< Number of I/O load issues */
+	PROC_PERF_CORE_DMLDS = 46,   /**< Number of loads that were not prefetches and missed in the cache */
+	PROC_PERF_CORE_STS = 48,     /**< Number of store issues */
+	PROC_PERF_CORE_LMSTS = 49,   /**< Number of local memory store issues */
+	PROC_PERF_CORE_IOSTS = 50,   /**< Number of I/O store issues */
+	PROC_PERF_CORE_IOBDMA = 51,  /**< Number of IOBDMAs */
+	PROC_PERF_CORE_DTLB = 53,    /**< Number of dstream TLB refill, invalid, or modified exceptions */
+	PROC_PERF_CORE_DTLBAD = 54,  /**< Number of dstream TLB address errors */
+	PROC_PERF_CORE_ITLB = 55,    /**< Number of istream TLB refill, invalid, or address error exceptions */
+	PROC_PERF_CORE_SYNC = 56,    /**< Number of SYNC stall cycles (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_SYNCIOB = 57, /**< Number of SYNCIOBDMA stall cycles (may need to set CvmCtl[DISCE] for accurate counts) */
+	PROC_PERF_CORE_SYNCW = 58,   /**< Number of SYNCWs */
+	PROC_PERF_CORE_MAX
+} proc_perf_core_t;
+
+/**
+ * The types of counters supported for L2
+ */
+typedef enum {
+	PROC_PERF_L2_CYCLES,	/* Cycles */
+	PROC_PERF_L2_IMISS,	/* L2 Instruction Miss */
+	PROC_PERF_L2_IHIT,	/* L2 Instruction Hit */
+	PROC_PERF_L2_DMISS,	/* L2 Data Miss */
+	PROC_PERF_L2_DHIT,	/* L2 Data Hit */
+	PROC_PERF_L2_MISS,	/* L2 Miss (I/D) */
+	PROC_PERF_L2_HIT,	/* L2 Hit (I/D) */
+	PROC_PERF_L2_VICTIM_BUFFER_HIT,	/* L2 Victim Buffer Hit (Retry Probe) */
+	PROC_PERF_L2_LFB_NQ_INDEX_CONFLICT,	/* LFB-NQ Index Conflict */
+	PROC_PERF_L2_TAG_PROBE,	/* L2 Tag Probe (issued - could be VB-Retried) */
+	PROC_PERF_L2_TAG_UPDATE,	/* L2 Tag Update (completed). Note: Some CMD types do not update */
+	PROC_PERF_L2_TAG_PROBE_COMPLETED,	/* L2 Tag Probe Completed (beyond VB-RTY window) */
+	PROC_PERF_L2_TAG_DIRTY_VICTIM,	/* L2 Tag Dirty Victim */
+	PROC_PERF_L2_DATA_STORE_NOP,	/* L2 Data Store NOP */
+	PROC_PERF_L2_DATA_STORE_READ,	/* L2 Data Store READ */
+	PROC_PERF_L2_DATA_STORE_WRITE,	/* L2 Data Store WRITE */
+	PROC_PERF_L2_MEMORY_FILL_DATA_VALID,	/* Memory Fill Data valid */
+	PROC_PERF_L2_MEMORY_WRITE_REQUEST,	/* Memory Write Request */
+	PROC_PERF_L2_MEMORY_READ_REQUEST,	/* Memory Read Request */
+	PROC_PERF_L2_MEMORY_WRITE_DATA_VALID,	/* Memory Write Data valid */
+	PROC_PERF_L2_XMC_NOP,	/* XMC NOP */
+	PROC_PERF_L2_XMC_LDT,	/* XMC LDT */
+	PROC_PERF_L2_XMC_LDI,	/* XMC LDI */
+	PROC_PERF_L2_XMC_LDD,	/* XMC LDD */
+	PROC_PERF_L2_XMC_STF,	/* XMC STF */
+	PROC_PERF_L2_XMC_STT,	/* XMC STT */
+	PROC_PERF_L2_XMC_STP,	/* XMC STP */
+	PROC_PERF_L2_XMC_STC,	/* XMC STC */
+	PROC_PERF_L2_XMC_DWB,	/* XMC DWB */
+	PROC_PERF_L2_XMC_PL2,	/* XMC PL2 */
+	PROC_PERF_L2_XMC_PSL1,	/* XMC PSL1 */
+	PROC_PERF_L2_XMC_IOBLD,	/* XMC IOBLD */
+	PROC_PERF_L2_XMC_IOBST,	/* XMC IOBST */
+	PROC_PERF_L2_XMC_IOBDMA,	/* XMC IOBDMA */
+	PROC_PERF_L2_XMC_IOBRSP,	/* XMC IOBRSP */
+	PROC_PERF_L2_XMD_BUS_VALID,	/* XMD Bus valid (all) */
+	PROC_PERF_L2_XMD_BUS_VALID_DST_L2C,	/* XMD Bus valid (DST=L2C) Memory */
+	PROC_PERF_L2_XMD_BUS_VALID_DST_IOB,	/* XMD Bus valid (DST=IOB) REFL Data */
+	PROC_PERF_L2_XMD_BUS_VALID_DST_PP,	/* XMD Bus valid (DST=PP) IOBRSP Data */
+	PROC_PERF_L2_RSC_NOP,	/* RSC NOP */
+	PROC_PERF_L2_RSC_STDN,	/* RSC STDN */
+	PROC_PERF_L2_RSC_FILL,	/* RSC FILL */
+	PROC_PERF_L2_RSC_REFL,	/* RSC REFL */
+	PROC_PERF_L2_RSC_STIN,	/* RSC STIN */
+	PROC_PERF_L2_RSC_SCIN,	/* RSC SCIN */
+	PROC_PERF_L2_RSC_SCFL,	/* RSC SCFL */
+	PROC_PERF_L2_RSC_SCDN,	/* RSC SCDN */
+	PROC_PERF_L2_RSD_DATA_VALID,	/* RSD Data Valid */
+	PROC_PERF_L2_RSD_DATA_VALID_FILL,	/* RSD Data Valid (FILL) */
+	PROC_PERF_L2_RSD_DATA_VALID_STRSP,	/* RSD Data Valid (STRSP) */
+	PROC_PERF_L2_RSD_DATA_VALID_REFL,	/* RSD Data Valid (REFL) */
+	PROC_PERF_L2_LRF_REQ,	/* LRF-REQ (LFB-NQ) */
+	PROC_PERF_L2_DT_RD_ALLOC,	/* DT RD-ALLOC */
+	PROC_PERF_L2_DT_WR_INVA,	/* DT WR-INVA */
+	PROC_PERF_L2_MAX
+} proc_perf_l2_t;
+
+/**
+ * IO addresses for L2 registers
+ */
+#define  OCTEON_L2C_PFCTL   0x8001180080000090ull
+#define  OCTEON_L2C_PFC0    0x8001180080000098ull
+#define  OCTEON_L2C_PFC1    0x80011800800000A0ull
+#define  OCTEON_L2C_PFC2    0x80011800800000A8ull
+#define  OCTEON_L2C_PFC3    0x80011800800000B0ull
+
+/**
+ * Bit description of the core counters control register
+ */
+typedef union {
+	uint32_t u32;
+	struct {
+		uint32_t M:1;
+		uint32_t W:1;
+		uint32_t reserved:19;
+		proc_perf_core_t event:6;
+		uint32_t IE:1;
+		uint32_t U:1;
+		uint32_t S:1;
+		uint32_t K:1;
+		uint32_t EX:1;
+	} s;
+} proc_perf_core_control_t;
+
+/**
+ * Bit description of the L2 counters control register
+ */
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:32;
+		uint64_t cnt3ena:1;
+		uint64_t cnt3clr:1;
+		proc_perf_l2_t cnt3sel:6;
+		uint64_t cnt2ena:1;
+		uint64_t cnt2clr:1;
+		proc_perf_l2_t cnt2sel:6;
+		uint64_t cnt1ena:1;
+		uint64_t cnt1clr:1;
+		proc_perf_l2_t cnt1sel:6;
+		uint64_t cnt0ena:1;
+		uint64_t cnt0clr:1;
+		proc_perf_l2_t cnt0sel:6;
+	} s;
+} proc_perf_l2_control_t;
+
+/**
+ * Module parameters used to control the counters. Can be
+ * changed on the fly through sysfs or ioctls.
+ */
+static char counter0[32] = "sissue";
+static char counter1[32] = "dissue";
+module_param_string(counter0, counter0, sizeof(counter0), 0666);
+module_param_string(counter1, counter1, sizeof(counter1), 0666);
+
+static char l2counter0[32] = "imiss";
+static char l2counter1[32] = "ihit";
+static char l2counter2[32] = "dmiss";
+static char l2counter3[32] = "dhit";
+module_param_string(l2counter0, l2counter0, sizeof(l2counter0), 0666);
+module_param_string(l2counter1, l2counter1, sizeof(l2counter1), 0666);
+module_param_string(l2counter2, l2counter2, sizeof(l2counter2), 0666);
+module_param_string(l2counter3, l2counter3, sizeof(l2counter3), 0666);
+
+static struct proc_dir_entry *proc_perf_entry;
+static uint64_t proc_perf_counter_control[2];
+static uint64_t proc_perf_counter_data[NR_CPUS][2];
+static uint64_t proc_perf_l2counter_control[4];
+static uint64_t proc_perf_l2counter_data[4];
+static const char *proc_perf_label[PROC_PERF_CORE_MAX];
+static const char *proc_perf_l2label[PROC_PERF_L2_MAX];
+
+/**
+ * Setup the core counters. Called on each core
+ *
+ * @param arg
+ */
+static void proc_perf_setup_counters(void *arg)
+{
+	proc_perf_core_control_t control;
+	control.u32 = 0;
+	control.s.event = proc_perf_counter_control[0];
+	control.s.U = 1;
+	control.s.S = 1;
+	control.s.K = 1;
+	control.s.EX = 1;
+	__write_64bit_c0_register($25, 0, control.u32);
+
+	control.s.event = proc_perf_counter_control[1];
+	__write_64bit_c0_register($25, 2, control.u32);
+
+	__write_64bit_c0_register($25, 1, 0);
+	__write_64bit_c0_register($25, 3, 0);
+}
+
+/**
+ * Update the counters for each core.
+ *
+ * @param arg
+ */
+static void proc_perf_update_counters(void *arg)
+{
+	int cpu = smp_processor_id();
+
+	proc_perf_counter_data[cpu][0] = __read_64bit_c0_register($25, 1);
+	proc_perf_counter_data[cpu][1] = __read_64bit_c0_register($25, 3);
+	mb();
+}
+
+/**
+ * Cleanup the input of sysfs
+ *
+ * @param str
+ * @param len
+ */
+static inline void clean_string(char *str, int len)
+{
+	int i;
+	for (i = 0; i < len; i++)
+		if (str[i] <= 32)
+			str[i] = 0;
+}
+
+/**
+ * Setup the counters using the current config
+ */
+static void proc_perf_setup(void)
+{
+	int i;
+	proc_perf_l2_control_t l2control;
+
+	proc_perf_counter_control[0] = 0;
+	proc_perf_counter_control[1] = 0;
+	proc_perf_l2counter_control[0] = 0;
+	proc_perf_l2counter_control[1] = 0;
+	proc_perf_l2counter_control[2] = 0;
+	proc_perf_l2counter_control[3] = 0;
+
+	/* Cleanup junk on end of param strings */
+	clean_string(counter0, sizeof(counter0));
+	clean_string(counter1, sizeof(counter1));
+	clean_string(l2counter0, sizeof(l2counter0));
+	clean_string(l2counter1, sizeof(l2counter1));
+	clean_string(l2counter2, sizeof(l2counter2));
+	clean_string(l2counter3, sizeof(l2counter3));
+
+	/* Set the core counters to match the string parameters */
+	for (i = 0; i < PROC_PERF_CORE_MAX; i++) {
+		if (proc_perf_label[i]) {
+			if (strcmp(proc_perf_label[i], counter0) == 0)
+				proc_perf_counter_control[0] = i;
+			if (strcmp(proc_perf_label[i], counter1) == 0)
+				proc_perf_counter_control[1] = i;
+		}
+	}
+
+	/* Set the L2 counters to match the string parameters */
+	for (i = 0; i < PROC_PERF_L2_MAX; i++) {
+		if (proc_perf_l2label[i]) {
+			if (strcmp(proc_perf_l2label[i], l2counter0) == 0)
+				proc_perf_l2counter_control[0] = i;
+			if (strcmp(proc_perf_l2label[i], l2counter1) == 0)
+				proc_perf_l2counter_control[1] = i;
+			if (strcmp(proc_perf_l2label[i], l2counter2) == 0)
+				proc_perf_l2counter_control[2] = i;
+			if (strcmp(proc_perf_l2label[i], l2counter3) == 0)
+				proc_perf_l2counter_control[3] = i;
+		}
+	}
+
+	/* Update strings to match final config */
+	strcpy(counter0, proc_perf_label[proc_perf_counter_control[0]]);
+	strcpy(counter1, proc_perf_label[proc_perf_counter_control[1]]);
+	strcpy(l2counter0, proc_perf_l2label[proc_perf_l2counter_control[0]]);
+	strcpy(l2counter1, proc_perf_l2label[proc_perf_l2counter_control[1]]);
+	strcpy(l2counter2, proc_perf_l2label[proc_perf_l2counter_control[2]]);
+	strcpy(l2counter3, proc_perf_l2label[proc_perf_l2counter_control[3]]);
+
+	on_each_cpu(proc_perf_setup_counters, NULL, 1, 1);
+
+	l2control.u64 = 0;
+	l2control.s.cnt3ena = 1;
+	l2control.s.cnt3clr = 1;
+	l2control.s.cnt3sel = proc_perf_l2counter_control[3];
+	l2control.s.cnt2ena = 1;
+	l2control.s.cnt2clr = 1;
+	l2control.s.cnt2sel = proc_perf_l2counter_control[2];
+	l2control.s.cnt1ena = 1;
+	l2control.s.cnt1clr = 1;
+	l2control.s.cnt1sel = proc_perf_l2counter_control[1];
+	l2control.s.cnt0ena = 1;
+	l2control.s.cnt0clr = 1;
+	l2control.s.cnt0sel = proc_perf_l2counter_control[0];
+
+	octeon_write_csr(OCTEON_L2C_PFCTL, l2control.u64);
+	octeon_write_csr(OCTEON_L2C_PFC0, 0);
+	octeon_write_csr(OCTEON_L2C_PFC1, 0);
+	octeon_write_csr(OCTEON_L2C_PFC2, 0);
+	octeon_write_csr(OCTEON_L2C_PFC3, 0);
+}
+
+static void proc_perf_update(void)
+{
+	on_each_cpu(proc_perf_update_counters, NULL, 1, 1);
+	mb();
+	proc_perf_l2counter_data[0] = octeon_read_csr(OCTEON_L2C_PFC0);
+	proc_perf_l2counter_data[1] = octeon_read_csr(OCTEON_L2C_PFC1);
+	proc_perf_l2counter_data[2] = octeon_read_csr(OCTEON_L2C_PFC2);
+	proc_perf_l2counter_data[3] = octeon_read_csr(OCTEON_L2C_PFC3);
+}
+
+/**
+ * Show the counters to the user
+ *
+ * @param m
+ * @param v
+ * @return
+ */
+static int proc_perf_show(struct seq_file *m, void *v)
+{
+	int cpu;
+	int i;
+
+	proc_perf_update();
+
+	seq_printf(m, "       %16s %16s\n",
+		   proc_perf_label[proc_perf_counter_control[0]],
+		   proc_perf_label[proc_perf_counter_control[1]]);
+	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+		if (cpu_online(cpu))
+			seq_printf(m, "CPU%2d: %16lu %16lu\n", cpu,
+				   proc_perf_counter_data[cpu][0],
+				   proc_perf_counter_data[cpu][1]);
+	}
+
+	seq_printf(m, "\n");
+	for (i = 0; i < 4; i++)
+		seq_printf(m, "%s: %lu\n",
+			   proc_perf_l2label[proc_perf_l2counter_control[i]],
+			   proc_perf_l2counter_data[i]);
+
+	seq_printf(m,
+		   "\n"
+		   "Configuration of the performance counters is controller by writing\n"
+		   "one of the following values to:\n"
+		   "    /sys/module/perf_counters/parameters/counter{0,1}\n"
+		   "    /sys/module/perf_counters/parameters/l2counter{0-3}\n"
+		   "\n" "Possible CPU counters:");
+	for (i = 0; i < PROC_PERF_CORE_MAX; i++) {
+		if ((i & 7) == 0)
+			seq_printf(m, "\n    ");
+		if (proc_perf_label[i])
+			seq_printf(m, "%s ", proc_perf_label[i]);
+	}
+
+	seq_printf(m, "\n\nPossible L2 counters:");
+	for (i = 0; i < PROC_PERF_L2_MAX; i++) {
+		if ((i & 3) == 0)
+			seq_printf(m, "\n    ");
+		if (proc_perf_l2label[i])
+			seq_printf(m, "%s ", proc_perf_l2label[i]);
+	}
+	seq_printf(m,
+		   "\nWarning: Counter configuration doesn't update till you access /proc/octeon_perf.\n");
+
+	proc_perf_setup();
+	return 0;
+}
+
+/**
+ * /proc/octeon_perf was openned. Use the single_open iterator
+ *
+ * @param inode
+ * @param file
+ * @return
+ */
+static int proc_perf_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_perf_show, NULL);
+}
+
+/**
+ * IOCTL on /proc/octeon_perf
+ *
+ * @param inode
+ * @param file
+ * @param cmd
+ * @param arg
+ * @return
+ */
+static int proc_perf_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	pr_debug("proc_perf_ioctl(cmd=0x%x(%u), arg=0x%lx)\n", cmd, cmd, arg);
+	switch (cmd) {
+	case PROC_PERF_IOCTL_SETUP_COUNTER0:
+		if ((arg <= PROC_PERF_CORE_MAX) && proc_perf_label[arg]) {
+			strcpy(counter0, proc_perf_label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_SETUP_COUNTER1:
+		if ((arg <= PROC_PERF_CORE_MAX) && proc_perf_label[arg]) {
+			strcpy(counter1, proc_perf_label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_SETUP_L2COUNTER0:
+		if ((arg <= PROC_PERF_L2_MAX) && proc_perf_l2label[arg]) {
+			strcpy(l2counter0, proc_perf_l2label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_SETUP_L2COUNTER1:
+		if ((arg <= PROC_PERF_L2_MAX) && proc_perf_l2label[arg]) {
+			strcpy(l2counter1, proc_perf_l2label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_SETUP_L2COUNTER2:
+		if ((arg <= PROC_PERF_L2_MAX) && proc_perf_l2label[arg]) {
+			strcpy(l2counter2, proc_perf_l2label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_SETUP_L2COUNTER3:
+		if ((arg <= PROC_PERF_L2_MAX) && proc_perf_l2label[arg]) {
+			strcpy(l2counter3, proc_perf_l2label[arg]);
+			proc_perf_setup();
+			return 0;
+		}
+		return -EINVAL;
+	case PROC_PERF_IOCTL_READ_COUNTER0:
+		proc_perf_update();
+		copy_to_user((void *)arg,
+			     proc_perf_counter_data[smp_processor_id()] + 0,
+			     sizeof(long long));
+		return 0;
+	case PROC_PERF_IOCTL_READ_COUNTER1:
+		proc_perf_update();
+		copy_to_user((void *)arg,
+			     proc_perf_counter_data[smp_processor_id()] + 1,
+			     sizeof(long long));
+		return 0;
+	case PROC_PERF_IOCTL_READ_L2COUNTER0:
+		proc_perf_update();
+		copy_to_user((void *)arg, proc_perf_l2counter_data + 0,
+			     sizeof(long long));
+		return 0;
+	case PROC_PERF_IOCTL_READ_L2COUNTER1:
+		proc_perf_update();
+		copy_to_user((void *)arg, proc_perf_l2counter_data + 1,
+			     sizeof(long long));
+		return 0;
+	case PROC_PERF_IOCTL_READ_L2COUNTER2:
+		proc_perf_update();
+		copy_to_user((void *)arg, proc_perf_l2counter_data + 2,
+			     sizeof(long long));
+		return 0;
+	case PROC_PERF_IOCTL_READ_L2COUNTER3:
+		proc_perf_update();
+		copy_to_user((void *)arg, proc_perf_l2counter_data + 3,
+			     sizeof(long long));
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct file_operations proc_perf_operations = {
+	.open = proc_perf_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.ioctl = proc_perf_ioctl,
+};
+
+/**
+ * Module initialization
+ *
+ * @return
+ */
+static int __init proc_perf_init(void)
+{
+	printk
+	    ("/proc/octeon_perf: Octeon performace counter interface loaded\n");
+
+	memset(proc_perf_label, 0, sizeof(proc_perf_label));
+	memset(proc_perf_l2label, 0, sizeof(proc_perf_l2label));
+
+	proc_perf_label[PROC_PERF_CORE_NONE] = "none";
+	proc_perf_label[PROC_PERF_CORE_CLK] = "clk";
+	proc_perf_label[PROC_PERF_CORE_ISSUE] = "issue";
+	proc_perf_label[PROC_PERF_CORE_RET] = "ret";
+	proc_perf_label[PROC_PERF_CORE_NISSUE] = "nissue";
+	proc_perf_label[PROC_PERF_CORE_SISSUE] = "sissue";
+	proc_perf_label[PROC_PERF_CORE_DISSUE] = "dissue";
+	proc_perf_label[PROC_PERF_CORE_IFI] = "ifi";
+	proc_perf_label[PROC_PERF_CORE_BR] = "br";
+	proc_perf_label[PROC_PERF_CORE_BRMIS] = "brmis";
+	proc_perf_label[PROC_PERF_CORE_J] = "j";
+	proc_perf_label[PROC_PERF_CORE_JMIS] = "jmis";
+	proc_perf_label[PROC_PERF_CORE_REPLAY] = "replay";
+	proc_perf_label[PROC_PERF_CORE_IUNA] = "iuna";
+	proc_perf_label[PROC_PERF_CORE_TRAP] = "trap";
+	proc_perf_label[PROC_PERF_CORE_UULOAD] = "uuload";
+	proc_perf_label[PROC_PERF_CORE_UUSTORE] = "uustore";
+	proc_perf_label[PROC_PERF_CORE_ULOAD] = "uload";
+	proc_perf_label[PROC_PERF_CORE_USTORE] = "ustore";
+	proc_perf_label[PROC_PERF_CORE_EC] = "ec";
+	proc_perf_label[PROC_PERF_CORE_MC] = "mc";
+	proc_perf_label[PROC_PERF_CORE_CC] = "cc";
+	proc_perf_label[PROC_PERF_CORE_CSRC] = "csrc";
+	proc_perf_label[PROC_PERF_CORE_CFETCH] = "cfetch";
+	proc_perf_label[PROC_PERF_CORE_CPREF] = "cpref";
+	proc_perf_label[PROC_PERF_CORE_ICA] = "ica";
+	proc_perf_label[PROC_PERF_CORE_II] = "ii";
+	proc_perf_label[PROC_PERF_CORE_IP] = "ip";
+	proc_perf_label[PROC_PERF_CORE_CIMISS] = "cimiss";
+	proc_perf_label[PROC_PERF_CORE_WBUF] = "wbuf";
+	proc_perf_label[PROC_PERF_CORE_WDAT] = "wdat";
+	proc_perf_label[PROC_PERF_CORE_WBUFLD] = "wbufld";
+	proc_perf_label[PROC_PERF_CORE_WBUFFL] = "wbuffl";
+	proc_perf_label[PROC_PERF_CORE_WBUFTR] = "wbuftr";
+	proc_perf_label[PROC_PERF_CORE_BADD] = "badd";
+	proc_perf_label[PROC_PERF_CORE_BADDL2] = "baddl2";
+	proc_perf_label[PROC_PERF_CORE_BFILL] = "bfill";
+	proc_perf_label[PROC_PERF_CORE_DDIDS] = "ddids";
+	proc_perf_label[PROC_PERF_CORE_IDIDS] = "idids";
+	proc_perf_label[PROC_PERF_CORE_DIDNA] = "didna";
+	proc_perf_label[PROC_PERF_CORE_LDS] = "lds";
+	proc_perf_label[PROC_PERF_CORE_LMLDS] = "lmlds";
+	proc_perf_label[PROC_PERF_CORE_IOLDS] = "iolds";
+	proc_perf_label[PROC_PERF_CORE_DMLDS] = "dmlds";
+	proc_perf_label[PROC_PERF_CORE_STS] = "sts";
+	proc_perf_label[PROC_PERF_CORE_LMSTS] = "lmsts";
+	proc_perf_label[PROC_PERF_CORE_IOSTS] = "iosts";
+	proc_perf_label[PROC_PERF_CORE_IOBDMA] = "iobdma";
+	proc_perf_label[PROC_PERF_CORE_DTLB] = "dtlb";
+	proc_perf_label[PROC_PERF_CORE_DTLBAD] = "dtlbad";
+	proc_perf_label[PROC_PERF_CORE_ITLB] = "itlb";
+	proc_perf_label[PROC_PERF_CORE_SYNC] = "sync";
+	proc_perf_label[PROC_PERF_CORE_SYNCIOB] = "synciob";
+	proc_perf_label[PROC_PERF_CORE_SYNCW] = "syncw";
+
+	proc_perf_l2label[PROC_PERF_L2_CYCLES] = "cycles";
+	proc_perf_l2label[PROC_PERF_L2_IMISS] = "imiss";
+	proc_perf_l2label[PROC_PERF_L2_IHIT] = "ihit";
+	proc_perf_l2label[PROC_PERF_L2_DMISS] = "dmiss";
+	proc_perf_l2label[PROC_PERF_L2_DHIT] = "dhit";
+	proc_perf_l2label[PROC_PERF_L2_MISS] = "miss";
+	proc_perf_l2label[PROC_PERF_L2_HIT] = "hit";
+	proc_perf_l2label[PROC_PERF_L2_VICTIM_BUFFER_HIT] = "victim-buffer-hit";
+	proc_perf_l2label[PROC_PERF_L2_LFB_NQ_INDEX_CONFLICT] =
+	    "lfb-nq-index-conflict";
+	proc_perf_l2label[PROC_PERF_L2_TAG_PROBE] = "tag-probe";
+	proc_perf_l2label[PROC_PERF_L2_TAG_UPDATE] = "tag-update";
+	proc_perf_l2label[PROC_PERF_L2_TAG_PROBE_COMPLETED] =
+	    "tag-probe-completed";
+	proc_perf_l2label[PROC_PERF_L2_TAG_DIRTY_VICTIM] = "tag-dirty-victim";
+	proc_perf_l2label[PROC_PERF_L2_DATA_STORE_NOP] = "data-store-nop";
+	proc_perf_l2label[PROC_PERF_L2_DATA_STORE_READ] = "data-store-read";
+	proc_perf_l2label[PROC_PERF_L2_DATA_STORE_WRITE] = "data-store-write";
+	proc_perf_l2label[PROC_PERF_L2_MEMORY_FILL_DATA_VALID] =
+	    "memory-fill-data-valid";
+	proc_perf_l2label[PROC_PERF_L2_MEMORY_WRITE_REQUEST] =
+	    "memory-write-request";
+	proc_perf_l2label[PROC_PERF_L2_MEMORY_READ_REQUEST] =
+	    "memory-read-request";
+	proc_perf_l2label[PROC_PERF_L2_MEMORY_WRITE_DATA_VALID] =
+	    "memory-write-data-valid";
+	proc_perf_l2label[PROC_PERF_L2_XMC_NOP] = "xmc-nop";
+	proc_perf_l2label[PROC_PERF_L2_XMC_LDT] = "xmc-ldt";
+	proc_perf_l2label[PROC_PERF_L2_XMC_LDI] = "xmc-ldi";
+	proc_perf_l2label[PROC_PERF_L2_XMC_LDD] = "xmc-ldd";
+	proc_perf_l2label[PROC_PERF_L2_XMC_STF] = "xmc-stf";
+	proc_perf_l2label[PROC_PERF_L2_XMC_STT] = "xmc-stt";
+	proc_perf_l2label[PROC_PERF_L2_XMC_STP] = "xmc-stp";
+	proc_perf_l2label[PROC_PERF_L2_XMC_STC] = "xmc-stc";
+	proc_perf_l2label[PROC_PERF_L2_XMC_DWB] = "xmc-dwb";
+	proc_perf_l2label[PROC_PERF_L2_XMC_PL2] = "xmc-pl2";
+	proc_perf_l2label[PROC_PERF_L2_XMC_PSL1] = "xmc-psl1";
+	proc_perf_l2label[PROC_PERF_L2_XMC_IOBLD] = "xmc-iobld";
+	proc_perf_l2label[PROC_PERF_L2_XMC_IOBST] = "xmc-iobst";
+	proc_perf_l2label[PROC_PERF_L2_XMC_IOBDMA] = "xmc-iobdma";
+	proc_perf_l2label[PROC_PERF_L2_XMC_IOBRSP] = "xmc-iobrsp";
+	proc_perf_l2label[PROC_PERF_L2_XMD_BUS_VALID] = "xmd-bus-valid";
+	proc_perf_l2label[PROC_PERF_L2_XMD_BUS_VALID_DST_L2C] =
+	    "xmd-bus-valid-dst-l2c";
+	proc_perf_l2label[PROC_PERF_L2_XMD_BUS_VALID_DST_IOB] =
+	    "xmd-bus-valid-dst-iob";
+	proc_perf_l2label[PROC_PERF_L2_XMD_BUS_VALID_DST_PP] =
+	    "xmd-bus-valid-dst-pp";
+	proc_perf_l2label[PROC_PERF_L2_RSC_NOP] = "rsc-nop";
+	proc_perf_l2label[PROC_PERF_L2_RSC_STDN] = "rsc-stdn";
+	proc_perf_l2label[PROC_PERF_L2_RSC_FILL] = "rsc-fill";
+	proc_perf_l2label[PROC_PERF_L2_RSC_REFL] = "rsc-refl";
+	proc_perf_l2label[PROC_PERF_L2_RSC_STIN] = "rsc-stin";
+	proc_perf_l2label[PROC_PERF_L2_RSC_SCIN] = "rsc-scin";
+	proc_perf_l2label[PROC_PERF_L2_RSC_SCFL] = "rsc-scfl";
+	proc_perf_l2label[PROC_PERF_L2_RSC_SCDN] = "rsc-scdn";
+	proc_perf_l2label[PROC_PERF_L2_RSD_DATA_VALID] = "rsd-data-valid";
+	proc_perf_l2label[PROC_PERF_L2_RSD_DATA_VALID_FILL] =
+	    "rsd-data-valid-fill";
+	proc_perf_l2label[PROC_PERF_L2_RSD_DATA_VALID_STRSP] =
+	    "rsd-data-valid-strsp";
+	proc_perf_l2label[PROC_PERF_L2_RSD_DATA_VALID_REFL] =
+	    "rsd-data-valid-refl";
+	proc_perf_l2label[PROC_PERF_L2_LRF_REQ] = "lrf-req";
+	proc_perf_l2label[PROC_PERF_L2_DT_RD_ALLOC] = "dt-rd-alloc";
+	proc_perf_l2label[PROC_PERF_L2_DT_WR_INVA] = "dt-wr-inva";
+
+	proc_perf_entry = create_proc_entry("octeon_perf", 0, NULL);
+	if (proc_perf_entry)
+		proc_perf_entry->proc_fops = &proc_perf_operations;
+
+	proc_perf_setup();
+	return 0;
+}
+
+/**
+ * Module cleanup
+ *
+ * @return
+ */
+static void __exit proc_perf_cleanup(void)
+{
+	if (proc_perf_entry)
+		remove_proc_entry("octeon_perf", NULL);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks Octeon performance counter interface.");
+module_init(proc_perf_init);
+module_exit(proc_perf_cleanup);
Index: linux-2.6.10/arch/mips/cavium-octeon/serial.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/serial.c
@@ -0,0 +1,44 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ */
+#include <linux/console.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <asm/time.h>
+#include <linux/serial_core.h>
+#include <asm/gdb-stub.h>
+#include <hal.h>
+
+extern int serial8250_register_port(struct uart_port *);
+
+static int octeon_serial_init(void)
+{
+	int port;
+
+	const int max_port = 1;
+
+	struct uart_port octeon_port;
+	memset(&octeon_port, 0, sizeof(octeon_port));
+	octeon_port.flags = ASYNC_SKIP_TEST | UPF_SHARE_IRQ;
+	octeon_port.iotype = UPIO_MEM;
+	octeon_port.regshift = 3;	/* I/O addresses are every 8 bytes */
+	octeon_port.uartclk = mips_hpt_frequency;	/* Clock rate of the chip */
+	octeon_port.fifosize = 64;
+
+	for (port = 0; port < max_port; port++) {
+		octeon_port.line = port;
+		octeon_port.mapbase = 0x8001180000000800ull + (1024 * port);
+		octeon_port.membase = (unsigned char *)octeon_port.mapbase;
+		// octeon_port.irq = 42+port;
+		serial8250_register_port(&octeon_port);
+
+	}
+
+	return 0;
+}
+
+late_initcall(octeon_serial_init);
Index: linux-2.6.10/arch/mips/cavium-octeon/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/setup.c
@@ -0,0 +1,814 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>	/* for memset */
+#include <linux/console.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <asm/time.h>
+#include <linux/serial_core.h>
+#include <linux/string.h>
+#include <linux/hrtime.h>
+#include <linux/kgdb.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/bootinfo.h>
+#include <asm/gdb-stub.h>
+#include <octeon-app-init.h>
+#include <hal.h>
+
+extern void *octeon_reserve32_memory;
+octeon_bootinfo_t *octeon_bootinfo;
+/* Set to non-zero, so it is not in .bss section and is not zeroed */
+volatile octeon_boot_descriptor_t *octeon_boot_desc_ptr = (void *)0xEADBEEFULL;
+
+#define MAX_MEMORY          ((512ull) << 20)
+
+//#define ECC_REPORT_SINGLE_BIT_ERRORS
+#define EARLY_BOOT_UART     (0)	/* 0 or 1 */
+#define CAVIUM_UART_IRQ     42
+
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+#warning: **************************************************************
+#warning: **************************************************************
+#warning: ************* Single bit ECC errors are reported *************
+#warning: **************************************************************
+#warning: **************************************************************
+#endif
+
+extern void octeon_user_io_init(void);
+extern asmlinkage void octeon_handle_irq(void);
+static uint64_t CYCLES_PER_JIFFY;
+
+/**
+ * Return the version string. Generated from CVS tags. Turns
+ * NAME_V_V_V_build_B into "V.V.V, build B". If the tag isn't of
+ * this format then the tag is returned. If there isn't a tag
+ * then the build date is returned as "Internal __DATE__".
+ *
+ * @return Version string
+ */
+static inline const char *get_version(void)
+{
+	static char version[80];
+	const char *cvs_tag = "$Name:  $";
+
+	if (cvs_tag[7] == ' ') {
+		snprintf(version, sizeof(version), "Internal %s", __DATE__);
+	} else {
+		char *major = NULL;
+		char *minor1 = NULL;
+		char *minor2 = NULL;
+		char *build = NULL;
+		char *buildnum = NULL;
+		char *end = NULL;
+		char buf[80];
+
+		strncpy(buf, cvs_tag, sizeof(buf));
+		buf[sizeof(buf) - 1] = 0;
+
+		major = strchr(buf, '_');
+		if (major) {
+			major++;
+			minor1 = strchr(major, '_');
+			if (minor1) {
+				*minor1 = 0;
+				minor1++;
+				minor2 = strchr(minor1, '_');
+				if (minor2) {
+					*minor2 = 0;
+					minor2++;
+					build = strchr(minor2, '_');
+					if (build) {
+						*build = 0;
+						build++;
+						buildnum = strchr(build, '_');
+						if (buildnum) {
+							*buildnum = 0;
+							buildnum++;
+							end =
+							    strchr(buildnum,
+								   ' ');
+							if (end)
+								*end = 0;
+						}
+					}
+				}
+			}
+		}
+
+		if (major && minor1 && minor2 && build && buildnum
+		    && (strcmp(build, "build") == 0))
+			snprintf(version, sizeof(version), "%s.%s.%s, build %s",
+				 major, minor1, minor2, buildnum);
+		else
+			snprintf(version, sizeof(version), "%s", cvs_tag);
+	}
+
+	return version;
+}
+
+/**
+ * Reboot Octeon
+ *
+ * @param command Command to pass to the bootloader. Currently ignored.
+ */
+static void octeon_restart(char *command)
+{
+	mb();
+	while (1)
+		octeon_write_csr(OCTEON_CIU_SOFT_RST, 1);
+}
+
+/**
+ * Permanently stop a core.
+ *
+ * @param arg
+ */
+static void octeon_kill_core(void *arg)
+{
+	mb();
+}
+
+/**
+ * Halt the system
+ */
+static void octeon_halt(void)
+{
+	smp_call_function(octeon_kill_core, NULL, 0, 0);
+	octeon_kill_core(NULL);
+}
+
+/**
+ * Turn power off. Currently just halts since we can't shut
+ * off power.
+ */
+static void octeon_power_off(void)
+{
+	octeon_halt();
+}
+
+#ifndef CONFIG_CPU_TIMER
+
+/**
+ * This variable is used to correct for a offset on the clock
+ * when Linux boots.
+ */
+static int64_t octeon_hpt_correction = 0;
+
+/**
+ * Read the Octeon high performance counter
+ *
+ * @return The counter value. For some brain dead reason, the kernel
+ *         uses a 32bit number here.
+ */
+static unsigned int octeon_hpt_read(void)
+{
+	if (octeon_is_pass1()) {
+		/* Pass 1 doesn't have a global cycle count */
+		return 0;
+	} else {
+		int64_t cycles = octeon_read_csr(OCTEON_IPD_CLK_COUNT);
+		return cycles - octeon_hpt_correction;
+	}
+}
+
+/**
+ * Initialize the high performance counter.
+ *
+ * @param count  Offset to apply to the counter
+ */
+static void octeon_hpt_init(unsigned int count)
+{
+	octeon_hpt_correction += count;
+}
+
+#endif
+
+/**
+ * Acknowledge a timer tick. We don't use the standard Mips
+ * one because it confuses the timer ticks and the HPT clock.
+ */
+static void octeon_timer_ack(void)
+{
+	uint32_t next_compare, count;
+	next_compare = read_c0_compare() + CYCLES_PER_JIFFY;
+	write_c0_compare(next_compare);
+	count = read_c0_count();
+	if ((count - next_compare) < 0x7fffffff) {
+		next_compare = count + CYCLES_PER_JIFFY;
+		write_c0_compare(next_compare);
+	}
+}
+
+/**
+ * Interrupt entry point for timer ticks
+ *
+ * @param irq
+ * @param dev_id
+ * @param regs
+ * @return
+ */
+static irqreturn_t octeon_main_timer_interrupt(int irq, void *dev_id,
+					       struct pt_regs *regs)
+{
+	if (read_c0_count() - read_c0_compare() >= 0) {
+		if (smp_processor_id() == 0)
+			timer_interrupt(irq, NULL, regs);
+		else {
+			octeon_timer_ack();
+			local_timer_interrupt(irq, NULL, regs);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/**
+ * Setup the first cores timer interrupt
+ *
+ * @param irq
+ * @return
+ */
+static void __init octeon_timer_setup(struct irqaction *irq)
+{
+	irq->handler = octeon_main_timer_interrupt;
+	irq->flags |= SA_SHIRQ;
+	setup_irq(7, irq);
+
+	write_c0_compare(read_c0_count() + CYCLES_PER_JIFFY);
+}
+
+/**
+ * Handle all the error condition interrupts that might occur.
+ *
+ * @param cpl
+ * @param dev_id
+ * @param regs
+ * @return
+ */
+static irqreturn_t octeon_ecc_interrupt(int cpl, void *dev_id,
+					struct pt_regs *regs)
+{
+	static uint64_t single_bit_errors = 0;
+	static uint64_t double_bit_errors = 0;
+	static uint64_t l2t_single_bit_errors = 0;
+	static uint64_t l2t_double_bit_errors = 0;
+	static uint64_t l2d_single_bit_errors = 0;
+	static uint64_t l2d_double_bit_errors = 0;
+	static uint64_t pow_single_bit_errors = 0;
+	static uint64_t pow_double_bit_errors = 0;
+	irqreturn_t result = IRQ_NONE;
+	uint64_t l2t_err, l2d_err, mem_cfg0, pow_err, iob_err, ipd_err, zip_err,
+	    pko_err, tim_err, fpa_err;
+
+	/* Get the ECC status from LMC config zero */
+	mem_cfg0 = octeon_read_csr(OCTEON_LMC_MEM_CFG0);
+	/* Write out the same value to clear the ECC error bits */
+	octeon_write_csr(OCTEON_LMC_MEM_CFG0, mem_cfg0);
+
+	mem_cfg0 = (mem_cfg0 >> 21) & 0xff;
+	if (mem_cfg0 & 0x1)
+		single_bit_errors++;
+	if (mem_cfg0 & 0x2)
+		single_bit_errors++;
+	if (mem_cfg0 & 0x4)
+		single_bit_errors++;
+	if (mem_cfg0 & 0x8)
+		single_bit_errors++;
+	if (mem_cfg0 & 0x10)
+		double_bit_errors++;
+	if (mem_cfg0 & 0x20)
+		double_bit_errors++;
+	if (mem_cfg0 & 0x40)
+		double_bit_errors++;
+	if (mem_cfg0 & 0x80)
+		double_bit_errors++;
+	if (mem_cfg0)
+		result = IRQ_HANDLED;
+
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	if (mem_cfg0)
+#else
+	if (mem_cfg0 & 0xf0)
+#endif
+	{
+		octeon_lmc_fadr_t fadr;
+		fadr.u64 = octeon_read_csr(OCTEON_LMC_FADR);
+		printk("\nECC: %lu Single bit errors, %lu Double bit errors\n"
+		       "ECC:\tFailing dimm:   %u\n"
+		       "ECC:\tFailing rank:   %u\n"
+		       "ECC:\tFailing bank:   %u\n"
+		       "ECC:\tFailing row:    0x%x\n"
+		       "ECC:\tFailing column: 0x%x\n",
+		       single_bit_errors, double_bit_errors, fadr.s.fdimm,
+		       fadr.s.fbunk, fadr.s.fbank, fadr.s.frow, fadr.s.fcol);
+	}
+
+	/* Get the ECC status from L2T_ERR */
+	l2t_err = octeon_read_csr(OCTEON_L2T_ERR);
+	/* Write out the same value to clear the ECC error bits */
+	octeon_write_csr(OCTEON_L2T_ERR, l2t_err);
+
+	l2t_err = (l2t_err >> 3) & 0x3;
+	if (l2t_err & 0x1)
+		l2t_single_bit_errors++;
+	if (l2t_err & 0x2)
+		l2t_double_bit_errors++;
+	if (l2t_err)
+		result = IRQ_HANDLED;
+
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	if (l2t_err)
+#else
+	if (l2t_err & 0x2)
+#endif
+	{
+		printk
+		    ("\nECC: L2T %lu Single bit errors, %lu Double bit errors\n",
+		     l2t_single_bit_errors, l2t_double_bit_errors);
+	}
+
+	/* Get the ECC status from L2D_ERR */
+	l2d_err = octeon_read_csr(OCTEON_L2D_ERR);
+	/* Write out the same value to clear the ECC error bits */
+	octeon_write_csr(OCTEON_L2D_ERR, l2d_err);
+
+	l2d_err = (l2d_err >> 3) & 0x3;
+	if (l2d_err & 0x1)
+		l2d_single_bit_errors++;
+	if (l2d_err & 0x2)
+		l2d_double_bit_errors++;
+	if (l2d_err)
+		result = IRQ_HANDLED;
+
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	if (l2d_err)
+#else
+	if (l2d_err & 0x2)
+#endif
+	{
+		printk
+		    ("\nECC: L2D %lu Single bit errors, %lu Double bit errors\n",
+		     l2d_single_bit_errors, l2d_double_bit_errors);
+	}
+
+	/* Get the ECC status from POW */
+	pow_err = octeon_read_csr(OCTEON_POW_ECC_ERR);
+	/* Write out the same value to clear the ECC error bits */
+	octeon_write_csr(OCTEON_POW_ECC_ERR, pow_err);
+
+	pow_err = pow_err & 0x3;
+	if (pow_err & 0x1)
+		pow_single_bit_errors++;
+	if (pow_err & 0x2)
+		pow_double_bit_errors++;
+	if (pow_err)
+		result = IRQ_HANDLED;
+
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	if (pow_err)
+#else
+	if (pow_err & 0x2)
+#endif
+	{
+		printk
+		    ("\nECC: POW %lu Single bit errors, %lu Double bit errors\n",
+		     pow_single_bit_errors, pow_double_bit_errors);
+	}
+
+	if (!octeon_is_pass1()) {
+		/* Check for IOB SOP and EOP errors */
+		iob_err = octeon_read_csr(OCTEON_IOB_INT_SUM);
+		if (iob_err) {
+			uint64_t port;
+			octeon_write_csr(OCTEON_IOB_INT_SUM, iob_err);
+			port = octeon_read_csr(OCTEON_IOB_PKT_ERR);
+			if (iob_err & 0x1)
+				printk("\nIOB: Port %lu SOP error\n", port);
+			if (iob_err & 0x2)
+				printk("\nIOB: Port %lu EOP error\n", port);
+			if (iob_err & 0x4)
+				printk
+				    ("\nIOB: Passthrough Port %lu SOP error\n",
+				     port);
+			if (iob_err & 0x8)
+				printk
+				    ("\nIOB: Passthrough Port %lu EOP error\n",
+				     port);
+			result = IRQ_HANDLED;
+		}
+
+		ipd_err = octeon_read_csr(OCTEON_IPD_INT_SUM);
+		if (ipd_err) {
+			octeon_write_csr(OCTEON_IPD_INT_SUM, ipd_err);
+			if (ipd_err & 0x1)
+				printk
+				    ("\nIPD: PBM memory parity error [31:0]\n");
+			if (ipd_err & 0x2)
+				printk
+				    ("\nIPD: PBM memory parity error [63:32]\n");
+			if (ipd_err & 0x4)
+				printk
+				    ("\nIPD: PBM memory parity error [95:64]\n");
+			if (ipd_err & 0x8)
+				printk
+				    ("\nIPD: PBM memory parity error [127:96]\n");
+			if (ipd_err & 0x10)
+				printk
+				    ("\nIPD: Backpressure subtract with an illegal value\n");
+			result = IRQ_HANDLED;
+		}
+
+		zip_err = octeon_read_csr(OCTEON_ZIP_ERROR);
+		if (zip_err) {
+			octeon_write_csr(OCTEON_ZIP_ERROR, zip_err);
+			printk("\nZIP: Doorbell overflow\n");
+			result = IRQ_HANDLED;
+		}
+
+		pko_err = octeon_read_csr(OCTEON_PKO_REG_DEBUG0);
+		if (pko_err) {
+			octeon_write_csr(OCTEON_PKO_REG_DEBUG0, 0);
+			printk("PKO: Hardware error\n");
+			result = IRQ_HANDLED;
+		}
+
+		tim_err = octeon_read_csr(OCTEON_TIM_REG_ERROR);
+		if (tim_err) {
+			int i;
+			octeon_write_csr(OCTEON_TIM_REG_ERROR, tim_err);
+			for (i = 0; i < 16; i++)
+				if (tim_err & (1 << i))
+					printk("TIM: Timer wheel %d error\n",
+					       i);
+			result = IRQ_HANDLED;
+		}
+
+		fpa_err = octeon_read_csr(OCTEON_FPA_INT_SUM);
+		if (fpa_err) {
+			octeon_write_csr(OCTEON_FPA_INT_SUM, fpa_err);
+			if (fpa_err & 0x8000000)
+				printk
+				    ("FPA: Set when a Queue 7 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x4000000)
+				printk
+				    ("FPA: Set when a Queue 7 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x2000000)
+				printk
+				    ("FPA: Set when a Queue 7 page count available goes negative.\n");
+			if (fpa_err & 0x1000000)
+				printk
+				    ("FPA: Set when a Queue 6 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x800000)
+				printk
+				    ("FPA: Set when a Queue 6 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x400000)
+				printk
+				    ("FPA: Set when a Queue 6 page count available goes negative.\n");
+			if (fpa_err & 0x200000)
+				printk
+				    ("FPA: Set when a Queue 5 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x100000)
+				printk
+				    ("FPA: Set when a Queue 5 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x80000)
+				printk
+				    ("FPA: Set when a Queue 5 page count available goes negative.\n");
+			if (fpa_err & 0x40000)
+				printk
+				    ("FPA: Set when a Queue 4 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x20000)
+				printk
+				    ("FPA: Set when a Queue 4 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x10000)
+				printk
+				    ("FPA: Set when a Queue 4 page count available goes negative.\n");
+			if (fpa_err & 0x8000)
+				printk
+				    ("FPA: Set when a Queue 3 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x4000)
+				printk
+				    ("FPA: Set when a Queue 3 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x2000)
+				printk
+				    ("FPA: Set when a Queue 3 page count available goes negative.\n");
+			if (fpa_err & 0x1000)
+				printk
+				    ("FPA: Set when a Queue 2 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x800)
+				printk
+				    ("FPA: Set when a Queue 2 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x400)
+				printk
+				    ("FPA: Set when a Queue 2 page count available goes negative.\n");
+			if (fpa_err & 0x200)
+				printk
+				    ("FPA: Set when a Queue 1 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x100)
+				printk
+				    ("FPA: Set when a Queue 1 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x80)
+				printk
+				    ("FPA: Set when a Queue 1 page count available goes negative.\n");
+			if (fpa_err & 0x40)
+				printk
+				    ("FPA: Set when a Queue 0 pointer read from the stack in the L2C does not have the FPA owner ship bit set.\n");
+			if (fpa_err & 0x20)
+				printk
+				    ("FPA: Set when a Queue 0 stack end tag is present and the count available is greater than than pointers present in the FPA.\n");
+			if (fpa_err & 0x10)
+				printk
+				    ("FPA: Set when a Queue 0 page count available goes negative.\n");
+			if (fpa_err & 0x8)
+				printk
+				    ("FPA: Set when a Double Bit Error is detected in FPF1.\n");
+			if (fpa_err & 0x4)
+				printk
+				    ("FPA: Set when a Single Bit Error is detected in FPF1.\n");
+			if (fpa_err & 0x2)
+				printk
+				    ("FPA: Set when a Double Bit Error is detected in FPF0.\n");
+			if (fpa_err & 0x1)
+				printk
+				    ("FPA: Set when a Single Bit Error is detected in FPF0.\n");
+			result = IRQ_HANDLED;
+		}
+	}
+
+	return result;
+}
+
+/**
+ * Return a string representing the system type
+ *
+ * @return
+ */
+const char *get_system_type(void)
+{
+	return "Octeon";
+}
+
+/**
+ * Initialize the interrupt sub system
+ */
+void arch_init_irq(void)
+{
+	extern void octeon_irq_init(void);
+
+	set_except_vector(0, octeon_handle_irq);
+	octeon_irq_init();
+}
+
+/**
+ * Early entry point for arch setup
+ */
+void prom_init(void)
+{
+	uint64_t mem_alloc_size = 1024 << 20;
+	uint64_t total = 0;
+	uint64_t coreid;
+	int count = 0;
+	int i;
+
+	octeon_led_init();
+	octeon_check_cpu_bist();
+
+	coreid = octeon_get_core_num();
+
+	/* Disable All CIU Interrupts. The ones we need will be enabled
+	   later. Read the SUM register so we know the write completed. */
+	octeon_write_csr(OCTEON_CIU_INTX_EN0((coreid * 2)), 0);
+	octeon_write_csr(OCTEON_CIU_INTX_EN0((coreid * 2 + 1)), 0);
+	octeon_read_csr(OCTEON_CIU_INTX_SUM0((coreid * 2)));
+
+	printk("Cavium Networks Version: %s\n", get_version());
+
+	/* Make sure we got the boot descriptor block */
+	if ((octeon_boot_desc_ptr == (void *)0xEADBEEFULL))
+		panic("Boot descriptor block wasn't passed properly\n");
+
+	octeon_bootinfo =
+	    octeon_phys_to_ptr(octeon_boot_desc_ptr->cvmx_desc_vaddr);
+
+	if (octeon_bootinfo->board_type == 2
+	    && octeon_bootinfo->board_rev_major < 2)
+		octeon_write_lcd("Linx");
+	else
+		octeon_write_lcd("LinuxSMP");
+
+	for (i = 0; i < octeon_boot_desc_ptr->argc; i++) {
+		char *arg;
+		arg = octeon_phys_to_ptr(octeon_boot_desc_ptr->argv[i]);
+		if (strlen(arcs_cmdline) + strlen(arg) + 1 <
+		    sizeof(arcs_cmdline) - 1) {
+			strcat(arcs_cmdline, " ");
+			strcat(arcs_cmdline, arg);
+		}
+	}
+
+	if ((octeon_bootinfo->eclock_hz < 300000000) ||
+	    (octeon_bootinfo->eclock_hz > 800000000)) {
+		printk
+		    ("Clock speed from bootloader (%dMhz) is out of range. Assuming 500Mhz\n",
+		     octeon_bootinfo->eclock_hz / 1000000);
+		octeon_bootinfo->eclock_hz = 500000000;
+	}
+
+	/* you should these macros defined in include/asm/bootinfo.h */
+	mips_machgroup = MACH_GROUP_CAVIUM;
+	mips_machtype = MACH_CAVIUM_OCTEON;
+
+	board_timer_setup = octeon_timer_setup;
+	mips_hpt_frequency = octeon_bootinfo->eclock_hz;
+#ifndef CONFIG_CPU_TIMER
+	mips_hpt_read = octeon_hpt_read;
+	mips_hpt_init = octeon_hpt_init;
+	mips_timer_ack = octeon_timer_ack;
+#endif
+	CYCLES_PER_JIFFY = ((mips_hpt_frequency + HZ / 2) / HZ);
+
+	_machine_restart = octeon_restart;
+	_machine_halt = octeon_halt;
+	_machine_power_off = octeon_power_off;
+
+	{
+		struct uart_port octeon_port;
+
+		memset(&octeon_port, 0, sizeof(octeon_port));
+		octeon_port.flags =
+		    ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | UPF_SHARE_IRQ;
+		octeon_port.iotype = UPIO_MEM;
+		octeon_port.regshift = 3;	/* I/O addresses are every 8 bytes */
+		octeon_port.uartclk = mips_hpt_frequency;	/* Clock rate of the chip */
+		octeon_port.fifosize = 64;
+
+		octeon_port.line = 0;
+		octeon_port.mapbase = 0x8001180000000800ull + (1024 * 0);
+		octeon_port.membase = (unsigned char *)octeon_port.mapbase;
+		early_serial_setup(&octeon_port);
+
+		octeon_port.line = 1;
+		octeon_port.mapbase = 0x8001180000000800ull + (1024 * 1);
+		octeon_port.membase = (unsigned char *)octeon_port.mapbase;
+		early_serial_setup(&octeon_port);
+
+#ifdef CONFIG_KGDB
+		octeon_port.irq = CAVIUM_UART_IRQ + 1;
+		kgdb8250_add_port(1, &octeon_port);
+#endif
+
+	}
+	/* Ignore invalid values of CONFIG_CAVIUM_RESERVE32 */
+	if (CONFIG_CAVIUM_RESERVE32 == 512 || CONFIG_CAVIUM_RESERVE32 == 1024)
+		octeon_reserve32_memory =
+		    (void *)(0x80000000 - (CONFIG_CAVIUM_RESERVE32 << 20));
+	else
+		octeon_reserve32_memory = NULL;
+
+	if (mem_alloc_size > MAX_MEMORY)
+		mem_alloc_size = MAX_MEMORY;
+
+	while ((count < BOOT_MEM_MAP_MAX) && (mem_alloc_size >= (1 << 20)) &&
+	       (total < MAX_MEMORY)) {
+		uint64_t memory;
+		if (!octeon_reserve32_memory) {
+			memory =
+			    octeon_ptr_to_phys(octeon_bootmem_alloc
+					       (mem_alloc_size, 0x10000));
+		} else {
+			/* If a 32 bit memory region has been set up, we want to avoid allocating kernel memory
+			 ** from that region.  To do this, we will allocate from the ranges above and below the 32 bit region.
+			 ** First allocate from the range above 32 bit space (this is likely to have larger chunks available,
+			 ** and try the lower range when the upper range fails.  This should result in alloc size backoff only
+			 ** when both ranges fail to alloc a given size. */
+			memory =
+			    octeon_ptr_to_phys(octeon_bootmem_alloc_range
+					       (mem_alloc_size, 0x10000,
+						0x80000000, 0x3ffffffffull));
+			if (!memory)
+				memory =
+				    octeon_ptr_to_phys
+				    (octeon_bootmem_alloc_range
+				     (mem_alloc_size, 0x10000, 0,
+				      (uint64_t) octeon_reserve32_memory - 1));
+		}
+
+		if (memory) {
+			memset(octeon_phys_to_ptr(memory), 0, mem_alloc_size);
+			add_memory_region(memory, mem_alloc_size, BOOT_MEM_RAM);
+			total += mem_alloc_size;
+			count++;
+		} else {
+			mem_alloc_size /= 2;
+		}
+	}
+
+	if (total == 0)
+		panic("Unable to allocate memory from octeon_bootmem_alloc\n");
+
+	set_c0_status(0xff << 8);	/* Enable core interrupt processing */
+
+}
+
+unsigned long prom_free_prom_memory(void)
+{
+	uint64_t mem_cfg0, l2t_err, l2d_err, pow_ecc;
+
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	octeon_user_io_init();
+#endif
+
+	/* Add an interrupt handler for ECC failures. Will also check ECC
+	   status on any interrupt on this line */
+	request_irq(8 + 46, octeon_ecc_interrupt, SA_SHIRQ, "ECC",
+		    octeon_ecc_interrupt);
+
+	/* Enable ECC Interrupts for double bit errors from main memory */
+	mem_cfg0 = octeon_read_csr(OCTEON_LMC_MEM_CFG0);
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	mem_cfg0 |= 0x3 << 19;
+#else
+	mem_cfg0 |= 0x2 << 19;
+#endif
+	octeon_write_csr(OCTEON_LMC_MEM_CFG0, mem_cfg0);
+
+	/* Enable ECC Interrupts for double bit errors from L2C Tags */
+	l2t_err = octeon_read_csr(OCTEON_L2T_ERR);
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	l2t_err |= 0x7;
+#else
+	l2t_err |= 0x5;
+#endif
+	octeon_write_csr(OCTEON_L2T_ERR, l2t_err);
+
+	/* Enable ECC Interrupts for double bit errors from L2D Errors */
+	l2d_err = octeon_read_csr(OCTEON_L2D_ERR);
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	l2d_err |= 0x7;
+#else
+	l2d_err |= 0x5;
+#endif
+	octeon_write_csr(OCTEON_L2D_ERR, l2d_err);
+
+	/* Enable ECC Interrupts for double bit errors from the POW */
+	pow_ecc = octeon_read_csr(OCTEON_POW_ECC_ERR);
+#ifdef ECC_REPORT_SINGLE_BIT_ERRORS
+	pow_ecc |= 0x3 << 2;
+#else
+	pow_ecc |= 0x2 << 2;
+#endif
+	octeon_write_csr(OCTEON_POW_ECC_ERR, pow_ecc);
+
+	if (!octeon_is_pass1()) {
+		/* Enable interrupt on IOB port SOP and EOP errors */
+		octeon_write_csr(OCTEON_IOB_INT_ENB, 0xf);
+
+		/* Enable interrupts on IPD errors */
+		octeon_write_csr(OCTEON_IPD_INT_ENB, 0x1f);
+
+		/* Enable zip interrupt on errors */
+		octeon_write_csr(OCTEON_ZIP_INT_MASK, 1);
+
+		/* Enable PKO interrupt on errors */
+		octeon_write_csr(OCTEON_PKO_REG_INT_MASK, 0x2);
+
+		/* Enable Timer interrupt on errors */
+		octeon_write_csr(OCTEON_TIM_REG_INT_MASK, 0xff);
+
+		/* Enable FPA interrupt on errors */
+		octeon_write_csr(OCTEON_FPA_INT_ENB, 0xfffffff);
+	}
+
+	return 0;
+}
+
+/**
+ * This is called from arch/mips/kernel/setup.c early
+ * during startup.
+ *
+ * @return
+ */
+void __init plat_setup(void)
+{
+	/* Currently nothing to do here... */
+}
+
+EXPORT_SYMBOL(octeon_bootinfo);
Index: linux-2.6.10/arch/mips/cavium-octeon/smp.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/smp.c
@@ -0,0 +1,222 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004-2005 Cavium Networks
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/smp.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <asm/mmu_context.h>
+#include <asm/time.h>
+#include <asm/system.h>
+
+#include <octeon-app-init.h>
+#include <hal.h>
+
+extern void octeon_user_io_init(void);
+
+volatile unsigned long octeon_processor_boot = 0xff;
+volatile unsigned long octeon_processor_sp;
+volatile unsigned long octeon_processor_gp;
+
+extern volatile octeon_boot_descriptor_t *octeon_boot_desc_ptr;
+
+/**
+ * Mailbox interrupt handler
+ *
+ * @param irq
+ * @param regs
+ */
+void mailbox_interrupt(int irq, struct pt_regs *regs)
+{
+	const uint64_t coreid = octeon_get_core_num();
+	uint64_t action;
+
+	/* Count the IRQs manually since we skip the normal process */
+	kstat_this_cpu.irqs[irq]++;
+
+	/* Load the mailbox register to figure out what we're supposed to do */
+	action = octeon_read_csr(OCTEON_CIU_MBOX_CLRX(coreid));
+
+	if (action) {
+		//octeon_led_set(1, 31-coreid);
+
+		/* Clear the mailbox to clear the interrupt */
+		octeon_write_csr(OCTEON_CIU_MBOX_CLRX(coreid), action);
+
+		pr_debug("SMP: Mailbox interrupt cpu=%u, coreid=%lu action=%lu\n", cpu_number_map(coreid), coreid, action);
+
+		if (action & SMP_CALL_FUNCTION) {
+			smp_call_function_interrupt();
+		}
+
+		/* Check if we've been told to flush the icache */
+		if (action & SMP_ICACHE_FLUSH) {
+			asm volatile ("synci 0($0)\n");
+		}
+		//octeon_led_clear(1, 31-coreid);
+	}
+}
+
+/**
+ * Cause the function described by call_data to be executed on the passed
+ * cpu.  When the function has finished, increment the finished field of
+ * call_data.
+ *
+ * @param cpu
+ * @param action
+ */
+void core_send_ipi(int cpu, unsigned int action)
+{
+	int coreid = cpu_logical_map(cpu);
+	pr_debug("SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n", cpu, coreid, action);
+	octeon_write_csr(OCTEON_CIU_MBOX_SETX(coreid), action);
+}
+
+/**
+ * Detect available CPUs, populate phys_cpu_present_map
+ */
+static void prom_build_cpu_map(void)
+{
+	const uint64_t coreid = octeon_get_core_num();
+	int cpus;
+	int id;
+
+	uint64_t core_mask = octeon_boot_desc_ptr->core_mask;
+
+	cpus_clear(phys_cpu_present_map);
+	__cpu_number_map[coreid] = 0;
+	__cpu_logical_map[0] = coreid;
+	cpu_set(0, phys_cpu_present_map);
+
+	cpus = 1;
+	for (id = 0; id < 16; id++) {
+		if ((id != coreid) && (core_mask & (1 << id))) {
+			cpu_set(cpus, phys_cpu_present_map);
+			__cpu_number_map[id] = cpus;
+			__cpu_logical_map[cpus] = id;
+			cpus++;
+		}
+	}
+}
+
+/**
+ * Firmware CPU startup hook
+ *
+ * @param cpu
+ * @param idle
+ */
+void prom_boot_secondary(int cpu, struct task_struct *idle)
+{
+	uint64_t count;
+
+	printk("SMP: Booting CPU%02d (CoreId %2d)...", cpu,
+	       cpu_logical_map(cpu));
+
+	octeon_processor_sp = __KSTK_TOS(idle);
+	octeon_processor_gp = (unsigned long)idle->thread_info;
+	mb();
+	octeon_processor_boot = cpu_logical_map(cpu);
+	mb();
+
+	count = 10000;
+	while (octeon_processor_sp && count) {
+		/* Waiting for processor to get the SP and GP */
+		udelay(1);
+		count--;
+	}
+	if (count == 0)
+		printk("Timeout\n");
+}
+
+/**
+ * After we've done initial boot, this function is called to allow the
+ * board code to clean up state, if needed
+ */
+void prom_init_secondary(void)
+{
+	const uint64_t coreid = octeon_get_core_num();
+	octeon_ciu_intx0_t interrupt_enable;
+
+	octeon_check_cpu_bist();
+
+	pr_debug("SMP: CPU%d (CoreId %lu) started\n", cpu, coreid);
+
+	/* Enable Mailbox interrupts to this core. These are the only interrupts
+	   allowed on line 3 */
+	octeon_write_csr(OCTEON_CIU_MBOX_CLRX(coreid), 0xffffffff);
+	interrupt_enable.u64 = 0;
+	interrupt_enable.s.mbox = 0x3;
+	octeon_write_csr(OCTEON_CIU_INTX_EN0((coreid * 2)), 0);
+	octeon_write_csr(OCTEON_CIU_INTX_EN0((coreid * 2 + 1)),
+			 interrupt_enable.u64);
+	set_c0_status(0xff01);	/* Enable core interrupt processing */
+}
+
+/**
+ * Callout to firmware before smp_init
+ *
+ * @param max_cpus
+ */
+void prom_prepare_cpus(unsigned int max_cpus)
+{
+	const uint64_t coreid = octeon_get_core_num();
+	octeon_ciu_intx0_t interrupt_enable;
+
+	/* This irq register is just a placeholder. For speed, the low level
+	   interrupt handler calls mailbox_interrupt directly. This just
+	   lets the normal interrupt handling stuff know */
+	request_irq(3,
+		    (irqreturn_t(*)
+		     (int, void *, struct pt_regs *))mailbox_interrupt,
+		    SA_SHIRQ, "IPC", mailbox_interrupt);
+
+	/* Enable Mailbox interrupts to this core. These are the only interrupts
+	   allowed on line 3 */
+	octeon_write_csr(OCTEON_CIU_MBOX_CLRX(coreid), 0xffffffff);
+	interrupt_enable.u64 = 0;
+	interrupt_enable.s.mbox = 0x3;
+	octeon_write_csr(OCTEON_CIU_INTX_EN0((coreid * 2 + 1)),
+			 interrupt_enable.u64);
+
+	prom_build_cpu_map();
+}
+
+/**
+ * Last chance for the board code to finish SMP initialization before
+ * the CPU is "online".
+ */
+void prom_smp_finish(void)
+{
+
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	octeon_user_io_init();
+#endif
+
+	/* to generate the first CPU timer interrupt */
+	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
+}
+
+/**
+ * Hook for after all CPUs are online
+ */
+void prom_cpus_done(void)
+{
+#ifdef CONFIG_CPU_TIMER
+	/*
+	 * Now that all the slave processors are up and running,
+	 * sync the count registers accross all
+	 */
+	extern void sync_c0_count_master(void);
+
+	sync_c0_count_master();
+#endif
+
+}
+
+EXPORT_SYMBOL(__cpu_logical_map);
Index: linux-2.6.10/arch/mips/cavium-octeon/userio.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/cavium-octeon/userio.c
@@ -0,0 +1,141 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>	/* for memset */
+#include <linux/console.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <asm/time.h>
+#include <linux/serial_core.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+#include <asm/bootinfo.h>
+#include <hal.h>
+
+void *octeon_reserve32_memory = NULL;
+
+extern void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
+			    unsigned long entryhi, unsigned long pagemask);
+
+/**
+ *
+ * @return
+ */
+void octeon_user_io_init(void)
+{
+	octeon_cvmemctl_t cvmmemctl;
+	octeon_iob_fau_timeout_t fau_timeout;
+	octeon_pow_nw_tim_t nm_tim;
+
+	/* Get the current settings for CP0_CVMMEMCTL_REG */
+	cvmmemctl.u64 = __read_64bit_c0_register($11, 7);
+
+	cvmmemctl.s.dismarkwblongto = 0;    /**< R/W If set, marked write-buffer entries time out the same as
+						as other entries; if clear, marked write-buffer entries use the
+						maximum timeout. */
+	cvmmemctl.s.dismrgclrwbto = 0;	    /**< R/W If set, a merged store does not clear the write-buffer entry
+						timeout state. */
+	cvmmemctl.s.iobdmascrmsb = 0;	    /**< R/W Two bits that are the MSBs of the resultant CVMSEG LM word
+						location for an IOBDMA. The other 8 bits come from the SCRADDR
+						field of the IOBDMA. */
+	cvmmemctl.s.syncwsmarked = 0;	    /**< R/W If set, SYNCWS and SYNCS only order marked stores; if clear,
+						SYNCWS and SYNCS only order unmarked stores. SYNCWSMARKED has no
+						effect when DISSYNCWS is set. */
+	cvmmemctl.s.dissyncws = 0;	    /**< R/W If set, SYNCWS acts as SYNCW and SYNCS acts as SYNC. */
+	if (octeon_is_pass1())
+		cvmmemctl.s.diswbfst = 0;   /**< R/W If set, no stall happens on write buffer full. */
+	else
+		cvmmemctl.s.diswbfst = 1;   /**< R/W If set, no stall happens on write buffer full. */
+	cvmmemctl.s.xkmemenas = 0;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
+						XKPHYS addresses with VA<48>==0 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	cvmmemctl.s.xkmemenau = 1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
+						addresses with VA<48>==0 */
+#else
+	cvmmemctl.s.xkmemenau = 0;
+#endif
+	cvmmemctl.s.xkioenas = 0;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
+						XKPHYS addresses with VA<48>==1 */
+	cvmmemctl.s.xkioenau = 1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
+						addresses with VA<48>==1 */
+	cvmmemctl.s.allsyncw = 0;	    /**< R/W If set, all stores act as SYNCW (NOMERGE must be set when
+						this is set) RW, reset to 0. */
+	cvmmemctl.s.nomerge = 0;	    /**< R/W If set, no stores merge, and all stores reach the coherent
+						bus in order. */
+	cvmmemctl.s.didtto = 0;		    /**< R/W Selects the bit in the counter used for DID time-outs
+						0 = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is between
+						1 and 2 this interval. For example, with DIDTTO=3, expiration
+						interval is between 16K and 32K. */
+	cvmmemctl.s.csrckalwys = 0;	    /**< R/W If set, the (mem) CSR clock never turns off. */
+	cvmmemctl.s.mclkalwys = 0;	    /**< R/W If set, mclk never turns off. */
+	cvmmemctl.s.wbfltime = 0;	    /**< R/W Selects the bit in the counter used for write buffer flush
+						time-outs (WBFLT+11) is the bit position in an internal counter
+						used to determine expiration. The write buffer expires between
+						1 and 2 this interval. For example, with WBFLT = 0, a write
+						buffer expires between 2K and 4K cycles after the write buffer
+						entry is allocated. */
+	cvmmemctl.s.istrnol2 = 0;	    /**< R/W If set, do not put Istream in the L2 cache. */
+	cvmmemctl.s.wbthresh = 10;	    /**< R/W The write buffer threshold. */
+	cvmmemctl.s.cvmsegenak = 1;	    /**< R/W If set, CVMSEG is available for loads/stores in kernel/debug mode. */
+	cvmmemctl.s.cvmsegenas = 0;	    /**< R/W If set, CVMSEG is available for loads/stores in supervisor mode. */
+	cvmmemctl.s.cvmsegenau = 0;	    /**< R/W If set, CVMSEG is available for loads/stores in user mode. */
+	cvmmemctl.s.lmemsz = CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE;
+							   /**< R/W Size of local memory in cache blocks, 54 (6912 bytes) is max legal value. */
+
+	if (smp_processor_id() == 0)
+		printk("CVMSEG size: %d cache lines (%d bytes)\n",
+		       CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE,
+		       CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE * 128);
+
+	__write_64bit_c0_register($11, 7, cvmmemctl.u64);
+
+	if (octeon_reserve32_memory) {
+		uint64_t size = CONFIG_CAVIUM_RESERVE32;
+		uint64_t entrylo0 =
+		    0x7 |
+		    ((((uint64_t) octeon_reserve32_memory & ((1ul << 40) - 1)))
+		     >> 6);
+		uint64_t entrylo1 = entrylo0 + (256 << 14);
+		uint64_t entryhi =
+		    (0x80000000UL - (CONFIG_CAVIUM_RESERVE32 << 20));
+		while (size >= 512) {
+			add_wired_entry(entrylo0, entrylo1, entryhi, PM_256M);
+			entrylo0 += 512 << 14;
+			entrylo1 += 512 << 14;
+			entryhi += 512 << 20;
+			size -= 512;
+		}
+		if (size != 0) {
+			printk("Invalid size specified for CAVIUM_RESERVE32\n");
+		}
+	}
+
+	/* Set a default for the hardware timeouts */
+	fau_timeout.u64 = 0;
+	fau_timeout.s.tout_enb = 1;
+	fau_timeout.s.tout_val = 16;	/* 4096 cycles */
+	octeon_write_csr(OCTEON_IOB_FAU_TIMEOUT, fau_timeout.u64);
+
+	nm_tim.u64 = 0;
+	nm_tim.s.nw_tim = 3;	/* 4096 cycles */
+	octeon_write_csr(OCTEON_POW_NW_TIM, nm_tim.u64);
+}
Index: linux-2.6.10/arch/mips/configs/cavium-octeon_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/configs/cavium-octeon_defconfig
@@ -0,0 +1,801 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.10_mvl402
+# Tue Mar  7 20:06:41 2006
+#
+CONFIG_MIPS=y
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="-Cavium-Octeon"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SEMMNI=128
+CONFIG_SYSVIPC_SEMMSL=250
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=15
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_BOOT_FLIGHT_RECORDER is not set
+CONFIG_LOCKLESS=y
+CONFIG_BOOT_FLIGHT_BUFFERS=4
+CONFIG_BOOT_FLIGHT_SIZE=524288
+CONFIG_FLIGHT_PROC_BUFFERS=8
+CONFIG_FLIGHT_PROC_SIZE=8192
+CONFIG_NEWEV=y
+CONFIG_CSTM=y
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_STOP_MACHINE=y
+
+#
+# Machine selection
+#
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_VR5701_SG2 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_TOSHIBA_RBTX4939 is not set
+CONFIG_CAVIUM_OCTEON_EBT3000=y
+CONFIG_CAVIUM_OCTEON_SPECIFIC_OPTIONS=y
+CONFIG_CAVIUM_OCTEON_HW_FIX_UNALIGNED=y
+CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE=2
+CONFIG_CAVIUM_OCTEON_USER_IO=y
+CONFIG_CAVIUM_OCTEON_USER_MEM=y
+CONFIG_CAVIUM_RESERVE32=0
+CONFIG_CAVIUM_OCTEON_NUM_PACKET_BUFFERS=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT_DESKTOP=y
+# CONFIG_PREEMPT_RT is not set
+CONFIG_PREEMPT=y
+# CONFIG_PREEMPT_SOFTIRQS is not set
+# CONFIG_PREEMPT_HARDIRQS is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_SPINLOCK_BKL is not set
+CONFIG_PREEMPT_BKL=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ASM_SEMAPHORES=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_DMA_COHERENT=y
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_IRQ_CPU_OCTEON=y
+CONFIG_MIPS_L1_CACHE_SHIFT=7
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32 is not set
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R5500 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_CPU_CAVIUM_OCTEON=y
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=16
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_HIGH_RES_RESOLUTION=3
+CONFIG_CPU_TIMER=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_MISC=y
+CONFIG_BUILD_ELF64=y
+CONFIG_MIPS32_COMPAT=y
+CONFIG_COMPAT=y
+CONFIG_MIPS32_O32=y
+CONFIG_MIPS32_N32=y
+CONFIG_BINFMT_ELF32=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+# CONFIG_MTD_MAP_BANK_WIDTH_2 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x1f400000
+CONFIG_MTD_PHYSMAP_LEN=0x800000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=1
+# CONFIG_MTD_MULTI_PHYSMAP is not set
+# CONFIG_MTD_CSTM_MIPS_IXX is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_RAMTD is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_IDEDISK is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_USE_POLICY_FWD=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_BLOCKER is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Synchronous Serial Interfaces (SSI)
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+# CONFIG_YAFFS1_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# MontaVista System tools
+#
+# CONFIG_ILATENCY is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+#CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_WAKEUP_TIMING is not set
+# CONFIG_CRITICAL_PREEMPT_TIMING is not set
+# CONFIG_CRITICAL_IRQSOFF_TIMING is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/cfa2"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
+
+#
+# Fast Real-Time Domain
+#
+# CONFIG_FRD is not set
+
+#
+# Fast Real-Time Domain Advanced Options
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
Index: linux-2.6.10/arch/mips/kernel/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/Makefile
+++ linux-2.6.10/arch/mips/kernel/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_CPU_SB1)		+= r4k_fpu.o r4k_
 obj-$(CONFIG_CPU_MIPS32)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_MIPS64)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R6000)		+= r6000_fpu.o r4k_switch.o
+obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= octeon_switch.o
 
 obj-$(CONFIG_SMP)		+= smp.o
 
@@ -51,6 +52,7 @@ obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
 obj-$(CONFIG_IRQ_CPU_RM7K)	+= irq-rm7000.o
 obj-$(CONFIG_IRQ_CPU_RM9K)	+= irq-rm9000.o
 obj-$(CONFIG_IRQ_MV64340)	+= irq-mv6434x.o
+obj-$(CONFIG_IRQ_CPU_OCTEON)	+= irq-octeon.o
 
 obj-$(CONFIG_MIPS32)		+= scall32-o32.o
 obj-$(CONFIG_MIPS64)		+= scall64-64.o
Index: linux-2.6.10/arch/mips/kernel/binfmt_elfn32.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/binfmt_elfn32.c
+++ linux-2.6.10/arch/mips/kernel/binfmt_elfn32.c
@@ -46,7 +46,11 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 	__res;								\
 })
 
+#ifdef CONFIG_CAVIUM_RESERVE32
+#define TASK32_SIZE		(0x7fff8000UL - (CONFIG_CAVIUM_RESERVE32<<20))
+#else
 #define TASK32_SIZE		0x7fff8000UL
+#endif
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
Index: linux-2.6.10/arch/mips/kernel/binfmt_elfo32.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/binfmt_elfo32.c
+++ linux-2.6.10/arch/mips/kernel/binfmt_elfo32.c
@@ -48,7 +48,11 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 	__res;								\
 })
 
+#ifdef CONFIG_CAVIUM_RESERVE32
+#define TASK32_SIZE		(0x7fff8000UL - (CONFIG_CAVIUM_RESERVE32<<20))
+#else
 #define TASK32_SIZE		0x7fff8000UL
+#endif
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
Index: linux-2.6.10/arch/mips/kernel/cpu-probe.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/cpu-probe.c
+++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
@@ -111,6 +111,7 @@ static inline void check_wait(void)
 	case CPU_24K:
 	case CPU_25KF:
 	case CPU_PR4450:
+	case CPU_CAVIUM_OCTEON:
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
 		break;
@@ -579,6 +580,28 @@ static inline void cpu_probe_philips(str
 	}
 }
 
+static inline void cpu_probe_cavium(struct cpuinfo_mips *c)
+{
+	decode_config1(c);
+	switch (c->processor_id & 0xff00) {
+    case PRID_IMP_CAVIUM_OCTEON:
+		c->cputype = CPU_CAVIUM_OCTEON;
+		c->isa_level = MIPS_CPU_ISA_M64;
+	c->options = MIPS_CPU_TLB |     /* CPU has TLB */
+		    MIPS_CPU_4KEX |     /* "R4K" exception model */
+		    MIPS_CPU_COUNTER |  /* Cycle count/compare */
+		    MIPS_CPU_WATCH |    /* watchpoint registers */
+		    MIPS_CPU_DIVEC |    /* dedicated interrupt vector */
+		    MIPS_CPU_EJTAG |    /* EJTAG exception */
+		    MIPS_CPU_LLSC;      /* CPU has ll/sc instructions */
+		c->tlbsize = 32;
+		break;
+	default:
+		c->cputype = CPU_UNKNOWN;
+		break;
+	}
+}
+
 __init void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -608,6 +631,9 @@ __init void cpu_probe(void)
 	case PRID_COMP_PHILIPS:
 		cpu_probe_philips(c);
 		break;
+	case PRID_COMP_CAVIUM:
+		cpu_probe_cavium(c);
+		break;
 	default:
 		c->cputype = CPU_UNKNOWN;
 	}
Index: linux-2.6.10/arch/mips/kernel/entry.S
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/entry.S
+++ linux-2.6.10/arch/mips/kernel/entry.S
@@ -95,6 +95,13 @@ FEXPORT(restore_all)			# restore full fr
 	RESTORE_STATIC
 FEXPORT(restore_partial)		# restore partial frame
 	RESTORE_SOME
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	dli	k0, (1<<47)
+	or	k1, ra, ra
+	jal	k0
+	nop
+	or	ra, k1, k1
+#endif
 	RESTORE_SP_AND_RET
 	.set	at
 
Index: linux-2.6.10/arch/mips/kernel/head.S
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/head.S
+++ linux-2.6.10/arch/mips/kernel/head.S
@@ -27,6 +27,9 @@
 #include <asm/sn/sn0/hubni.h>
 #include <asm/sn/klkernvars.h>
 #endif
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <kernel-entry-init.h>
+#endif
 
 	.macro	ARC64_TWIDDLE_PC
 #if defined(CONFIG_ARC64) || defined(CONFIG_MAPPED_KERNEL)
@@ -142,6 +145,10 @@ EXPORT(_stext)
 	__INIT
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
+
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	kernel_entry_setup			# cpu specific setup
+#endif
 	setup_c0_status_pri
 
 #ifdef CONFIG_SGI_IP27
Index: linux-2.6.10/arch/mips/kernel/ioctl32.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/ioctl32.c
+++ linux-2.6.10/arch/mips/kernel/ioctl32.c
@@ -19,6 +19,10 @@
 #include <asm/sibyte/trace_prof.h>
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/mach-cavium-octeon/perf_counters.h>
+#endif
+
 #define A(__x) ((unsigned long)(__x))
 
 long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
@@ -47,6 +51,21 @@ COMPATIBLE_IOCTL(SBPROF_ZBSTOP)
 COMPATIBLE_IOCTL(SBPROF_ZBWAITFULL)
 #endif /* CONFIG_SIBYTE_TBPROF */
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_COUNTER0)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_COUNTER1)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_L2COUNTER0)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_L2COUNTER1)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_L2COUNTER2)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_SETUP_L2COUNTER3)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_COUNTER0)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_COUNTER1)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_L2COUNTER0)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_L2COUNTER1)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_L2COUNTER2)
+COMPATIBLE_IOCTL(PROC_PERF_IOCTL_READ_L2COUNTER3)
+#endif /* CONFIG_CPU_CAVIUM_OCTEON */
+
 /*HANDLE_IOCTL(RTC_IRQP_READ, w_long)
 COMPATIBLE_IOCTL(RTC_IRQP_SET)
 HANDLE_IOCTL(RTC_EPOCH_READ, w_long)
Index: linux-2.6.10/arch/mips/kernel/irq-octeon.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/kernel/irq-octeon.c
@@ -0,0 +1,153 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004-2005 Cavium Networks
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+#include <hal.h>
+
+static inline void octeon_unmask_irq(unsigned int irq)
+{
+    unsigned long flags;
+    local_irq_save(flags);
+    if (irq < 8)
+    {
+	clear_c0_cause(0x100 << irq);
+	set_c0_status(0x100 << irq);
+    }
+    else
+    {
+	const uint64_t coreid = octeon_get_core_num();
+	uint64_t bit = (irq - 8) & 0x3f;    /* Bit 0-63 of EN0 */
+	uint64_t index = (irq - 8) >> 6;    /* Route to irq 2 or 3 */
+
+	uint64_t en0 = octeon_read_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index));
+	en0 |= 1ull<<bit;
+	octeon_write_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index), en0);
+    }
+    local_irq_restore(flags);
+}
+
+static inline void octeon_mask_irq(unsigned int irq)
+{
+    unsigned long flags;
+    local_irq_save(flags);
+    if (irq < 8)
+    {
+	clear_c0_status(0x100 << irq);
+    }
+    else
+    {
+	const uint64_t coreid = octeon_get_core_num();
+	uint64_t bit = (irq - 8) & 0x3f;    /* Bit 0-63 of EN0 */
+	uint64_t index = (irq - 8) >> 6;    /* Route to irq 2 or 3 */
+
+	uint64_t en0 = octeon_read_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index));
+	en0 &= ~(1ull<<bit);
+	octeon_write_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index), en0);
+	octeon_read_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index));
+    }
+    local_irq_restore(flags);
+}
+
+static inline void octeon_mask_irq_all(unsigned int irq)
+{
+    unsigned long flags;
+    local_irq_save(flags);
+    if (irq < 8)
+    {
+	clear_c0_status(0x100 << irq);
+    }
+    else
+    {
+	uint64_t bit = (irq - 8) & 0x3f;    /* Bit 0-63 of EN0 */
+	uint64_t index = (irq - 8) >> 6;    /* Route to irq 2 or 3 */
+
+	int cpu;
+	for (cpu=0; cpu<NR_CPUS; cpu++)
+	{
+	    if (cpu_present(cpu))
+	    {
+		uint64_t coreid = cpu_logical_map(cpu);
+		uint64_t en0 = octeon_read_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index));
+		en0 &= ~(1ull<<bit);
+		octeon_write_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index), en0);
+		octeon_read_csr(OCTEON_CIU_INTX_EN0(coreid*2 + index));
+	    }
+	}
+    }
+    local_irq_restore(flags);
+}
+
+
+
+static inline void octeon_irq_enable(unsigned int irq)
+{
+	octeon_unmask_irq(irq);
+}
+
+static void octeon_irq_disable(unsigned int irq)
+{
+	octeon_mask_irq_all(irq);
+}
+
+static unsigned int octeon_irq_startup(unsigned int irq)
+{
+	octeon_unmask_irq(irq);
+	return 0;
+}
+
+static void octeon_irq_shutdown(unsigned int irq)
+{
+	octeon_mask_irq_all(irq);
+}
+
+static void octeon_irq_ack(unsigned int irq)
+{
+	octeon_mask_irq(irq);
+}
+
+static void octeon_irq_end(unsigned int irq)
+{
+    octeon_unmask_irq(irq);
+}
+
+static void octeon_irq_set_affinity(unsigned int irq, cpumask_t dest)
+{
+}
+
+static hw_irq_controller octeon_irq_controller = {
+	"Octeon",
+	octeon_irq_startup,
+	octeon_irq_shutdown,
+	octeon_irq_enable,
+	octeon_irq_disable,
+	octeon_irq_ack,
+	octeon_irq_end,
+    octeon_irq_set_affinity
+};
+
+void __init octeon_irq_init(void)
+{
+	int i;
+
+    if (NR_IRQS < 8 + 64*1)
+	printk("octeon_irq_init: NR_IRQS is set too low\n");
+
+	for (i = 0; i < 8 + 64*1; i++) {
+		irq_desc[i].status = IRQ_DISABLED | IRQ_PER_CPU;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &octeon_irq_controller;
+	}
+    set_c0_status(0x100 << 2);
+}
Index: linux-2.6.10/arch/mips/kernel/octeon_switch.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/kernel/octeon_switch.S
@@ -0,0 +1,489 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994, 1995, 1996, 1998, 1999, 2002, 2003 Ralf Baechle
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1994, 1995, 1996, by Andreas Busse
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ * Copyright (C) 2000 MIPS Technologies, Inc.
+ *    written by Carsten Langgaard, carstenl@mips.com
+ */
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/cachectl.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/offset.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/thread_info.h>
+
+#include <asm/asmmacro.h>
+
+/*
+ * Offset to the current process status flags, the first 32 bytes of the
+ * stack are not used.
+ */
+#define ST_OFF (_THREAD_SIZE - 32 - PT_SIZE + PT_STATUS)
+
+/*
+ * task_struct *resume(task_struct *prev, task_struct *next,
+ *                     struct thread_info *next_ti)
+ */
+	.align	7
+	LEAF(resume)
+#ifndef CONFIG_CPU_HAS_LLSC
+	sw	zero, ll_bit
+#endif
+	mfc0	t1, CP0_STATUS
+	LONG_S	t1, THREAD_STATUS(a0)
+	cpu_save_nonscratch a0
+	LONG_S	ra, THREAD_REG31(a0)
+
+	/* check if we need to save COP2 registers */
+	mfc0	t0, CP0_STATUS
+	bbit0	t0, 30, 1f
+
+	/* Store the COP2 state. I don't need to save ra since it is overwritten
+	    later in cpu_restore_nonscratch */
+	jal octeon_cop2_save
+
+	/* clear saved user stack CU2 bit and disable COP2 */
+	mfc0	t0, CP0_STATUS
+	li	t1, ~ST0_CU2
+	and	t0, t0, t1
+	mtc0	t0, CP0_STATUS
+	LONG_S	t0, THREAD_STATUS(a0)
+	PTR_L	t2, TASK_THREAD_INFO(a0)
+	LONG_L	t0, ST_OFF(t2)
+	and	t0, t0, t1
+	LONG_S	t0, ST_OFF(t2)
+
+1:
+	/* Check if we need to store CVMSEG state */
+	mfc0	t0, $11,7 	/* CvmMemCtl */
+	bbit0	t0, 6, 3f	/* Is user access enabled? */
+
+	/* Store the CVMSEG state */
+	andi	t0, 0x3f	/* Extract the size of CVMSEG */
+	sll	t0, 3		/* Multiply * 8 (cache line size/16) */
+	dli	t1, 0xFFFFFFFFFFFF8000 	/* Base address of CVMSEG */
+	daddi	t2, a0, THREAD_CVMSEG	/* Where to store CVMSEG to */
+	synciobdma
+2:
+	LONG_L	t8, 0(t1)	/* Load from CVMSEG */
+	subu	t0, 1		/* Decrement loop var */
+	LONG_L	t9, 8(t1)	/* Load from CVMSEG */
+	daddu	t1, 16		/* Increment loc in CVMSEG */
+	LONG_S	t8, 0(t2)	/* Store CVMSEG to thread storage */
+	LONG_S	t9, 8(t2)	/* Store CVMSEG to thread storage */
+	daddu	t2, 16		/* Increment loc in thread storage */
+	bnez	t0, 2b		/* Loop until we've copied it all */
+
+	/* Disable access to CVMSEG */
+	mfc0	t0, $11,7 	/* CvmMemCtl */
+	xori	t0, t0, 0x40	/* Bit 6 is CVMSEG user enable */
+	mtc0	t0, $11,7 	/* CvmMemCtl */
+
+3:
+	/*
+	 * The order of restoring the registers takes care of the race
+	 * updating $28, $29 and kernelsp without disabling ints.
+	 */
+	move	$28, a2
+	cpu_restore_nonscratch a1
+
+	PTR_ADDIU	t0, $28, _THREAD_SIZE - 32
+	set_saved_sp	t0, t1, t2
+
+	mfc0	t1, CP0_STATUS		/* Do we really need this? */
+	li	a3, 0xff01
+	and	t1, a3
+	LONG_L	a2, THREAD_STATUS(a1)
+	nor	a3, $0, a3
+	and	a2, a3
+	or	a2, t1
+	mtc0	a2, CP0_STATUS
+	move	v0, a0
+	jr	ra
+	END(resume)
+
+/*
+ * void octeon_cop2_save(struct task_struct *current)
+ */
+	.align	7
+	LEAF(octeon_cop2_save)
+
+	dmfc0	t9, $9,7	/* CvmCtl register. */
+
+        /* Save the COP2 CRC state */
+	dmfc2	t0, 0x0201
+	dmfc2	t1, 0x0202
+	dmfc2	t2, 0x0200
+	LONG_S	t0, THREAD_CP2_CRC_IV(a0)
+	LONG_S	t1, THREAD_CP2_CRC_LENGTH(a0)
+	LONG_S	t2, THREAD_CP2_CRC_POLY(a0)
+
+	bbit1	t9, 28, 1f	/* Skip next instructions if CvmCtl[NODFA_CP2] set */
+
+	/* Save the LLM state */
+	dmfc2	t0, 0x0402
+	dmfc2	t1, 0x040A
+	LONG_S	t0, THREAD_CP2_LLM_DAT(a0)
+	LONG_S	t1, THREAD_CP2_LLM_DAT+8(a0)
+
+1:      bbit1	t9, 26, 3f	/* done if CvmCtl[NOCRYPTO] set */
+
+	/* Save the COP2 crypto state */
+        /* this part is mostly common to both pass 1 and later revisions */
+	dmfc2 	t0, 0x0084
+	dmfc2 	t1, 0x0080
+	dmfc2 	t2, 0x0081
+	dmfc2 	t3, 0x0082
+	LONG_S	t0, THREAD_CP2_3DES_IV(a0)
+	dmfc2 	t0, 0x0088
+	LONG_S	t1, THREAD_CP2_3DES_KEY(a0)
+	dmfc2 	t1, 0x0111                      /* only necessary for pass 1 */
+	LONG_S	t2, THREAD_CP2_3DES_KEY+8(a0)
+	dmfc2 	t2, 0x0102
+	LONG_S	t3, THREAD_CP2_3DES_KEY+16(a0)
+	dmfc2 	t3, 0x0103
+	LONG_S	t0, THREAD_CP2_3DES_RESULT(a0)
+	dmfc2 	t0, 0x0104
+	LONG_S	t1, THREAD_CP2_AES_INP0(a0)     /* only necessary for pass 1 */
+	dmfc2 	t1, 0x0105
+	LONG_S	t2, THREAD_CP2_AES_IV(a0)
+	dmfc2	t2, 0x0106
+	LONG_S	t3, THREAD_CP2_AES_IV+8(a0)
+	dmfc2 	t3, 0x0107
+	LONG_S	t0, THREAD_CP2_AES_KEY(a0)
+	dmfc2	t0, 0x0110
+	LONG_S	t1, THREAD_CP2_AES_KEY+8(a0)
+	dmfc2	t1, 0x0100
+	LONG_S	t2, THREAD_CP2_AES_KEY+16(a0)
+	dmfc2	t2, 0x0101
+	LONG_S	t3, THREAD_CP2_AES_KEY+24(a0)
+	mfc0	t3, $15,0 	/* Get the processor ID register */
+	LONG_S	t0, THREAD_CP2_AES_KEYLEN(a0)
+	li	t0, 0x000d0000	/* This is the processor ID of Octeon Pass1 */
+	LONG_S	t1, THREAD_CP2_AES_RESULT(a0)
+	LONG_S	t2, THREAD_CP2_AES_RESULT+8(a0)
+
+	beq	t3, t0, 2f	/* Skip to the Pass1 version of the remainder of the COP2 state */
+
+        /* the non-pass1 state when !CvmCtl[NOCRYPTO] */
+	dmfc2	t1, 0x0240
+	dmfc2	t2, 0x0241
+	dmfc2	t3, 0x0242
+	dmfc2	t0, 0x0243
+	LONG_S	t1, THREAD_CP2_HSH_DATW(a0)
+	dmfc2	t1, 0x0244
+	LONG_S	t2, THREAD_CP2_HSH_DATW+8(a0)
+	dmfc2	t2, 0x0245
+	LONG_S	t3, THREAD_CP2_HSH_DATW+16(a0)
+	dmfc2	t3, 0x0246
+	LONG_S	t0, THREAD_CP2_HSH_DATW+24(a0)
+	dmfc2	t0, 0x0247
+	LONG_S	t1, THREAD_CP2_HSH_DATW+32(a0)
+	dmfc2	t1, 0x0248
+	LONG_S	t2, THREAD_CP2_HSH_DATW+40(a0)
+	dmfc2	t2, 0x0249
+	LONG_S	t3, THREAD_CP2_HSH_DATW+48(a0)
+	dmfc2	t3, 0x024A
+	LONG_S	t0, THREAD_CP2_HSH_DATW+56(a0)
+	dmfc2	t0, 0x024B
+	LONG_S	t1, THREAD_CP2_HSH_DATW+64(a0)
+	dmfc2	t1, 0x024C
+	LONG_S	t2, THREAD_CP2_HSH_DATW+72(a0)
+	dmfc2	t2, 0x024D
+	LONG_S	t3, THREAD_CP2_HSH_DATW+80(a0)
+	dmfc2 	t3, 0x024E
+	LONG_S	t0, THREAD_CP2_HSH_DATW+88(a0)
+	dmfc2	t0, 0x0250
+	LONG_S	t1, THREAD_CP2_HSH_DATW+96(a0)
+	dmfc2	t1, 0x0251
+	LONG_S	t2, THREAD_CP2_HSH_DATW+104(a0)
+	dmfc2	t2, 0x0252
+	LONG_S	t3, THREAD_CP2_HSH_DATW+112(a0)
+	dmfc2	t3, 0x0253
+	LONG_S	t0, THREAD_CP2_HSH_IVW(a0)
+	dmfc2	t0, 0x0254
+	LONG_S	t1, THREAD_CP2_HSH_IVW+8(a0)
+	dmfc2	t1, 0x0255
+	LONG_S	t2, THREAD_CP2_HSH_IVW+16(a0)
+	dmfc2	t2, 0x0256
+	LONG_S	t3, THREAD_CP2_HSH_IVW+24(a0)
+	dmfc2	t3, 0x0257
+	LONG_S	t0, THREAD_CP2_HSH_IVW+32(a0)
+	dmfc2 	t0, 0x0258
+	LONG_S	t1, THREAD_CP2_HSH_IVW+40(a0)
+	dmfc2 	t1, 0x0259
+	LONG_S	t2, THREAD_CP2_HSH_IVW+48(a0)
+	dmfc2	t2, 0x025E
+	LONG_S	t3, THREAD_CP2_HSH_IVW+56(a0)
+	dmfc2	t3, 0x025A
+	LONG_S	t0, THREAD_CP2_GFM_MULT(a0)
+	dmfc2	t0, 0x025B
+	LONG_S	t1, THREAD_CP2_GFM_MULT+8(a0)
+	LONG_S	t2, THREAD_CP2_GFM_POLY(a0)
+	LONG_S	t3, THREAD_CP2_GFM_RESULT(a0)
+	LONG_S	t0, THREAD_CP2_GFM_RESULT+8(a0)
+	jr	ra
+
+2:      /* pass 1 special stuff when !CvmCtl[NOCRYPTO] */
+	dmfc2	t3, 0x0040
+	dmfc2	t0, 0x0041
+	dmfc2	t1, 0x0042
+	dmfc2	t2, 0x0043
+	LONG_S	t3, THREAD_CP2_HSH_DATW(a0)
+	dmfc2	t3, 0x0044
+	LONG_S	t0, THREAD_CP2_HSH_DATW+8(a0)
+	dmfc2	t0, 0x0045
+	LONG_S	t1, THREAD_CP2_HSH_DATW+16(a0)
+	dmfc2	t1, 0x0046
+	LONG_S	t2, THREAD_CP2_HSH_DATW+24(a0)
+	dmfc2	t2, 0x0048
+	LONG_S	t3, THREAD_CP2_HSH_DATW+32(a0)
+	dmfc2	t3, 0x0049
+	LONG_S	t0, THREAD_CP2_HSH_DATW+40(a0)
+	dmfc2	t0, 0x004A
+	LONG_S	t1, THREAD_CP2_HSH_DATW+48(a0)
+	LONG_S	t2, THREAD_CP2_HSH_IVW(a0)
+	LONG_S	t3, THREAD_CP2_HSH_IVW+8(a0)
+	LONG_S	t0, THREAD_CP2_HSH_IVW+16(a0)
+
+3:      /* pass 1 or CvmCtl[NOCRYPTO] set */
+	jr	ra
+	END(octeon_cop2_save)
+
+/*
+ * void octeon_cop2_restore(struct task_struct *current)
+ */
+	.align	7
+	LEAF(octeon_cop2_restore)
+	dmfc0	t9, $9,7	/* CvmCtl register. */
+        pref    4, 0(a0)        /* prefetch 1st cache block into L1, bypassing L2 if it misses in L2 */
+	bbit1	t9, 26, 1f	/* don't prefetch 2nd and 3rd blocks if CvmCtl[NOCRYPTO] is set */
+
+        pref    4, 128(a0)      /* prefetch 2nd cache block into L1, bypassing L2 if it misses in L2 */
+        pref    4, 256(a0)      /* prefetch 3rd cache block into L1, bypassing L2 if it misses in L2 */
+
+1:
+	/* Enable COP2 accesses so we can restore the state */
+	mfc0	t2, CP0_STATUS
+	LONG_L	t0, THREAD_CP2_CRC_IV(a0)
+	li	t3, ST0_CU2
+	LONG_L	t1, THREAD_CP2_CRC_LENGTH(a0)
+	or	t3, t2, t3
+	LONG_L	t2, THREAD_CP2_CRC_POLY(a0)
+	mtc0	t3, CP0_STATUS
+
+	/* Restore the COP2 CRC state */
+	dmtc2	t0, 0x0201
+	dmtc2 	t1, 0x1202
+	dmtc2	t2, 0x4200
+
+	bbit1	t9, 28, 2f	/* Skip next few instructions if CvmCtl[NODFA_CP2] is set */
+
+	/* Restore the LLM state */
+	LONG_L	t0, THREAD_CP2_LLM_DAT(a0)
+	LONG_L	t1, THREAD_CP2_LLM_DAT+8(a0)
+	dmtc2	t0, 0x0402
+	dmtc2	t1, 0x040A
+
+2:
+	bbit1	t9, 26, done_restore	/* done if CvmCtl[NOCRYPTO] set */
+
+	/* Restore the COP2 crypto state common to pass 1 and pass 2 */
+	LONG_L	t0, THREAD_CP2_3DES_IV(a0)
+	LONG_L	t1, THREAD_CP2_3DES_KEY(a0)
+	LONG_L	t2, THREAD_CP2_3DES_KEY+8(a0)
+	dmtc2 	t0, 0x0084
+	LONG_L	t0, THREAD_CP2_3DES_KEY+16(a0)
+	dmtc2 	t1, 0x0080
+	LONG_L	t1, THREAD_CP2_3DES_RESULT(a0)
+	dmtc2 	t2, 0x0081
+	LONG_L	t2, THREAD_CP2_AES_INP0(a0)       /* only really needed for pass 1 */
+	dmtc2	t0, 0x0082
+	LONG_L	t0, THREAD_CP2_AES_IV(a0)
+	dmtc2 	t1, 0x0098
+	LONG_L	t1, THREAD_CP2_AES_IV+8(a0)
+	dmtc2 	t2, 0x010A                        /* only really needed for pass 1 */
+	LONG_L	t2, THREAD_CP2_AES_KEY(a0)
+	dmtc2 	t0, 0x0102
+	LONG_L	t0, THREAD_CP2_AES_KEY+8(a0)
+	dmtc2	t1, 0x0103
+	LONG_L	t1, THREAD_CP2_AES_KEY+16(a0)
+	dmtc2	t2, 0x0104
+	LONG_L	t2, THREAD_CP2_AES_KEY+24(a0)
+	dmtc2	t0, 0x0105
+	LONG_L	t0, THREAD_CP2_AES_KEYLEN(a0)
+	dmtc2	t1, 0x0106
+	LONG_L	t1, THREAD_CP2_AES_RESULT(a0)
+	dmtc2	t2, 0x0107
+	LONG_L	t2, THREAD_CP2_AES_RESULT+8(a0)
+	mfc0	t3, $15,0 	/* Get the processor ID register */
+	dmtc2	t0, 0x0110
+	li	t0, 0x000d0000	/* This is the processor ID of Octeon Pass1 */
+	dmtc2	t1, 0x0100
+	dmtc2	t2, 0x0101
+
+	bne	t0, t3, 3f	/* Skip the next stuff for non-pass1 */
+
+        /* this code is specific for pass 1 */
+	LONG_L	t0, THREAD_CP2_HSH_DATW(a0)
+	LONG_L	t1, THREAD_CP2_HSH_DATW+8(a0)
+	LONG_L	t2, THREAD_CP2_HSH_DATW+16(a0)
+	dmtc2	t0, 0x0040
+	LONG_L	t0, THREAD_CP2_HSH_DATW+24(a0)
+	dmtc2	t1, 0x0041
+	LONG_L	t1, THREAD_CP2_HSH_DATW+32(a0)
+	dmtc2	t2, 0x0042
+	LONG_L	t2, THREAD_CP2_HSH_DATW+40(a0)
+	dmtc2	t0, 0x0043
+	LONG_L	t0, THREAD_CP2_HSH_DATW+48(a0)
+	dmtc2	t1, 0x0044
+	LONG_L	t1, THREAD_CP2_HSH_IVW(a0)
+	dmtc2	t2, 0x0045
+	LONG_L	t2, THREAD_CP2_HSH_IVW+8(a0)
+	dmtc2	t0, 0x0046
+	LONG_L	t0, THREAD_CP2_HSH_IVW+16(a0)
+	dmtc2	t1, 0x0048
+	dmtc2	t2, 0x0049
+	dmtc2	t0, 0x004A
+        b done_restore   /* unconditional branch */
+
+3:      /* this is post-pass1 code */
+	LONG_L	t2, THREAD_CP2_HSH_DATW(a0)
+	LONG_L	t0, THREAD_CP2_HSH_DATW+8(a0)
+	LONG_L	t1, THREAD_CP2_HSH_DATW+16(a0)
+	dmtc2	t2, 0x0240
+	LONG_L	t2, THREAD_CP2_HSH_DATW+24(a0)
+	dmtc2	t0, 0x0241
+	LONG_L	t0, THREAD_CP2_HSH_DATW+32(a0)
+	dmtc2	t1, 0x0242
+	LONG_L	t1, THREAD_CP2_HSH_DATW+40(a0)
+	dmtc2	t2, 0x0243
+	LONG_L	t2, THREAD_CP2_HSH_DATW+48(a0)
+	dmtc2	t0, 0x0244
+	LONG_L	t0, THREAD_CP2_HSH_DATW+56(a0)
+	dmtc2	t1, 0x0245
+	LONG_L	t1, THREAD_CP2_HSH_DATW+64(a0)
+	dmtc2	t2, 0x0246
+	LONG_L	t2, THREAD_CP2_HSH_DATW+72(a0)
+	dmtc2	t0, 0x0247
+	LONG_L	t0, THREAD_CP2_HSH_DATW+80(a0)
+	dmtc2	t1, 0x0248
+	LONG_L	t1, THREAD_CP2_HSH_DATW+88(a0)
+	dmtc2	t2, 0x0249
+	LONG_L	t2, THREAD_CP2_HSH_DATW+96(a0)
+	dmtc2	t0, 0x024A
+	LONG_L	t0, THREAD_CP2_HSH_DATW+104(a0)
+	dmtc2	t1, 0x024B
+	LONG_L	t1, THREAD_CP2_HSH_DATW+112(a0)
+	dmtc2	t2, 0x024C
+	LONG_L	t2, THREAD_CP2_HSH_IVW(a0)
+	dmtc2	t0, 0x024D
+	LONG_L	t0, THREAD_CP2_HSH_IVW+8(a0)
+	dmtc2	t1, 0x024E
+	LONG_L	t1, THREAD_CP2_HSH_IVW+16(a0)
+	dmtc2	t2, 0x0250
+	LONG_L	t2, THREAD_CP2_HSH_IVW+24(a0)
+	dmtc2	t0, 0x0251
+	LONG_L	t0, THREAD_CP2_HSH_IVW+32(a0)
+	dmtc2	t1, 0x0252
+	LONG_L	t1, THREAD_CP2_HSH_IVW+40(a0)
+	dmtc2	t2, 0x0253
+	LONG_L	t2, THREAD_CP2_HSH_IVW+48(a0)
+	dmtc2	t0, 0x0254
+	LONG_L	t0, THREAD_CP2_HSH_IVW+56(a0)
+	dmtc2	t1, 0x0255
+	LONG_L	t1, THREAD_CP2_GFM_MULT(a0)
+	dmtc2	t2, 0x0256
+	LONG_L	t2, THREAD_CP2_GFM_MULT+8(a0)
+	dmtc2	t0, 0x0257
+	LONG_L	t0, THREAD_CP2_GFM_POLY(a0)
+	dmtc2	t1, 0x0258
+	LONG_L	t1, THREAD_CP2_GFM_RESULT(a0)
+	dmtc2	t2, 0x0259
+	LONG_L	t2, THREAD_CP2_GFM_RESULT+8(a0)
+	dmtc2	t0, 0x025E
+	dmtc2	t1, 0x025A
+	dmtc2	t2, 0x025B
+
+done_restore:
+	/* Disable COP2 accesses so nobody can use it. It will be enabled as
+	   soon as the task is scheduled. ST0_CU2 was enabled in the saved
+	   status register than will be resotred later */
+	mfc0	t0, CP0_STATUS
+	li	t1, ~ST0_CU2
+	and	t0, t0, t1
+	mtc0	t0, CP0_STATUS
+	jr	ra
+	END(octeon_cop2_restore)
+
+/*
+ * void octeon_mult_save()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in SAVE_SOME in stackframe.h. It can only
+ *       safely modify k0 and k1.
+ */
+	.align	7
+	LEAF(octeon_mult_save)
+	dmfc0	k0, $9,7	/* CvmCtl register. */
+	bbit1	k0, 27, 1f	/* Skip CvmCtl[NOMUL] */
+
+	/* Save the multiplier state */
+	v3mulu	k0, $0, $0
+	v3mulu	k1, $0, $0
+	LONG_S	k0, PT_MTP(sp)        /* PT_MTP    has P0 */
+	v3mulu	k0, $0, $0
+	LONG_S	k1, PT_MTP+8(sp)      /* PT_MTP+8  has P1 */
+	ori	k1, $0, 1
+	v3mulu	k1, k1, $0
+	LONG_S	k0, PT_MTP+16(sp)     /* PT_MTP+16 has P2 */
+	v3mulu	k0, $0, $0
+	sd	k1, PT_MPL(sp)        /* PT_MPL    has MPL0 */
+	v3mulu	k1, $0, $0
+	sd	k0, PT_MPL+8(sp)      /* PT_MPL+8  has MPL1 */
+	sd	k1, PT_MPL+16(sp)     /* PT_MPL+16 has MPL2 */
+
+1:	/* Resume here if CvmCtl[NOMUL] */
+	jr	ra
+	END(octeon_mult_save)
+
+/*
+ * void octeon_mult_restore()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in RESTORE_SOME in stackframe.h. It can only
+ *       safely modify k0 and k1.
+ */
+	.align	7
+	LEAF(octeon_mult_restore)
+	LONG_L	k0, PT_MPL(sp)        /* MPL0 */
+	dmfc0	k1, $9,7	/* CvmCtl register. */
+	bbit1	k1, 27, 1f	/* Skip CvmCtl[NOMUL] */
+
+	/* Restore the multiplier state */
+	LONG_L	k1, PT_MPL+8(sp)      /* MPL1 */
+	MTM0	k0
+	LONG_L	k0, PT_MPL+16(sp)     /* MPL2 */
+	MTM1	k1
+	LONG_L	k1, PT_MTP+16(sp)     /* P2 */
+	MTM2	k0
+	LONG_L	k0, PT_MTP+8(sp)      /* P1 */
+	MTP2	k1
+	LONG_L	k1, PT_MTP(sp)        /* P0 */
+	MTP1	k0
+	MTP0	k1
+
+1:	/* Resume here if CvmCtl[NOMUL] */
+	jr	ra
+	END(octeon_mult_restore)
+
Index: linux-2.6.10/arch/mips/kernel/offset.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/offset.c
+++ linux-2.6.10/arch/mips/kernel/offset.c
@@ -69,6 +69,10 @@ void output_ptreg_defines(void)
 	offset("#define PT_BVADDR ", struct pt_regs, cp0_badvaddr);
 	offset("#define PT_STATUS ", struct pt_regs, cp0_status);
 	offset("#define PT_CAUSE  ", struct pt_regs, cp0_cause);
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	offset("#define PT_MPL    ", struct pt_regs, mpl);
+	offset("#define PT_MTP    ", struct pt_regs, mtp);
+#endif
 	size("#define PT_SIZE   ", struct pt_regs);
 	linefeed;
 }
@@ -313,3 +317,29 @@ void output_irq_cpustat_t_defines(void)
 	size("#define IC_IRQ_CPUSTAT_T   ", irq_cpustat_t);
 	linefeed;
 }
+
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+void output_octeon_thread_defines(void)
+{
+	text("/* Octeon specific thread_struct offsets. */");
+    offset("#define THREAD_CP2_CRC_IV       ", struct task_struct, thread.cp2.cop2_crc_iv);
+    offset("#define THREAD_CP2_CRC_LENGTH   ", struct task_struct, thread.cp2.cop2_crc_length);
+    offset("#define THREAD_CP2_CRC_POLY     ", struct task_struct, thread.cp2.cop2_crc_poly);
+    offset("#define THREAD_CP2_LLM_DAT      ", struct task_struct, thread.cp2.cop2_llm_dat);
+    offset("#define THREAD_CP2_3DES_IV      ", struct task_struct, thread.cp2.cop2_3des_iv);
+    offset("#define THREAD_CP2_3DES_KEY     ", struct task_struct, thread.cp2.cop2_3des_key);
+    offset("#define THREAD_CP2_3DES_RESULT  ", struct task_struct, thread.cp2.cop2_3des_result);
+    offset("#define THREAD_CP2_AES_INP0     ", struct task_struct, thread.cp2.cop2_aes_inp0);
+    offset("#define THREAD_CP2_AES_IV       ", struct task_struct, thread.cp2.cop2_aes_iv);
+    offset("#define THREAD_CP2_AES_KEY      ", struct task_struct, thread.cp2.cop2_aes_key);
+    offset("#define THREAD_CP2_AES_KEYLEN   ", struct task_struct, thread.cp2.cop2_aes_keylen);
+    offset("#define THREAD_CP2_AES_RESULT   ", struct task_struct, thread.cp2.cop2_aes_result);
+    offset("#define THREAD_CP2_GFM_MULT     ", struct task_struct, thread.cp2.cop2_gfm_mult);
+    offset("#define THREAD_CP2_GFM_POLY     ", struct task_struct, thread.cp2.cop2_gfm_poly);
+    offset("#define THREAD_CP2_GFM_RESULT   ", struct task_struct, thread.cp2.cop2_gfm_result);
+    offset("#define THREAD_CP2_HSH_DATW     ", struct task_struct, thread.cp2.cop2_hsh_datw);
+    offset("#define THREAD_CP2_HSH_IVW      ", struct task_struct, thread.cp2.cop2_hsh_ivw);
+    offset("#define THREAD_CVMSEG           ", struct task_struct, thread.cvmseg.cvmseg);
+	linefeed;
+}
+#endif
Index: linux-2.6.10/arch/mips/kernel/proc.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/proc.c
+++ linux-2.6.10/arch/mips/kernel/proc.c
@@ -77,7 +77,8 @@ static const char *cpu_name[] = {
 	[CPU_VR4181]	"NEC VR4181",
 	[CPU_VR4181A]	"NEC VR4181A",
 	[CPU_SR71000]	"Sandcraft SR71000",
-	[CPU_PR4450]	"Philips PR4450"
+	[CPU_PR4450]	"Philips PR4450",
+	[CPU_CAVIUM_OCTEON] = "Cavium Networks Octeon"
 };
 
 #if defined(CONFIG_CPU_TIMER)
Index: linux-2.6.10/arch/mips/kernel/traps.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/traps.c
+++ linux-2.6.10/arch/mips/kernel/traps.c
@@ -63,6 +63,10 @@ extern asmlinkage void handle_watch(void
 extern asmlinkage void handle_mcheck(void);
 extern asmlinkage void handle_reserved(void);
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+extern asmlinkage void octeon_cop2_restore(struct task_struct *task);
+#endif
+
 extern int fpu_emulator_cop1Handler(int xcptno, struct pt_regs *xcp,
 	struct mips_fpu_soft_struct *ctx);
 
@@ -269,6 +273,17 @@ void show_registers(struct pt_regs *regs
 	show_trace(current, (long *) regs->regs[29]);
 	show_code((unsigned int *) regs->cp0_epc);
 	printk("\n");
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	printk("\n");
+	printk("CacheErr icache: %016llx\n", __read_64bit_c0_register($27,0));
+	printk("CacheErr dcache: %016llx\n", __read_64bit_c0_register($27,1));
+	printk("CvmCtl:          %016llx\n", __read_64bit_c0_register($9,7));
+	printk("CvmMemCtl:       %016llx\n", __read_64bit_c0_register($11,7));
+	printk("POW_BIST_STAT:   %016llx\n", *(unsigned long long*)0x80016700000003F8ull);
+	printk("\nTLB\n");
+	dump_tlb_all();
+#endif
+
 }
 
 static raw_spinlock_t die_lock = RAW_SPIN_LOCK_UNLOCKED;
@@ -759,6 +774,11 @@ asmlinkage void do_cpu(struct pt_regs *r
 		return;
 
 	case 2:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		KSTK_STATUS(current) |= ST0_CU2;
+	octeon_cop2_restore(current);
+	return;
+#endif
 	case 3:
 		break;
 	}
@@ -920,6 +940,9 @@ void nmi_exception_handler(struct pt_reg
 }
 
 unsigned long exception_handlers[32];
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+unsigned long ebase;
+#endif
 
 /*
  * As a side effect of the way this is implemented we're limited
@@ -941,6 +964,10 @@ void *set_except_vector(int n, void *add
 		*(volatile u32 *)(CAC_BASE + 0x208) = 0x03400008;
 
 		flush_icache_range(CAC_BASE + 0x200, CAC_BASE + 0x20C);
+#elif defined(CONFIG_CPU_CAVIUM_OCTEON)
+		*(volatile u32 *)(ebase + 0x200) = 0x08000000 |
+						 (0x03ffffff & (handler >> 2));
+		flush_icache_range(ebase + 0x200, ebase + 0x204);
 #else
 		*(volatile u32 *)(CAC_BASE + 0x200) = 0x08000000 |
 		                                 (0x03ffffff & (handler >> 2));
@@ -1046,6 +1073,10 @@ void __init trap_init(void)
 	extern char except_vec_ejtag_debug;
 	extern char except_vec4;
 	unsigned long i;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	unsigned int octeon_except_base = read_c0_ebase() & 0x3ffff000;
+	ebase = CAC_BASE + octeon_except_base;
+#endif
 
 	if (kgdb_early_setup)
 		return;	/* Already done */
@@ -1057,7 +1088,11 @@ void __init trap_init(void)
 	 * This will be overriden later as suitable for a particular
 	 * configuration.
 	 */
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	memcpy((void *)(ebase + 0x180), &except_vec3_generic, 0x80);
+#else
 	memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+#endif
 
 	/*
 	 * Setup default vectors
@@ -1070,7 +1105,11 @@ void __init trap_init(void)
 	 * destination.
 	 */
 	if (cpu_has_ejtag)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		memcpy((void *)(ebase + 0x300), &except_vec_ejtag_debug, 0x80);
+#else
 		memcpy((void *)(CAC_BASE + 0x300), &except_vec_ejtag_debug, 0x80);
+#endif
 
 	/*
 	 * Only some CPUs have the watch exceptions.
@@ -1083,7 +1122,11 @@ void __init trap_init(void)
 	 * interrupt processing overhead.  Use it where available.
 	 */
 	if (cpu_has_divec)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		memcpy((void *)(ebase + 0x200), &except_vec4, 0x8);
+#else
 		memcpy((void *)(CAC_BASE + 0x200), &except_vec4, 0x8);
+#endif
 
 	/*
 	 * Some CPUs can enable/disable for cache parity detection, but does
@@ -1127,7 +1170,11 @@ void __init trap_init(void)
 		/* Special exception: R4[04]00 uses also the divec space. */
 		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
 	else if (cpu_has_4kex)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		memcpy((void *)(ebase + 0x180), &except_vec3_generic, 0x80);
+#else
 		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+#endif
 	else
 		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
 
@@ -1150,7 +1197,11 @@ void __init trap_init(void)
 	signal32_init();
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	flush_icache_range(ebase, ebase + 0x400);
+#else
 	flush_icache_range(CAC_BASE, CAC_BASE + 0x400);
+#endif
 }
 
 #ifdef CONFIG_LTT
Index: linux-2.6.10/arch/mips/kernel/unaligned.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/unaligned.c
+++ linux-2.6.10/arch/mips/kernel/unaligned.c
@@ -506,6 +506,37 @@ asmlinkage void do_ade(struct pt_regs *r
 	if (do_dsemulret(regs))
 		return;
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+    /* This section of code allows tasks to access CVMSEG addresses. These are
+	special addresses into the Octeon L1 Cache that can be used as fast
+	scratch memory. By default access to this memory is disabled so we
+	don't have to save it on context switch. When a userspace task
+	references one of these addresses, we enable the region and size it
+	to match the app */
+	{
+		const uint64_t CVMSEG_BASE = 0xFFFFFFFFFFFF8000ull;
+		const uint64_t CVMSEG_IO = 0xFFFFFFFFFFFFa200ull;
+		uint64_t cvmmemctl = __read_64bit_c0_register($11, 7);
+		uint64_t cvmseg_size = (cvmmemctl&0x3f) * 128;
+
+		if ((regs->cp0_badvaddr==CVMSEG_IO) ||
+		((regs->cp0_badvaddr>=CVMSEG_BASE) && (regs->cp0_badvaddr<CVMSEG_BASE + cvmseg_size)))
+		{
+			/* Make sure all async operations are done */
+			asm volatile ("synciobdma" ::: "memory");
+			/* Enable userspace access to CVMSEG */
+			cvmmemctl |= 1<<6;
+			__write_64bit_c0_register($11, 7, cvmmemctl);
+
+			//printk("Enabling CVMSEG access for task %p (%lu lines)\n", current, cvmmemctl&0x3f);
+
+			/* Restore the processes CVMSEG data */
+			memcpy((void*)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size);
+			return;
+		}
+	}
+#endif
+
 	/* Otherwise handle as normal */
 
 	/*
Index: linux-2.6.10/arch/mips/lib-32/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/lib-32/Makefile
+++ linux-2.6.10/arch/mips/lib-32/Makefile
@@ -22,5 +22,6 @@ obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
 obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
 obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
+obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= dump_tlb.o
 
 EXTRA_AFLAGS := $(CFLAGS)
Index: linux-2.6.10/arch/mips/lib-64/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/lib-64/Makefile
+++ linux-2.6.10/arch/mips/lib-64/Makefile
@@ -22,5 +22,6 @@ obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
 obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
 obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
+obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= dump_tlb.o
 
 EXTRA_AFLAGS := $(CFLAGS)
Index: linux-2.6.10/arch/mips/mm/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/Makefile
+++ linux-2.6.10/arch/mips/mm/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_CPU_SB1)		+= c-sb1.o cerr-s
 obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-r4k.o tlb-r3k.o
 obj-$(CONFIG_CPU_TX49XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
+obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= c-octeon.o cex-gen.o pg-octeon.o tlb-r4k.o
 
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
Index: linux-2.6.10/arch/mips/mm/c-octeon.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mm/c-octeon.c
@@ -0,0 +1,253 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Cavium Networks, Inc.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/bitops.h>
+
+#include <asm/bcache.h>
+#include <asm/bootinfo.h>
+#include <asm/cacheops.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/r4kcache.h>
+#include <asm/system.h>
+#include <asm/mmu_context.h>
+#include <asm/war.h>
+
+/**
+ * Octeon automatically flushes the dcache on tlb changes, so
+ * from Linux's viewpoint it acts much like a physically
+ * tagged cache. No flushing is needed
+ *
+ * @param addr
+ */
+static void octeon_flush_data_cache_page(unsigned long addr)
+{
+	/* Nothing to do */
+}
+
+/**
+ * Flush caches as necessary for all cores affected by a
+ * vma. If no vma is supplied, all cores are flushed.
+ *
+ * @param vma    VMA to flush or NULL to flush all icaches.
+ */
+static void octeon_flush_icache_all_cores(struct vm_area_struct *vma)
+{
+#ifdef CONFIG_SMP
+	int i;
+	int cpu = smp_processor_id();
+#endif
+	mb();
+
+	/* If we have a vma structure, we only need to worry about cores it
+	   has been used on */
+	if (vma) {
+		/* Octeon dcache does enough magic we don't need to worry about it.
+		   Only flush the icache if this vma was executable */
+		if (vma->vm_flags & VM_EXEC) {
+#ifdef CONFIG_SMP
+			for (i = 0; i < NR_CPUS; i++)
+				if (cpu_isset(i, vma->vm_mm->cpu_vm_mask)
+				    && i != cpu)
+					core_send_ipi(i, SMP_ICACHE_FLUSH);
+#endif
+			asm volatile ("synci 0($0)\n");
+		}
+	} else {
+		/* No extra info available. Flush the icache on all cores that
+		   are online */
+#ifdef CONFIG_SMP
+		for (i = 0; i < NR_CPUS; i++)
+			if (cpu_online(i) && i != cpu)
+				core_send_ipi(i, SMP_ICACHE_FLUSH);
+#endif
+		asm volatile ("synci 0($0)\n");
+	}
+}
+
+/**
+ * Called to flush the icache on all cores
+ */
+static void octeon_flush_icache_all(void)
+{
+	octeon_flush_icache_all_cores(NULL);
+}
+
+/**
+ * Called to flush all memory associated with a memory
+ * context. Will flush all cores that the memory context
+ * was used on.
+ *
+ * @param mm     Memory context to flush
+ */
+static void octeon_flush_cache_mm(struct mm_struct *mm)
+{
+	int i, cpu;
+	mb();
+#ifdef CONFIG_SMP
+	cpu = smp_processor_id();
+	for (i = 0; i < NR_CPUS; i++)
+		if (cpu_online(i) && i != cpu)
+			core_send_ipi(i, SMP_ICACHE_FLUSH);
+#endif
+	asm volatile ("synci 0($0)\n");
+}
+
+/**
+ * Flush a range of kernel addresses out of the icache
+ *
+ * @param start
+ * @param end
+ */
+static void octeon_flush_icache_range(unsigned long start, unsigned long end)
+{
+	octeon_flush_icache_all_cores(NULL);
+}
+
+/**
+ * Flush a specific page of a vma
+ *
+ * @param vma    VMA to flush page for
+ * @param page   Page to flush
+ */
+static void octeon_flush_icache_page(struct vm_area_struct *vma,
+				     struct page *page)
+{
+	octeon_flush_icache_all_cores(vma);
+}
+
+/**
+ * Flush the icache for a trampoline. These are used for interrupt
+ * and exception hooking.
+ *
+ * @param addr   Address to flush
+ */
+static void octeon_flush_cache_sigtramp(unsigned long addr)
+{
+	/* Only flush trampolines on the current core. Assume trampoline fits
+	   in a cache line. */
+	mb();
+	asm volatile ("synci 0(%0)\n"::"r" (addr));
+}
+
+/**
+ * Flush a range out of a vma
+ *
+ * @param vma    VMA to flush
+ * @param start
+ * @param end
+ */
+static void octeon_flush_cache_range(struct vm_area_struct *vma,
+				     unsigned long start, unsigned long end)
+{
+	octeon_flush_icache_all_cores(vma);
+}
+
+/**
+ * Flush a specific page of a vma
+ *
+ * @param vma    VMA to flush page for
+ * @param page   Page to flush
+ * @param pfn
+ */
+static void octeon_flush_cache_page(struct vm_area_struct *vma,
+				    unsigned long page, unsigned long pfn)
+{
+	octeon_flush_icache_all_cores(vma);
+}
+
+/**
+ * Probe Octeon's caches
+ *
+ * @return
+ */
+static void __init probe_octeon(void)
+{
+	unsigned long icache_size;
+	unsigned long dcache_size;
+	struct cpuinfo_mips *c = &current_cpu_data;
+
+	switch (c->cputype) {
+	case CPU_CAVIUM_OCTEON:
+		c->icache.linesz = 128;
+		c->icache.sets = 4;
+		c->icache.ways = 64;
+		c->icache.flags |= MIPS_CACHE_VTAG;
+		icache_size =
+		    c->icache.sets * c->icache.ways * c->icache.linesz;
+		c->icache.waybit = ffs(icache_size / c->icache.ways) - 1;
+		c->dcache.linesz = 128;
+		c->dcache.sets = 1;
+		c->dcache.ways = 64;
+		dcache_size =
+		    c->dcache.sets * c->dcache.ways * c->dcache.linesz;
+		c->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;
+		c->options |= MIPS_CPU_PREFETCH;
+		break;
+
+	default:
+		panic("Unsupported Cavium Networks CPU type\n");
+		break;
+	}
+
+	/* compute a couple of other cache variables */
+	c->icache.waysize = icache_size / c->icache.ways;
+	c->dcache.waysize = dcache_size / c->dcache.ways;
+
+	c->icache.sets = icache_size / (c->icache.linesz * c->icache.ways);
+	c->dcache.sets = dcache_size / (c->dcache.linesz * c->dcache.ways);
+
+	if (smp_processor_id() == 0) {
+		printk
+		    ("Primary instruction cache %ldkB, %s, %d-way, linesize %d bytes.\n",
+		     icache_size >> 10,
+		     cpu_has_vtag_icache ? "virtually tagged" :
+		     "physically tagged", c->icache.ways, c->icache.linesz);
+
+		printk("Primary data cache %ldkB, %d-way, linesize %d bytes.\n",
+		       dcache_size >> 10, c->dcache.ways, c->dcache.linesz);
+	}
+}
+
+/**
+ * Setup the Octeon cache flush routines
+ *
+ * @return
+ */
+void __init ld_mmu_octeon(void)
+{
+	extern char except_vec2_generic;
+
+	memcpy((void *)(CAC_BASE + 0x100), &except_vec2_generic, 0x80);
+	memcpy((void *)(UNCAC_BASE + 0x100), &except_vec2_generic, 0x80);
+
+	mb();
+	asm volatile ("synci 0($0)\n");
+
+	probe_octeon();
+
+	shm_align_mask = PAGE_SIZE - 1;
+
+	flush_cache_all = octeon_flush_icache_all;
+	__flush_cache_all = octeon_flush_icache_all;
+	flush_cache_mm = octeon_flush_cache_mm;
+	flush_cache_page = octeon_flush_cache_page;
+	flush_icache_page = octeon_flush_icache_page;
+	flush_cache_range = octeon_flush_cache_range;
+	flush_cache_sigtramp = octeon_flush_cache_sigtramp;
+	flush_icache_all = octeon_flush_icache_all;
+	flush_data_cache_page = octeon_flush_data_cache_page;
+	flush_icache_range = octeon_flush_icache_range;
+}
Index: linux-2.6.10/arch/mips/mm/cache.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/cache.c
+++ linux-2.6.10/arch/mips/mm/cache.c
@@ -107,6 +107,7 @@ extern void ld_mmu_r6000(void);
 extern void ld_mmu_tfp(void);
 extern void ld_mmu_andes(void);
 extern void ld_mmu_sb1(void);
+extern void ld_mmu_octeon(void);
 
 void __init cpu_cache_init(void)
 {
@@ -146,6 +147,11 @@ void __init cpu_cache_init(void)
 		ld_mmu_sb1();
 		break;
 #endif
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		case CPU_CAVIUM_OCTEON:
+			ld_mmu_octeon();
+			break;
+#endif
 
 	case CPU_R8000:
 		panic("R8000 is unsupported");
Index: linux-2.6.10/arch/mips/mm/fault.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/fault.c
+++ linux-2.6.10/arch/mips/mm/fault.c
@@ -47,6 +47,20 @@ asmlinkage void do_page_fault(struct pt_
 	       field, regs->cp0_epc);
 #endif
 
+#ifdef CONFIG_CAVIUM_OCTEON_HW_FIX_UNALIGNED
+	/*
+	 * Normally the FPU emulator uses a load word from address one to retake
+	 * control of the CPU after executing the instruction in the delay slot
+	 * of an emulated branch. The Octeon hardware unaligned access fix changes
+	 * this from an address exception into a TLB exception. This code checks
+	 * to see if this page fault was caused by an FPU emulation.
+	 *
+	 * Terminate if exception was recognized as a delay slot return */
+	extern int do_dsemulret(struct pt_regs *);
+	if (do_dsemulret(regs))
+		return;
+#endif
+
 	info.si_code = SEGV_MAPERR;
 
 	/*
Index: linux-2.6.10/arch/mips/mm/pg-octeon.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mm/pg-octeon.c
@@ -0,0 +1,107 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Cavium Networks, Inc.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+
+
+void clear_page(void *page)
+{
+	void *end = page + PAGE_SIZE;
+
+    asm volatile (
+        "   .set	push		\n"
+        "   .set	mips64		\n"
+        "   .set	noreorder	\n"
+        "1: pref    30, 0(%0)   \n" /* Prepare cache line for store */
+        "   sd      $0, 0(%0)   \n" /* Write zeros to the cache line */
+        "   sd      $0, 8(%0)   \n"
+        "   sd      $0, 16(%0)  \n"
+        "   sd      $0, 24(%0)  \n"
+        "   sd      $0, 32(%0)  \n"
+        "   sd      $0, 40(%0)  \n"
+        "   sd      $0, 48(%0)  \n"
+        "   sd      $0, 56(%0)  \n"
+        "   sd      $0, 64(%0)  \n"
+        "   sd      $0, 72(%0)  \n"
+        "   sd      $0, 80(%0)  \n"
+        "   sd      $0, 88(%0)  \n"
+        "   sd      $0, 96(%0)  \n"
+        "   sd      $0, 104(%0) \n"
+        "   sd      $0, 112(%0) \n"
+        "   daddu   %0, 128     \n" /* Increment to the next address. Will be dual issued */
+        "   blt     %0, %1, 1b  \n" /* Loop until we've completed the page */
+        "    sd     $0, -8(%0)  \n"
+        "   .set	pop		\n"
+        : "+r" (page)
+        : "r" (end)
+        : "memory"
+    );
+}
+
+
+void copy_page(void *to, void *from)
+{
+	void *end = to + PAGE_SIZE;
+
+    asm volatile (
+        "   .set	push		\n"
+        "   .set	mips64		\n"
+        "   .set	noreorder	\n"
+        "   pref    0,  0(%1)   \n" /* Prefetch the first cache line of "from" */
+        "1: pref    0,  128(%1) \n" /* Prefetch the next "from" cache line for the next iteration */
+        "   pref    30, 0(%0)   \n" /* Prepare the "to" cache line for store */
+        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+        "   ld      $13, 8(%1)  \n"
+        "   ld      $14, 16(%1) \n"
+        "   ld      $15, 24(%1) \n"
+        "   daddu   %1, 32      \n" /* Dual issued */
+        "   sd      $12, 0(%0)  \n"
+        "   sd      $13, 8(%0)  \n"
+        "   sd      $14, 16(%0) \n"
+        "   sd      $15, 24(%0) \n"
+        "   daddu   %0, 32      \n" /* Dual issued */
+        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+        "   ld      $13, 8(%1)  \n"
+        "   ld      $14, 16(%1) \n"
+        "   ld      $15, 24(%1) \n"
+        "   daddu   %1, 32      \n" /* Dual issued */
+        "   sd      $12, 0(%0)  \n"
+        "   sd      $13, 8(%0)  \n"
+        "   sd      $14, 16(%0) \n"
+        "   sd      $15, 24(%0) \n"
+        "   daddu   %0, 32      \n" /* Dual issued */
+        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+        "   ld      $13, 8(%1)  \n"
+        "   ld      $14, 16(%1) \n"
+        "   ld      $15, 24(%1) \n"
+        "   daddu   %1, 32      \n" /* Dual issued */
+        "   sd      $12, 0(%0)  \n"
+        "   sd      $13, 8(%0)  \n"
+        "   sd      $14, 16(%0) \n"
+        "   sd      $15, 24(%0) \n"
+        "   daddu   %0, 32      \n" /* Dual issued */
+        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+        "   ld      $13, 8(%1)  \n"
+        "   ld      $14, 16(%1) \n"
+        "   ld      $15, 24(%1) \n"
+        "   daddu   %1, 32      \n" /* Dual issued */
+        "   sd      $12, 0(%0)  \n"
+        "   sd      $13, 8(%0)  \n"
+        "   sd      $14, 16(%0) \n"
+        "   daddu   %0, 32      \n" /* Dual issued */
+        "   blt     %0, %2, 1b  \n" /* Loop until we've completed the page */
+        "    sd     $15, -8(%0) \n"
+        "   .set	pop		\n"
+        : "+r" (to), "+r" (from)
+        : "r" (end)
+        : "$12", "$13", "$14", "$15", "memory"
+    );
+}
+
+EXPORT_SYMBOL(clear_page);
+EXPORT_SYMBOL(copy_page);
Index: linux-2.6.10/arch/mips/mm/tlb-r4k.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/tlb-r4k.c
+++ linux-2.6.10/arch/mips/mm/tlb-r4k.c
@@ -21,6 +21,12 @@
 
 extern void build_tlb_refill_handler(void);
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#define UNIQUE_ENTRYHI(idx) (XKPHYS + ((idx) << (PAGE_SHIFT + 1)))
+#else
+#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+#endif
+
 /* CP0 hazard avoidance. */
 #define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
 				     "nop; nop; nop; nop; nop; nop;\n\t" \
@@ -46,7 +52,7 @@ void local_flush_tlb_all(void)
 		 * Make sure all entries differ.  If they're not different
 		 * MIPS32 will take revenge ...
 		 */
-		write_c0_entryhi(CKSEG0 + (entry << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -104,8 +110,7 @@ void local_flush_tlb_range(struct vm_are
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
-				write_c0_entryhi(CKSEG0 +
-				                 (idx << (PAGE_SHIFT + 1)));
+				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -147,7 +152,7 @@ void local_flush_tlb_kernel_range(unsign
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
-			write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -181,7 +186,7 @@ void local_flush_tlb_page(struct vm_area
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -213,7 +218,7 @@ void local_flush_tlb_one(unsigned long p
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -425,4 +430,14 @@ void __init tlb_init(void)
 	local_flush_tlb_all();
 
 	build_tlb_refill_handler();
+
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	{
+	extern void octeon_adel_workaround(void);
+	printk
+	    ("Adding workaround for Adel hardware bug for Octeon Pass 1-A0\n");
+	add_wired_entry((((unsigned long)octeon_adel_workaround & 0x7ffffffful)
+			 >> 6) | 0xbul, 0x9, (1ul << 47), PM_4K);
+	}
+#endif
 }
Index: linux-2.6.10/arch/mips/mm/tlbex.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/tlbex.c
+++ linux-2.6.10/arch/mips/mm/tlbex.c
@@ -921,6 +921,7 @@ static __init void build_tlb_write_entry
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
+	case CPU_CAVIUM_OCTEON:
 		tlbw(p);
 		break;
 
@@ -1308,8 +1309,14 @@ static void __init build_r4000_tlb_refil
 #endif /* CONFIG_MIPS64 */
 
 	resolve_relocs(relocs, labels);
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	if (smp_processor_id() == 0)
+		printk("Synthesized TLB refill handler (%u instructions).\n",
+		       final_len);
+#else
 	printk("Synthesized TLB refill handler (%u instructions).\n",
 	       final_len);
+#endif
 
 #ifdef DEBUG_TLB
 	{
@@ -1320,8 +1327,18 @@ static void __init build_r4000_tlb_refil
 	}
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	{
+		unsigned int octeon_except_base = read_c0_ebase() & 0x3ffff000;
+		memcpy((void *)CAC_BASE + octeon_except_base, final_handler,
+		       0x100);
+		flush_icache_range(CAC_BASE + octeon_except_base,
+				   CAC_BASE + octeon_except_base + 0x100);
+	}
+#else
 	memcpy((void *)CAC_BASE, final_handler, 0x100);
 	flush_icache_range(CAC_BASE, CAC_BASE + 0x100);
+#endif
 }
 
 /*
Index: linux-2.6.10/drivers/serial/8250.c
===================================================================
--- linux-2.6.10.orig/drivers/serial/8250.c
+++ linux-2.6.10/drivers/serial/8250.c
@@ -275,7 +275,11 @@ static _INLINE_ unsigned int serial_in(s
 		return inb(up->port.iobase + 1);
 
 	case UPIO_MEM:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return readq(up->port.membase + offset);
+#else
 		return readb(up->port.membase + offset);
+#endif
 
 	case UPIO_MEM32:
 		return readl(up->port.membase + offset);
@@ -297,7 +301,13 @@ serial_out(struct uart_8250_port *up, in
 		break;
 
 	case UPIO_MEM:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		if (offset == (UART_LCR<<up->port.regshift))
+			value &= 0x9f;
+		writeq((unsigned char)value, up->port.membase + offset);
+#else
 		writeb(value, up->port.membase + offset);
+#endif
 		break;
 
 	case UPIO_MEM32:
@@ -655,7 +665,9 @@ static void autoconfig_16550a(struct uar
 
 	if (!((status2 ^ status1) & UART_MCR_LOOP)) {
 		serial_outp(up, UART_LCR, 0);
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		serial_outp(up, UART_MCR, status1 ^ UART_MCR_LOOP);
+#endif
 		serial_outp(up, UART_LCR, 0xE0);
 		status2 = serial_in(up, 0x02); /* EXCR1 */
 		serial_outp(up, UART_LCR, 0);
@@ -850,6 +862,10 @@ static void autoconfig(struct uart_8250_
 	up->port.fifosize = uart_config[up->port.type].fifo_size;
 	up->capabilities = uart_config[up->port.type].flags;
 	up->tx_loadsz = uart_config[up->port.type].tx_loadsz;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	up->port.fifosize = 64;
+	up->tx_loadsz = 64;
+#endif
 
 	if (up->port.type == PORT_UNKNOWN)
 		goto out;
@@ -1274,7 +1290,11 @@ static void serial8250_timeout(unsigned 
 	unsigned int timeout;
 	unsigned int iir;
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	iir = 0;
+#else
 	iir = serial_in(up, UART_IIR);
+#endif
 	if (!(iir & UART_IIR_NO_INT)) {
 		spin_lock(&up->port.lock);
 		serial8250_handle_port(up, NULL);
@@ -1719,6 +1739,16 @@ serial8250_set_termios(struct uart_port 
 	serial_outp(up, UART_DLL, quot & 0xff);		/* LS of divisor */
 	serial_outp(up, UART_DLM, quot >> 8);		/* MS of divisor */
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	{
+		int spin_loop;
+		for (spin_loop=0;spin_loop<quot*2*16; spin_loop++)
+		{
+			/* spin */
+		}
+	}
+#endif
+
 	/*
 	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
 	 * is written without DLAB set, this mode will be disabled.
Index: linux-2.6.10/drivers/serial/8250_early.c
===================================================================
--- linux-2.6.10.orig/drivers/serial/8250_early.c
+++ linux-2.6.10/drivers/serial/8250_early.c
@@ -47,7 +47,11 @@ static int early_uart_registered __initd
 static unsigned int __init serial_in(struct uart_port *port, int offset)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return readq(port->membase + offset);
+#else
 		return readb(port->membase + offset);
+#endif
 	else
 		return inb(port->iobase + offset);
 }
@@ -55,7 +59,11 @@ static unsigned int __init serial_in(str
 static void __init serial_out(struct uart_port *port, int offset, int value)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		writeq((unsigned char)value, port->membase + offset);
+#else
 		writeb(value, port->membase + offset);
+#endif
 	else
 		outb(value, port->iobase + offset);
 }
Index: linux-2.6.10/include/asm-mips/addrspace.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/addrspace.h
+++ linux-2.6.10/include/asm-mips/addrspace.h
@@ -127,7 +127,8 @@
     || defined (CONFIG_CPU_R5000)					\
     || defined (CONFIG_CPU_NEVADA)					\
     || defined (CONFIG_CPU_TX49XX)					\
-    || defined (CONFIG_CPU_MIPS64)
+    || defined (CONFIG_CPU_MIPS64)					\
+    || defined (CONFIG_CPU_CAVIUM_OCTEON)
 #define	KUSIZE			0x0000010000000000	/* 2^^40 */
 #define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
 #define	K0SIZE			0x0000001000000000	/* 2^^36 */
Index: linux-2.6.10/include/asm-mips/atomic.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/atomic.h
+++ linux-2.6.10/include/asm-mips/atomic.h
@@ -150,12 +150,17 @@ static __inline__ int atomic_add_return(
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -194,12 +199,17 @@ static __inline__ int atomic_sub_return(
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -237,7 +247,6 @@ static __inline__ int atomic_sub_if_posi
 		"	bltz	%0, 1f					\n"
 		"	sc	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
-		"	sync						\n"
 		"1:							\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -246,12 +255,17 @@ static __inline__ int atomic_sub_if_posi
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	ll	%1, %2		# atomic_sub_if_positive\n"
 		"	subu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
 		"	sc	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		"1:							\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -460,12 +474,17 @@ static __inline__ long atomic64_add_retu
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	lld	%1, %2		# atomic64_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -504,12 +523,17 @@ static __inline__ long atomic64_sub_retu
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	lld	%1, %2		# atomic64_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -556,12 +580,17 @@ static __inline__ long atomic64_sub_if_p
 		unsigned long temp;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	lld	%1, %2		# atomic64_sub_if_positive\n"
 		"	dsubu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
 		"	scd	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
 		"	sync						\n"
+#endif
 		"1:							\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
Index: linux-2.6.10/include/asm-mips/bitops.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bitops.h
+++ linux-2.6.10/include/asm-mips/bitops.h
@@ -272,12 +272,15 @@ static inline int test_and_set_bit(unsig
 
 		__asm__ __volatile__(
 		"	.set	noreorder	# test_and_set_bit	\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	" __LL "%0, %1					\n"
 		"	or	%2, %0, %3				\n"
 		"	" __SC	"%2, %1					\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"sync							\n"
 #endif
 		".set\treorder"
@@ -363,13 +366,16 @@ static inline int test_and_clear_bit(uns
 
 		__asm__ __volatile__(
 		"	.set	noreorder	# test_and_clear_bit	\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	" __LL	"%0, %1					\n"
 		"	or	%2, %0, %3				\n"
 		"	xor	%2, %3					\n"
 			__SC 	"%2, %1					\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
 #endif
 		"	.set	reorder					\n"
@@ -454,12 +460,15 @@ static inline int test_and_change_bit(un
 
 		__asm__ __volatile__(
 		"	.set	noreorder	# test_and_change_bit	\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	" __LL	" %0, %1				\n"
 		"	xor	%2, %0, %3				\n"
 		"	"__SC	"\t%2, %1				\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
 #endif
 		"	.set	reorder					\n"
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -220,6 +220,12 @@
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
 /*
+ * Valid machtype for group CAVIUM
+ */
+#define MACH_GROUP_CAVIUM	23	/* Cavium Octeon */
+#define MACH_CAVIUM_OCTEON	1	/* Cavium Octeon */
+
+/*
  * Valid machtype for group VR5701
  */
 #define MACH_GROUP_VR5701       24 	/* VR5701     */
Index: linux-2.6.10/include/asm-mips/cpu.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cpu.h
+++ linux-2.6.10/include/asm-mips/cpu.h
@@ -29,6 +29,7 @@
 #define PRID_COMP_SIBYTE       0x040000
 #define PRID_COMP_SANDCRAFT    0x050000
 #define PRID_COMP_PHILIPS      0x060000
+#define PRID_COMP_CAVIUM       0x0d0000
 
 /*
  * Assigned values for the product ID register.  In order to detect a
@@ -89,6 +90,12 @@
 #define PRID_IMP_SR71000        0x0400
 
 /*
+ * These are the PRID's for when 23:16 == PRID_COMP_CAVIUM
+ */
+
+#define PRID_IMP_CAVIUM_OCTEON 0x0000
+
+/*
  * Definitions for 7:0 on legacy processors
  */
 
@@ -181,7 +188,8 @@
 #define CPU_24K			58
 #define CPU_AU1200		59
 #define CPU_PR4450		60
-#define CPU_LAST		60
+#define CPU_CAVIUM_OCTEON	61
+#define CPU_LAST		61
 
 /*
  * ISA Level encodings
Index: linux-2.6.10/include/asm-mips/hazards.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/hazards.h
+++ linux-2.6.10/include/asm-mips/hazards.h
@@ -74,10 +74,10 @@
 #define irq_disable_hazard
 	_ehb
 
-#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000) ||  defined(CONFIG_CPU_CAVIUM_OCTEON)
 
 /*
- * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ * R10000, Octeon rocks - all hazards handled in hardware, so this becomes a nobrainer.
  */
 
 #define irq_enable_hazard
@@ -170,10 +170,10 @@ __asm__(
 	__asm__ __volatile__(						\
 	"_ehb\t\t\t\t# irq_disable_hazard")
 
-#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000) || defined(CONFIG_CPU_CAVIUM_OCTEON)
 
 /*
- * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ * R10000, Octeon rocks - all hazards handled in hardware, so this becomes a nobrainer.
  */
 
 __asm__(
Index: linux-2.6.10/include/asm-mips/interrupt.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/interrupt.h
+++ linux-2.6.10/include/asm-mips/interrupt.h
@@ -25,10 +25,14 @@ __asm__ (
 	".set\tpush\n\t"
 	".set\treorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"ei\n\t"
+#else
 	"mfc0\t$1,$12\n\t"
 	"ori\t$1,0x1f\n\t"
 	"xori\t$1,0x1e\n\t"
 	"mtc0\t$1,$12\n\t"
+#endif
 	"irq_enable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -64,11 +68,15 @@ __asm__ (
 	".macro\tlocal_irq_disable\n\t"
 	".set\tpush\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"di\n\t"
+#else
 	"mfc0\t$1,$12\n\t"
 	"ori\t$1,0x1f\n\t"
 	"xori\t$1,0x1f\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1,$12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -100,11 +108,15 @@ __asm__ (
 	".set\tpush\n\t"
 	".set\treorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"di\t\\result\n\t"
+#else
 	"mfc0\t\\result, $12\n\t"
 	"ori\t$1, \\result, 0x1f\n\t"
 	"xori\t$1, 0x1f\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1, $12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -120,12 +132,21 @@ __asm__ (
 	".macro\tlocal_irq_restore flags\n\t"
 	".set\tnoreorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	/*
+	 * Fast, dangerous.
+	 */
+	"mfc0\t$1, $12\n\t"
+	"ins\t$1, \\flags, 0, 1\n\t"
+	"mtc0\t$1, $12\n\t"
+#else
 	"mfc0\t$1, $12\n\t"
 	"andi\t\\flags, 1\n\t"
 	"ori\t$1, 0x1f\n\t"
 	"xori\t$1, 0x1f\n\t"
 	"or\t\\flags, $1\n\t"
 	"mtc0\t\\flags, $12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tat\n\t"
 	".set\treorder\n\t"
@@ -156,10 +177,14 @@ __asm__ (
 	".set\tpush\n\t"
 	".set\treorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"ei\n\t"
+#else
 	"mfc0\t$1,$12\n\t"
 	"ori\t$1,0x1f\n\t"
 	"xori\t$1,0x1e\n\t"
 	"mtc0\t$1,$12\n\t"
+#endif
 	"irq_enable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -195,11 +220,15 @@ __asm__ (
 	".macro\tlocal_irq_disable\n\t"
 	".set\tpush\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"di\n\t"
+#else
 	"mfc0\t$1,$12\n\t"
 	"ori\t$1,0x1f\n\t"
 	"xori\t$1,0x1f\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1,$12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -231,11 +260,15 @@ __asm__ (
 	".set\tpush\n\t"
 	".set\treorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	"di\t\\result\n\t"
+#else
 	"mfc0\t\\result, $12\n\t"
 	"ori\t$1, \\result, 0x1f\n\t"
 	"xori\t$1, 0x1f\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1, $12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
@@ -251,12 +284,21 @@ __asm__ (
 	".macro\tlocal_irq_restore flags\n\t"
 	".set\tnoreorder\n\t"
 	".set\tnoat\n\t"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	/*
+	 * Fast, dangerous.
+	 */
+	"mfc0\t$1, $12\n\t"
+	"ins\t$1, \\flags, 0, 1\n\t"
+	"mtc0\t$1, $12\n\t"
+#else
 	"mfc0\t$1, $12\n\t"
 	"andi\t\\flags, 1\n\t"
 	"ori\t$1, 0x1f\n\t"
 	"xori\t$1, 0x1f\n\t"
 	"or\t\\flags, $1\n\t"
 	"mtc0\t\\flags, $12\n\t"
+#endif
 	"irq_disable_hazard\n\t"
 	".set\tat\n\t"
 	".set\treorder\n\t"
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h
@@ -0,0 +1,37 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Cavium Networks
+ */
+#ifndef __ASM_MACH_CAVIUM_OCTEON_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_CAVIUM_OCTEON_CPU_FEATURE_OVERRIDES_H
+
+/*
+ * Cavium Octeons are MIPS64v2 processors
+ */
+#define cpu_dcache_line_size()	128
+#define cpu_icache_line_size()	128
+
+#define cpu_has_llsc		1
+#define cpu_has_prefetch  	1
+#define cpu_has_dc_aliases  0
+#define cpu_has_fpu         0
+
+#define ARCH_HAS_READ_CURRENT_TIMER 1
+
+static inline unsigned long read_current_timer(unsigned long *result)
+{
+	asm volatile ("rdhwr %0,$31":"=r" (*result));
+	return *result;
+}
+
+static inline int octeon_is_pass1(void)
+{
+	uint32_t id;
+	asm volatile ("mfc0 %0, $15,0":"=r" (id));
+	return (id == 0x000d0000);
+}
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/cvmx-bootmem-shared.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/cvmx-bootmem-shared.h
@@ -0,0 +1,232 @@
+/*************************************************************************
+Copyright (c) 2004-2005 Cavium Networks (support@cavium.com). All rights
+reserved.
+
+This file is subject to the terms and conditions of the GNU General Public
+License.  See the file "COPYING" in the main directory of this archive
+for more details.
+
+*************************************************************************/
+
+/**
+ * @file
+ * Simple allocate only memory allocator.  Used to allocate memory at application
+ * start time.
+ * This file is used by both the bootloader and the simple executive.
+ *
+ * $Id: pro_mips_cavium_octeon.patch,v 1.1.2.7 2007/01/27 05:20:47 cminyard Exp $
+ *
+ */
+#ifndef __CVMX_BOOTMEM_SHARED_H__
+#define __CVMX_BOOTMEM_SHARED_H__
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#define CVMX_BOOTMEM_NAME_LEN 128	/* Must be multiple of 8, changing breaks ABI */
+#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS 64	/* Can change without breaking ABI */
+
+#define CVMX_BOOTMEM_ALIGNMENT_SIZE     (16ull)	/* minimum alignment of bootmem alloced blocks */
+#ifndef CAST64
+#define CAST64(v) ((unsigned long long)(unsigned long)(v))	/* Removes warnings when building for 32 bit */
+#endif
+
+/* First bytes of each free physical block of memory contain this structure,
+ * which is used to maintain the free memory list.  Since the bootloader is
+ * only 32 bits, there is a union providing 64 and 32 bit versions.  The
+ * application init code converts addresses to 64 bit addresses before the
+ * application starts.
+ */
+	typedef struct {
+		/* Note: these are referenced from assembly routines in the bootloader, so this structure
+		 ** should not be changed without changing those routines as well. */
+		uint64_t next_block_addr;
+		uint64_t size;
+
+	} cvmx_bootmem_block_header_t;
+
+/* Structure for named memory blocks
+** Number of descriptors
+** available can be changed without affecting compatiblity,
+** but name length changes require a bump in the bootmem
+** descriptor version
+** Note: This structure must be naturally 64 bit aligned, as a single
+** memory image will be used by both 32 and 64 bit programs.
+*/
+	typedef struct {
+		uint64_t base_addr;
+			    /**< Base address of named block */
+		uint64_t size;
+			    /**< Size actually allocated for named block (may differ from requested) */
+		char name[CVMX_BOOTMEM_NAME_LEN];
+					/**< name of named block */
+	} cvmx_bootmem_named_block_desc_t;
+
+/* Current descriptor versions */
+#define CVMX_BOOTMEM_DESC_MAJ_VER   3	/* CVMX bootmem descriptor major version */
+#define CVMX_BOOTMEM_DESC_MIN_VER   0	/* CVMX bootmem descriptor minor version */
+
+/* First three members of cvmx_bootmem_desc_t are left in original
+** positions for backwards compatibility.
+*/
+	typedef struct {
+		uint32_t lock;
+			    /**< spinlock to control access to list */
+		uint32_t flags;
+			    /**< flags for indicating various conditions */
+		uint64_t head_addr;
+
+		uint32_t major_version;
+				/**< incremented changed when incompatible changes made */
+		uint32_t minor_version;
+				/**< incremented changed when compatible changes made, reset to zero when major incremented */
+		uint64_t app_data_addr;
+		uint64_t app_data_size;
+
+		uint32_t named_block_num_blocks;
+					 /**< number of elements in named blocks array */
+		uint32_t named_block_name_len;
+					 /**< length of name array in bootmem blocks */
+		uint64_t named_block_array_addr;
+					 /**< address of named memory block descriptors */
+
+	} cvmx_bootmem_desc_t;
+
+	static inline uint64_t octeon_xkphys(uint64_t address) {
+		return address | (1ull << 63);
+	}
+#if !defined(CONFIG_OCTEON_U_BOOT)
+	static inline void octeon_lock(uint64_t lock_address) {
+
+		if (sizeof(void *) == 8) {
+			uint32_t tmp;
+			__asm__ __volatile__(".set noreorder             \n"
+#ifdef __OCTEON__
+					     "   syncw                   \n"
+#else
+					     "   sync                    \n"
+#endif
+					     "1: ll   %[tmp], 0(%[addr]) \n"
+					     "   bnez %[tmp], 1b         \n"
+					     "   li   %[tmp], 1          \n"
+					     "   sc   %[tmp], 0(%[addr]) \n"
+					     "   beqz %[tmp], 1b         \n"
+					     "   nop                     \n"
+					     ".set reorder               \n":
+					     [tmp] "=&r"(tmp)
+					     :[addr] "r"(lock_address)
+					     :"memory");
+		} else {
+			uint32_t addrh = lock_address >> 32;
+			uint32_t addrl = lock_address;
+			uint32_t tmph;
+			uint32_t tmpl;
+			__asm__
+			    __volatile__
+			    (".set noreorder                         \n"
+#ifdef __OCTEON__
+			     "   syncw                   \n"
+#else
+			     "   sync                    \n"
+#endif
+			     "   dsll %[tmpl], %[addrl], 32          \n"
+			     "   dsll %[tmph], %[addrh], 32          \n"
+			     "   dsrl %[tmpl], %[tmpl], 32           \n"
+			     "   or   %[tmph], %[tmph], %[tmpl]      \n"
+			     "1: ll   %[tmpl], 0(%[tmph])            \n"
+			     "   bnez %[tmpl], 1b                    \n"
+			     "   li   %[tmpl], 1                     \n"
+			     "   sc   %[tmpl], 0(%[tmph])            \n"
+			     "   beqz %[tmpl], 1b                    \n"
+			     "   nop                                 \n"
+			     ".set reorder                           \n":[tmpl]
+			     "=r"(tmpl),[tmph] "=r"(tmph)
+			     :[addrh] "r"(addrh),[addrl] "r"(addrl)
+			     :"memory");
+		}
+	}
+
+	static inline void octeon_unlock(uint64_t lock_address) {
+
+		if (sizeof(void *) == 8) {
+			__asm__ __volatile__(".set noreorder             \n"
+#ifdef __OCTEON__
+					     "   syncw                   \n"
+					     "   sw   $0, 0(%[addr])     \n"
+					     "   syncw                   \n"
+#else
+					     "   sync                    \n"
+					     "   sw   $0, 0(%[addr])     \n"
+					     "   sync                    \n"
+#endif
+					     ".set reorder               \n"::
+					     [addr] "r"(lock_address)
+					     :"memory");
+		} else {
+			uint32_t addrh = lock_address >> 32;
+			uint32_t addrl = lock_address;
+			uint32_t tmph;
+			uint32_t tmpl;
+			__asm__
+			    __volatile__
+			    (".set noreorder                         \n"
+#ifdef __OCTEON__
+			     "   syncw                   \n"
+#else
+			     "   sync                                \n"
+#endif
+			     "   dsll %[tmpl], %[addrl], 32          \n"
+			     "   dsll %[tmph], %[addrh], 32          \n"
+			     "   dsrl %[tmpl], %[tmpl], 32           \n"
+			     "   or   %[tmph], %[tmph], %[tmpl]      \n"
+			     "   sw   $0, 0(%[tmph])                 \n"
+#ifdef __OCTEON__
+			     "   syncw                               \n"
+#else
+			     "   sync                                \n"
+#endif
+			     ".set reorder                           \n":[tmph]
+			     "=r"(tmph),[tmpl] "=r"(tmpl)
+			     :[addrh] "r"(addrh),[addrl] "r"(addrl)
+			     :"memory");
+		}
+	}
+#endif
+
+/* Prototypes for the functions shared between the bootloader and
+** the simple exec.  These must NOT be called directly from applications
+*/
+	uint64_t octeon_phy_mem_block_alloc(cvmx_bootmem_desc_t *
+					    bootmem_desc_ptr, uint64_t req_size,
+					    uint64_t address_min,
+					    uint64_t address_max,
+					    uint64_t alignment);
+
+	uint64_t octeon_phy_mem_named_block_alloc(cvmx_bootmem_desc_t *
+						  bootmem_desc_ptr,
+						  uint64_t size,
+						  uint64_t min_addr,
+						  uint64_t max_addr,
+						  uint64_t alignment,
+						  char *name);
+	cvmx_bootmem_named_block_desc_t
+	    *octeon_phy_mem_named_block_find(cvmx_bootmem_desc_t *
+					     bootmem_desc_ptr, char *name);
+
+	void octeon_phy_mem_list_print(cvmx_bootmem_desc_t * bootmem_desc_ptr);
+	int octeon_phy_mem_block_free(cvmx_bootmem_desc_t * bootmem_desc_ptr,
+				      uint64_t phy_addr, uint64_t size);
+	void octeon_phy_mem_named_block_print(cvmx_bootmem_desc_t *
+					      bootmem_desc_ptr);
+	int octeon_phy_mem_named_block_free(cvmx_bootmem_desc_t *
+					    bootmem_desc_ptr, char *name);
+	uint64_t octeon_phy_mem_list_available_mem(cvmx_bootmem_desc_t *
+						   bootmem_desc_ptr,
+						   uint64_t min_block_size);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif				/* __CVMX_BOOTMEM_SHARED_H__ */
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/hal.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/hal.h
@@ -0,0 +1,958 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 Cavium Networks
+ */
+#ifndef __CAVIUM_OCTEON_HAL_H
+#define __CAVIUM_OCTEON_HAL_H
+
+/* Copy of cvmx_bootinfo_t structure from cvmx-app-init.h.  This must be kept in sync
+** with that definition */
+extern void *octeon_bootmem_alloc(uint64_t size, uint64_t alignment);
+extern void *octeon_bootmem_alloc_range(uint64_t size, uint64_t alignment,
+					uint64_t min_addr, uint64_t max_addr);
+
+typedef struct {
+	uint32_t major_version;
+	uint32_t minor_version;
+
+	uint64_t stack_top;
+	uint64_t heap_base;
+	uint64_t heap_end;
+	uint64_t desc_vaddr;
+
+	uint32_t exception_base_addr;
+	uint32_t stack_size;
+	uint32_t flags;
+	uint32_t core_mask;
+	uint32_t dram_size;
+			 /**< DRAM size in megabyes */
+	uint32_t phy_mem_desc_addr;
+				 /**< physical address of free memory descriptor block*/
+	uint32_t debugger_flags_base_addr;
+					/**< used to pass flags from app to debugger */
+	uint32_t eclock_hz;
+			 /**< CPU clock speed, in hz */
+	uint32_t dclock_hz;
+			 /**< DRAM clock speed, in hz */
+	uint32_t spi_clock_hz;
+			    /**< SPI4 clock in hz */
+	uint16_t board_type;
+	uint8_t board_rev_major;
+	uint8_t board_rev_minor;
+	uint16_t chip_type;
+	uint8_t chip_rev_major;
+	uint8_t chip_rev_minor;
+	char board_serial_number[20];
+	uint8_t mac_addr_base[6];
+	uint8_t mac_addr_count;
+    /***************** Start of fields added in cvmx_bootinfo_t version 1.1 ******/
+	/* Several boards support compact flash on the Octeon boot bus.  The CF
+	 ** memory spaces may be mapped to different addresses on different boards.
+	 ** These are the physical addresses, so care must be taken to use the correct
+	 ** XKPHYS/KSEG0 addressing depending on the application's ABI.
+	 ** These values will be 0 if CF is not present */
+	uint64_t compact_flash_common_base_addr;
+	uint64_t compact_flash_attribute_base_addr;
+	/* Base address of the LED display (as on EBT3000 board)
+	 ** This will be 0 if LED display not present. */
+	uint64_t led_display_base_addr;
+    /***************** End of fields added in cvmx_bootinfo_t version 1.1 ******/
+
+} octeon_bootinfo_t;
+
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t tlbbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t l1cbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t l1dbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t dcmbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t ptgbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t wbfbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
+		uint64_t reserved:22;	    /**< Reserved */
+		uint64_t dismarkwblongto:1; /**< R/W If set, marked write-buffer entries time out the same as
+						as other entries; if clear, marked write-buffer entries use the
+						maximum timeout. */
+		uint64_t dismrgclrwbto:1;   /**< R/W If set, a merged store does not clear the write-buffer entry
+						timeout state. */
+		uint64_t iobdmascrmsb:2;    /**< R/W Two bits that are the MSBs of the resultant CVMSEG LM word
+						location for an IOBDMA. The other 8 bits come from the SCRADDR
+						field of the IOBDMA. */
+		uint64_t syncwsmarked:1;    /**< R/W If set, SYNCWS and SYNCS only order marked stores; if clear,
+						SYNCWS and SYNCS only order unmarked stores. SYNCWSMARKED has no
+						effect when DISSYNCWS is set. */
+		uint64_t dissyncws:1;	    /**< R/W If set, SYNCWS acts as SYNCW and SYNCS acts as SYNC. */
+		uint64_t diswbfst:1;	    /**< R/W If set, no stall happens on write buffer full. */
+		uint64_t xkmemenas:1;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
+						XKPHYS addresses with VA<48>==0 */
+		uint64_t xkmemenau:1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
+						addresses with VA<48>==0 */
+		uint64_t xkioenas:1;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
+						XKPHYS addresses with VA<48>==1 */
+		uint64_t xkioenau:1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
+						addresses with VA<48>==1 */
+		uint64_t allsyncw:1;	    /**< R/W If set, all stores act as SYNCW (NOMERGE must be set when
+						this is set) RW, reset to 0. */
+		uint64_t nomerge:1;	    /**< R/W If set, no stores merge, and all stores reach the coherent
+						bus in order. */
+		uint64_t didtto:2;	    /**< R/W Selects the bit in the counter used for DID time-outs
+						0 = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is between
+						1 and 2 this interval. For example, with DIDTTO=3, expiration
+						interval is between 16K and 32K. */
+		uint64_t csrckalwys:1;	    /**< R/W If set, the (mem) CSR clock never turns off. */
+		uint64_t mclkalwys:1;	    /**< R/W If set, mclk never turns off. */
+		uint64_t wbfltime:3;	    /**< R/W Selects the bit in the counter used for write buffer flush
+						time-outs (WBFLT+11) is the bit position in an internal counter
+						used to determine expiration. The write buffer expires between
+						1 and 2 this interval. For example, with WBFLT = 0, a write
+						buffer expires between 2K and 4K cycles after the write buffer
+						entry is allocated. */
+		uint64_t istrnol2:1;	    /**< R/W If set, do not put Istream in the L2 cache. */
+		uint64_t wbthresh:4;	    /**< R/W The write buffer threshold. */
+		uint64_t reserved2:2;	    /**< Reserved */
+		uint64_t cvmsegenak:1;	    /**< R/W If set, CVMSEG is available for loads/stores in kernel/debug mode. */
+		uint64_t cvmsegenas:1;	    /**< R/W If set, CVMSEG is available for loads/stores in supervisor mode. */
+		uint64_t cvmsegenau:1;	    /**< R/W If set, CVMSEG is available for loads/stores in user mode. */
+		uint64_t lmemsz:6;	    /**< R/W Size of local memory in cache blocks, 54 (6912 bytes) is max legal value. */
+	} s;
+} octeon_cvmemctl_t;
+
+#define OCTEON_CIU_INTX_SUM0(offset) (0x8001070000000000ull+((offset)*8))
+#define OCTEON_CIU_INTX_EN0(offset) (0x8001070000000200ull+((offset)*16))
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:8;
+		uint64_t timer:4;
+		uint64_t key_zero:1;
+		uint64_t ipd_drp:1;
+		uint64_t gmx_drp:2;
+		uint64_t trace:1;
+		uint64_t rml:1;
+		uint64_t twsi:1;
+		uint64_t wdog_sum:1;
+		uint64_t pci_msi:4;
+		uint64_t pci_int:4;
+		uint64_t uart:2;
+		uint64_t mbox:2;
+		uint64_t gpio:16;
+		uint64_t workq:16;
+	} s;
+} octeon_ciu_intx0_t;
+
+#define OCTEON_IOB_FAU_TIMEOUT (0x80011800F0000000ull)
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:51;
+		uint64_t tout_enb:1;
+		uint64_t tout_val:12;
+	} s;
+} octeon_iob_fau_timeout_t;
+
+#define OCTEON_POW_NW_TIM (0x8001670000000210ull)
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:54;
+		uint64_t nw_tim:10;
+	} s;
+} octeon_pow_nw_tim_t;
+
+#define OCTEON_LMC_FADR (0x8001180088000020ull)
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:32;
+		uint64_t fdimm:2;
+		uint64_t fbunk:1;
+		uint64_t fbank:3;
+		uint64_t frow:14;
+		uint64_t fcol:12;
+	} s;
+} octeon_lmc_fadr_t;
+
+#define OCTEON_NPI_MEM_ACCESS_SUBID3 (0x80011F0000000028ull)
+#define OCTEON_NPI_MEM_ACCESS_SUBID4 (0x80011F0000000030ull)
+#define OCTEON_NPI_MEM_ACCESS_SUBID5 (0x80011F0000000038ull)
+#define OCTEON_NPI_MEM_ACCESS_SUBID6 (0x80011F0000000040ull)
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:28;		    /**< Reserved */
+		uint64_t esr:2;			    /**< Endian-Swap on read. */
+		uint64_t esw:2;			    /**< Endian-Swap on write. */
+		uint64_t nsr:1;			    /**< No-Snoop on read. */
+		uint64_t nsw:1;			    /**< No-Snoop on write. */
+		uint64_t ror:1;			    /**< Relax Read on read. */
+		uint64_t row:1;			    /**< Relax Order on write. */
+		uint64_t ba:28;			    /**< PCI Address bits [63:36]. */
+	} s;
+} octeon_npi_mem_access_subid_t;
+
+#define OCTEON_NPI_PCI_CFG00    (0x80011F0000001800ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t devid:16;		    /**< This is the device ID for N3 */
+		uint64_t vendid:16;		    /**< This is the Cavium's vendor ID */
+	} s;
+} octeon_pci_cfg00_t;
+
+#define OCTEON_NPI_PCI_CFG01    (0x80011F0000001804ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t dpe:1;			    /**< Detected Parity Error */
+		uint64_t sse:1;			    /**< Signaled System Error */
+		uint64_t rma:1;			    /**< Received Master Abort */
+		uint64_t rta:1;			    /**< Received Target Abort */
+		uint64_t sta:1;			    /**< Signaled Target Abort */
+		uint64_t devt:2;		    /**< DEVSEL# timing (for PCI only/for PCIX = don?t care) */
+		uint64_t mdpe:1;		    /**< Master Data Parity Error */
+		uint64_t fbb:1;			    /**< Fast Back-to-Back Transactions Capable
+							 Mode               1 = PCI Mode     0 = PCIX Mode
+							 Dependent */
+		uint64_t reserved:1;		    /**< Reserved */
+		uint64_t m66:1;			    /**< 66MHz Capable */
+		uint64_t cle:1;			    /**< Capabilities List Enable */
+		uint64_t i_stat:1;		    /**< When INTx# is asserted by N3 this bit will be set.
+							 When deasserted by N3 this bit will be cleared. */
+		uint64_t reserved1:8;		    /**< Reserved */
+		uint64_t i_dis:1;		    /**< When asserted '1' disables the generation of INTx#
+							 by N3. When disabled '0' allows assertion of INTx#
+							 by N3. */
+		uint64_t fbbe:1;		    /**< Fast Back to Back Transaction Enable */
+		uint64_t see:1;			    /**< System Error Enable */
+		uint64_t ads:1;			    /**< Address/Data Stepping */
+		uint64_t pee:1;			    /**< PERR# Enable */
+		uint64_t vps:1;			    /**< VGA Palette Snooping */
+		uint64_t mwice:1;		    /**< Memory Write & Invalidate Command Enable */
+		uint64_t scse:1;		    /**< Special Cycle Snooping Enable */
+		uint64_t me:1;			    /**< Master Enable */
+		uint64_t msae:1;		    /**< Memory Space Access Enable */
+		uint64_t isae:1;		    /**< I/O Space Access Enable */
+	} s;
+} octeon_pci_cfg01_t;
+
+#define OCTEON_NPI_PCI_CFG02    (0x80011F0000001808ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t cc:24;			    /**< Class Code (Network Encryption/Decryption Class) */
+		uint64_t rid:8;			    /**< Revision ID */
+	} s;
+} octeon_pci_cfg02_t;
+
+#define OCTEON_NPI_PCI_CFG03    (0x80011F000000180Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t bcap:1;		    /**< BIST Capable */
+		uint64_t brb:1;			    /**< BIST Request/busy bit
+							 Note: N3 does not support PCI BIST, therefore
+							 this bit should remain zero. */
+		uint64_t reserved:2;		    /**< Reserved */
+		uint64_t bcod:4;		    /**< BIST Code */
+		uint64_t ht:8;			    /**< Header Type (Type 0) */
+		uint64_t lt:8;			    /**< Latency Timer
+							 (0=PCI)                 (0=PCI)
+							 (0x40=PCIX)             (0x40=PCIX) */
+		uint64_t cls:8;			    /**< Cache Line Size */
+	} s;
+} octeon_pci_cfg03_t;
+
+#define OCTEON_NPI_PCI_CFG04    (0x80011F0000001810ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t lbase:20;		    /**< Base Address[31:12] */
+		uint64_t lbasez:8;		    /**< Base Address[11:4] (Read as Zero) */
+		uint64_t pf:1;			    /**< Prefetchable Space */
+		uint64_t typ:2;			    /**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
+		uint64_t mspc:1;		    /**< Memory Space Indicator */
+	} s;
+} octeon_pci_cfg04_t;
+
+#define OCTEON_NPI_PCI_CFG05    (0x80011F0000001814ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t hbase:32;		    /**< Base Address[63:32] */
+	} s;
+} octeon_pci_cfg05_t;
+
+#define OCTEON_NPI_PCI_CFG06    (0x80011F0000001818ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t lbase:5;		    /**< Base Address[31:27] */
+		uint64_t lbasez:23;		    /**< Base Address[26:4] (Read as Zero) */
+		uint64_t pf:1;			    /**< Prefetchable Space */
+		uint64_t typ:2;			    /**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
+		uint64_t mspc:1;		    /**< Memory Space Indicator */
+	} s;
+} octeon_pci_cfg06_t;
+
+#define OCTEON_NPI_PCI_CFG07    (0x80011F000000181Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t hbase:32;		    /**< Base Address[63:32] */
+	} s;
+} octeon_pci_cfg07_t;
+
+#define OCTEON_NPI_PCI_CFG08    (0x80011F0000001820ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t lbasez:28;		    /**< Base Address[31:4] (Read as Zero) */
+		uint64_t pf:1;			    /**< Prefetchable Space */
+		uint64_t typ:2;			    /**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
+		uint64_t mspc:1;		    /**< Memory Space Indicator */
+	} s;
+} octeon_pci_cfg08_t;
+
+#define OCTEON_NPI_PCI_CFG09    (0x80011F0000001824ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t hbase:25;		    /**< Base Address[63:39] */
+		uint64_t hbasez:7;		    /**< Base Address[38:31] (Read as Zero) */
+	} s;
+} octeon_pci_cfg09_t;
+
+#define OCTEON_NPI_PCI_CFG10    (0x80011F0000001828ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t cisp:32;		    /**< CardBus CIS Pointer (UNUSED) */
+	} s;
+} octeon_pci_cfg10_t;
+
+#define OCTEON_NPI_PCI_CFG11    (0x80011F000000182Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t ssid:16;		    /**< SubSystem ID */
+		uint64_t ssvid:16;		    /**< Subsystem Vendor ID */
+	} s;
+} octeon_pci_cfg11_t;
+
+#define OCTEON_NPI_PCI_CFG12    (0x80011F0000001830ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t erbar:16;		    /**< Expansion ROM Base Address[31:16] 64KB in size */
+		uint64_t erbarz:5;		    /**< Expansion ROM Base Base Address (Read as Zero) */
+		uint64_t reserved:10;		    /**< Reserved */
+		uint64_t erbar_en:1;		    /**< Expansion ROM Address Decode Enable */
+	} s;
+} octeon_pci_cfg12_t;
+
+#define OCTEON_NPI_PCI_CFG13    (0x80011F0000001834ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:24;		    /**< Reserved */
+		uint64_t cp:8;			    /**< Capabilities Pointer */
+	} s;
+} octeon_pci_cfg13_t;
+
+#define OCTEON_NPI_PCI_CFG15    (0x80011F000000183Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t ml:8;			    /**< Maximum Latency */
+		uint64_t mg:8;			    /**< Minimum Grant */
+		uint64_t inta:8;		    /**< Interrupt Pin (INTA#) */
+		uint64_t il:8;			    /**< Interrupt Line */
+	} s;
+} octeon_pci_cfg15_t;
+
+#define OCTEON_NPI_PCI_CFG16    (0x80011F0000001840ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t trdnpr:1;		    /**< Target Read Delayed Transaction for I/O and
+							 non-prefetchable regions discarded. */
+		uint64_t trdard:1;		    /**< Target Read Delayed Transaction for all regions
+							 discarded. */
+		uint64_t rdsati:1;		    /**< Target(I/O and Memory) Read Delayed/Split at
+							 timeout/immediately (default timeout). */
+		uint64_t trdrs:1;		    /**< Target(I/O and Memory) Read Delayed/Split or Retry
+							 select (of the application interface is not ready)
+							 0 = Delayed Split Transaction
+							 1 = Retry Transaction (always Immediate Retry, no
+							 AT_REQ to application). */
+		uint64_t trtae:1;		    /**< Target(I/O and Memory) Read Target Abort Enable
+							 (if application interface is not ready at the
+							 latency timeout).
+							 Note: N3 as target will never target-abort,
+							 therefore this bit should never be set. */
+		uint64_t twsei:1;		    /**< Target(I/O) Write Split Enable (at timeout /
+							 iately; default timeout) */
+		uint64_t twsen:1;		    /**< T(I/O) write split Enable (if the application
+							 interface is not ready) */
+		uint64_t twtae:1;		    /**< Target(I/O and Memory) Write Target Abort Enable
+							 (if the application interface is not ready at the
+							 start of the cycle).
+							 Note: N3 as target will never target-abort,
+							 therefore this bit should never be set. */
+		uint64_t tmae:1;		    /**< Target(Read/Write) Master Abort Enable; check
+							 at the start of each transaction.
+							 Note: This bit can be used to force a Master
+							 Abort when N3 is acting as the intended target
+							 device. */
+		uint64_t tslte:3;		    /**< Target Subsequent(2nd-last) Latency Timeout Enable
+							 Valid range: [1..7] and 0=8. */
+		uint64_t tilt:4;		    /**< Target Initial(1st data) Latency Timeout in PCI
+							 ModeValid range: [8..15] and 0=16. */
+		uint64_t pbe:12;		    /**< Programmable Boundary Enable to disconnect/prefetch
+							 for target burst read cycles to prefetchable
+							 region in PCI. A value of 1 indicates end of
+							 boundary (64 KB down to 16 Bytes). */
+		uint64_t dppmr:1;		    /**< Disconnect/Prefetch to prefetchable memory
+							 regions Enable. Prefetchable memory regions
+							 are always disconnected on a region boundary.
+							 Non-prefetchable regions for PCI are always
+							 disconnected on the first transfer.
+							 Note: N3 as target will never target-disconnect,
+							 therefore this bit should never be set. */
+		uint64_t reserved:1;		    /**< Reserved */
+		uint64_t tswc:1;		    /**< Target Split Write Control
+							 0 = Blocks all requests except PMW
+							 1 = Blocks all requests including PMW until
+							 split completion occurs. */
+		uint64_t mltd:1;		    /**< Master Latency Timer Disable */
+	} s;
+} octeon_pci_cfg16_t;
+
+#define OCTEON_NPI_PCI_CFG17    (0x80011F0000001844ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t tscme:32;		    /**< Target Split Completion Message Enable */
+	} s;
+} octeon_pci_cfg17_t;
+
+#define OCTEON_NPI_PCI_CFG18    (0x80011F0000001848ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t tdsrps:32;		    /**< Target Delayed/Split Request Pending Sequences */
+	} s;
+} octeon_pci_cfg18_t;
+
+#define OCTEON_NPI_PCI_CFG19    (0x80011F000000184Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t mrbcm:1;		    /**< Master Request (Memory Read) Byte Count/Byte
+							 Enable select.
+							 0 = Byte Enables valid. In PCI mode, a burst
+							 transaction cannot be performed using
+							 Memory Read command=4?h6.
+							 1 = DWORD Byte Count valid (default). In PCI
+							 Mode, the memory read byte enables are
+							 automatically generated by the core.
+							 Note: N3 Master Request transaction sizes are
+							 always determined through the
+							 am_attr[<35:32>|<7:0>] field. */
+		uint64_t mrbci:1;		    /**< Master Request (I/O and CR cycles) byte count/byte
+							 enable select.
+							 0 = Byte Enables valid (default)
+							 1 = DWORD byte count valid
+							 Note: For N3K, This bit must always be zero
+							 for proper operation (in support of
+							 Type0/1 Cfg Space accesses which require byte
+							 enable generation directly from a read mask). */
+		uint64_t mdwe:1;		    /**< Master (Retry) Deferred Write Enable (allow
+							 read requests to pass).
+							 NOTE: Applicable to PCI Mode I/O and memory
+							 transactions only.
+							 0 = New read requests are NOT accepted until
+							 the current write cycle completes. [Reads
+							 cannot pass writes]
+							 1 = New read requests are accepted, even when
+							 there is a write cycle pending [Reads can
+							 pass writes]. */
+		uint64_t mdre:1;		    /**< Master (Retry) Deferred Read Enable (Allows
+							 read/write requests to pass).
+							 NOTE: Applicable to PCI mode I/O and memory
+							 transactions only.
+							 0 = New read/write requests are NOT accepted
+							 until the current read cycle completes.
+							 [Read/write requests CANNOT pass reads]
+							 1 = New read/write requests are accepted, even
+							 when there is a read cycle pending.
+							 [Read/write requests CAN pass reads] */
+		uint64_t mdrimc:1;		    /**< Master I/O Deferred/Split Request Outstanding
+							 Maximum Count
+							 0 = 4Ch[26:24]
+							 1 = 1 */
+		uint64_t mdrrmc:3;		    /**< Master Deferred Read Request Outstanding Max
+							 Count (PCI only).
+							 CR4C[26:24]  Max SAC cycles   MAX DAC cycles
+							 000              8                4
+							 001              1                0
+							 010              2                1
+							 011              3                1
+							 100              4                2
+							 101              5                2
+							 110              6                3
+							 111              7                3
+							 For example, if these bits are programmed to
+							 100, the core can support 2 DAC cycles, 4 SAC
+							 cycles or a combination of 1 DAC and 2 SAC cycles.
+							 NOTE: For the PCI-X maximum outstanding split
+							 transactions, refer to CRE0[22:20] */
+		uint64_t tmes:8;		    /**< Target/Master Error Sequence # */
+		uint64_t teci:1;		    /**< Target Error Command Indication
+							 0 = Delayed/Split
+							 1 = Others */
+		uint64_t tmei:1;		    /**< Target/Master Error Indication
+							 0 = Target
+							 1 = Master */
+		uint64_t tmse:1;		    /**< Target/Master System Error. This bit is set
+							 whenever ATM_SERR_O is active. */
+		uint64_t tmdpes:1;		    /**< Target/Master Data PERR# error status. This
+							 bit is set whenever ATM_DATA_PERR_O is active. */
+		uint64_t tmapes:1;		    /**< Target/Master Address PERR# error status. This
+							 bit is set whenever ATM_ADDR_PERR_O is active. */
+		uint64_t reserved:2;		    /**< Reserved */
+		uint64_t tibcd:1;		    /**< Target Illegal I/O DWORD byte combinations detected. */
+		uint64_t tibde:1;		    /**< Target Illegal I/O DWORD byte detection enable */
+		uint64_t reserved1:1;		    /**< Reserved */
+		uint64_t tidomc:1;		    /**< Target I/O Delayed/Split request outstanding
+							 maximum count.
+							 0 = 4Ch[4:0],
+							 1 = 1 */
+		uint64_t tdomc:5;		    /**< Target Delayed/Split request outstanding maximum
+							 count. [1..31] and 0=32.
+							 NOTE: If the user programs these bits beyond the
+							 Designed Maximum outstanding count, then the
+							 designed maximum table depth will be used instead.
+							 No additional Deferred/Split transactions will be
+							 accepted if this outstanding maximum count
+							 is reached. Furthermore, no additional
+							 deferred/split transactions will be accepted if
+							 the I/O delay/ I/O Split Request outstanding
+							 maximum is reached. */
+	} s;
+} octeon_pci_cfg19_t;
+
+#define OCTEON_NPI_PCI_CFG20    (0x80011F0000001850ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t mdsp:32;		    /**< Master Deferred/Split sequence Pending */
+	} s;
+} octeon_pci_cfg20_t;
+
+#define OCTEON_NPI_PCI_CFG21    (0x80011F0000001854ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t scmre:32;		    /**< Master Split Completion message received with
+							 error message. */
+	} s;
+} octeon_pci_cfg21_t;
+
+#define OCTEON_NPI_PCI_CFG22    (0x80011F0000001858ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t mac:7;			    /**< Master Arbiter Control
+							 [31:26]: Used only in Fixed Priority mode
+							 (when [25]=1)
+							 [31:30]: MSI Request
+							 00 = Highest Priority
+							 01 = Medium Priority
+							 10 = Lowest Priority
+							 11 = RESERVED
+							 [29:28]: Target Split Completion
+							 00 = Highest Priority
+							 01 = Medium Priority
+							 10 = Lowest Priority
+							 11 = RESERVED
+							 [27:26]: New Request; Deferred Read,Deferred Write
+							 00 = Highest Priority
+							 01 = Medium Priority
+							 10 = Lowest Priority
+							 11 = RESERVED
+							 [25]: Fixed/Round Robin Priority Selector
+							 0 = Round Robin
+							 1 = Fixed */
+		uint64_t reserved:6;		    /**< Reserved */
+		uint64_t flush:1;		    /**< AM_DO_FLUSH_I control
+							 NOTE: This bit MUST BE ONE for proper N3K operation */
+		uint64_t mra:1;			    /**< Master Retry Aborted */
+		uint64_t mtta:1;		    /**< Master TRDY timeout aborted */
+		uint64_t mrv:8;			    /**< Master Retry Value [1..255] and 0=infinite */
+		uint64_t mttv:8;		    /**< Master TRDY timeout value [1..255] and 0=disabled
+							 Note: N3 does not support master TRDY timeout
+							 (target is expected to be well behaved). */
+	} s;
+} octeon_pci_cfg22_t;
+
+#define OCTEON_NPI_PCI_CFG56    (0x80011F00000018E0ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:9;		    /**< RESERVED */
+		uint64_t most:3;		    /**< Maximum outstanding Split transactions
+							 [000b=1..111b=32] */
+		uint64_t mmbc:2;		    /**< Maximum Memory Byte Count
+							 [0=512B,1=1024B,2=2048B,3=4096B] */
+		uint64_t roe:1;			    /**< Relaxed Ordering Enable */
+		uint64_t dpere:1;		    /**< Data Parity Error Recovery Enable */
+		uint64_t ncp:8;			    /**< Next Capability Pointer */
+		uint64_t pxcid:8;		    /**< PCI-X Capability ID */
+	} s;
+} octeon_pci_cfg56_t;
+
+#define OCTEON_NPI_PCI_CFG57    (0x80011F00000018E4ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:2;		    /**< RESERVED */
+		uint64_t scemr:1;		    /**< Split Completion Error Message Received */
+		uint64_t mcrsd:3;		    /**< Maximum Cumulative Read Size designed */
+		uint64_t mostd:3;		    /**< Maximum Outstanding Split transaction designed */
+		uint64_t mmrbcd:2;		    /**< Maximum Memory Read byte count designed */
+		uint64_t dc:1;			    /**< Device Complexity
+							 0 = Simple Device
+							 1 = Bridge Device */
+		uint64_t usc:1;			    /**< Unexpected Split Completion */
+		uint64_t scd:1;			    /**< Split Completion Discarded */
+		uint64_t m133:1;		    /**< 133MHz Capable */
+		uint64_t w64:1;			    /**< Indicates a 32b(=0) or 64b(=1) device */
+		uint64_t bn:8;			    /**< Bus Number. Updated on all configuration write
+							 (0x11=PCI)             cycles. It?s value is dependent upon the PCI/X
+							 (0xFF=PCIX)            mode. */
+		uint64_t dn:5;			    /**< Device Number. Updated on all configuration
+							 write cycles. */
+		uint64_t fn:3;			    /**< Function Number */
+	} s;
+} octeon_pci_cfg57_t;
+
+#define OCTEON_NPI_PCI_CFG58    (0x80011F00000018E8ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t pmes:5;		    /**< PME Support (D0 to D3cold) */
+		uint64_t d2s:1;			    /**< D2_Support */
+		uint64_t d1s:1;			    /**< D1_Support */
+		uint64_t auxc:3;		    /**< AUX_Current (0..375mA) */
+		uint64_t dsi:1;			    /**< Device Specific Initialization */
+		uint64_t reserved:1;		    /**< Reserved */
+		uint64_t pmec:1;		    /**< PME Clock */
+		uint64_t pcimiv:3;		    /**< Indicates the version of the PCI
+							 Management
+							 Interface Specification with which the core
+							 complies.
+							 010b = Complies with PCI Management Interface
+							 Specification Revision 1.1 */
+		uint64_t ncp:8;			    /**< Next Capability Pointer */
+		uint64_t pmcid:8;		    /**< Power Management Capability ID */
+	} s;
+} octeon_pci_cfg58_t;
+
+#define OCTEON_NPI_PCI_CFG59    (0x80011F00000018ECull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t pmdia:8;		    /**< Power Management data input from application
+							 (PME_DATA) */
+		uint64_t bpccen:1;		    /**< BPCC_En (bus power/clock control) enable */
+		uint64_t bd3h:1;		    /**< B2_B3#, B2/B3 Support for D3hot */
+		uint64_t reserved:6;		    /**< Reserved */
+		uint64_t pmess:1;		    /**< PME_Status sticky bit */
+		uint64_t pmedsia:2;		    /**< PME_Data_Scale input from application
+							 Device                  (PME_DATA_SCALE[1:0])
+							 Specific */
+		uint64_t pmds:4;		    /**< Power Management Data_select */
+		uint64_t pmeens:1;		    /**< PME_En sticky bit */
+		uint64_t reserved1:6;		    /**< RESERVED */
+		uint64_t ps:2;			    /**< Power State (D0 to D3)
+							 The N2 DOES NOT support D1/D2 Power Management
+							 states, therefore writing to this register has
+							 no effect (please refer to the PCI Power
+							 Management
+							 Specification v1.1 for further details about
+							 it?s R/W nature. This is not a conventional
+							 R/W style register. */
+	} s;
+} octeon_pci_cfg59_t;
+
+#define OCTEON_NPI_PCI_CFG60    (0x80011F00000018F0ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:8;		    /**< RESERVED */
+		uint64_t m64:1;			    /**< 32/64 b message */
+		uint64_t mme:3;			    /**< Multiple Message Enable(1,2,4,8,16,32) */
+		uint64_t mmc:3;			    /**< Multiple Message Capable(0=1,1=2,2=4,3=8,4=16,5=32) */
+		uint64_t msien:1;		    /**< MSI Enable */
+		uint64_t ncp:8;			    /**< Next Capability Pointer */
+		uint64_t msicid:8;		    /**< MSI Capability ID */
+	} s;
+} octeon_pci_cfg60_t;
+
+#define OCTEON_NPI_PCI_CFG61    (0x80011F00000018F4ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t msi31t2:30;		    /**< App Specific MSI Address [31:2] */
+		uint64_t reserved:2;		    /**< RESERVED */
+	} s;
+} octeon_pci_cfg61_t;
+
+#define OCTEON_NPI_PCI_CFG62    (0x80011F00000018F8ull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t msi:32;		    /**< MSI Address [63:32] */
+	} s;
+} octeon_pci_cfg62_t;
+
+#define OCTEON_NPI_PCI_CFG63    (0x80011F00000018FCull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:16;		    /**< RESERVED */
+		uint64_t msimd:16;		    /**< MSI Message Data */
+	} s;
+} octeon_pci_cfg63_t;
+
+#define OCTEON_NPI_PCI_CTL_STATUS_2 (0x80011F000000118Cull)
+typedef union {
+	uint32_t u32;
+	struct {
+		uint64_t reserved:12;		    /**< Reserved */
+		uint64_t erst_n:1;		    /**< Reset active Low. PASS-2 */
+		uint64_t bar2pres:1;		    /**< From fuse block. When fuse(MIO_FUS_DAT3[BAR2_EN])
+							 is NOT blown the value of this field is '0' after
+							 reset and BAR2 is NOT present. When the fuse IS
+							 blown the value of this field is '1' after reset
+							 and BAR2 is present. Note that SW can change this
+							 field after reset. This is a PASS-2 field. */
+		uint64_t scmtyp:1;		    /**< Split Completion Message CMD Type (0=RD/1=WR)
+							 When SCM=1, SCMTYP specifies the CMD intent (R/W) */
+		uint64_t scm:1;			    /**< Split Completion Message Detected (Read or Write) */
+		uint64_t en_wfilt:1;		    /**< When '1' the window-access filter is enabled.
+							 Unfilter writes are:
+							 MIO, SubId0
+							 MIO, SubId7
+							 NPI, SubId0
+							 NPI, SubId7
+							 POW, SubId7
+							 DFA, SubId7
+							 IPD, SubId7
+							 Unfiltered Reads are:
+							 MIO, SubId0
+							 MIO, SubId7
+							 NPI, SubId0
+							 NPI, SubId7
+							 POW, SubId1
+							 POW, SubId2
+							 POW, SubId3
+							 POW, SubId7
+							 DFA, SubId7
+							 IPD, SubId7 */
+		uint64_t spare:1;		    /**< Spare Bit */
+		uint64_t ap_pcix:1;		    /**< PCX Core Mode status (0=PCI Bus/1=PCIX) */
+		uint64_t ap_64ad:1;		    /**< PCX Core Bus status (0=32b Bus/1=64b Bus) */
+		uint64_t b12_bist:1;		    /**< Bist Status For Memeory In B12 */
+		uint64_t pmo_amod:1;		    /**< PMO-ARB Mode (0=FP[HP=CMD1,LP=CMD0]/1=RR) */
+		uint64_t pmo_fpc:3;		    /**< PMO-ARB Fixed Priority Counter
+							 When PMO_AMOD=0 (FP mode), this field represents
+							 the # of CMD1 requests that are issued (at higher
+							 priority) before a single lower priority CMD0
+							 is allowed to issue (to ensure foward progress).
+							 0: 1 CMD1 Request issued before CMD0 allowed
+							 ...
+							 7: 8 CMD1 Requests issued before CMD0 allowed */
+		uint64_t tsr_hwm:3;		    /**< Target Split-Read ADB(allowable disconnect boundary)
+							 High Water Mark.
+							 Specifies the number of ADBs(128 Byte aligned chunks)
+							 that are accumulated(pending) BEFORE the Target Split
+							 completion is attempted on the PCI bus.
+							 0: RESERVED/ILLEGAL
+							 1: 2 Pending ADBs (129B-256B)
+							 2: 3 Pending ADBs (257B-384B)
+							 3: 4 Pending ADBs (385B-512B)
+							 4: 5 Pending ADBs (513B-640B)
+							 5: 6 Pending ADBs (641B-768B)
+							 6: 7 Pending ADBs (769B-896B)
+							 7: 8 Pending ADBs (897B-1024B)
+							 Example: Suppose a 1KB target memory request with
+							 starting byte offset address[6:0]=0x7F is split by
+							 the OCTEON and the TSR_HWM=1(2 ADBs).
+							 The OCTEON will start the target split completion
+							 on the PCI Bus after 1B(1st ADB)128B(2nd ADB)=129B
+							 of data have been received from memory (even though
+							 the remaining 895B has not yet been received). The
+							 OCTEON will continue the split completion until it
+							 has consumed all of the pended split data. If the
+							 full transaction length(1KB) of data was NOT entirely
+							 transferred, then OCTEON will terminate the split
+							 completion and again wait for another 2 ADB-aligned data
+							 chunks(256B) of pended split data to be received from
+							 memory before starting another split completion request.
+							 This allows Octeon (as split completer), to send back
+							 multiple split completions for a given large split
+							 transaction without having to wait for the entire
+							 transaction length to be received from memory.
+							 NOTE: For split transaction sizes 'smaller' than the
+							 specified TSR_HWM value, the split completion
+							 is started when the last datum has been received from
+							 memory.
+							 NOTE: It is IMPERATIVE that this field NEVER BE
+							 written to a ZERO value. A value of zero is
+							 reserved/illegal and can result in PCIX bus hangs). */
+		uint64_t bar2_enb:1;		    /**< When set '1' BAR2 is enable and will respond when
+							 clear '0' BAR2 access will be target-aborted. */
+		uint64_t bar2_esx:2;		    /**< Value will be XORed with pci-address[37:36] to
+							 determine the endian swap mode. */
+		uint64_t bar2_cax:1;		    /**< Value will be XORed with pci-address[38] to
+							 determine the L2 cache attribute. */
+	} s;
+} octeon_pci_ctl_status_2_t;
+
+#define OCTEON_NPI_PCI_READ_CMD_6   (0x80011F0000001180ull)
+#define OCTEON_NPI_PCI_READ_CMD_C   (0x80011F0000001184ull)
+#define OCTEON_NPI_PCI_READ_CMD_E   (0x80011F0000001188ull)
+
+#define OCTEON_NPI_PCI_INT_ARB_CFG  (0x80011F0000000130ull)
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t reserved:59;		    /**< Reserved */
+		uint64_t en:1;			    /**< Internal arbiter enable. */
+		uint64_t park_mod:1;		    /**< Bus park mode. 0=park on last, 1=park on device. */
+		uint64_t park_dev:3;		    /**< Bus park device. 0-3 External device, 4 = Octane. */
+	} s;
+} octeon_npi_pci_int_arb_cfg_t;
+
+#define OCTEON_CIU_MBOX_SETX(offset)    (0x8001070000000600ull+((offset)*8))
+#define OCTEON_CIU_MBOX_CLRX(offset)    (0x8001070000000680ull+((offset)*8))
+#define OCTEON_CIU_SOFT_RST             (0x8001070000000740ull)
+#define OCTEON_CIU_SOFT_PRST            (0x8001070000000748ull)
+#define OCTEON_LMC_MEM_CFG0             (0x8001180088000000ull)
+#define OCTEON_L2C_CFG                  (0x8001180080000000ull)
+#define OCTEON_L2T_ERR                  (0x8001180080000008ull)
+#define OCTEON_L2D_ERR                  (0x8001180080000010ull)
+#define OCTEON_POW_ECC_ERR              (0x8001670000000218ull)
+#define OCTEON_MIO_UARTX_SRR(offset)    (0x8001180000000A10ull+((offset)*1024))
+#define OCTEON_MIO_UARTX_LSR(offset)    (0x8001180000000828ull+((offset)*1024))
+#define OCTEON_MIO_UARTX_RBR(offset)    (0x8001180000000800ull+((offset)*1024))
+#define OCTEON_MIO_UARTX_IER(offset)    (0x8001180000000808ull+((offset)*1024))
+#define OCTEON_MIO_UARTX_THR(offset)    (0x8001180000000840ull+((offset)*1024))
+#define OCTEON_LED_EN                   (0x8001180000001A00ull)
+#define OCTEON_LED_CLK_PHASE            (0x8001180000001A08ull)
+#define OCTEON_LED_PRT                  (0x8001180000001A10ull)
+#define OCTEON_LED_DBG                  (0x8001180000001A18ull)
+#define OCTEON_LED_UDD_CNTX(offset)     (0x8001180000001A20ull+((offset)*8))
+#define OCTEON_LED_PRT_FMT              (0x8001180000001A30ull)
+#define OCTEON_LED_UDD_DATX(offset)     (0x8001180000001A38ull+((offset)*8))
+#define OCTEON_LED_BLINK                (0x8001180000001A48ull)
+#define OCTEON_LED_POLARITY             (0x8001180000001A50ull)
+#define OCTEON_LED_PRT_STATUSX(offset)  (0x8001180000001A80ull+((offset)*8))
+#define OCTEON_LED_CYLON                (0x8001180000001AF8ull)
+#define OCTEON_LED_UDD_DAT_SETX(offset) (0x8001180000001AC0ull+((offset)*16))
+#define OCTEON_LED_UDD_DAT_CLRX(offset) (0x8001180000001AC8ull+((offset)*16))
+
+#define OCTEON_IOB_INT_SUM              (0x80011800F0000058ull)
+#define OCTEON_IOB_PKT_ERR              (0x80011800F0000068ull)
+#define OCTEON_IPD_INT_SUM              (0x80014F0000000168ull)
+#define OCTEON_ZIP_ERROR                (0x8001180038000088ull)
+#define OCTEON_PKO_REG_DEBUG0           (0x8001180050000098ull)
+#define OCTEON_TIM_REG_ERROR            (0x8001180058000088ull)
+#define OCTEON_FPA_INT_SUM              (0x8001180028000040ull)
+#define OCTEON_IOB_INT_ENB              (0x80011800F0000060ull)
+#define OCTEON_IPD_CLK_COUNT            (0x80014F0000000338ull)
+#define OCTEON_IPD_INT_ENB              (0x80014F0000000160ull)
+#define OCTEON_ZIP_INT_MASK             (0x8001180038000090ull)
+#define OCTEON_PKO_REG_INT_MASK         (0x8001180050000090ull)
+#define OCTEON_TIM_REG_INT_MASK         (0x8001180058000090ull)
+#define OCTEON_FPA_INT_ENB              (0x8001180028000048ull)
+
+static inline uint64_t octeon_ptr_to_phys(void *ptr)
+{
+	if (((uint64_t) ptr >> 62) == 3)
+		return (uint64_t) ptr & 0x3ffffffful;
+	else
+		return (uint64_t) ptr & 0xfffffffffful;
+}
+
+static inline void *octeon_phys_to_ptr(uint64_t physical_address)
+{
+	return (void *)(physical_address | (1ul << 63));
+}
+
+static inline void octeon_write_csr(uint64_t csr_addr, uint64_t val)
+{
+	*(volatile uint64_t *)csr_addr = val;
+}
+
+static inline uint64_t octeon_read_csr(uint64_t csr_addr)
+{
+	return *(volatile uint64_t *)csr_addr;
+}
+
+static inline uint64_t octeon_get_core_num(void)
+{
+	uint64_t core_num;
+      asm("rdhwr %0, $0":"=r"(core_num));
+	return core_num;
+}
+
+static inline void octeon_led_write(int bank, uint32_t data)
+{
+	octeon_write_csr(OCTEON_LED_UDD_DATX(bank), data);
+}
+
+static inline uint32_t octeon_led_read(int bank)
+{
+	return octeon_read_csr(OCTEON_LED_UDD_DATX(bank));
+}
+
+static inline void octeon_led_set(int bank, int bit)
+{
+	if (octeon_is_pass1()) {
+		extern spinlock_t octeon_led_lock;
+		spin_lock(&octeon_led_lock);
+		octeon_write_csr(OCTEON_LED_UDD_DATX(bank),
+				 octeon_read_csr(OCTEON_LED_UDD_DATX(bank)) | (1
+									       <<
+									       bit));
+		spin_unlock(&octeon_led_lock);
+	} else {
+		octeon_write_csr(OCTEON_LED_UDD_DAT_SETX(bank), 1 << bit);
+	}
+}
+
+static inline void octeon_led_clear(int bank, int bit)
+{
+	if (octeon_is_pass1()) {
+		extern spinlock_t octeon_led_lock;
+		spin_lock(&octeon_led_lock);
+		octeon_write_csr(OCTEON_LED_UDD_DATX(bank),
+				 octeon_read_csr(OCTEON_LED_UDD_DATX(bank)) &
+				 ~(1 << bit));
+		spin_unlock(&octeon_led_lock);
+	} else {
+		octeon_write_csr(OCTEON_LED_UDD_DAT_CLRX(bank), 1 << bit);
+	}
+}
+
+void octeon_write_lcd(const char *s);
+void octeon_check_cpu_bist(void);
+void octeon_led_init(void);
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h
@@ -0,0 +1,83 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Cavium Networks, Inc
+ */
+#ifndef __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+#define __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+
+
+#define CP0_CVMCTL_REG $9,7
+#define CP0_PRID_REG $15,0
+
+.macro  kernel_entry_setup
+    # Registers set by bootloader:
+    # (only 32 bits set by bootloader, all addresses are physical addresses, and need
+    #   to have the appropriate memory region set by the kernel
+    # a0 = argc
+    # a1 = argv (kseg0 compat addr )
+    # a2 = 1 if init core, zero otherwise
+    # a3 = address of boot descriptor block
+
+    dmfc0   v0, CP0_CVMCTL_REG          # Read the cavium control register
+#ifdef CONFIG_CAVIUM_OCTEON_HW_FIX_UNALIGNED
+    or  v0, v0, 0x5001                  # Disable unaligned load/store support but leave HW fixup enabled
+    xor v0, v0, 0x1001
+#else
+    or  v0, v0, 0x5001                  # Disable unaligned load/store and HW fixup support
+    xor v0, v0, 0x5001
+#endif
+    mfc0 v1, CP0_PRID_REG               # Read the processor ID register
+    and v1, 0xff                        # Mask off the revision, lower 8 bits
+    or  v0, v0, 0x2000                  # Disable instruction prefetching (Octeon Pass1 errata)
+    beq v1, $0, pass1                   # Skip reenable of prefetching for Octeon Pass1
+    nop
+    xor v0, v0, 0x2000                  # Reenable instruction prefetching, not on Pass1
+pass1:
+    dmtc0   v0, CP0_CVMCTL_REG          # Write the cavium control register
+    sync
+    cache   9, 0($0)                    # Flush dcache after config change
+
+    PTR_LA  t2, octeon_boot_desc_ptr    # Store the boot descriptor pointer
+    LONG_S  a3, (t2)
+
+#ifdef CONFIG_SMP
+    rdhwr   v0, $0                      # Get my core id
+
+    bne     a2, zero, octeon_main_processor # Jump the master to kernel_entry
+    nop
+    #
+    # All cores other than the master need to wait here for SMP bootstrap
+    # to begin
+    #
+    PTR_LA  t0, octeon_processor_boot   # This is the variable where the next core to boot os stored
+octeon_spin_wait_boot:
+    LONG_L  t1, (t0)                    # Get the core id of the next to be booted
+    bne t1, v0, octeon_spin_wait_boot   # Keep looping if it isn't me
+    nop
+    PTR_LA  t0, octeon_processor_gp     # Get my GP from the global variable
+    LONG_L  gp, (t0)
+    PTR_LA  t0, octeon_processor_sp     # Get my SP from the global variable
+    LONG_L  sp, (t0)
+    LONG_S  zero, (t0)                  # Set the SP global variable to zero so the master knows we've started
+#ifdef __OCTEON__
+    syncw
+#else
+    sync
+#endif
+    b   smp_bootstrap                   # Jump to the normal Linux SMP entry point
+    nop
+octeon_main_processor:
+#endif
+.endm
+
+/*
+ * Do SMP slave processor setup necessary before we can savely execute C code.
+ */
+    .macro  smp_slave_setup
+    .endm
+
+
+#endif /* __ASM_MACH_GENERIC_KERNEL_ENTRY_H */
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/octeon-app-init.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/octeon-app-init.h
@@ -0,0 +1,91 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Cavium Networks
+ */
+/**
+ * @file octeon-app-init.h
+ *
+ * Structures used to pass information from the bootloader to the application.
+ */
+
+#ifndef __OCTEON_APP_INIT_H__
+#define __OCTEON_APP_INIT_H__
+
+/* Macro indicates that bootmem related structures are now in
+** cvmx-bootmem.h */
+#define OCTEON_APP_INIT_BOOTMEM_STRUCTS_MOVED
+
+typedef enum
+{
+	BOOT_FLAG_INIT_CORE     = 1,  /*( If flag set, core should do app-wide init */
+				  /* only one core per app will have this flag set */
+    OCTEON_BL_FLAG_DEBUG    = 1 << 1,
+    OCTEON_BL_FLAG_NO_MAGIC = 1 << 2,
+} octeon_boot_descriptor_flag_t;
+
+#define OCTEON_CURRENT_DESC_VERSION     6
+#define OCTEON_ARGV_MAX_ARGS            (64)
+
+#define OCTOEN_SERIAL_LEN 20
+/** Bootloader structure used to pass info to Octeon executive startup code. */
+/* NOTE: all fields are deprecated except for:
+ * desc_version
+ * desc_size,
+ * heap_base
+ * heap_end
+ * exception_base_addr
+ * flags
+ * argc
+ * argv
+ * desc_size
+ * cvmx_desc_vaddr
+ * debugger_flags_base_addr
+ *
+ * All other fields have been moved to the cvmx_descriptor, and new fields should be added there.
+ * They are left as placeholders in this structure for binary compatibility.
+ */
+typedef struct
+{
+    /* Start of block referenced by assembly code - do not change! */
+    uint32_t desc_version;
+    uint32_t desc_size;
+
+    uint64_t stack_top;
+    uint64_t heap_base;
+    uint64_t heap_end;
+    uint64_t entry_point;   /* Only used by bootloader */
+    uint64_t desc_vaddr;
+    /* End of This block referenced by assembly code - do not change! */
+
+    uint32_t exception_base_addr;
+    uint32_t stack_size;
+    uint32_t heap_size;
+    uint32_t argc;  /* Argc count for application */
+    uint32_t argv[OCTEON_ARGV_MAX_ARGS];
+    uint32_t flags;
+    uint32_t core_mask;
+    uint32_t dram_size;  /**< DRAM size in megabyes */
+    uint32_t phy_mem_desc_addr;  /**< physical address of free memory descriptor block*/
+    uint32_t debugger_flags_base_addr;  /**< used to pass flags from app to debugger */
+    uint32_t eclock_hz;  /**< CPU clock speed, in hz */
+    uint32_t dclock_hz;  /**< DRAM clock speed, in hz */
+    uint32_t spi_clock_hz;  /**< SPI4 clock in hz */
+    uint16_t board_type;
+    uint8_t board_rev_major;
+    uint8_t board_rev_minor;
+    uint16_t chip_type;
+    uint8_t chip_rev_major;
+    uint8_t chip_rev_minor;
+    char board_serial_number[OCTOEN_SERIAL_LEN];
+    uint8_t mac_addr_base[6];
+    uint8_t mac_addr_count;
+    uint64_t cvmx_desc_vaddr;
+} octeon_boot_descriptor_t;
+
+/* Debug flags bit definitions */
+#define DEBUG_FLAG_CORE_DONE    0x1
+
+#endif /* __OCTEON_APP_INIT_H__ */
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/param.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/param.h
@@ -0,0 +1,17 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Cavium Networks
+ */
+#ifndef __ASM_MACH_CAVIUM_OCTEON_PARAM_OVERRIDES_H
+#define __ASM_MACH_CAVIUM_OCTEON_PARAM_OVERRIDES_H
+
+#ifdef CONFIG_CAVIUM_OCTEON_SIMULATOR
+#define HZ 100
+#else
+#define HZ 1000
+#endif
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-cavium-octeon/perf_counters.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-cavium-octeon/perf_counters.h
@@ -0,0 +1,23 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Cavium Networks
+ */
+
+/**
+ * The IOCTL numbers supported on /proc/octeon_perf
+ */
+#define PROC_PERF_IOCTL_SETUP_COUNTER0      _IOW(0x81, 0, int)
+#define PROC_PERF_IOCTL_SETUP_COUNTER1      _IOW(0x81, 1, int)
+#define PROC_PERF_IOCTL_SETUP_L2COUNTER0    _IOW(0x81, 2, int)
+#define PROC_PERF_IOCTL_SETUP_L2COUNTER1    _IOW(0x81, 3, int)
+#define PROC_PERF_IOCTL_SETUP_L2COUNTER2    _IOW(0x81, 4, int)
+#define PROC_PERF_IOCTL_SETUP_L2COUNTER3    _IOW(0x81, 5, int)
+#define PROC_PERF_IOCTL_READ_COUNTER0       _IOR(0x81, 6, long long)
+#define PROC_PERF_IOCTL_READ_COUNTER1       _IOR(0x81, 7, long long)
+#define PROC_PERF_IOCTL_READ_L2COUNTER0     _IOR(0x81, 8, long long)
+#define PROC_PERF_IOCTL_READ_L2COUNTER1     _IOR(0x81, 9, long long)
+#define PROC_PERF_IOCTL_READ_L2COUNTER2     _IOR(0x81, 10, long long)
+#define PROC_PERF_IOCTL_READ_L2COUNTER3     _IOR(0x81, 11, long long)
Index: linux-2.6.10/include/asm-mips/mipsregs.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/mipsregs.h
+++ linux-2.6.10/include/asm-mips/mipsregs.h
@@ -788,7 +788,16 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+/*
+ * The Cavium Octeon simulator validates that unused hardware bits are zero.
+ * The kernel by default allows the ASID to overflow the actual hardware
+ * space. Most mips hardware doesn't care, but the simulator does.
+ */
+#define write_c0_entryhi(val) __write_ulong_c0_register($10, 0, (unsigned long)((val) & 0xFFFFFFFFFFFFE0FFul))
+#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
+#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
@@ -923,6 +932,22 @@ do {									\
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
+/* MIPSR2 */
+#define read_c0_hwrena()	__read_32bit_c0_register($7,0)
+#define write_c0_hwrena(val)	__write_32bit_c0_register($7, 0, val)
+
+#define read_c0_intctl()	__read_32bit_c0_register($12, 1)
+#define write_c0_intctl(val)	__write_32bit_c0_register($12, 1, val)
+
+#define read_c0_srsctl()	__read_32bit_c0_register($12, 2)
+#define write_c0_srsctl(val)	__write_32bit_c0_register($12, 2, val)
+
+#define read_c0_srsmap()	__read_32bit_c0_register($12, 3)
+#define write_c0_srsmap(val)	__write_32bit_c0_register($12, 3, val)
+
+#define read_c0_ebase()	__read_32bit_c0_register($15,1)
+#define write_c0_ebase(val)	__write_32bit_c0_register($15, 1, val)
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
Index: linux-2.6.10/include/asm-mips/module.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/module.h
+++ linux-2.6.10/include/asm-mips/module.h
@@ -117,6 +117,8 @@ search_module_dbetables(unsigned long ad
 #define MODULE_PROC_FAMILY "RM9000"
 #elif defined CONFIG_CPU_SB1
 #define MODULE_PROC_FAMILY "SB1"
+#elif defined CONFIG_CPU_CAVIUM_OCTEON
+#define MODULE_PROC_FAMILY "CAVIUM_OCTEON"
 #else
 #error MODULE_PROC_FAMILY undefined for your processor configuration
 #endif
Index: linux-2.6.10/include/asm-mips/pgtable-bits.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/pgtable-bits.h
+++ linux-2.6.10/include/asm-mips/pgtable-bits.h
@@ -136,6 +136,11 @@
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CACHABLE_NONCOHERENT
 #elif defined(CONFIG_CPU_RM9000)
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CWB
+#elif defined(CONFIG_CPU_CAVIUM_OCTEON)
+/* Use cache mode 7 on Octeon. This cache region is marked special and can be
+    write flushed seperately from other memory addresses. This allows us to
+    flush hardware writes without flushing user writes */
+#define PAGE_CACHABLE_DEFAULT	_CACHE_UNCACHED_ACCELERATED
 #else
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CACHABLE_COW
 #endif
Index: linux-2.6.10/include/asm-mips/processor.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/processor.h
+++ linux-2.6.10/include/asm-mips/processor.h
@@ -61,7 +61,11 @@ extern unsigned int vced_count, vcei_cou
  * support 16TB; the architectural reserve for future expansion is
  * 8192EB ...
  */
+#ifdef CONFIG_CAVIUM_RESERVE32
+#define TASK_SIZE32	(0x7fff8000UL - (CONFIG_CAVIUM_RESERVE32<<20))
+#else
 #define TASK_SIZE32	0x7fff8000UL
+#endif
 #define TASK_SIZE	0x10000000000UL
 
 /*
@@ -107,6 +111,45 @@ union mips_fpu_union {
 	{{0,},} \
 }
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+
+struct octeon_cop2_state {
+	unsigned long cop2_crc_iv;	/* DMFC2 rt, 0x0201 */
+	unsigned long cop2_crc_length;	/* DMFC2 rt, 0x0202 (Set with DMTC2 rt, 0x1202) */
+	unsigned long cop2_crc_poly;	/* DMFC2 rt, 0x0200 (set with DMTC2 rt, 0x4200) */
+
+	unsigned long cop2_llm_dat[2];	/* DMFC2 rt, 0x0402; DMFC2 rt, 0x040A */
+
+	unsigned long cop2_3des_iv;	/* DMFC2 rt, 0x0084 */
+	unsigned long cop2_3des_key[3];	/* DMFC2 rt, 0x0080; DMFC2 rt, 0x0081; DMFC2 rt, 0x0082 */
+	unsigned long cop2_3des_result;	/* DMFC2 rt, 0x0088 (Set with DMTC2 rt, 0x0098) */
+	unsigned long cop2_aes_inp0;	/* DMFC2 rt, 0x0111 (FIXME: Read Pass1 Errata) */
+	unsigned long cop2_aes_iv[2];	/* DMFC2 rt, 0x0102; DMFC2 rt, 0x0103 */
+	unsigned long cop2_aes_key[4];	/* DMFC2 rt, 0x0104; DMFC2 rt, 0x0105; DMFC2 rt, 0x0106; DMFC2 rt, 0x0107 */
+	unsigned long cop2_aes_keylen;	/* DMFC2 rt, 0x0110 */
+	unsigned long cop2_aes_result[2];	/* DMFC2 rt, 0x0100; DMFC2 rt, 0x0101 */
+
+	unsigned long cop2_hsh_datw[15];	/* DMFC2 rt, 0x0240; DMFC2 rt, 0x0241; DMFC2 rt, 0x0242; DMFC2 rt, 0x0243;
+						   DMFC2 rt, 0x0244; DMFC2 rt, 0x0245; DMFC2 rt, 0x0246; DMFC2 rt, 0x0247;
+						   DMFC2 rt, 0x0248; DMFC2 rt, 0x0249; DMFC2 rt, 0x024A; DMFC2 rt, 0x024B;
+						   DMFC2 rt, 0x024C; DMFC2 rt, 0x024D; DMFC2 rt, 0x024E - Pass2 */
+	unsigned long cop2_hsh_ivw[8];	/* DMFC2 rt, 0x0250; DMFC2 rt, 0x0251; DMFC2 rt, 0x0252; DMFC2 rt, 0x0253;
+					   DMFC2 rt, 0x0254; DMFC2 rt, 0x0255; DMFC2 rt, 0x0256; DMFC2 rt, 0x0257 - Pass2 */
+	unsigned long cop2_gfm_mult[2];	/* DMFC2 rt, 0x0258; DMFC2 rt, 0x0259 - Pass2 */
+	unsigned long cop2_gfm_poly;	/* DMFC2 rt, 0x025E - Pass2 */
+	unsigned long cop2_gfm_result[2];	/* DMFC2 rt, 0x025A; DMFC2 rt, 0x025B - Pass2 */
+};
+#define INIT_OCTEON_COP2 {0,}
+
+struct octeon_cvmseg_state {
+	unsigned long
+	 cvmseg[CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE][cpu_dcache_line_size() /
+						  sizeof(unsigned long)];
+};
+#define INIT_OCTEON_CVMSEG {{{0,},}}
+
+#endif
+
 typedef struct {
 	unsigned long seg;
 } mm_segment_t;
@@ -140,6 +183,10 @@ struct thread_struct {
 	unsigned long mflags;
 	unsigned long irix_trampoline;  /* Wheee... */
 	unsigned long irix_oldctx;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	struct octeon_cop2_state cp2 __attribute__ ((__aligned__(128)));
+	struct octeon_cvmseg_state cvmseg __attribute__ ((__aligned__(128)));
+#endif
 };
 
 #define MF_ABI_MASK	(MF_32BIT_REGS | MF_32BIT_ADDR)
Index: linux-2.6.10/include/asm-mips/ptrace.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/ptrace.h
+++ linux-2.6.10/include/asm-mips/ptrace.h
@@ -43,6 +43,10 @@ struct pt_regs {
 	unsigned long cp0_badvaddr;
 	unsigned long cp0_cause;
 	unsigned long cp0_epc;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	unsigned long mpl[3];	/* MTM{0,1,2} */
+	unsigned long mtp[3];	/* MTP{0,1,2} */
+#endif
 };
 
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
Index: linux-2.6.10/include/asm-mips/smp.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/smp.h
+++ linux-2.6.10/include/asm-mips/smp.h
@@ -47,6 +47,7 @@ extern struct call_data_struct *call_dat
 #define SMP_RESCHEDULE_YOURSELF	0x1	/* XXX braindead */
 #define SMP_CALL_FUNCTION	0x2
 #define SMP_LOCAL_TIMER		0x4	/* SMP Timer */
+#define SMP_ICACHE_FLUSH	0x8	/* Octeon - Tell another core to flush its icache */
 
 extern cpumask_t phys_cpu_present_map;
 extern cpumask_t cpu_online_map;
Index: linux-2.6.10/include/asm-mips/spinlock.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/spinlock.h
+++ linux-2.6.10/include/asm-mips/spinlock.h
@@ -55,6 +55,23 @@ static inline void __raw_spin_lock(raw_s
 		: "m" (lock->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_spin_lock	\n"
+		"	 syncw				# Flush the write buffer while we're waiting\n"
+		"1:	ll	%1, %2					\n"
+		"	bnez	%1, 1b					\n"
+		"	li	%1, 1					\n"
+		"	sc	%1, %0			# This will go out after the syncw completes\n"
+		"	beqz	%1, 1b					\n"
+		"	 nop # No syncw is needed here since the sc goes out immediately\n"
+		"	.set	reorder					\n"
+		: "=m" (lock->lock), "=&r" (tmp)
+		: "m" (lock->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_spin_lock	\n"
 		"1:	ll	%1, %2					\n"
@@ -67,6 +84,7 @@ static inline void __raw_spin_lock(raw_s
 		: "=m" (lock->lock), "=&r" (tmp)
 		: "m" (lock->lock)
 		: "memory");
+#endif
 	}
 }
 
@@ -74,8 +92,18 @@ static inline void __raw_spin_unlock(raw
 {
 	__asm__ __volatile__(
 	"	.set	noreorder	# _raw_spin_unlock	\n"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+	"	syncw   # Make sure the unlock doesn't merge with other writes\n"
+#else
 	"	sync						\n"
+#endif
 	"	sw	$0, %0					\n"
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+    /* This is an optimization to make sure the unlock doesn't sit in the write buffer */
+	"	syncw   # Force the unlock write out\n"
+#endif
 	"	.set\treorder					\n"
 	: "=m" (lock->lock)
 	: "m" (lock->lock)
@@ -101,6 +129,23 @@ static inline unsigned int __raw_spin_tr
 		: "m" (lock->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_spin_trylock	\n"
+		"	syncw				# Flush the write buffer while we're waiting\n"
+		"1:	ll	%0, %3					\n"
+		"	ori	%2, %0, 1				\n"
+		"	sc	%2, %1			# This will go out after the syncw completes\n"
+		"	beqz	%2, 1b					\n"
+		"	 andi	%2, %0, 1				\n"
+		"	# No syncw is needed here since the sc goes out immediately\n"
+		"	.set	reorder"
+		: "=&r" (temp), "=m" (lock->lock), "=&r" (res)
+		: "m" (lock->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_spin_trylock	\n"
 		"1:	ll	%0, %3					\n"
@@ -113,6 +158,7 @@ static inline unsigned int __raw_spin_tr
 		: "=&r" (temp), "=m" (lock->lock), "=&r" (res)
 		: "m" (lock->lock)
 		: "memory");
+#endif
 	}
 
 	return res == 0;
@@ -146,6 +192,23 @@ static inline void __raw_read_lock(rwloc
 		: "m" (rw->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_read_lock	\n"
+		"	syncw				# Flush the write buffer while we're waiting\n"
+		"1:	ll	%1, %2					\n"
+		"	bltz	%1, 1b					\n"
+		"	 addu	%1, 1					\n"
+		"	sc	%1, %0			# This will go out after the syncw completes\n"
+		"	beqz	%1, 1b					\n"
+		"	 nop # No syncw is needed here since the sc goes out immediately\n"
+		"	.set	reorder					\n"
+		: "=m" (rw->lock), "=&r" (tmp)
+		: "m" (rw->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_read_lock	\n"
 		"1:	ll	%1, %2					\n"
@@ -158,6 +221,7 @@ static inline void __raw_read_lock(rwloc
 		: "=m" (rw->lock), "=&r" (tmp)
 		: "m" (rw->lock)
 		: "memory");
+#endif
 	}
 }
 
@@ -179,6 +243,22 @@ static inline void __raw_read_unlock(raw
 		: "m" (rw->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_read_unlock	\n"
+		"	syncw				# Flush the write buffer while we're waiting\n"
+		"1:	ll	%1, %2					\n"
+		"	sub	%1, 1					\n"
+		"	sc	%1, %0			# This will go out after the syncw completes\n"
+		"	beqz	%1, 1b					\n"
+		"	 nop # No syncw is needed here since the sc goes out immediately\n"
+		"	.set	reorder					\n"
+		: "=m" (rw->lock), "=&r" (tmp)
+		: "m" (rw->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_read_unlock	\n"
 		"1:	ll	%1, %2					\n"
@@ -190,6 +270,7 @@ static inline void __raw_read_unlock(raw
 		: "=m" (rw->lock), "=&r" (tmp)
 		: "m" (rw->lock)
 		: "memory");
+#endif
 	}
 }
 
@@ -212,6 +293,23 @@ static inline void __raw_write_lock(raw_
 		: "m" (rw->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_write_lock	\n"
+		"	syncw				# Flush the write buffer while we're waiting\n"
+		"1:	ll	%1, %2					\n"
+		"	bnez	%1, 1b					\n"
+		"	 lui	%1, 0x8000				\n"
+		"	sc	%1, %0			# This will go out after the syncw completes\n"
+		"	beqz	%1, 1b					\n"
+		"	 nop # No syncw is needed here since the sc goes out immediately\n"
+		"	.set	reorder					\n"
+		: "=m" (rw->lock), "=&r" (tmp)
+		: "m" (rw->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_write_lock	\n"
 		"1:	ll	%1, %2					\n"
@@ -225,17 +323,30 @@ static inline void __raw_write_lock(raw_
 		: "=m" (rw->lock), "=&r" (tmp)
 		: "m" (rw->lock)
 		: "memory");
+#endif
 	}
 }
 
 static inline void __raw_write_unlock(raw_rwlock_t *rw)
 {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+	__asm__ __volatile__(
+	"	syncw			# _raw_write_unlock	\n"
+	"	sw	$0, %0					\n"
+	"	syncw           # Make sure the unlock goes out\n"
+	: "=m" (rw->lock)
+	: "m" (rw->lock)
+	: "memory");
+#else
 	__asm__ __volatile__(
 	"	sync			# _raw_write_unlock	\n"
 	"	sw	$0, %0					\n"
 	: "=m" (rw->lock)
 	: "m" (rw->lock)
 	: "memory");
+#endif
 }
 
 #define __raw_read_trylock(lock) generic_raw_read_trylock(lock)
@@ -263,6 +374,26 @@ static inline int __raw_write_trylock(ra
 		: "m" (rw->lock)
 		: "memory");
 	} else {
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(__OCTEON__)
+        /* When using the Octeon compiler, use syncw instead of sync since
+            it is faster */
+		__asm__ __volatile__(
+		"	.set	noreorder	# _raw_write_trylock	\n"
+		"	syncw				# Flush the write buffer while we're waiting\n"
+		"	li	%2, 0					\n"
+		"1:	ll	%1, %3					\n"
+		"	bnez	%1, 2f					\n"
+		"	lui	%1, 0x8000				\n"
+		"	sc	%1, %0			# This will go out after the syncw completes\n"
+		"	beqz	%1, 1b					\n"
+		"	 nop # No syncw is needed here since the sc goes out immediately\n"
+		"	li	%2, 1					\n"
+		"	.set	reorder					\n"
+		"2:							\n"
+		: "=m" (rw->lock), "=&r" (tmp), "=&r" (ret)
+		: "m" (rw->lock)
+		: "memory");
+#else
 		__asm__ __volatile__(
 		"	.set	noreorder	# _raw_write_trylock	\n"
 		"	li	%2, 0					\n"
@@ -278,6 +409,7 @@ static inline int __raw_write_trylock(ra
 		: "=m" (rw->lock), "=&r" (tmp), "=&r" (ret)
 		: "m" (rw->lock)
 		: "memory");
+#endif
 	}
 
 	return ret;
Index: linux-2.6.10/include/asm-mips/stackframe.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/stackframe.h
+++ linux-2.6.10/include/asm-mips/stackframe.h
@@ -153,6 +153,13 @@
 		LONG_S	$31, PT_R31(sp)
 		ori	$28, sp, _THREAD_MASK
 		xori	$28, _THREAD_MASK
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	/* The Octeon multiplier state is affected by general multiply
+	   instructions. It must be saved before and kernel code might
+	   corrupt it */
+		jal     octeon_mult_save
+		LONG_L  ra, PT_R31(sp)      /* Restore $31(ra) that was changed by the jal */
+#endif
 		.set	pop
 		.endm
 
@@ -249,6 +256,10 @@
 		.set	push
 		.set	reorder
 		.set	noat
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	/* Restore the Octeon multiplier state */
+		jal octeon_mult_restore
+#endif
 		mfc0	a0, CP0_STATUS
 		ori	a0, 0x1f
 		xori	a0, 0x1f
Index: linux-2.6.10/include/asm-mips/system.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/system.h
+++ linux-2.6.10/include/asm-mips/system.h
@@ -90,6 +90,18 @@
 #define __sync()	do { } while(0)
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+
+#define __octeon_write_barrier() __asm__ __volatile__("syncw" ::: "memory")
+#define __octeon_read_barrier()  __asm__ __volatile__("" ::: "memory")
+
+#define fast_wmb()	__octeon_write_barrier()
+#define fast_rmb()	__octeon_read_barrier()
+#define fast_mb()	__octeon_write_barrier()
+#define fast_iob()	__octeon_write_barrier()
+
+#else				/* CONFIG_CPU_CAVIUM_OCTEON */
+
 #define __fast_iob()				\
 	__asm__ __volatile__(			\
 		".set	push\n\t"		\
@@ -110,6 +122,8 @@
 		__fast_iob();			\
 	} while (0)
 
+#endif				/* CONFIG_CPU_CAVIUM_OCTEON */
+
 #ifdef CONFIG_CPU_HAS_WB
 
 #include <asm/wbflush.h>
@@ -186,12 +200,17 @@ static inline unsigned long __xchg_u32(v
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	ll	%0, %3			# xchg_u32	\n"
 		"	move	%2, %z4					\n"
 		"	sc	%2, %1					\n"
 		"	beqz	%2, 1b					\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
+#else
+		"	nop 						\n"
 #endif
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
@@ -217,13 +236,18 @@ static inline __u64 __xchg_u64(volatile 
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	lld	%0, %3			# xchg_u64	\n"
 		"	move	%2, %z4					\n"
 		"	scd	%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
 		ROT_IN_PIECES
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
+#else
+		"	nop						\n"
 #endif
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
@@ -304,13 +328,18 @@ static inline unsigned long __cmpxchg_u3
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
 		"	.set	noat					\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	ll	%0, %2			# __cmpxchg_u32	\n"
 		"	bne	%0, %z3, 2f				\n"
 		"	move	$1, %z4					\n"
 		"	sc	$1, %2					\n"
 		"	beqz	$1, 1b					\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
+#else
+		"	nop						\n"
 #endif
 		"2:							\n"
 		"	.set	at					\n"
@@ -356,13 +385,18 @@ static inline unsigned long __cmpxchg_u6
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
 		"	.set	noat					\n"
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		"	syncw						\n"
+#endif
 		"1:	lld	%0, %2			# __cmpxchg_u64	\n"
 		"	bne	%0, %z3, 2f				\n"
 		"	move	$1, %z4					\n"
 		"	scd	$1, %1					\n"
 		"	beqz	$1, 1b					\n"
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_CPU_CAVIUM_OCTEON)
 		"	sync						\n"
+#else
+		"	nop						\n"
 #endif
 		"2:							\n"
 		"	.set	at					\n"
Index: linux-2.6.10/include/asm-mips/timex.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/timex.h
+++ linux-2.6.10/include/asm-mips/timex.h
@@ -44,12 +44,24 @@
  * We know that all SMP capable CPUs have cycle counters.
  */
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+/* Since the Octeon supports a 64 bit cycle counter we might as well use it */
+typedef unsigned long cycles_t;
+#else
 typedef unsigned int cycles_t;
+#endif
+
 extern cycles_t cacheflush_time;
 
 static inline cycles_t get_cycles (void)
 {
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	cycles_t result;
+	asm volatile ("rdhwr %0,$31":"=r" (result));
+	return result;
+#else
 	return read_c0_count();
+#endif
 }
 
 #endif /*  _ASM_TIMEX_H */
Index: linux-2.6.10/mvl_patches/pro-1049.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1049.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1049);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

