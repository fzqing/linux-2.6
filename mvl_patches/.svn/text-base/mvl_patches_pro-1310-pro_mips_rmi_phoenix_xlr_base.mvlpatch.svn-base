#! /usr/bin/env bash
# Patch: -pro_mips_rmi_phoenix_xlr_base
# Date: Thu May  3 22:18:38 2007
# Source: RMI Electronics
# MR: 21903
# Type: Integration
# Disposition: MontaVista
# Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
# Description:
# 
# This patch adds support for RMI Phoenix processor and base
# board suppport for the RMI XLR
# 
#  arch/mips/Kconfig                                 |   30 
#  arch/mips/Makefile                                |    9 
#  arch/mips/configs/xlr-atx_defconfig               | 1440 ++++++++++++++
#  arch/mips/kernel/Makefile                         |    1 
#  arch/mips/kernel/cpu-probe.c                      |   24 
#  arch/mips/kernel/proc.c                           |    1 
#  arch/mips/lib-32/Makefile                         |    2 
#  arch/mips/lib-32/xlr_csum_nocopy.S                |  207 ++
#  arch/mips/lib-32/xlr_csum_partial.S               |  242 ++
#  arch/mips/lib-64/Makefile                         |    1 
#  arch/mips/lib-64/xlr_csum_nocopy.S                |  214 ++
#  arch/mips/lib-64/xlr_csum_partial.S               |  242 ++
#  arch/mips/lib/csum_partial_copy.c                 |   24 
#  arch/mips/mm/Makefile                             |    2 
#  arch/mips/mm/c-phoenix.c                          |  390 +++
#  arch/mips/mm/cache.c                              |   21 
#  arch/mips/mm/cerr-phoenix.c                       |   38 
#  arch/mips/mm/cex-gen.S                            |    6 
#  arch/mips/mm/pg-phoenix.c                         |  143 +
#  arch/mips/mm/tlbex.c                              |    1 
#  arch/mips/pci/Makefile                            |    1 
#  arch/mips/pci/pci-phoenix.c                       |  593 +++++
#  arch/mips/rmi/Kconfig                             |   72 
#  arch/mips/rmi/phoenix/Makefile                    |    7 
#  arch/mips/rmi/phoenix/dma.c                       |  328 +++
#  arch/mips/rmi/phoenix/irq.c                       |  383 +++
#  arch/mips/rmi/phoenix/irq_handler.S               |   94 
#  arch/mips/rmi/phoenix/msgring.c                   |  283 ++
#  arch/mips/rmi/phoenix/on_chip.c                   |  588 +++++
#  arch/mips/rmi/phoenix/smp.c                       |  108 +
#  arch/mips/rmi/phoenix/time.c                      |  183 +
#  arch/mips/rmi/ptr/Makefile                        |    7 
#  arch/mips/rmi/ptr/setup.c                         |  486 ++++
#  arch/mips/rmi/ptr/smp.c                           |  226 ++
#  arch/mips/rmi/ptr/smpboot.S                       |   46 
#  include/asm-mips/addrspace.h                      |    2 
#  include/asm-mips/bootinfo.h                       |    9 
#  include/asm-mips/cacheflush.h                     |    8 
#  include/asm-mips/checksum.h                       |    8 
#  include/asm-mips/cpu-features.h                   |    3 
#  include/asm-mips/cpu.h                            |    8 
#  include/asm-mips/hazards.h                        |   24 
#  include/asm-mips/mach-rmi/cpu-feature-overrides.h |    6 
#  include/asm-mips/mach-rmi/param.h                 |    6 
#  include/asm-mips/module.h                         |    2 
#  include/asm-mips/page.h                           |   16 
#  include/asm-mips/pgtable-bits.h                   |    6 
#  include/asm-mips/rmi/64bit.h                      |   73 
#  include/asm-mips/rmi/debug.h                      |   90 
#  include/asm-mips/rmi/devices.h                    |   10 
#  include/asm-mips/rmi/interrupt.h                  |   38 
#  include/asm-mips/rmi/iomap.h                      |  103 +
#  include/asm-mips/rmi/mips-exts.h                  |  315 +++
#  include/asm-mips/rmi/msgring.h                    |  528 +++++
#  include/asm-mips/rmi/pci.h                        |    8 
#  include/asm-mips/rmi/perf_ctr.h                   |   42 
#  include/asm-mips/rmi/phnx_mmap.h                  |   13 
#  include/asm-mips/rmi/phnx_tb.h                    |   68 
#  include/asm-mips/rmi/phnx_user_mac.h              |   50 
#  include/asm-mips/rmi/phoenix_ide.h                |   51 
#  include/asm-mips/rmi/phoenix_mac.h                | 1395 +++++++++++++
#  include/asm-mips/rmi/phxdesc.h                    | 2225 ++++++++++++++++++++++
#  include/asm-mips/rmi/phxdrv.h                     |  688 ++++++
#  include/asm-mips/rmi/phxsec.h                     |  643 ++++++
#  include/asm-mips/rmi/pic.h                        |  200 +
#  include/asm-mips/rmi/rmios_user_mac.h             |   34 
#  include/asm-mips/rmi/rmisec.h                     |   36 
#  include/asm-mips/rmi/sim.h                        |  249 ++
#  include/asm-mips/serial.h                         |   19 
#  include/asm-mips/smp.h                            |    4 
#  include/linux/i2c-algo-palm.h                     |   39 
#  include/linux/i2c-id.h                            |    3 
#  include/linux/phnx_tb.h                           |  143 +
#  include/linux/phnx_user_mac.h                     |  200 +
#  74 files changed, 13798 insertions(+), 10 deletions(-)
# 

PATCHNUM=1310
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: RMI Electronics
MR: 21903
Type: Integration
Disposition: MontaVista
Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
Description:

This patch adds support for RMI Phoenix processor and base
board suppport for the RMI XLR

 arch/mips/Kconfig                                 |   30 
 arch/mips/Makefile                                |    9 
 arch/mips/configs/xlr-atx_defconfig               | 1440 ++++++++++++++
 arch/mips/kernel/Makefile                         |    1 
 arch/mips/kernel/cpu-probe.c                      |   24 
 arch/mips/kernel/proc.c                           |    1 
 arch/mips/lib-32/Makefile                         |    2 
 arch/mips/lib-32/xlr_csum_nocopy.S                |  207 ++
 arch/mips/lib-32/xlr_csum_partial.S               |  242 ++
 arch/mips/lib-64/Makefile                         |    1 
 arch/mips/lib-64/xlr_csum_nocopy.S                |  214 ++
 arch/mips/lib-64/xlr_csum_partial.S               |  242 ++
 arch/mips/lib/csum_partial_copy.c                 |   24 
 arch/mips/mm/Makefile                             |    2 
 arch/mips/mm/c-phoenix.c                          |  390 +++
 arch/mips/mm/cache.c                              |   21 
 arch/mips/mm/cerr-phoenix.c                       |   38 
 arch/mips/mm/cex-gen.S                            |    6 
 arch/mips/mm/pg-phoenix.c                         |  143 +
 arch/mips/mm/tlbex.c                              |    1 
 arch/mips/pci/Makefile                            |    1 
 arch/mips/pci/pci-phoenix.c                       |  593 +++++
 arch/mips/rmi/Kconfig                             |   72 
 arch/mips/rmi/phoenix/Makefile                    |    7 
 arch/mips/rmi/phoenix/dma.c                       |  328 +++
 arch/mips/rmi/phoenix/irq.c                       |  383 +++
 arch/mips/rmi/phoenix/irq_handler.S               |   94 
 arch/mips/rmi/phoenix/msgring.c                   |  283 ++
 arch/mips/rmi/phoenix/on_chip.c                   |  588 +++++
 arch/mips/rmi/phoenix/smp.c                       |  108 +
 arch/mips/rmi/phoenix/time.c                      |  183 +
 arch/mips/rmi/ptr/Makefile                        |    7 
 arch/mips/rmi/ptr/setup.c                         |  486 ++++
 arch/mips/rmi/ptr/smp.c                           |  226 ++
 arch/mips/rmi/ptr/smpboot.S                       |   46 
 include/asm-mips/addrspace.h                      |    2 
 include/asm-mips/bootinfo.h                       |    9 
 include/asm-mips/cacheflush.h                     |    8 
 include/asm-mips/checksum.h                       |    8 
 include/asm-mips/cpu-features.h                   |    3 
 include/asm-mips/cpu.h                            |    8 
 include/asm-mips/hazards.h                        |   24 
 include/asm-mips/mach-rmi/cpu-feature-overrides.h |    6 
 include/asm-mips/mach-rmi/param.h                 |    6 
 include/asm-mips/module.h                         |    2 
 include/asm-mips/page.h                           |   16 
 include/asm-mips/pgtable-bits.h                   |    6 
 include/asm-mips/rmi/64bit.h                      |   73 
 include/asm-mips/rmi/debug.h                      |   90 
 include/asm-mips/rmi/devices.h                    |   10 
 include/asm-mips/rmi/interrupt.h                  |   38 
 include/asm-mips/rmi/iomap.h                      |  103 +
 include/asm-mips/rmi/mips-exts.h                  |  315 +++
 include/asm-mips/rmi/msgring.h                    |  528 +++++
 include/asm-mips/rmi/pci.h                        |    8 
 include/asm-mips/rmi/perf_ctr.h                   |   42 
 include/asm-mips/rmi/phnx_mmap.h                  |   13 
 include/asm-mips/rmi/phnx_tb.h                    |   68 
 include/asm-mips/rmi/phnx_user_mac.h              |   50 
 include/asm-mips/rmi/phoenix_ide.h                |   51 
 include/asm-mips/rmi/phoenix_mac.h                | 1395 +++++++++++++
 include/asm-mips/rmi/phxdesc.h                    | 2225 ++++++++++++++++++++++
 include/asm-mips/rmi/phxdrv.h                     |  688 ++++++
 include/asm-mips/rmi/phxsec.h                     |  643 ++++++
 include/asm-mips/rmi/pic.h                        |  200 +
 include/asm-mips/rmi/rmios_user_mac.h             |   34 
 include/asm-mips/rmi/rmisec.h                     |   36 
 include/asm-mips/rmi/sim.h                        |  249 ++
 include/asm-mips/serial.h                         |   19 
 include/asm-mips/smp.h                            |    4 
 include/linux/i2c-algo-palm.h                     |   39 
 include/linux/i2c-id.h                            |    3 
 include/linux/phnx_tb.h                           |  143 +
 include/linux/phnx_user_mac.h                     |  200 +
 mvl_patches/pro-1310.c                            |   16 
 75 files changed, 13814 insertions(+), 10 deletions(-)

Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -520,6 +520,25 @@ config MARKEINS
 	  Features : kernel debugging, serial terminal, NFS root fs, on-board
 	  ether port USB, PCI, etc.
 
+config RMI_PHOENIX
+	bool "Support for Raza Microelectronics Inc PHOENIX Processor (EXPERIMENTAL"
+	depends on EXPERIMENTAL
+	select DMA_COHERENT
+	select BOOT_ELF32
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	help
+	This RMI Phoenix board is based on XLR732 processor. Say Y here to
+	support this machine type.
+
+if RMI_PHOENIX
+  source "arch/mips/rmi/Kconfig"
+endif
+
 config SGI_IP22
 	bool "Support for SGI IP22 (Indy/Indigo2)"
 	select ARC
@@ -1399,6 +1418,13 @@ config CPU_RM9000
 	bool "RM9000"
 	select CPU_HAS_PREFETCH
 
+config CPU_PHOENIX
+	bool "PHOENIX"
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_HIGHMEM
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+
 config CPU_SB1
 	bool "SB1"
 
@@ -1508,7 +1534,7 @@ config SB1_PASS_2_1_WORKAROUNDS
 
 config 64BIT_PHYS_ADDR
 	bool "Support for 64-bit physical address space"
-	depends on (CPU_R4X00 || CPU_R5000 || CPU_RM7000 || CPU_RM9000 || CPU_R10000 || CPU_SB1 || CPU_MIPS32 || CPU_MIPS64) && MIPS32
+	depends on (CPU_R4X00 || CPU_R5000 || CPU_RM7000 || CPU_RM9000 || CPU_R10000 || CPU_SB1 || CPU_MIPS32 || CPU_MIPS64 || CPU_PHOENIX) && MIPS32
 
 config CPU_ADVANCED
 	bool "Override CPU Options"
@@ -1570,7 +1596,7 @@ config HIGHMEM
 
 config SMP
 	bool "Multi-Processing support"
-	depends on (CPU_RM9000 || (SIBYTE_SB1250 && !SIBYTE_STANDALONE) || SGI_IP27 || CPU_CAVIUM_OCTEON) && CPU_HAS_LLSC
+	depends on (CPU_RM9000 || (SIBYTE_SB1250 && !SIBYTE_STANDALONE) || SGI_IP27 || CPU_CAVIUM_OCTEON || RMI_PHOENIX) && CPU_HAS_LLSC
 	---help---
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -735,6 +735,15 @@ core-$(CONFIG_TOSHIBA_RBTX4939) += arch/
 cflags-$(CONFIG_TOSHIBA_RBTX4939) += -Iinclude/asm-mips/tx4939
 load-$(CONFIG_TOSHIBA_RBTX4939) += 0xffffffff80100000
 
+# RMI PHOENIX SOC
+core-$(CONFIG_RMI_PHOENIX)      += arch/mips/rmi/phoenix/
+core-$(CONFIG_PHOENIX_USER_MAC) += arch/mips/rmi/rmios/
+cflags-$(CONFIG_RMI_PHOENIX)    += -Iinclude/asm-mips/mach-rmi/
+
+# RMI PTR board
+core-$(CONFIG_RMI_PTR)          += arch/mips/rmi/ptr/
+load-$(CONFIG_RMI_PTR)          += 0xffffffff81000000
+
 #
 # Cavium Octeon
 #
Index: linux-2.6.10/arch/mips/kernel/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/Makefile
+++ linux-2.6.10/arch/mips/kernel/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_CPU_SB1)		+= r4k_fpu.o r4k_
 obj-$(CONFIG_CPU_MIPS32)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_MIPS64)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R6000)		+= r6000_fpu.o r4k_switch.o
+obj-$(CONFIG_CPU_PHOENIX)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= octeon_switch.o
 
 obj-$(CONFIG_SMP)		+= smp.o
Index: linux-2.6.10/arch/mips/kernel/cpu-probe.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/cpu-probe.c
+++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
@@ -111,6 +111,7 @@ static inline void check_wait(void)
 	case CPU_24K:
 	case CPU_25KF:
 	case CPU_PR4450:
+	case CPU_PHOENIX:
 	case CPU_CAVIUM_OCTEON:
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
@@ -140,6 +141,26 @@ void __init check_bugs32(void)
 	check_wait();
 }
 
+static __inline__ void cpu_probe_rmi(struct cpuinfo_mips *c)
+{
+	decode_configs(c);
+	c->options &= ~MIPS_CPU_4K_CACHE;
+	switch (c->processor_id & 0xff00) {
+		default:
+		c->cputype = CPU_PHOENIX;
+		c->isa_level = MIPS_CPU_ISA_M64;
+		c->options = (MIPS_CPU_TLB		|
+				MIPS_CPU_4KEX		|
+				MIPS_CPU_COUNTER	|
+				MIPS_CPU_DIVEC		|
+				MIPS_CPU_WATCH		|
+				MIPS_CPU_EJTAG		|
+				MIPS_CPU_XLR_CACHE	|
+				MIPS_CPU_LLSC);
+		break;
+	}
+}	
+
 /*
  * Probe whether cpu has config register by trying to play with
  * alternate cache bit and see whether it matters.
@@ -633,6 +654,9 @@ __init void cpu_probe(void)
 	case PRID_COMP_PHILIPS:
 		cpu_probe_philips(c);
 		break;
+	case PRID_COMP_RMI:
+		cpu_probe_rmi(c);
+		break;
 	case PRID_COMP_CAVIUM:
 		cpu_probe_cavium(c);
 		break;
Index: linux-2.6.10/arch/mips/kernel/proc.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/proc.c
+++ linux-2.6.10/arch/mips/kernel/proc.c
@@ -78,6 +78,7 @@ static const char *cpu_name[] = {
 	[CPU_VR4181A]	"NEC VR4181A",
 	[CPU_SR71000]	"Sandcraft SR71000",
 	[CPU_PR4450]	"Philips PR4450",
+ 	[CPU_PHOENIX]	"RMI XLR"
 	[CPU_CAVIUM_OCTEON] = "Cavium Networks Octeon"
 };
 
Index: linux-2.6.10/arch/mips/lib-32/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/lib-32/Makefile
+++ linux-2.6.10/arch/mips/lib-32/Makefile
@@ -3,6 +3,7 @@
 #
 
 lib-y	+= csum_partial.o memset.o watch.o 
+lib-$(CONFIG_PHOENIX_FAST_CSUM)	+= xlr_csum_partial.o xlr_csum_nocopy.o
 
 obj-$(CONFIG_CPU_MIPS32)	+= dump_tlb.o
 obj-$(CONFIG_CPU_MIPS64)	+= dump_tlb.o
@@ -19,6 +20,7 @@ obj-$(CONFIG_CPU_R8000)		+=
 obj-$(CONFIG_CPU_RM7000)	+= dump_tlb.o
 obj-$(CONFIG_CPU_RM9000)	+= dump_tlb.o
 obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
+obj-$(CONFIG_CPU_PHOENIX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
 obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
Index: linux-2.6.10/arch/mips/lib-32/xlr_csum_nocopy.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/lib-32/xlr_csum_nocopy.S
@@ -0,0 +1,207 @@
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+
+/*
+ * a0: source address
+ * a1: length of the area to checksum
+ * a2: partial checksum
+ * a3: dst
+ */
+
+#define src a0
+#define dst a3
+#define sum v0
+
+	.text
+	.set	noreorder
+
+	.macro	CSUM_BIGCHUNK_AND_COPY offset
+	pref		0, (\offset+0x0)(a0)
+	ld		t0, (\offset+0x00)(a0)
+	ld		t1, (\offset+0x08)(a0)
+	.word		0x70481038  /*daddwc v0, v0, t0 */
+	.word		0x70491038 /*daddwc v0, v0, t1 */
+	ld		t0, (\offset + 0x10)(a0)
+	ld		t1, (\offset + 0x18)(a0)
+	.word		0x70481038 /* daddwc v0, v0, t0 */
+	.word		0x70491038 /*daddwc v0, v0, t1 */
+	.endm
+
+small_csumcpy: /* unknown src alignment and < 8 bytes to go  */
+
+	move		a1, t2
+	andi		t0, a1, 4
+	beqz		t0, 1f
+	andi		t0, a1, 2
+
+	ulw		t1, (src) /* Still a full word to go  */
+	daddiu		src, 4
+	.word		0x70491038 /*daddwc v0, v0, t1 */
+
+1:	move		t1, zero
+	beqz		t0, 1f
+	andi		t0, a1, 1
+
+	ulhu		t1, (src) /* Still a halfword to go  */
+
+	daddiu		src, 2
+
+1:
+	beqz		t0, 1f
+	sll		t1, t1, 16
+
+	lbu		t2, (src)
+	nop
+
+#ifdef __MIPSEB__
+	sll		t2, t2, 8
+#endif
+	or		t1, t2
+	
+1:	.word		0x70491038 /*daddwc v0, v0, t1 */
+	
+	.word		0x70461038 /*daddwc v0, v0, a2 */
+	.word		0x70401038 /*daddwc v0, v0, $0 */
+
+	/* Ideally at this point of time the status flag must be cleared */
+
+	dsll32		v1, sum, 0
+	.word		0x70431038 /*daddwc v0, v0, v1 */
+	dsrl32		sum, sum, 0
+	.word		0x70401038 /*daddwc v0, v0, zero */
+
+	/* fold the checksum */
+	sll		v1, sum, 16
+	addu		sum, v1
+	sltu		v1, sum, v1
+	srl		sum, sum, 16
+	addu		sum, v1
+
+1:
+	.set		reorder
+	jr		ra
+	.set		noreorder
+
+/* ------------------------------------------------------------------ */
+
+	.align	5
+LEAF(xlr_csum_partial_nocopy)
+	move		sum, zero
+	move		t7, zero
+	sltiu		t8, a1, 0x8
+	bnez		t8, small_csumcpy	/* < 8 bytes to copy */
+	move		t2, a1
+	beqz		a1, out
+	andi		t7, src, 0x1		/* odd buffer? */
+
+hword_align:
+	beqz		t7, word_align
+	andi		t8, src, 0x2
+	lbu		t0, (src)
+	dsubu		a1, a1, 0x1
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x1
+	andi		t8, src, 0x2
+
+word_align:
+	beqz		t8, dword_align
+	sltiu		t8, a1, 56
+	lhu		t0, (src)
+	dsubu		a1, a1, 0x2
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	sltiu		t8, a1, 56
+	daddu		src, src, 0x2
+
+dword_align:
+	bnez		t8, do_end_words
+	move		t8, a1
+	andi		t8, src, 0x4
+	beqz		t8, qword_align
+	andi		t8, src, 0x8
+	lw		t0, 0x00(src)
+	dsubu		a1, a1, 0x4
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x4
+	andi		t8, src, 0x8
+
+qword_align:
+	beqz		t8, oword_align
+	andi		t8, src, 0x10
+	ld		t0, 0x00(src)
+	dsubu		a1, a1, 0x8
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x8
+	andi		t8, src, 0x10
+
+oword_align:
+	beqz		t8, begin_movement
+	dsrl		t8, a1, 0x7
+	ld		t3, 0x08(src)
+	ld		t0, 0x00(src)
+	.word		0x704b1038 /*daddwc v0, v0, t3 */
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	dsubu		a1, a1, 0x10
+	daddu		src, src, 0x10
+	dsrl		t8, a1, 0x7
+
+begin_movement:
+	beqz		t8, 1f
+	andi		t2, a1, 0x40
+
+move_128bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	CSUM_BIGCHUNK_AND_COPY(0x40)
+	CSUM_BIGCHUNK_AND_COPY(0x60)
+	dsubu		t8, t8, 0x01
+	bnez		t8, move_128bytes       /* flag */
+	daddu		src, src, 0x80
+
+1:
+	beqz		t2, 1f
+	andi		t2, a1, 0x20
+
+move_64bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	daddu		src, src, 0x40
+
+1:
+	beqz		t2, do_end_words
+	andi		t8, a1, 0x1c
+
+move_32bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	andi		t8, a1, 0x1c
+	daddu		src, src, 0x20
+
+do_end_words:
+	beqz		t8, maybe_end_cruft
+	dsrl		t8, t8, 0x2
+
+end_words:
+	lw		t0, (src)
+	dsubu		t8, t8, 0x1
+	.word		0x70481038 /*daddwc v0, v0, t0 */
+	bnez		t8, end_words
+	daddu		src, src, 0x4
+
+maybe_end_cruft:
+	andi		t2, a1, 0x3
+
+small_memcpy:
+ j small_csumcpy; move a1, t2
+	beqz		t2, out
+	move		a1, t2
+
+end_bytes:
+	lb		t0, (src)
+	dsubu		a1, a1, 0x1
+	bnez		a2, end_bytes
+	daddu		src, src, 0x1
+
+out:
+	jr		ra
+	move		v0, sum
+	END(xlr_csum_partial_nocopy)
Index: linux-2.6.10/arch/mips/lib-64/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/lib-64/Makefile
+++ linux-2.6.10/arch/mips/lib-64/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_CPU_R8000)		+=
 obj-$(CONFIG_CPU_RM7000)	+= dump_tlb.o
 obj-$(CONFIG_CPU_RM9000)	+= dump_tlb.o
 obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
+obj-$(CONFIG_CPU_PHOENIX)	dump_tlb.o
 obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
 obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
Index: linux-2.6.10/arch/mips/lib/csum_partial_copy.c
===================================================================
--- linux-2.6.10.orig/arch/mips/lib/csum_partial_copy.c
+++ linux-2.6.10/arch/mips/lib/csum_partial_copy.c
@@ -16,6 +16,7 @@
 /*
  * copy while checksumming, otherwise like csum_partial
  */
+#ifndef CONFIG_PHOENIX_FAST_CSUM
 unsigned int csum_partial_copy_nocheck(const char *src, char *dst,
 	int len, unsigned int sum)
 {
@@ -28,7 +29,17 @@ unsigned int csum_partial_copy_nocheck(c
 
 	return sum;
 }
-
+#else
+unsigned int csum_partial_copy_nocheck(const unsigned char *src,
+	unsigned char *dst, int len, unsigned int sum)
+{
+	local_irq_disable();
+	sum = xlr_csum_partial(src, len, sum, dst);
+	local_irq_enable();
+	return sum;
+}
+#endif
+	
 /*
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
@@ -37,7 +48,9 @@ unsigned int csum_partial_copy_from_user
 	int len, unsigned int sum, int *err_ptr)
 {
 	int missing;
-
+#ifdef CONFIG_PHOENIX_FAST_CSUM
+	unsigned int csum;
+#endif
 	might_sleep();
 	missing = copy_from_user(dst, src, len);
 	if (missing) {
@@ -45,5 +58,12 @@ unsigned int csum_partial_copy_from_user
 		*err_ptr = -EFAULT;
 	}
 
+#ifdef CONFIG_PHOENIX_FAST_CSUM
+	local_irq_disable();
+	csum = xlr_csum_partial_nocopy(dst, len, sum);
+	local_irq_enable();
+	return csum;
+#else
 	return csum_partial(dst, len, sum);
+#endif
 }
Index: linux-2.6.10/arch/mips/mm/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/Makefile
+++ linux-2.6.10/arch/mips/mm/Makefile
@@ -22,6 +22,8 @@ obj-$(CONFIG_CPU_R5500)		+= c-r4k.o cex-
 obj-$(CONFIG_CPU_R8000)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r8k.o
 obj-$(CONFIG_CPU_RM7000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_RM9000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
+obj-$(CONFIG_CPU_PHOENIX)	+= pg-phoenix.o c-phoenix.o tlb-r4k.o \
+				   cex-gen.o cerr-phoenix.o
 obj-$(CONFIG_CPU_SB1)		+= c-sb1.o cerr-sb1.o cex-sb1.o pg-sb1.o \
 				   tlb-sb1.o
 obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-r4k.o tlb-r3k.o
Index: linux-2.6.10/arch/mips/mm/cache.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/cache.c
+++ linux-2.6.10/arch/mips/mm/cache.c
@@ -88,6 +88,20 @@ void __update_cache(struct vm_area_struc
 	struct page *page;
 	unsigned long pfn, addr;
 
+#ifdef CONFIG_RMI_PHOENIX
+	/* 
+	 * Data cache on Phoenix is coherent. Only I-cache needs to be taken
+	 * care
+	 */
+	if (!(vma->vm_flags & VM_EXEC)) return;
+	page = pte_page(pte);
+	if (TestPageDcacheDirty(page)) return;
+	pfn = pte_pfn(pte);
+	if(pfn_valid(pfn)) {
+		phoenix_flush_icache_range_paddr(pfn << PAGE_SHIFT);
+		SetPageDcacheDirty(page);
+	}
+#else
 	pfn = pte_pfn(pte);
 	if (pfn_valid(pfn) && (page = pfn_to_page(pfn), page_mapping(page)) &&
 	    Page_dcache_dirty(page)) {
@@ -99,6 +113,7 @@ void __update_cache(struct vm_area_struc
 
 		ClearPageDcacheDirty(page);
 	}
+#endif
 }
 
 extern void ld_mmu_r23000(void);
@@ -153,7 +168,11 @@ void __init cpu_cache_init(void)
 			ld_mmu_octeon();
 			break;
 #endif
-
+#ifdef CONFIG_RMI_PHOENIX
+	extern void __weak xlr_cache_init(void);
+	xlr_cache_init();
+	break;
+#endif
 	case CPU_R8000:
 		panic("R8000 is unsupported");
 		break;
Index: linux-2.6.10/arch/mips/mm/cex-gen.S
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/cex-gen.S
+++ linux-2.6.10/arch/mips/mm/cex-gen.S
@@ -37,6 +37,12 @@
 	nop
 	nop
 
+#ifdef CONFIG_RMI_PHOENIX
+	la	k0, phoenix_cache_error
+	jalr	k0
+	nop
+#else
 	j	cache_parity_error
 	nop
+#endif
 	END(except_vec2_generic)
Index: linux-2.6.10/arch/mips/mm/tlbex.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/tlbex.c
+++ linux-2.6.10/arch/mips/mm/tlbex.c
@@ -921,6 +921,7 @@ static __init void build_tlb_write_entry
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
+	case CPU_PHOENIX:
 	case CPU_CAVIUM_OCTEON:
 		tlbw(p);
 		break;
Index: linux-2.6.10/arch/mips/pci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/pci/Makefile
+++ linux-2.6.10/arch/mips/pci/Makefile
@@ -48,6 +48,7 @@ obj-$(CONFIG_SGI_IP27)		+= pci-ip27.o
 obj-$(CONFIG_SGI_IP32)		+= fixup-ip32.o ops-mace.o pci-ip32.o
 obj-$(CONFIG_SIBYTE_SB1250)	+= fixup-sb1250.o pci-sb1250.o
 obj-$(CONFIG_SNI_RM200_PCI)	+= fixup-sni.o ops-sni.o
+obj-$(CONFIG_RMI_PHOENIX)	+= pci-phoenix.o
 obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
 obj-$(CONFIG_TOSHIBA_JMR3927)	+= fixup-jmr3927.o pci-jmr3927.o
Index: linux-2.6.10/include/asm-mips/addrspace.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/addrspace.h
+++ linux-2.6.10/include/asm-mips/addrspace.h
@@ -138,7 +138,7 @@
 #define TO_PHYS_MASK		0x0000000fffffffff	/* 2^^36 - 1 */
 #endif
 
-#if defined (CONFIG_CPU_R8000)
+#if defined (CONFIG_CPU_R8000) || defined (CONFIG_CPU_PHOENIX)
 /* We keep KUSIZE consistent with R4000 for now (2^^40) instead of (2^^48) */
 #define	KUSIZE			0x0000010000000000	/* 2^^40 */
 #define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -237,7 +237,16 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+/*
+ * Valid machtype for group RMI
+ */
+#define MACH_GROUP_RMI		23
+#define MACH_PTR		0
+#ifdef CONFIG_RMI_PHOENIX
+#define CL_SIZE			2048
+#else
 #define CL_SIZE			COMMAND_LINE_SIZE
+#endif
 
 const char *get_system_type(void);
 
Index: linux-2.6.10/include/asm-mips/cacheflush.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cacheflush.h
+++ linux-2.6.10/include/asm-mips/cacheflush.h
@@ -39,9 +39,13 @@ extern void __flush_dcache_page(struct p
 
 static inline void flush_dcache_page(struct page *page)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	extern void phoenix_flush_dcache_page(struct page *page);
+	phoenix_flush_dcache_page(page);
+#else
 	if (cpu_has_dc_aliases)
 		__flush_dcache_page(page);
-
+#endif
 }
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
@@ -88,5 +92,7 @@ extern void (*flush_data_cache_page)(uns
 	set_bit(PG_dcache_dirty, &(page)->flags)
 #define ClearPageDcacheDirty(page)	\
 	clear_bit(PG_dcache_dirty, &(page)->flags)
+#define TestPageDcacheDirty(page)	\
+	test_bit(PG_dcache_dirty, &(page)->flags)
 
 #endif /* _ASM_CACHEFLUSH_H */
Index: linux-2.6.10/include/asm-mips/checksum.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/checksum.h
+++ linux-2.6.10/include/asm-mips/checksum.h
@@ -30,6 +30,14 @@
  */
 unsigned int csum_partial(const unsigned char *buff, int len, unsigned int sum);
 
+#ifdef CONFIG_PHOENIX_FAST_CSUM
+/* For fast checksum computations */
+unsigned int xlr_csum_partial(const unsigned char *src, int len,
+				unsigned int sum, unsigned char *dst);
+unsigned int xlr_csum_partial_nocopy(const unsigned char *src, int len,
+				unsigned int sum);
+#endif
+
 /*
  * this is a new version of the above that records errors it finds in *errp,
  * but continues and zeros the rest of the buffer.
Index: linux-2.6.10/include/asm-mips/cpu-features.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cpu-features.h
+++ linux-2.6.10/include/asm-mips/cpu-features.h
@@ -75,6 +75,9 @@
 #ifndef cpu_has_ic_fills_f_dc
 #define cpu_has_ic_fills_f_dc	(cpu_data[0].icache.flags & MIPS_CACHE_IC_F_DC)
 #endif
+#ifndef cpu_has_xlr_cache
+#define cpu_has_xlr_cache	(cpu_data[0].options & MIPS_CPU_XLR_CACHE)
+#endif
 
 /*
  * I-Cache snoops remote store.  This only matters on SMP.  Some multiprocessors
Index: linux-2.6.10/include/asm-mips/cpu.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cpu.h
+++ linux-2.6.10/include/asm-mips/cpu.h
@@ -29,6 +29,7 @@
 #define PRID_COMP_SIBYTE       0x040000
 #define PRID_COMP_SANDCRAFT    0x050000
 #define PRID_COMP_PHILIPS      0x060000
+#define PRID_COMP_RMI          0x0c0000		
 #define PRID_COMP_CAVIUM       0x0d0000
 
 /*
@@ -189,7 +190,11 @@
 #define CPU_AU1200		59
 #define CPU_PR4450		60
 #define CPU_CAVIUM_OCTEON	61
-#define CPU_LAST		61
+/* Save for CPU_BCM4710 */
+/* Save for CPU_BCM5365 */
+/* Save for CPU_BCM3302 */
+#define CPU_PHOENIX		65
+#define CPU_LAST		65
 
 /*
  * ISA Level encodings
@@ -230,5 +235,6 @@
 #define MIPS_CPU_LLSC		0x00010000 /* CPU has ll/sc instructions */
 #define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
 #define MIPS_CPU_PREFETCH	0x00040000 /* CPU has usable prefetch */
+#define MIPS_CPU_XLR_CACHE	0x00400000 /* XLR-style caches */
 
 #endif /* _ASM_CPU_H */
Index: linux-2.6.10/include/asm-mips/hazards.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/hazards.h
+++ linux-2.6.10/include/asm-mips/hazards.h
@@ -169,7 +169,6 @@ __asm__(
 #define irq_disable_hazard()						\
 	__asm__ __volatile__(						\
 	"_ehb\t\t\t\t# irq_disable_hazard")
-
 #elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000) || defined(CONFIG_CPU_CAVIUM_OCTEON)
 
 /*
@@ -212,6 +211,29 @@ __asm__(
 
 #endif
 
+#if defined(CONFIG_RMI_PHOENIX)
+#define cacheop_hazard()	\
+	__asm__ __volatile__ (						\
+			".set push				\n"	\
+			".set noreorder				\n"	\
+			"nop;nop;nop;nop			\n"	\
+			"nop;nop;nop;nop			\n"	\
+			".set pop				\n"	\
+			);
+
+#define sync_istream()		\
+	__asm__ __volatile__ (						\
+			".set push				\n"	\
+			".set noreorder				\n"	\
+			"nop					\n"	\
+			"nop					\n"	\
+			"nop					\n"	\
+			"nop;nop;nop;nop			\n"	\
+			"nop;nop;nop;nop			\n"	\
+			".set pop				\n"	\
+			);
+#endif
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_HAZARDS_H */
Index: linux-2.6.10/include/asm-mips/mach-rmi/cpu-feature-overrides.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-rmi/cpu-feature-overrides.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_MACH_RMI_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_RMI_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_llsc	1
+
+#endif /* __ASM_MACH_RMI_CPU_FEATURE_OVERRIDES_H */
Index: linux-2.6.10/include/asm-mips/mach-rmi/param.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-rmi/param.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_MACH_RMI_PARAM_H
+#define __ASM_MACH_RMI_PARAM_H
+
+#define HZ	100	/* Internal kernel timer frequency */
+
+#endif /* __ASM_MACH_RMI_PARAM_H */
Index: linux-2.6.10/include/asm-mips/module.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/module.h
+++ linux-2.6.10/include/asm-mips/module.h
@@ -117,6 +117,8 @@ search_module_dbetables(unsigned long ad
 #define MODULE_PROC_FAMILY "RM9000"
 #elif defined CONFIG_CPU_SB1
 #define MODULE_PROC_FAMILY "SB1"
+#elif defined CONFIG_CPU_PHOENIX
+#define MODULE_PROC_FAMILY "XLR"
 #elif defined CONFIG_CPU_CAVIUM_OCTEON
 #define MODULE_PROC_FAMILY "CAVIUM_OCTEON"
 #else
Index: linux-2.6.10/include/asm-mips/page.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/page.h
+++ linux-2.6.10/include/asm-mips/page.h
@@ -55,21 +55,37 @@ struct page;
 static inline void clear_user_page(void *addr, unsigned long vaddr,
 	struct page *page)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	extern void phoenix_flush_dcache_page(struct page *page);
+#else
 	extern void (*flush_data_cache_page)(unsigned long addr);
+#endif
 
 	clear_page(addr);
+#ifdef CONFIG_RMI_PHOENIX
+	phoenix_flush_dcache_page(page);
+#else
 	if (pages_do_alias((unsigned long) addr, vaddr))
 		flush_data_cache_page((unsigned long)addr);
+#endif
 }
 
 static inline void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
 	struct page *to)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	extern void phoenix_flush_dcache_page(struct page *page);
+#else
 	extern void (*flush_data_cache_page)(unsigned long addr);
+#endif
 
 	copy_page(vto, vfrom);
+#ifdef CONFIG_RMI_PHOENIX
+	phoenix_flush_dcache_page(to);
+#else
 	if (pages_do_alias((unsigned long)vto, vaddr))
 		flush_data_cache_page((unsigned long)vto);
+#endif
 }
 
 /*
Index: linux-2.6.10/include/asm-mips/pgtable-bits.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/pgtable-bits.h
+++ linux-2.6.10/include/asm-mips/pgtable-bits.h
@@ -110,6 +110,12 @@
 #define _CACHE_UNCACHED			_CACHE_UC_B
 #define _CACHE_CACHABLE_NONCOHERENT	_CACHE_WB
 
+#elif defined(CONFIG_CPU_PHOENIX)
+
+#define _CACHE_UNCACHED			(2<<9)
+#define _CACHE_CACHABLE_COW		(3<<9)
+#define _CACHE_CACHABLE_NONCOHERENT	(3<<9)
+
 #else
 
 #define _CACHE_CACHABLE_NO_WA       (0<<9)  /* R4600 only              */
Index: linux-2.6.10/include/asm-mips/serial.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/serial.h
+++ linux-2.6.10/include/asm-mips/serial.h
@@ -438,6 +438,22 @@
 #define IP32_SERIAL_PORT_DEFNS
 #endif /* CONFIG_SGI_IP32 */
 
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/pic.h>
+#define RMI_PHOENIX_BASE_BAUD	(66000000 / 16)
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS							\
+	{ .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_0_IRQ,			\
+	  .flags = STD_COM_FLAGS,							\
+	  .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_0_OFFSET),	\
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},				\
+	{ .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_1_IRQ,			\
+	  .flags = STD_COM_FLAGS,							\
+	  .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_1_OFFSET),	\
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},
+#else
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS
+#endif /* CONFIG_RMI_PHOENIX */
+
 #ifdef CONFIG_MIPS_AVALANCHE_SOC
 #include <asm/mach-avalanche/pal.h>
 #ifdef CONFIG_KGDB
@@ -483,6 +499,7 @@
 	TXX927_SERIAL_PORT_DEFNS                        \
 	AU1000_SERIAL_PORT_DEFNS                        \
 	VR5701_SG2_SERIAL_PORT_DEFNS			\
-	AVALANCHE_SERIAL_PORT_DEFNS
+	AVALANCHE_SERIAL_PORT_DEFNS			\
+ 	RMI_PHOENIX_SERIAL_PORT_DEFNS
 
 #endif /* _ASM_SERIAL_H */
Index: linux-2.6.10/include/asm-mips/smp.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/smp.h
+++ linux-2.6.10/include/asm-mips/smp.h
@@ -51,7 +51,11 @@ extern struct call_data_struct *call_dat
 
 extern cpumask_t phys_cpu_present_map;
 extern cpumask_t cpu_online_map;
+#ifdef CONFIG_RMI_PHOENIX
+#define cpu_possible_map	cpu_present_map
+#else
 #define cpu_possible_map	phys_cpu_present_map
+#endif
 
 extern cpumask_t cpu_callout_map;
 /* We don't mark CPUs online until __cpu_up(), so we need another measure */
Index: linux-2.6.10/arch/mips/configs/xlr-atx_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/configs/xlr-atx_defconfig
@@ -0,0 +1,1440 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc2
+# Tue Mar 14 22:47:13 2006
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+# CONFIG_CPUSETS is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+# CONFIG_EPOLL is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+CONFIG_RMI_PHOENIX=y
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_PHOENIX_PSB=y
+CONFIG_RMI_PTR=y
+CONFIG_PHOENIX_SMP_PREFIX=y
+CONFIG_PHOENIX_MAC=y
+# CONFIG_PHOENIX_SPI4 is not set
+CONFIG_PHOENIX_TRACEBUFFER=y
+CONFIG_PHOENIX_EARLY_PRINTK=y
+CONFIG_PHOENIX_FAST_CSUM=y
+CONFIG_PHOENIX_RAW_PERF_COUNTERS=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SWAP_IO_SPACE=y
+CONFIG_BOOT_ELF32=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+CONFIG_CPU_PHOENIX=y
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_SYS_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SMP=y
+CONFIG_NR_CPUS=32
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_MISC=m
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=16
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS application helper
+#
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+# CONFIG_NETFILTER_NETLINK is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CONNTRACK_EVENTS is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+# CONFIG_IP_NF_PPTP is not set
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+# CONFIG_IP_NF_MATCH_IPRANGE is not set
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+# CONFIG_IP_NF_MATCH_PHYSDEV is not set
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_REALM is not set
+# CONFIG_IP_NF_MATCH_SCTP is not set
+# CONFIG_IP_NF_MATCH_DCCP is not set
+# CONFIG_IP_NF_MATCH_COMMENT is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+# CONFIG_IP_NF_MATCH_STRING is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_SAME is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+# CONFIG_IP_NF_TARGET_CLASSIFY is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+# CONFIG_IP6_NF_MATCH_PHYSDEV is not set
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_RAW is not set
+
+#
+# DECnet: Netfilter Configuration
+#
+# CONFIG_DECNET_NF_GRABULATOR is not set
+
+#
+# Bridge: Netfilter Configuration
+#
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+CONFIG_ATM=y
+CONFIG_ATM_CLIP=y
+# CONFIG_ATM_CLIP_NO_ICMP is not set
+CONFIG_ATM_LANE=m
+CONFIG_ATM_MPOA=m
+CONFIG_ATM_BR2684=m
+CONFIG_ATM_BR2684_IPFILTER=y
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
+CONFIG_DECNET=m
+CONFIG_DECNET_ROUTER=y
+CONFIG_DECNET_ROUTE_FWMARK=y
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=y
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+CONFIG_NET_DIVERT=y
+# CONFIG_ECONET is not set
+CONFIG_WAN_ROUTER=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_ATM is not set
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+# CONFIG_NET_SCH_NETEM is not set
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_NET_CLS_IND is not set
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+# CONFIG_PARPORT_SERIAL is not set
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_GSC is not set
+CONFIG_PARPORT_1284=y
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_IDEDMA_ONLYDISK=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+CONFIG_BLK_DEV_PDC202XX_NEW=y
+# CONFIG_PDC202XX_FORCE is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_BLK_DEV_IDE_PHOENIX=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+CONFIG_SCSI_SATA=m
+# CONFIG_SCSI_SATA_AHCI is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_MV is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_QSTOR is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_PPA=m
+CONFIG_SCSI_IMM=m
+# CONFIG_SCSI_IZIP_EPP16 is not set
+# CONFIG_SCSI_IZIP_SLOW_CTR is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=m
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+CONFIG_SCSI_DEBUG=m
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_EQUALIZER=m
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+CONFIG_NATSEMI=y
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+CONFIG_STRIP=m
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+#
+# CONFIG_PRISM54 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Wan interfaces
+#
+CONFIG_WAN=y
+# CONFIG_DSCC4 is not set
+# CONFIG_LANMEDIA is not set
+# CONFIG_SYNCLINK_SYNCPPP is not set
+# CONFIG_HDLC is not set
+CONFIG_DLCI=m
+CONFIG_DLCI_COUNT=24
+CONFIG_DLCI_MAX=8
+CONFIG_WAN_ROUTER_DRIVERS=y
+# CONFIG_CYCLADES_SYNC is not set
+
+#
+# ATM drivers
+#
+CONFIG_ATM_TCP=m
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_FORE200E_MAYBE is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PLIP=m
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+CONFIG_PPPOATM=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
+# CONFIG_NET_FC is not set
+CONFIG_SHAPER=m
+CONFIG_NETCONSOLE=m
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_RX is not set
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+
+#
+# ISDN subsystem
+#
+CONFIG_ISDN=m
+
+#
+# Old ISDN4Linux
+#
+# CONFIG_ISDN_I4L is not set
+
+#
+# CAPI subsystem
+#
+CONFIG_ISDN_CAPI=m
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON=y
+CONFIG_ISDN_CAPI_MIDDLEWARE=y
+CONFIG_ISDN_CAPI_CAPI20=m
+CONFIG_ISDN_CAPI_CAPIFS_BOOL=y
+CONFIG_ISDN_CAPI_CAPIFS=m
+
+#
+# CAPI hardware drivers
+#
+
+#
+# Active AVM cards
+#
+# CONFIG_CAPI_AVM is not set
+
+#
+# Active Eicon DIVA Server cards
+#
+# CONFIG_CAPI_EICON is not set
+
+#
+# Telephony Support
+#
+CONFIG_PHONE=m
+CONFIG_PHONE_IXJ=m
+
+#
+# Input device support
+#
+CONFIG_INPUT=m
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=m
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=m
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=m
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=m
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_PRINTER=m
+CONFIG_LP_CONSOLE=y
+CONFIG_PPDEV=m
+CONFIG_TIPAR=m
+
+#
+# IPMI
+#
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+# CONFIG_IPMI_SI is not set
+CONFIG_IPMI_WATCHDOG=m
+# CONFIG_IPMI_POWEROFF is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+CONFIG_DTLK=m
+CONFIG_R3964=m
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCF=m
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGOPALM is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_BK3220 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+CONFIG_I2C_PARPORT=m
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+CONFIG_SENSORS_EEPROM=m
+CONFIG_SENSORS_PCF8574=m
+# CONFIG_SENSORS_PCA9539 is not set
+CONFIG_SENSORS_PCF8591=m
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=m
+
+#
+# Video For Linux
+#
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_BT848 is not set
+CONFIG_VIDEO_BWQCAM=m
+CONFIG_VIDEO_CQCAM=m
+CONFIG_VIDEO_W9966=m
+CONFIG_VIDEO_CPIA=m
+CONFIG_VIDEO_CPIA_PP=m
+# CONFIG_VIDEO_SAA5246A is not set
+CONFIG_VIDEO_SAA5249=m
+CONFIG_TUNER_3036=m
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_DPC is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+CONFIG_RADIO_MAESTRO=m
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+CONFIG_REISERFS_PROC_INFO=y
+# CONFIG_REISERFS_FS_XATTR is not set
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+# CONFIG_JFS_SECURITY is not set
+CONFIG_JFS_DEBUG=y
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+CONFIG_MINIX_FS=m
+CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=m
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_HFS_FS=m
+# CONFIG_HFSPLUS_FS is not set
+CONFIG_BEFS_FS=m
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=m
+CONFIG_VXFS_FS=m
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_SYSV_FS=m
+CONFIG_UFS_FS=m
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+CONFIG_NCP_FS=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_NCPFS_OS2_NS=y
+CONFIG_NCPFS_SMALLDOS=y
+CONFIG_NCPFS_NLS=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_CODA_FS=m
+# CONFIG_CODA_FS_OLD_API is not set
+CONFIG_AFS_FS=m
+CONFIG_RXRPC=m
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_TEST=m
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
Index: linux-2.6.10/arch/mips/lib-32/xlr_csum_partial.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/lib-32/xlr_csum_partial.S
@@ -0,0 +1,242 @@
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+
+
+
+/*
+ * a0: source address
+ * a1: length of the area to checksum
+ * a2: partial checksum
+ * a3: dst
+ */
+
+#define src a0
+#define dst a3
+#define sum v0
+
+	.text
+	.set	noreorder
+
+	.macro CSUM_BIGCHUNK_AND_COPY offset 
+	pref                    1,  (\offset+0x0)(a3)
+	pref                    0,  (\offset+0x0)(a0)
+	ld			t0, (\offset+0x00)(a0)
+	ld			t1, (\offset+0x08)(a0)
+	usd			t0, (\offset+0x00)(a3)
+	usd			t1, (\offset+0x08)(a3)
+	.word			0x70481038  /*daddwc v0, v0, t0 */
+	.word			0x70491038 /*daddwc v0, v0, t1 */
+	ld			t0, (\offset + 0x10)(a0)		
+	ld			t1, (\offset + 0x18)(a0)	
+	usd			t0, (\offset + 0x10)(a3)
+	usd			t1, (\offset + 0x18)(a3)
+	.word			0x70481038 /* daddwc v0, v0, t0 */
+	.word			0x70491038 /*daddwc v0, v0, t1 */
+	.endm
+
+small_csumcpy: 						/* unknown src alignment and < 8 bytes to go  */
+	move 		a1, t2
+
+	andi		t0, a1, 4
+	beqz		t0, 1f
+	andi		t0, a1, 2
+
+	ulw			t1, (src) 			/* Still a full word to go  */
+	usw			t1, (dst)
+	daddiu		src, 4
+	daddiu		dst, 4
+	.word			0x70491038 /*daddwc v0, v0, t1 */
+
+1:	move		t1, zero
+	beqz		t0, 1f
+	andi		t0, a1, 1
+
+	ulhu		t1, (src) 			/* Still a halfword to go  */
+	ush     	t1, (dst)
+	daddiu		src, 2
+	daddiu		dst, 2
+
+1:	beqz		t0, 1f
+	sll			t1, t1, 16
+
+	lbu			t2, (src)
+	sb			t2, (dst)
+	nop
+
+#ifdef __MIPSEB__
+	sll		t2, t2, 8
+#endif
+	or		t1, t2
+
+1: 	.word			0x70491038 /*daddwc v0, v0, t1 */
+
+	.word			0x70461038 /*daddwc v0, v0, a2 */
+	.word			0x70401038 /*daddwc v0, v0, $0 */
+
+	/* Ideally at this point of time the status flag must be cleared */
+					
+	dsll32      v1, sum, 0
+	.word			0x70431038 /*daddwc v0, v0, v1 */
+	dsrl32		sum, sum, 0
+	.word			0x70401038 /*daddwc v0, v0, zero */
+
+	/* fold the checksum */
+	sll             v1, sum, 16
+	addu            sum, v1
+	sltu            v1, sum, v1
+	srl             sum, sum, 16
+	addu            sum, v1
+1:
+	.set		reorder
+	jr			ra
+	.set		noreorder
+
+/* ------------------------------------------------------------------ */
+
+	.align	5
+LEAF(xlr_csum_partial)
+	move		sum, zero
+	move		t7, zero
+
+	sltiu		t8, a1, 0x8
+	bnez		t8, small_csumcpy		/* < 8 bytes to copy */
+	move		t2, a1
+
+	beqz		a1, out
+	andi		t7, src, 0x1			/* odd buffer? */
+
+hword_align:
+	beqz		t7, word_align
+	andi		t8, src, 0x2
+
+	lbu			t0, (src)
+	sb			t0, (dst)
+	dsubu		a1, a1, 0x1
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x1
+	daddu		dst, dst, 0x1
+	andi		t8, src, 0x2
+
+word_align:
+	beqz		t8, dword_align
+	sltiu		t8, a1, 56
+
+	lhu			t0, (src)
+	ush			t0, (dst)
+	dsubu		a1, a1, 0x2
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	sltiu		t8, a1, 56
+	daddu		src, src, 0x2
+	daddu		dst, dst, 0x2
+
+dword_align:
+	bnez		t8, do_end_words
+	move		t8, a1
+
+	andi		t8, src, 0x4
+	beqz		t8, qword_align
+	andi		t8, src, 0x8
+
+	lw			t0, 0x00(src)
+	usw			t0, 0x00(dst)
+	dsubu		a1, a1, 0x4
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x4
+	daddu		dst, dst, 0x4
+	andi		t8, src, 0x8
+
+qword_align:
+	beqz		t8, oword_align
+	andi		t8, src, 0x10
+
+	ld			t0, 0x00(src)
+	usd  		t0, 0x00(dst)
+	dsubu		a1, a1, 0x8
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x8
+	daddu		dst, dst, 0x8
+	andi		t8, src, 0x10
+
+oword_align:
+	beqz		t8, begin_movement
+	dsrl		t8, a1, 0x7
+
+	ld			t3, 0x08(src)
+	usd  		t3, 0x08(dst)
+	ld			t0, 0x00(src)
+	usd  		t0, 0x00(dst)
+	.word			0x704b1038 /*daddwc v0, v0, t3 */
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	dsubu		a1, a1, 0x10
+	daddu		src, src, 0x10
+	daddu		dst, dst, 0x10
+	dsrl		t8, a1, 0x7
+
+begin_movement:
+	beqz		t8, 1f
+	andi		t2, a1, 0x40
+
+move_128bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	CSUM_BIGCHUNK_AND_COPY(0x40)
+	CSUM_BIGCHUNK_AND_COPY(0x60)
+	dsubu		t8, t8, 0x01
+	daddu		dst, dst, 0x80
+	bnez		t8, move_128bytes	/* flag */
+	daddu		src, src, 0x80
+
+1:
+	beqz		t2, 1f
+	andi		t2, a1, 0x20
+
+move_64bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	daddu	src, src, 0x40
+	daddu	dst, dst, 0x40
+
+1:
+	beqz		t2, do_end_words
+	andi		t8, a1, 0x1c
+
+move_32bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	andi		t8, a1, 0x1c
+	daddu		src, src, 0x20
+	daddu		dst, dst, 0x20
+
+do_end_words:
+	beqz		t8, maybe_end_cruft
+	dsrl		t8, t8, 0x2
+
+end_words:
+	lw			t0, (src)
+	usw			t0, (dst)
+	dsubu		t8, t8, 0x1
+	.word			0x70481038 /*daddwc v0, v0, t0 */
+	daddu       dst, dst, 0x4		/* flag */
+	bnez		t8, end_words
+	daddu		src, src, 0x4
+
+maybe_end_cruft:
+	andi		t2, a1, 0x3
+
+small_memcpy:
+ j small_csumcpy; move a1, t2
+	beqz		t2, out
+	move		a1, t2
+
+end_bytes:
+	lb			t0, (src)
+	sb			t0, (dst)
+	dsubu		a1, a1, 0x1
+	daddu		dst, dst, 0x1
+	bnez		a2, end_bytes
+	daddu		src, src, 0x1
+
+out:
+	jr			ra
+	move		v0, sum
+	END(xlr_csum_partial)
Index: linux-2.6.10/arch/mips/lib-64/xlr_csum_nocopy.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/lib-64/xlr_csum_nocopy.S
@@ -0,0 +1,214 @@
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+
+
+
+/*
+ * a0: source address
+ * a1: length of the area to checksum
+ * a2: partial checksum
+ * a3: dst
+ */
+
+#define src a0
+#define dst a3
+#define sum v0
+
+	.text
+	.set	noreorder
+
+	.macro CSUM_BIGCHUNK_AND_COPY offset 
+	pref                    0,  (\offset+0x0)(a0)
+	ld			t0, (\offset+0x00)(a0)
+	ld			t1, (\offset+0x08)(a0)
+	.dword			0x704c1038  /*daddwc v0, v0, t0 */
+	.dword			0x704d1038 /*daddwc v0, v0, t1 */
+	ld			t0, (\offset + 0x10)(a0)		
+	ld			t1, (\offset + 0x18)(a0)	
+	.dword			0x704c1038 /* daddwc v0, v0, t0 */
+	.dword			0x704d1038 /*daddwc v0, v0, t1 */
+	.endm
+
+small_csumcpy: 						/* unknown src alignment and < 8 bytes to go  */
+	move 		a1, t2
+
+	andi		t0, a1, 4
+	beqz		t0, 1f
+	andi		t0, a1, 2
+
+	ulw			t1, (src) 			/* Still a full word to go  */
+	daddiu		src, 4
+	.dword			0x704d1038 /*daddwc v0, v0, t1 */
+
+1:	move		t1, zero
+	beqz		t0, 1f
+	andi		t0, a1, 1
+
+	ulhu		t1, (src) 			/* Still a halfword to go  */
+	daddiu		src, 2
+
+1:	beqz		t0, 1f
+	sll			t1, t1, 16
+
+	lbu			t2, (src)
+	nop
+
+#ifdef __MIPSEB__
+	sll		t2, t2, 8
+#endif
+	or		t1, t2
+
+1: 	.dword			0x704d1038 /*daddwc v0, v0, t1 */
+
+	.dword			0x70461038 /*daddwc v0, v0, a2 */
+	.dword			0x70401038 /*daddwc v0, v0, $0 */
+
+	/* Ideally at this point of time the status flag must be cleared */
+					
+	dsll32      v1, sum, 0
+	.dword			0x70431038 /*daddwc v0, v0, v1 */
+	dsrl32		sum, sum, 0
+	.dword			0x70401038 /*daddwc v0, v0, zero */
+
+	/* fold the checksum */
+	sll             v1, sum, 16
+	addu            sum, v1
+	sltu            v1, sum, v1
+	srl             sum, sum, 16
+	addu            sum, v1
+1:
+	.set		reorder
+	jr			ra
+	.set		noreorder
+
+/* ------------------------------------------------------------------ */
+
+	.align	5
+LEAF(xlr_csum_partial_nocopy)
+	move		sum, zero
+	move		t3, zero
+
+	sltiu		t8, a1, 0x8
+	bnez		t8, small_csumcpy		/* < 8 bytes to copy */
+	move		t2, a1
+
+	beqz		a1, out
+	andi		t3, src, 0x1			/* odd buffer? */
+
+hword_align:
+	beqz		t3, word_align
+	andi		t8, src, 0x2
+
+	lbu			t0, (src)
+	dsubu		a1, a1, 0x1
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x1
+	andi		t8, src, 0x2
+
+word_align:
+	beqz		t8, dword_align
+	sltiu		t8, a1, 56
+
+	lhu			t0, (src)
+	dsubu		a1, a1, 0x2
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	sltiu		t8, a1, 56
+	daddu		src, src, 0x2
+
+dword_align:
+	bnez		t8, do_end_words
+	move		t8, a1
+
+	andi		t8, src, 0x4
+	beqz		t8, qword_align
+	andi		t8, src, 0x8
+
+	lw			t0, 0x00(src)
+	dsubu		a1, a1, 0x4
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x4
+	andi		t8, src, 0x8
+
+qword_align:
+	beqz		t8, oword_align
+	andi		t8, src, 0x10
+
+	ld			t0, 0x00(src)
+	dsubu		a1, a1, 0x8
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x8
+	andi		t8, src, 0x10
+
+oword_align:
+	beqz		t8, begin_movement
+	dsrl		t8, a1, 0x7
+
+	ld			t3, 0x08(src)
+	ld			t0, 0x00(src)
+	.dword			0x704f1038 /*daddwc v0, v0, t3 */
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	dsubu		a1, a1, 0x10
+	daddu		src, src, 0x10
+	dsrl		t8, a1, 0x7
+
+begin_movement:
+	beqz		t8, 1f
+	andi		t2, a1, 0x40
+
+move_128bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	CSUM_BIGCHUNK_AND_COPY(0x40)
+	CSUM_BIGCHUNK_AND_COPY(0x60)
+	dsubu		t8, t8, 0x01
+	bnez		t8, move_128bytes	/* flag */
+	daddu		src, src, 0x80
+
+1:
+	beqz		t2, 1f
+	andi		t2, a1, 0x20
+
+move_64bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	daddu	src, src, 0x40
+
+1:
+	beqz		t2, do_end_words
+	andi		t8, a1, 0x1c
+
+move_32bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	andi		t8, a1, 0x1c
+	daddu		src, src, 0x20
+
+do_end_words:
+	beqz		t8, maybe_end_cruft
+	dsrl		t8, t8, 0x2
+
+end_words:
+	lw			t0, (src)
+	dsubu		t8, t8, 0x1
+	.dword			0x704c1038 /*daddwc v0, v0, t0 */
+	bnez		t8, end_words
+	daddu		src, src, 0x4
+
+maybe_end_cruft:
+	andi		t2, a1, 0x3
+
+small_memcpy:
+ j small_csumcpy; move a1, t2
+	beqz		t2, out
+	move		a1, t2
+
+end_bytes:
+	lb			t0, (src)
+	dsubu		a1, a1, 0x1
+	bnez		a2, end_bytes
+	daddu		src, src, 0x1
+
+out:
+	jr			ra
+	move		v0, sum
+	END(xlr_csum_partial_nocopy)
Index: linux-2.6.10/arch/mips/lib-64/xlr_csum_partial.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/lib-64/xlr_csum_partial.S
@@ -0,0 +1,242 @@
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+
+
+
+/*
+ * a0: source address
+ * a1: length of the area to checksum
+ * a2: partial checksum
+ * a3: dst
+ */
+
+#define src a0
+#define dst a3
+#define sum v0
+
+	.text
+	.set	noreorder
+
+	.macro CSUM_BIGCHUNK_AND_COPY offset 
+	pref                    1,  (\offset+0x0)(a3)
+	pref                    0,  (\offset+0x0)(a0)
+	ld			t0, (\offset+0x00)(a0)
+	ld			t1, (\offset+0x08)(a0)
+	usd			t0, (\offset+0x00)(a3)
+	usd			t1, (\offset+0x08)(a3)
+	.word			0x704c1038  /*daddwc v0, v0, t0 */
+	.word			0x704d1038 /*daddwc v0, v0, t1 */
+	ld			t0, (\offset + 0x10)(a0)		
+	ld			t1, (\offset + 0x18)(a0)	
+	usd			t0, (\offset + 0x10)(a3)
+	usd			t1, (\offset + 0x18)(a3)
+	.word			0x704c1038 /* daddwc v0, v0, t0 */
+	.word			0x704d1038 /*daddwc v0, v0, t1 */
+	.endm
+
+small_csumcpy: 						/* unknown src alignment and < 8 bytes to go  */
+	move 		a1, t2
+
+	andi		t0, a1, 4
+	beqz		t0, 1f
+	andi		t0, a1, 2
+
+	ulw			t1, (src) 			/* Still a full word to go  */
+	usw			t1, (dst)
+	daddiu		src, 4
+	daddiu		dst, 4
+	.word			0x704d1038 /*daddwc v0, v0, t1 */
+
+1:	move		t1, zero
+	beqz		t0, 1f
+	andi		t0, a1, 1
+
+	ulhu		t1, (src) 			/* Still a halfword to go  */
+	ush     	t1, (dst)
+	daddiu		src, 2
+	daddiu		dst, 2
+
+1:	beqz		t0, 1f
+	sll			t1, t1, 16
+
+	lbu			t2, (src)
+	sb			t2, (dst)
+	nop
+
+#ifdef __MIPSEB__
+	sll		t2, t2, 8
+#endif
+	or		t1, t2
+
+1: 	.word			0x704d1038 /*daddwc v0, v0, t1 */
+
+	.word			0x70461038 /*daddwc v0, v0, a2 */
+	.word			0x70401038 /*daddwc v0, v0, $0 */
+
+	/* Ideally at this point of time the status flag must be cleared */
+					
+	dsll32      v1, sum, 0
+	.word			0x70431038 /*daddwc v0, v0, v1 */
+	dsrl32		sum, sum, 0
+	.word			0x70401038 /*daddwc v0, v0, zero */
+
+	/* fold the checksum */
+	sll             v1, sum, 16
+	addu            sum, v1
+	sltu            v1, sum, v1
+	srl             sum, sum, 16
+	addu            sum, v1
+1:
+	.set		reorder
+	jr			ra
+	.set		noreorder
+
+/* ------------------------------------------------------------------ */
+
+	.align	5
+LEAF(xlr_csum_partial)
+	move		sum, zero
+	move		t3, zero
+
+	sltiu		t8, a1, 0x8
+	bnez		t8, small_csumcpy		/* < 8 bytes to copy */
+	move		t2, a1
+
+	beqz		a1, out
+	andi		t3, src, 0x1			/* odd buffer? */
+
+hword_align:
+	beqz		t3, word_align
+	andi		t8, src, 0x2
+
+	lbu			t0, (src)
+	sb			t0, (dst)
+	dsubu		a1, a1, 0x1
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x1
+	daddu		dst, dst, 0x1
+	andi		t8, src, 0x2
+
+word_align:
+	beqz		t8, dword_align
+	sltiu		t8, a1, 56
+
+	lhu			t0, (src)
+	ush			t0, (dst)
+	dsubu		a1, a1, 0x2
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	sltiu		t8, a1, 56
+	daddu		src, src, 0x2
+	daddu		dst, dst, 0x2
+
+dword_align:
+	bnez		t8, do_end_words
+	move		t8, a1
+
+	andi		t8, src, 0x4
+	beqz		t8, qword_align
+	andi		t8, src, 0x8
+
+	lw			t0, 0x00(src)
+	usw			t0, 0x00(dst)
+	dsubu		a1, a1, 0x4
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x4
+	daddu		dst, dst, 0x4
+	andi		t8, src, 0x8
+
+qword_align:
+	beqz		t8, oword_align
+	andi		t8, src, 0x10
+
+	ld			t0, 0x00(src)
+	usd  		t0, 0x00(dst)
+	dsubu		a1, a1, 0x8
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu		src, src, 0x8
+	daddu		dst, dst, 0x8
+	andi		t8, src, 0x10
+
+oword_align:
+	beqz		t8, begin_movement
+	dsrl		t8, a1, 0x7
+
+	ld			t3, 0x08(src)
+	usd  		t3, 0x08(dst)
+	ld			t0, 0x00(src)
+	usd  		t0, 0x00(dst)
+	.word			0x704f1038 /*daddwc v0, v0, t3 */
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	dsubu		a1, a1, 0x10
+	daddu		src, src, 0x10
+	daddu		dst, dst, 0x10
+	dsrl		t8, a1, 0x7
+
+begin_movement:
+	beqz		t8, 1f
+	andi		t2, a1, 0x40
+
+move_128bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	CSUM_BIGCHUNK_AND_COPY(0x40)
+	CSUM_BIGCHUNK_AND_COPY(0x60)
+	dsubu		t8, t8, 0x01
+	daddu		dst, dst, 0x80
+	bnez		t8, move_128bytes	/* flag */
+	daddu		src, src, 0x80
+
+1:
+	beqz		t2, 1f
+	andi		t2, a1, 0x20
+
+move_64bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	CSUM_BIGCHUNK_AND_COPY(0x20)
+	daddu	src, src, 0x40
+	daddu	dst, dst, 0x40
+
+1:
+	beqz		t2, do_end_words
+	andi		t8, a1, 0x1c
+
+move_32bytes:
+	CSUM_BIGCHUNK_AND_COPY(0x00)
+	andi		t8, a1, 0x1c
+	daddu		src, src, 0x20
+	daddu		dst, dst, 0x20
+
+do_end_words:
+	beqz		t8, maybe_end_cruft
+	dsrl		t8, t8, 0x2
+
+end_words:
+	lw			t0, (src)
+	usw			t0, (dst)
+	dsubu		t8, t8, 0x1
+	.word			0x704c1038 /*daddwc v0, v0, t0 */
+	daddu       dst, dst, 0x4		/* flag */
+	bnez		t8, end_words
+	daddu		src, src, 0x4
+
+maybe_end_cruft:
+	andi		t2, a1, 0x3
+
+small_memcpy:
+ j small_csumcpy; move a1, t2
+	beqz		t2, out
+	move		a1, t2
+
+end_bytes:
+	lb			t0, (src)
+	sb			t0, (dst)
+	dsubu		a1, a1, 0x1
+	daddu		dst, dst, 0x1
+	bnez		a2, end_bytes
+	daddu		src, src, 0x1
+
+out:
+	jr			ra
+	move		v0, sum
+	END(xlr_csum_partial)
Index: linux-2.6.10/arch/mips/mm/cerr-phoenix.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mm/cerr-phoenix.c
@@ -0,0 +1,38 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/config.h>
+
+/* generic MIPS cache error handler */
+extern void cache_parity_error(void);
+
+/* On Phoenix, errors reported by bridge (like misconfigured BARS etc) are also
+ * reported as cache errors. Need to check if it is really a cache error or a "bus error"
+ * and take action appropriately.
+ * For now, treat it as a cache error 
+ */
+void phoenix_cache_error(void)
+{
+	cache_parity_error();
+}
Index: linux-2.6.10/arch/mips/mm/c-phoenix.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mm/c-phoenix.c
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/mmu_context.h>
+#include <asm/bootinfo.h>
+#include <asm/hazards.h>
+#include <asm/cacheops.h>
+#include <asm/cpu.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/uaccess.h>
+#include <asm/asm.h>
+#include <linux/smp.h>
+#include <linux/kallsyms.h>
+
+#include <asm/rmi/debug.h>
+
+static unsigned int icache_linesz;
+static unsigned int icache_lines;
+
+#define cacheop(op, base) __asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
+
+#define cacheop_extable(op, base) do {                    \
+  __asm__ __volatile__(                                    \
+		       "    .set push                \n"   \
+		       "    .set noreorder           \n"   \
+		       "    .set mips4               \n"   \
+		       "1:  cache %0, 0(%1)           \n"  \
+		       "2:  .set pop                 \n"   \
+		       "    .section __ex_table,\"a\"\n"   \
+			STR(PTR)"\t1b, 2b\n\t"			\
+		       "     .previous               \n"   \
+		       : : "i" (op), "r" (base));          \
+  } while (0) 
+
+
+static __inline__ void cacheop_sync_istream(void)
+{
+	cacheop_hazard();
+	sync_istream();
+}
+
+
+/*****************************************************************************
+ * 
+ * These routines support Generic Kernel cache flush requirements
+ *
+ ***************************************************************************/
+void phoenix_flush_dcache_page(struct page *page)
+{
+	ClearPageDcacheDirty(page);    
+}
+
+static void phoenix_local_flush_icache_range(long start, 
+						long end)
+{
+	long addr;
+  
+	for(addr = (start & ~(icache_linesz - 1)); addr < end; 
+			addr += icache_linesz) {
+		cacheop(Hit_Invalidate_I, addr);
+	}
+
+	cacheop_sync_istream();
+}
+
+struct flush_icache_range_args {
+  long start;
+  long end;
+};
+
+static void phoenix_flush_icache_range_ipi(void *info)
+{
+	struct flush_icache_range_args *args = info;
+
+	phoenix_local_flush_icache_range(args->start, args->end);
+}
+
+void phoenix_flush_icache_range(unsigned long start, unsigned long end)
+{
+	struct flush_icache_range_args args;
+
+#ifdef CONFIG_PHOENIX_VM_DEBUG
+	rmi_dbg_msg("return address: ");
+	print_symbol("ra[0]=%s\n", (unsigned long) __builtin_return_address(0));
+#endif
+  
+	args.start = start;
+	args.end = end;
+	on_each_cpu(phoenix_flush_icache_range_ipi, &args, 1, 1);
+}
+
+static void phoenix_flush_cache_sigtramp_ipi(void *info)
+{
+	unsigned long addr = (unsigned long)info;
+
+	addr = addr & ~((unsigned long)icache_linesz - 1);
+	cacheop_extable(Hit_Invalidate_I, addr );
+	cacheop_sync_istream();
+}
+
+static void phoenix_flush_cache_sigtramp(unsigned long addr)
+{
+	on_each_cpu(phoenix_flush_cache_sigtramp_ipi, (void *) addr, 1, 1);
+}
+
+/**************************************************************************
+ * 
+ * These routines support MIPS specific cache flush requirements.
+ * These are called only during bootup or special system calls 
+ *
+ **************************************************************************/
+
+static void phoenix_local_flush_icache(void)
+{
+	int i=0;
+	unsigned long base = CKSEG0;
+
+	/* Index Invalidate all the lines and the ways */
+	for(i=0;i<icache_lines;i++) {
+		cacheop(Index_Invalidate_I, base);
+		base += icache_linesz;
+	}
+
+	cacheop_sync_istream(); 
+
+}
+
+static void phoenix_local_flush_dcache(void)
+{
+	int i=0;
+	unsigned long base = CKSEG0;
+	unsigned int lines;
+
+	lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
+	
+	/* Index Invalidate all the lines and the ways */  
+	for(i=0;i<lines;i++) {
+		cacheop(Index_Writeback_Inv_D, base);
+		base += current_cpu_data.dcache.linesz;
+	}
+
+	cacheop_hazard(); 
+
+}
+
+static void phoenix_flush_l1_caches_ipi(void *info)
+{
+	phoenix_local_flush_dcache();
+	phoenix_local_flush_icache();
+}
+
+static void phoenix_flush_l1_caches(void)
+{
+	on_each_cpu(phoenix_flush_l1_caches_ipi, (void *)NULL, 1, 1);
+}
+
+static void phoenix_noflush(void) { /* do nothing */ }
+
+static __init void probe_l1_cache(void)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	unsigned int config1 = read_c0_config1();
+	int lsize = 0;
+	int icache_size=0, dcache_size=0;
+
+	if ((lsize = ((config1 >> 19) & 7)))
+		c->icache.linesz = 2 << lsize;
+	else
+		c->icache.linesz = lsize;
+	c->icache.sets = 64 << ((config1 >> 22) & 7);
+	c->icache.ways = 1 + ((config1 >> 16) & 7);
+
+	icache_size = c->icache.sets *
+			c->icache.ways * c->icache.linesz;
+	c->icache.waybit = ffs(icache_size/c->icache.ways) - 1;
+
+	c->dcache.flags = 0;
+
+	if ((lsize = ((config1 >> 10) & 7)))
+		c->dcache.linesz = 2 << lsize;
+	else
+		c->dcache.linesz= lsize;
+	c->dcache.sets = 64 << ((config1 >> 13) & 7);
+	c->dcache.ways = 1 + ((config1 >> 7) & 7);
+
+	dcache_size = c->dcache.sets *
+			c->dcache.ways * c->dcache.linesz;
+	c->dcache.waybit = ffs(dcache_size/c->dcache.ways) - 1;
+
+	if (smp_processor_id()==0) {
+		printk("Primary instruction cache %dkB, %d-way," 
+			"linesize %d bytes.\n", icache_size >> 10, 
+			c->icache.ways, c->icache.linesz);
+		printk("Primary data cache %dkB %d-way, linesize %d bytes.\n",
+			dcache_size >> 10, c->dcache.ways, c->dcache.linesz);
+	}
+
+}
+
+static __inline__ void install_cerr_handler(void)
+{
+	extern char except_vec2_generic;
+
+	memcpy((void *)(CAC_BASE + 0x100), &except_vec2_generic, 0x80);
+}
+
+static void update_kseg0_coherency(void)
+{
+	int attr = read_c0_config() & CONF_CM_CMASK;
+
+	if (attr != CONF_CM_DEFAULT) {
+
+		phoenix_local_flush_dcache();
+		phoenix_local_flush_icache();
+
+		change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
+
+		sync_istream();
+	}
+
+}
+
+void xlr_cache_init(void)
+{
+	/* update cpu_data */
+	probe_l1_cache();
+
+	if (smp_processor_id()) {  
+
+		/* flush the exception vector region to make sure 
+		* not to execute bootloader's exception code 
+		*/
+		phoenix_local_flush_icache_range(CAC_BASE, CAC_BASE + 0x400);
+
+		update_kseg0_coherency();
+
+		return;
+	}
+
+	/* These values are assumed to be the same for all cores */
+	icache_lines = 
+		current_cpu_data.icache.ways * current_cpu_data.icache.sets;
+	icache_linesz = current_cpu_data.icache.linesz;
+
+	/* When does this function get called? Looks like MIPS has some syscalls
+	 * to flush the caches. 
+	 */
+	__flush_cache_all = phoenix_flush_l1_caches;
+
+	/* flush_cache_all: makes all kernel data coherent.
+	 * This gets called just before changing or removing
+	 * a mapping in the page-table-mapped kernel segment (kmap). 
+	 * Physical Cache -> do nothing
+	 */
+	flush_cache_all = phoenix_noflush;
+
+	/* flush_icache_range: makes the range of addresses coherent w.r.t 
+	 * I-cache and D-cache 
+	 * This gets called after the instructions are written to memory
+	 * All addresses are valid kernel or mapped user-space virtual addresses
+	 */
+	flush_icache_range = phoenix_flush_icache_range;
+
+	/* flush_cache_{mm, range, page}: make these memory locations, 
+	 * that may have been written by a user process, coherent
+	 * These get called when virtual->physical translation of a user 
+	 * address space is about to be changed. 
+	 * These are closely related to TLB coherency 
+	 * (flush_tlb_{mm, range, page})
+	 */
+	flush_cache_mm = (void (*)(struct mm_struct *))phoenix_noflush;
+	flush_cache_range = (void *) phoenix_noflush;
+	flush_cache_page = (void *) phoenix_noflush;
+
+	/* flush_icache_page: flush_dcache_page + update_mmu_cache takes 
+	 * care of this
+	 */
+	flush_icache_page = (void *) phoenix_noflush;
+	flush_data_cache_page = (void *) phoenix_noflush;
+
+	/* flush_cache_sigtramp: flush the single I-cache line with the 
+	 * proper fixup code
+	 */
+	flush_cache_sigtramp = phoenix_flush_cache_sigtramp;
+
+	/* flush_icache_all: This should get called only for Virtuall Tagged 
+	 * I-Caches
+	 */
+	flush_icache_all = (void *)phoenix_noflush;
+
+	install_cerr_handler();
+
+	update_kseg0_coherency();
+}
+
+#define cacheop_paddr(op, base) __asm__ __volatile__ ( \
+                         ".set push\n"           \
+                         ".set noreorder\n"      \
+                         ".set mips64\n"          \
+                         "dli $8, 0x9800000000000000\n"              \
+                         "daddu $8, $8, %1\n"       \
+                         "cache %0, 0($8)\n"     \
+                         ".set pop\n"            \
+                         : : "i"(op), "r"(base) : "$8")
+
+#define enable_KX(flags)   \
+ __asm__ __volatile__ (          \
+	".set push\n"              \
+	".set noat\n"               \
+	".set noreorder\n"     \
+	"mfc0 %0, $12\n\t"             \
+	"ori $1, %0, 0x81\n\t"   \
+	"xori $1, 1\n\t"      \
+	"mtc0 $1, $12\n"       \
+        ".set pop\n"          \
+        : "=r"(flags) )
+	
+#define disable_KX(flags)   \
+ __asm__ __volatile__ (          \
+	".set push\n"              \
+	"mtc0 %0, $12\n"       \
+        ".set pop\n"          \
+        : : "r"(flags) )
+	
+
+static void phoenix_local_flush_icache_range_paddr(unsigned long start, 
+					unsigned long end)
+{
+	unsigned long addr;
+	unsigned long flags;
+
+	enable_KX(flags);
+	for(addr = (start & ~(icache_linesz - 1)); addr < end; 
+			addr += icache_linesz) {
+		unsigned long long temp = addr & 0xffffffff;
+		cacheop_paddr(Hit_Invalidate_I, temp);
+	}
+	disable_KX(flags);
+
+	cacheop_sync_istream();
+}
+
+static void phoenix_flush_icache_range_paddr_ipi(void *info)
+{
+	struct flush_icache_range_args *args = info;
+
+	phoenix_local_flush_icache_range_paddr(args->start, args->end);
+}
+
+void phoenix_flush_icache_range_paddr(unsigned long start)
+{
+	struct flush_icache_range_args args;
+
+#ifdef CONFIG_PHOENIX_VM_DEBUG
+	rmi_dbg_msg("return address: ");
+	print_symbol("ra[0]=%s\n", (unsigned long) __builtin_return_address(0));
+#endif
+	
+	args.start = start;
+	args.end = start + PAGE_SIZE;
+	/* TODO: don't even send ipi to non-zero thread ids 
+	 * This may require some changes to smp_call_function interface, 
+	 * for now just avoid redundant cache ops
+	 */
+	on_each_cpu(phoenix_flush_icache_range_paddr_ipi, &args, 1, 1);
+}
Index: linux-2.6.10/arch/mips/mm/pg-phoenix.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mm/pg-phoenix.c
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#include <linux/config.h>
+#include <linux/smp.h>
+
+#include <asm/page.h>
+#include <asm/bug.h>
+#include <asm/asm.h>
+#include <asm/system.h>
+
+/* These are the functions hooked by the memory management function pointers */
+void clear_page(void *page)
+{
+#ifdef CONFIG_PHOENIX_VM_DEBUG
+  printk("[%s]: page = %lx\n", __FUNCTION__, (unsigned long)page);
+#endif
+  __asm__ __volatile__(
+		       ".set push                  \n"
+		       ".set noreorder             \n"
+		       ".set noat                  \n"
+		       ".set mips4                 \n"
+
+		       /* store the address of last cacheline in $1 */
+		       STR(LONG_ADDIU)"\t$1, %0, %1  \n"  
+
+		       /* pref with prep_for_store and zero the cacheline */
+		       "1:   pref      30,  0(%0)  \n"
+
+		       "     sd        $0,  0(%0)  \n"  
+		       "     sd        $0,  8(%0)  \n"
+		       "     sd        $0, 16(%0)  \n"
+		       "     sd        $0, 24(%0)  \n"
+
+		       /* loop till the last cacheline */
+		       STR(LONG_ADDIU)"\t%0, %0, 32  \n"  
+		       "     bne       %0, $1, 1b  \n"
+		       "     nop                   \n"
+
+		       ".set pop                   \n"
+		       :
+		       :"r" (page), "I" (PAGE_SIZE)
+		       :"$1","memory");
+}
+
+extern int xlr_request_dma(uint64_t src, uint64_t dest, uint32_t len);
+void copy_page(void *to, void *from)
+{
+#ifdef PHOENIX_DMA_PAGEOPS
+
+	u64 from_phys = CPHYSADDR(from);
+	u64 to_phys = CPHYSADDR(to);
+
+	/* if any page is not in KSEG0, use old way */
+	if ((long)KSEGX(to) != (long)CKSEG0
+	    || (long)KSEGX(from) != (long)CKSEG0) 
+		goto cpu_copy;
+
+	if((xlr_request_dma(from_phys, to_phys, PAGE_SIZE)) == 0) {
+		return;
+	}
+	/* try the old way */
+
+cpu_copy:
+#endif
+  __asm__ __volatile__(
+		       ".set push                  \n"
+		       ".set noreorder             \n"
+		       ".set noat                  \n"
+		       ".set mips64                 \n"
+
+		       /* store the address of last cacheline in $1 */
+		       STR(LONG_ADDIU)"\t$1, %1, %2  \n"  
+
+		       /* pref with prep_for_store the current cacheline */
+		       /* the stores should merge into this pref cacheline */
+		       "1:   pref      1,   0(%0)  \n"
+
+		       /* pref the next cacheline "from" */
+		       "     pref      0,    32(%1)  \n"
+
+		       /* copy the cacheline */
+#ifdef CONFIG_64BIT
+ 		       "2:   ld        $8,   0(%1)  \n"
+		       "     ld        $9,   8(%1)  \n"
+		       "     ld        $10,  16(%1)  \n"
+		       "     ld        $11,  24(%1)  \n"
+		       "     sd        $8,   0(%0)  \n"
+		       "     sd        $9,   8(%0)  \n"
+		       "     sd        $10,  16(%0)  \n"
+		       "     sd        $11,  24(%0)  \n"
+#else
+ 		       "2:   lw        $8,   0(%1)  \n"
+		       "     lw        $9,   4(%1)  \n"
+		       "     lw        $10,  8(%1)  \n"
+		       "     lw        $11,  12(%1)  \n"
+		       "     sw        $8,   0(%0)  \n"
+		       "     sw        $9,   4(%0)  \n"
+		       "     sw        $10,  8(%0)  \n"
+		       "     sw        $11,  12(%0)  \n"
+ 		       "     lw        $8,   16(%1)  \n"
+		       "     lw        $9,   20(%1)  \n"
+		       "     lw        $10,  24(%1)  \n"
+		       "     lw        $11,  28(%1)  \n"
+		       "     sw        $8,   16(%0)  \n"
+		       "     sw        $9,   20(%0)  \n"
+		       "     sw        $10,  24(%0)  \n"
+		       "     sw        $11,  28(%0)  \n"
+#endif
+
+		       /* loop till the last cacheline */		       
+		       STR(LONG_ADDIU)"\t%1, %1, 32  \n"  
+		       STR(LONG_ADDIU)"\t%0, %0, 32  \n"  
+		       "     bne       %1, $1, 1b  \n"
+		       "     nop                   \n"
+
+		       ".set pop                   \n"
+
+		       :
+		       :"r" (to), "r"(from), "I" (PAGE_SIZE)
+		       :"$1","$8", "$9", "$10", "$11", "memory");
+}
Index: linux-2.6.10/arch/mips/pci/pci-phoenix.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/pci-phoenix.c
@@ -0,0 +1,593 @@
+/*
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+
+#include <asm/io.h>
+
+#include <asm/rmi/interrupt.h>
+#include <asm/rmi/pci.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/sim.h>
+
+#define  PCI_HT_LCTR_INIT   0x0020  /* Initialization Complete */
+
+#define LSU_CFG0_REGID       0
+#define LSU_CERRLOG_REGID    9
+#define LSU_CERROVF_REGID    10
+#define LSU_CERRINT_REGID    11
+
+
+#define pci_cfg_offset(bus,devfn,where) (((bus)<<16)+((devfn)<<8)+(where))
+#define pci_cfg_addr(bus,devfn,where) pci_cfg_offset((bus)->number,(devfn),where)
+static int  pci_bus_status;
+static int  pci_start_busno;
+static int  pci_start_bus_fixed;
+/*
+  Maximum bus number on PCI is 0xff,
+  hence, start the ht_busno with 
+  0xff + 1. This variable will get
+  reset to the actual value when
+  the enumeration of HT begins.
+*/
+static int  ht_start_busno = 0x100;
+static int  ht_start_bus_fixed;
+static void *pci_config_base;
+void *pci_io_base;
+
+static void *ht_io_base;
+
+void *ht_config_base;
+
+#define CFGTYPE(x) ((x)<(1)?(0):(1))
+#define MB16 0x01000000
+
+#define SWAP32(x)\
+        (((x) & 0xff000000) >> 24) | \
+        (((x) & 0x000000ff) << 24) | \
+        (((x) & 0x0000ff00) << 8)  | \
+        (((x) & 0x00ff0000) >> 8)
+
+static __inline__ void disable_and_clear_cache_error(void)
+{ 
+        uint64_t lsu_cfg0 = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+        lsu_cfg0 = lsu_cfg0 & ~0x2e;
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID, lsu_cfg0);
+        /* Clear cache error log */
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+}
+
+static __inline__ void clear_and_enable_cache_error(void)
+{ 
+        uint64_t lsu_cfg0 = 0;
+
+        /* first clear the cache error logging register */
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERROVF_REGID, 0);
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRINT_REGID, 0);
+
+        lsu_cfg0 = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+        lsu_cfg0 = lsu_cfg0 | 0x2e;
+        write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID, lsu_cfg0);
+}
+
+
+static inline int ht_controller_init_done(void) 
+{
+    int init_done=0;
+    phoenix_reg_t *ht_mmio = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+    phoenix_reg_t reg = cpu_to_le32(phoenix_read_reg(ht_mmio, (0xA4 >> 2)));
+    if ((uint16_t)reg & PCI_HT_LCTR_INIT)
+        init_done = 1;
+    else
+        printk("Skipping XLR HT-Controller Registration...\n");
+    return init_done;
+}
+#if 1
+static inline __u32 pci_cfg_read_32bit(unsigned long addr)
+{
+        __u32 temp = 0;
+        __u32 *p = (__u32 *) (pci_config_base + (addr & ~3));
+        __u64 cerr_cpu_log = 0;
+
+	disable_and_clear_cache_error();
+
+        temp = SWAP32(*p);
+
+        /* Read cache err log */
+        cerr_cpu_log = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+
+        if(cerr_cpu_log)
+        {
+                /* Device don't exist. */
+                temp = ~0x0;
+        }
+	clear_and_enable_cache_error();
+        return temp;
+
+}
+static inline void pci_cfg_write_32bit(unsigned long addr, __u32 data)
+{
+        unsigned int *p = (unsigned int *)(pci_config_base + (addr & ~3));
+
+        *p = SWAP32(data);
+}
+
+#else
+/*
+ * Read/write 32-bit values in config space.
+ * pci config space is little endian
+ */
+static inline __u32 pci_cfg_read_32bit(unsigned long addr)
+{
+  __u8 *p = (__u8 *)(pci_config_base + (addr & ~3));
+
+  //printk("[%s]: addr = %p, data = %x\n", __FUNCTION__, p, *(__u32*)p);
+  
+  return ( (*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | *p);
+}
+
+static inline void pci_cfg_write_32bit(unsigned long addr, __u32 data)
+{
+  __u8 *p = (__u8 *)(pci_config_base + (addr & ~3));
+  int i=0;
+
+  for(i=0;i<4;i++)
+    p[i] = (data >> (i<<3)) & 0xff;
+}
+#endif
+/* 
+ * Low-level HT Configuration READ and Write Routines 
+ */
+static inline __u32 ht_cfg_read_32bit(unsigned long addr) {
+
+
+    __u8 *p;
+    __u32 temp = 0;
+    __u64 cerr_cpu_log = 0;
+
+    disable_and_clear_cache_error();
+    p = (__u8 *)((addr & ~3));
+   //printk("[%s]: addr = %p, data = %x\n", __FUNCTION__, p, *(__u32*)p);
+    temp =  ( (*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | *p);
+
+    cerr_cpu_log = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+
+    if(cerr_cpu_log)
+    {
+	    /* Device don't exist. */
+	    temp = ~0x0;
+    }
+    clear_and_enable_cache_error();
+
+    return temp;
+}
+
+static inline void ht_cfg_write_32bit(unsigned long addr, __u32 data) {
+
+    __u8 *p;
+    int i=0;
+
+    p = (__u8 *)((addr & ~3));
+
+    for(i=0;i<4;i++)
+        p[i] = (data >> (i<<3)) & 0xff;
+}
+/* 
+ * HT Wrapper Routine: READ 
+ */
+static int phoenix_htbios_read(struct pci_bus *bus, unsigned int devfn,
+                               int where, int size, u32 * val)
+{
+    __u32 data = 0;
+    unsigned long long int cfgaddr;
+
+    /* Keep track of where the PCIX
+     * bus numbering starts from..
+     */
+    if (!ht_start_bus_fixed) {
+	    ht_start_busno     = (int)(bus->number);
+	    ht_start_bus_fixed = 1;
+    }
+
+    if ((size == 2) && (where & 1))
+        return PCIBIOS_BAD_REGISTER_NUMBER;
+    else if ((size == 4) && (where & 3))
+        return PCIBIOS_BAD_REGISTER_NUMBER;
+
+    cfgaddr = (long) ht_config_base +
+	    CFGTYPE(bus->number - ht_start_busno) * MB16 +
+	    pci_cfg_offset((int)bus->number,devfn,where);
+	    
+    if (pci_bus_status)
+	    data = ht_cfg_read_32bit(cfgaddr);
+    else
+        data = 0xFFFFFFFF;
+
+    if (size == 1)
+        *val = (data >> ((where & 3) << 3)) & 0xff;
+    else if (size == 2)
+        *val = (data >> ((where & 3) << 3)) & 0xffff;
+    else
+        *val = data;
+
+    return PCIBIOS_SUCCESSFUL;
+}
+/* 
+ * HT Wrapper Routine: WRITE
+ */
+static int phoenix_htbios_write(struct pci_bus *bus, unsigned int devfn,
+                                int where, int size, u32 val)
+{  
+    unsigned long long int cfgaddr;
+//    __u32 cfgaddr = pci_cfg_offset(bus->number , devfn, where);
+    __u32 data = 0;
+
+    if ((size == 2) && (where & 1))
+        return PCIBIOS_BAD_REGISTER_NUMBER;
+    else if ((size == 4) && (where & 3))
+        return PCIBIOS_BAD_REGISTER_NUMBER;
+
+    if (!pci_bus_status)
+        return PCIBIOS_BAD_REGISTER_NUMBER;
+
+    cfgaddr = (long) ht_config_base +
+	    CFGTYPE(bus->number - ht_start_busno) * MB16 +
+	    pci_cfg_offset(bus->number,devfn,where);
+	    
+
+    data = ht_cfg_read_32bit(cfgaddr);
+
+    if (size == 1)
+        data = (data & ~(0xff << ((where & 3) << 3))) |
+            (val << ((where & 3) << 3));
+    else if (size == 2)
+        data = (data & ~(0xffff << ((where & 3) << 3))) |
+            (val << ((where & 3) << 3));
+    else
+        data = val;
+
+    ht_cfg_write_32bit(cfgaddr, data);
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+static int phoenix_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+			       int where, int size, u32 * val)
+{
+    __u32 data = 0;
+
+    /* Keep track of where the PCIX
+     * bus numbering starts from..
+     */
+    if (!pci_start_bus_fixed) {
+        pci_start_busno     = (int)(bus->number);
+        pci_start_bus_fixed = 1;
+    }
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (pci_bus_status)
+		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number-pci_start_busno), devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int phoenix_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 val)
+{  
+	__u32 cfgaddr = pci_cfg_offset((bus->number-pci_start_busno), devfn, where);
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!pci_bus_status)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else
+	  data = val;
+
+	pci_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops phoenix_pci_ops = {
+    .read  = phoenix_pcibios_read,
+    .write = phoenix_pcibios_write
+};
+
+struct pci_ops phoenix_ht_ops = {
+    .read  = phoenix_htbios_read,
+    .write = phoenix_htbios_write
+};
+
+/* 
+ * XLR PCIX Controller 
+ */
+static struct resource phoenix_mem_resource = {
+    .name           = "PHOENIX PCI MEM",
+    .start          = 0xd0000000UL,          /* 256MB PCI mem @ 0xd000_0000 */
+    .end            = 0xdfffffffUL,                 
+    .flags          = IORESOURCE_MEM,
+};
+static struct resource phoenix_io_resource = {
+    .name           = "PHOENIX IO MEM",
+    .start          = 0x10000000UL,         /* 16MB PCI IO @ 0x1000_0000 */
+    .end            = 0x100fffffUL,
+    .flags          = IORESOURCE_IO,
+};
+
+struct pci_controller phoenix_controller = {
+    .pci_ops        = &phoenix_pci_ops,
+    .mem_resource   = &phoenix_mem_resource,
+    .io_resource    = &phoenix_io_resource,
+    .io_offset      = 0x00000000UL,
+    .mem_offset     = 0x00000000UL
+};
+
+/* 
+ * XLR HT Controller 
+ */
+static struct resource phoenix_htmem_resource = {
+    .name           = "PHOENIX HT MEM",
+    .start          = 0xc0000000UL,                 /* 256MB HT mem @ 0xC0000000 */
+    .end            = 0xcfffffffUL,
+    .flags          = IORESOURCE_MEM,
+};
+static struct resource phoenix_htio_resource = {
+    .name           = "PHOENIX HT IO",
+    .start          = 0x14000000UL,                 /* 16MB HT IO @ 0x1400_0000 */
+    .end            = 0x140fffffUL,
+    .flags          = IORESOURCE_IO,
+};
+struct pci_controller phoenix_ht_controller = {
+    .pci_ops        = &phoenix_ht_ops,
+    .mem_resource   = &phoenix_htmem_resource,
+    .io_resource    = &phoenix_htio_resource,
+    .io_offset      = 0x00000000UL,
+    .mem_offset     = 0x00000000UL
+};
+/* I/O routines for IDE on PCI */
+#define pci_ide_phys_to_virt(x) ((x) - (phoenix_io_resource.start) + (unsigned long)pci_io_base )
+
+static inline void rmi_ide_mm_insw(unsigned long port, void *addr, u32 count) 
+{
+  unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u16 *)addr = (__raw_readw(v_port));
+		addr += 2;
+	}
+}
+
+static inline void rmi_ide_mm_insl(unsigned long port, void *addr, unsigned int count) 
+{
+  unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u32 *)addr = (__raw_readl(v_port));
+		addr += 4;
+	}
+}
+
+static inline void rmi_ide_mm_outsw(unsigned long port, void *addr, unsigned int count) 
+{
+  unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		__raw_writew(*(u16 *)addr, v_port);
+		addr += 2;
+	}
+}
+
+static inline void rmi_ide_mm_outsl(unsigned long port, void *addr, unsigned int count) 
+{
+  unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		__raw_writel(*(u32 *)addr, v_port);
+		addr += 4;
+	}
+}
+
+static u8 rmi_ide_mm_inb (unsigned long port)
+{
+	return((u8)__raw_readb(pci_ide_phys_to_virt(port)));
+}
+
+static u16 rmi_ide_mm_inw (unsigned long port)
+{
+	return ((u16) swab16(__raw_readw(pci_ide_phys_to_virt(port))));
+}
+
+static u32 rmi_ide_mm_inl (unsigned long port)
+{
+	return ((u32)swab32(__raw_readl(pci_ide_phys_to_virt(port))));
+}
+
+static void rmi_ide_mm_outb (u8 value, unsigned long port)
+{
+	__raw_writeb(value, pci_ide_phys_to_virt(port));
+}
+
+static void rmi_ide_mm_outbsync (ide_drive_t *drive, u8 value, unsigned long port)
+{
+	__raw_writeb(value, pci_ide_phys_to_virt(port));
+}
+
+static void rmi_ide_mm_outw (u16 value, unsigned long port)
+{
+	__raw_writew(swab16(value), pci_ide_phys_to_virt(port));
+}
+
+static void rmi_ide_mm_outl (u32 value, unsigned long port)
+{
+	__raw_writel(swab32(value), pci_ide_phys_to_virt(port));
+}
+
+void xlr_hwif_mmiops (ide_hwif_t *hwif)
+{
+	hwif->OUTB      = rmi_ide_mm_outb;
+	hwif->OUTBSYNC  = rmi_ide_mm_outbsync;
+	hwif->OUTW      = rmi_ide_mm_outw;
+	hwif->OUTL      = rmi_ide_mm_outl;
+	hwif->OUTSW     = rmi_ide_mm_outsw;
+	hwif->OUTSL     = rmi_ide_mm_outsl;
+	hwif->INB       = rmi_ide_mm_inb;
+	hwif->INW       = rmi_ide_mm_inw;
+	hwif->INL       = rmi_ide_mm_inl;
+	hwif->INSW      = rmi_ide_mm_insw;
+	hwif->INSL      = rmi_ide_mm_insl;
+}
+
+EXPORT_SYMBOL(xlr_hwif_mmiops);
+
+int pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+    if (dev->bus->number >= ht_start_busno) 
+        return PIC_HYPER_IRQ;  /* IRQ Vector 23 for HT Devices */
+    else 
+        return PIC_PCIX_IRQ;   /* IRQ Vector 24 for PCI/X Devices */
+}
+
+extern int pci_probe_only;
+
+static int __initdata xlr_nopci;
+
+static int __init xlr_nopci_setup(char *str) 
+{
+    xlr_nopci = 1;
+    return 1;
+}
+__setup("xlr_nopci", xlr_nopci_setup);
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+static int __init pcibios_init(void)
+{
+  if (xlr_nopci || xlr_board_atx_iii()) return 0;
+  
+	/* PSB assigns PCI resources */
+	pci_probe_only = 1;
+	
+	/* Map the PCIX CFG space */
+	pci_config_base = ioremap(DEFAULT_PCI_CONFIG_BASE, (32<<20));
+	if (!pci_config_base) {
+		printk("Unable to map PCI config space!\n");
+		return 1;
+	}
+	                                    
+	/* Map the HT CFG spaces... */
+	ht_config_base = ioremap(DEFAULT_HT_TYPE0_CFG_BASE, (32<<20));
+	if (!ht_config_base) {
+		printk("Unable to map HT config space!\n");
+		return 1;
+	}
+
+	{
+	  unsigned long phys = phoenix_io_resource.start;
+	  unsigned long size = phoenix_io_resource.end - phoenix_io_resource.start + 1;
+
+	  pci_io_base = ioremap(phys, size);
+	  if (!pci_io_base) {
+	    printk("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+		   __FUNCTION__, phys, size);
+	  }
+	  else {
+	    printk("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+		   __FUNCTION__, phys, size, pci_io_base);
+	  }
+	}
+
+	{
+	  unsigned long phys = phoenix_htio_resource.start;
+	  unsigned long size = phoenix_htio_resource.end - phoenix_htio_resource.start + 1;
+
+	  ht_io_base = ioremap(phys, size);
+	  if (!ht_io_base) {
+	    printk("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+		   __FUNCTION__, phys, size);
+	  }
+	  else {
+	    printk("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+		   __FUNCTION__, phys, size, ht_io_base);
+	  }
+	}
+
+	pci_bus_status = 1;
+	pci_start_bus_fixed = 0;
+	ht_start_bus_fixed = 0;
+
+	/* IO Range for 16MB from where the MEM Range Ends */
+	ioport_resource.start = 0;
+	ioport_resource.end =   ~0;
+
+    printk("Registering XLR PCI Controller \n");
+	register_pci_controller(&phoenix_controller);
+    
+    if ((xlr_board_atx_i()) && ht_controller_init_done()) {
+        printk("Registering XLR HT Controller \n");
+        register_pci_controller(&phoenix_ht_controller);
+    }
+	
+	return 0;
+}
+
+arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+  {0}
+};
+
Index: linux-2.6.10/arch/mips/rmi/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/Kconfig
@@ -0,0 +1,72 @@
+config PHOENIX_PSB
+	bool 
+	default y
+
+config RMI_PTR
+	bool
+	default y
+
+config PHOENIX_SMP_PREFIX
+	bool 'Support for printk SMP prefix'
+	depends on RMI_PHOENIX
+	help
+	Selecting this option will result in prefixing of kernel printk's by
+	the logical CPU ID.
+
+config PHOENIX_MAC
+	bool 'Support for On-Chip MAC'
+	depends on RMI_PHOENIX
+	help
+	Selecting this option will enable support for on-chip 1G MACs.
+
+config PHOENIX_USER_MAC
+	bool 'Support for User Mac'
+	depends on PHOENIX_MAC
+
+config PHOENIX_SPI4
+	bool 'Support for on-chip SPI4 interfaces'
+	depends on RMI_PHOENIX
+	help
+	With the Vitesse SPI4 daughter card, this driver will abstract the 
+	20 SPI4 channels as Gigabit ethernet interfaces.
+
+config PHOENIX_DMA
+	bool 'Support for On-Chip DMA Engine'
+	depends on RMI_PHOENIX
+	default n
+	help
+	Selecting this option will enable support for XLR DMA engine. 
+
+config PHOENIX_DMA_PAGEOPS
+	bool 'Support for Copy page using DMA engine'
+	depends on PHOENIX_DMA
+	default n
+	help
+	Selecting this option will enable copy_page to use DMA instead of 
+	CPU copy.
+
+config PHOENIX_TRACEBUFFER
+	bool 'Driver for capturing tracebuffer contents'
+	depends on RMI_PHOENIX
+	help
+	With the help of this driver and a simple application, one can capture
+	tracebuffer FIFO contents into a file. Sample application is 
+	provided in apps/tracebuffer
+
+config PHOENIX_EARLY_PRINTK
+	bool 'Support for Early printk'
+	depends on RMI_PHOENIX
+	default y
+	help
+	Selecting this option will enable output of kernel log messages on
+	the serial console before the actual serial port driver is loaded.
+
+config PHOENIX_FAST_CSUM
+	bool 'Support for Fast Checksum using DADDWC'
+	depends on RMI_PHOENIX
+	default y
+	help
+	Selecting this option will enable checksum(TCP) computations using XLR
+	specific daddwc instruction. This will double the speed of checksum
+	computations.
+
Index: linux-2.6.10/arch/mips/rmi/phoenix/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/Makefile
@@ -0,0 +1,7 @@
+
+obj-y := irq.o irq_handler.o time.o msgring.o on_chip.o
+
+obj-$(CONFIG_SMP)	+= smp.o
+obj-$(CONFIG_PHOENIX_DMA) += dma.o
+
+EXTRA_AFLAGS := $(CFLAGS)
Index: linux-2.6.10/arch/mips/rmi/phoenix/dma.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/dma.c
@@ -0,0 +1,328 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/sim.h>
+
+#define CH0_CONTROL 8
+#define MSGRNG_CODE_DMA 8
+#define XLR_DMA_RESP_TIMEOUT 500
+
+#define NEXT_SEQ_NUM(x) ((x->sequence_number + 1) & (MAX_DMA_TRANS_PER_CPU - 1))
+#define INC_SEQ_NUM(x) x->sequence_number = \
+		((x->sequence_number + 1) & (MAX_DMA_TRANS_PER_CPU - 1))
+
+#define DMA_SLOT_BUSY(x) (x->trans[x->sequence_number].pending)
+
+#define DMA_RESP_PENDING(x, seq) (x->trans[seq].pending)
+
+#define DMA_SLOT_GET(x) (x->trans[x->sequence_number].pending = 1); \
+				INC_SEQ_NUM(ctrl);
+
+#define DMA_SLOT_PUT(x, seq) (x->trans[seq].pending = 0)
+
+#define DMA_GET_RESP(x, seq) (x->trans[seq].dma_resp)
+
+#define DMA_PUT_RESP(x, seq, msg) x->trans[seq].dma_resp = msg; \
+				x->trans[seq].pending = 0;
+
+#define DMA_DONE(x, seq) (x->trans[seq].pending == 0)
+
+enum dma_msgring_bucket_config {
+
+	DMA_MSG_BUCKET0_SIZE = 0x320,
+	DMA_MSG_BUCKET1_SIZE,
+	DMA_MSG_BUCKET2_SIZE,
+	DMA_MSG_BUCKET3_SIZE,
+};
+
+enum dma_msgring_credit_config {
+
+	DMA_CC_CPU0_0                        = 0x380,
+	DMA_CC_CPU1_0                        = 0x388,
+	DMA_CC_CPU2_0                        = 0x390,
+	DMA_CC_CPU3_0                        = 0x398,
+	DMA_CC_CPU4_0                        = 0x3a0,
+	DMA_CC_CPU5_0                        = 0x3a8,
+	DMA_CC_CPU6_0                        = 0x3b0,
+	DMA_CC_CPU7_0                        = 0x3b8
+};
+
+/* We use 10 bit transaction id in the DMA message to uniquely identify a DMA
+   response.
+   0-7 indicate a sequence number (0 to 255)
+   8-9 bits encode the CPU thread id (0 to 3)
+   */
+#define MAX_DMA_TRANS_PER_CPU 256
+#define XLR_MAX_DMA_LEN_PER_DESC ((1 << 20) - 1) /* 1 MB - 1 */
+typedef struct dma_trans {
+	int pending;
+	uint64_t dma_resp;
+}dma_trans_t;
+
+typedef struct xlr_dma_ctrl {
+	spinlock_t q_lock;
+	int sequence_number;
+	dma_trans_t trans[MAX_DMA_TRANS_PER_CPU];
+}xlr_dma_ctrl_t;
+
+
+static int xlr_dma_init_done = 0;
+DEFINE_PER_CPU(struct xlr_dma_ctrl, xlr_dma_ctrl) ;
+
+/* DMA message handler - Called from interrupt context */
+static void xlr_dma_msgring_handler(int bucket, int size, int code, 
+		int stid, struct msgrng_msg *msg, void *data/* ignored */)
+{
+	int cpu, thr_id, tx_id, seq;
+	xlr_dma_ctrl_t *ctrl;
+
+	tx_id = (msg->msg0 >> 48) & 0x3ff;
+	thr_id = (tx_id >> 8) & 0x3;
+	seq = (tx_id & 0xff);
+
+	cpu = (phoenix_cpu_id() * 4) + thr_id;
+	ctrl = &per_cpu(xlr_dma_ctrl, cpu);
+
+	spin_lock(&ctrl->q_lock);
+	/* Check if there was a pending request. This can happen if the
+	   requestor times out and gives up the request. So in that case
+	   do not update the response
+	NOTE: One corner case that is not handled here is that when seq no
+	wraps around and request was pending for the new one and this response
+	was for the old request. This ideally must not happen.
+	   */
+	if(DMA_RESP_PENDING(ctrl, seq)) {
+		DMA_PUT_RESP(ctrl, seq, msg->msg0);
+		spin_unlock(&ctrl->q_lock);
+		return;
+	}
+	spin_unlock(&ctrl->q_lock);
+	printk("ERROR: Stale response from DMA engine for transaction id %d\n",
+			seq);
+	return;
+}
+
+inline void xlr_build_xfer_msg(struct msgrng_msg *msg, uint64_t src, 
+				uint64_t dest, uint32_t len, int tx_id,
+				int resp_bkt)
+{
+	msg->msg0 = (1ULL << 63) | ((uint64_t)len << 40) | 
+				(src & 0xffffffffffULL);
+	msg->msg1 = (1ULL << 62) | (1ULL << 58) | ((uint64_t)tx_id << 48) |
+			((uint64_t)resp_bkt << 40) | (dest & 0xffffffffffULL);
+}
+
+/* Returns 0 on success, -1 otherwise */
+int xlr_request_dma(uint64_t src, uint64_t dest, uint32_t len)
+{
+	int thr_id, cpu, i;
+	xlr_dma_ctrl_t *ctrl;
+	int tx_id, resp_bkt, seq, ret, err;
+	struct msgrng_msg  msg, r_msg;
+	unsigned long flags;
+
+	thr_id = phoenix_thr_id();
+	cpu = (phoenix_cpu_id() * 4) + thr_id;
+
+	/* Driver does not support multiple descriptor DMA yet */
+	if(len > XLR_MAX_DMA_LEN_PER_DESC) {
+		printk("%s: Cannot do DMA for more than %d bytes\n",
+				__FUNCTION__, XLR_MAX_DMA_LEN_PER_DESC);
+		return -1;
+	}
+	if(xlr_dma_init_done == 0) {
+		printk("%s: XLR DMA engine is not initialized\n", __FUNCTION__);
+		return -1;
+	}
+
+	ctrl = &per_cpu(xlr_dma_ctrl, cpu);
+	spin_lock_irq(&ctrl->q_lock);
+	if(DMA_SLOT_BUSY(ctrl)) {
+		printk("%s: No space to enqueue this request\n", __FUNCTION__);
+		spin_unlock_irq(&ctrl->q_lock);
+		return -1;
+	}
+	tx_id = (thr_id << 8) | ctrl->sequence_number;
+	seq = ctrl->sequence_number;
+	DMA_SLOT_GET(ctrl);
+	spin_unlock_irq(&ctrl->q_lock);
+
+	/* use bucket 0 of each core as the bucket where response will be 
+	   received
+	   */
+	resp_bkt = phoenix_cpu_id() * 8;
+
+	/* Form the DMA simple xfer request and send to Channel 0 */
+	xlr_build_xfer_msg(&msg, src, dest, len, tx_id, resp_bkt);
+	msgrng_access_enable(flags);
+	if(message_send_retry(2, MSGRNG_CODE_DMA, MSGRNG_STNID_DMA_0, &msg)) {
+		printk("
+		Message_send failed: Cannot submit DMA request to engine\n");
+		msgrng_access_disable(flags);
+		spin_lock_irq(&ctrl->q_lock);
+		DMA_SLOT_PUT(ctrl, seq);
+		spin_unlock_irq(&ctrl->q_lock);
+		return -1;
+	}
+	msgrng_access_disable(flags);
+	/* wait for the response here */
+	for(i=0; i < XLR_DMA_RESP_TIMEOUT; i++) {
+		if(DMA_DONE(ctrl, seq)) break;
+
+		udelay(50);
+	}
+	if(i == XLR_DMA_RESP_TIMEOUT) {
+		printk("%s:Did not get response from DMA engine\n", 
+						__FUNCTION__);
+		spin_lock_irq(&ctrl->q_lock);
+		DMA_SLOT_PUT(ctrl, seq);
+		spin_unlock_irq(&ctrl->q_lock);
+		return -1;
+	}
+	/* Do some error checks */
+
+	r_msg.msg0 = DMA_GET_RESP(ctrl, seq);
+	ret = (r_msg.msg0 >> 62) & 0x3;
+	err = (r_msg.msg0 >> 60) & 0x3;
+	if(ret != 0x3) {
+		printk("%s: Bad return code %d from DMA engine\n", __FUNCTION__,
+					ret);
+		return -1;
+	}
+	if(err & 0x2) {
+		printk("%s:DMA engine reported Message format error\n", 
+				__FUNCTION__);
+		return -1;
+	}
+	if(err & 0x1) {
+		printk("%s:DMA engine reported Bus error\n", __FUNCTION__);
+		return -1;
+	}
+	return 0;
+}
+
+static int xlr_init_dma(void)
+{
+	int i;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_DMA_OFFSET);
+	xlr_dma_ctrl_t *ctrl;
+
+	for(i=0; i < NR_CPUS; i++) {
+		ctrl = &per_cpu(xlr_dma_ctrl, i);
+		spin_lock_init(&ctrl->q_lock);
+		ctrl->sequence_number = 0;
+	}
+	/* Register for the Message ring handler */
+	if (register_msgring_handler(TX_STN_DMA,
+				xlr_dma_msgring_handler, NULL)) {
+		printk("Couldn't register DMA msgring handler\n");
+		return -1;
+	}
+	
+	/* Use channel 0 for all DMA */
+	/* Section Size = 4, RMaxCr=4, WMaxCr =4, En=1; */
+	mmio[CH0_CONTROL] = (4<<12) | (4<<8) | (4<<5) | (1<<4);
+
+	/* Configure the bucket sizes */
+	mmio[DMA_MSG_BUCKET0_SIZE] = bucket_sizes.bucket[MSGRNG_STNID_DMA_0];
+	mmio[DMA_MSG_BUCKET1_SIZE] = bucket_sizes.bucket[MSGRNG_STNID_DMA_1];
+	mmio[DMA_MSG_BUCKET2_SIZE] = bucket_sizes.bucket[MSGRNG_STNID_DMA_2];
+	mmio[DMA_MSG_BUCKET3_SIZE] = bucket_sizes.bucket[MSGRNG_STNID_DMA_3];
+
+	/* Configure the DMA credits */
+	for(i=0;i<128;i++) {
+		mmio[DMA_CC_CPU0_0 + i] = cc_table_dma.counters[i>>3][i&0x07];
+	}
+	xlr_dma_init_done = 1;
+	printk("Initialized XLR DMA Controller, Channel 0 \n");
+	return 0;
+}
+
+#ifdef TEST_DMA
+void xlr_dma_test(void)
+{
+	int i;
+	uint8_t *ptr1, *ptr2;
+	unsigned long s_jiffy, e_jiffy;
+
+	ptr1 = (uint8_t *)kmalloc(0x1000, GFP_KERNEL);
+	ptr2 = (uint8_t *)kmalloc(0x1000, GFP_KERNEL);
+	if(!ptr1 || !ptr2){
+		printk("DMA test buffer alloc failed\n");
+		return;
+	}
+	memset(ptr1, 0xa5, 0x1000);
+	s_jiffy = read_c0_count();
+	for(i=0; i < 512; i++) {
+		xlr_request_dma((uint64_t)virt_to_phys(ptr1),
+				(uint64_t)virt_to_phys(ptr2), 0x1000);
+	}
+	e_jiffy = read_c0_count();
+	if(memcmp(ptr1, ptr2, 0x1000)) {
+		printk("DMA Data does not match. Test failed\n");
+	}else
+		printk("DMA Data Matches. Test Successful\n");
+
+	printk("Start time = %lx end time = %lx\n", s_jiffy, e_jiffy);
+	kfree(ptr1);
+	kfree(ptr2);
+}
+#endif
+
+int xlr_dma_init_module(void)
+{
+	int ret;
+
+	ret = xlr_init_dma();
+#ifdef TEST_DMA
+	xlr_dma_test();
+#endif
+	return ret;
+}
+void xlr_dma_exit_module(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_DMA_OFFSET);
+
+	mmio[CH0_CONTROL] = 0;
+}
+
+module_init(xlr_dma_init_module);
+module_exit(xlr_dma_exit_module);
+
+EXPORT_SYMBOL(xlr_request_dma);
Index: linux-2.6.10/arch/mips/rmi/phoenix/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/irq.c
@@ -0,0 +1,383 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <asm/errno.h>
+#include <asm/signal.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/mipsregs.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/debug.h>
+
+/*
+ * These are the routines that handle all the low level interrupt stuff. 
+ * Actions handled here are: initialization of the interrupt map, requesting of
+ * interrupt lines by handlers, dispatching if interrupts to handlers, probing
+ * for interrupt lines 
+ */
+
+extern void *ht_config_base;
+
+__u64 phnx_irq_mask;
+spinlock_t phnx_pic_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned int pic_startup(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+
+	if (!PIC_IRQ_IS_IRT(irq)) return 1;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	/* By default all the interrupts are initialized as level senstive - 
+	 * fix for the PCMCIA flash */
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, 
+					reg | (1<<6)|(1<<30)| (1<<31));
+	 
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return 0;
+}
+
+static void pic_ack(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_reg_t *pci_mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+	phoenix_reg_t *ht_mmio  = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+	unsigned long i, flags;
+	phoenix_reg_t reg;
+
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	/*Interrupt (level sensitive )acknowledge method for the PCMCIA flash */
+
+	if (irq == PIC_PCMCIA_IRQ ) {
+		reg = *(unsigned char *)(PIC_PCMCIA_STATUS_1);
+		reg = *(unsigned int *)(PIC_PCMCIA_STATUS_2);
+		for ( i = 0; i<0x100; i++)
+			;
+		*(unsigned int *)(PIC_PCMCIA_STATUS_2) = reg ;
+		for ( i = 0; i<0x1000; i++)
+			;
+		reg = *(unsigned int *)(PIC_PCMCIA_STATUS_2);
+
+	}
+
+	/* Deal with All PCI-Interrupts.. Brigde ACK */
+	if (irq == PIC_PCIX_IRQ)
+		phoenix_read_reg(pci_mmio, (0x140 >> 2));
+
+	if (irq == 23) {
+		/* Clear INT Status */
+		phoenix_read_reg (ht_mmio, (0x700 >> 2)); 
+        
+		/* 
+		   Generating EOI.
+		   On B0 Silicon, the EOI broadcast don't work. Hence, we clear the
+		   interrupt by directly writing to PLX's Configuration Space. For
+		   that, first we setup the offset value in register 0xB8
+		   (Interrupt Discovery Configuration, bits 23-16). Then we
+		   clear the interrupt by setting the IRR bit (bit 63) in register
+		   0xBC (IRDR). 
+
+		   Note that, this technique works only because we have one device
+		   on the HT (PLX bridge). If more devices are added to HT, we have
+		   to use the EOI broadcast.
+
+		   NOTE: We need to do the EOI for all interrupts (INT A, B, C and D).
+		   Bridge Cards, if plugged into the slot, may re-route interrupts.
+		   e.g. Intel Bridge 31154 eval board re-routes INTA of the endpoint
+		   to INTC of PLX.
+	  
+		   Since we only have PLX in our HT, the PLX's bus/device/function
+		   value is 0/1/0. Hence, its configuration space address is 
+	            
+		   ht_config_base + (device <<11) + cfg_offset.
+
+		   Since CPU is Big Endian, we need to do swapping as well.
+		   For e.g. to generate EOI for INTA, the config space address is 
+		   ht_config_base + SWAP32((1 << 11) + 0xb8) = ht_config_base + 0x8b8.
+		   and the offset value is SWAP32(0x8011c008).
+		   See PLX manual v1.0 pp 3-19 for more details on how to derive
+		   the offset value. And to clear the interrupt, write SWAP32(0x8000000)
+		   to (ht_config_base + SWAP32((1<<11) + 0xbc).
+
+		   TODO: With B1 silicon, the EOI broadcast should work. Should thrash
+		   this story and the code then.
+		*/
+
+		/* Generate EOI for INTA */
+		*(unsigned long *)(ht_config_base + 0x008b8) = 0x08c01180; 
+		*(unsigned long *)(ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTB */
+		*(unsigned long *)(ht_config_base + 0x008b8) = 0x08c01380; 
+		*(unsigned long *)(ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTC */
+		*(unsigned long *)(ht_config_base + 0x008b8) = 0x08c01580; 
+		*(unsigned long *)(ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTD */
+		*(unsigned long *)(ht_config_base + 0x008b8) = 0x08c01780; 
+		*(unsigned long *)(ht_config_base + 0x008bc) = 0x00000080;
+	}
+
+
+	/* If edge triggered IRQ, ack it immediately, else when the device
+	 * interrupt condition is cleared, we may lose interrupts 
+	 */
+	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK, 
+					(1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_end(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	/* If level triggered, ack it after the device condition is cleared */
+	if (! PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK, 
+						(1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_shutdown(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+	  
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, 
+					(reg & ~(1<<31)));
+	  
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static void pic_set_affinity(unsigned int irq, cpumask_t dest)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	unsigned long mask = dest.bits[0];
+
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, mask);
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static struct hw_interrupt_type phnx_pic = {
+  .typename     =          "Phoenix-PIC",
+  .startup      =          pic_startup,
+  .shutdown     =          pic_shutdown,
+  .enable       =          (void (*)(unsigned int))pic_startup,
+  .disable      =          pic_shutdown,
+  .ack          =          pic_ack,
+  .end          =          pic_end,
+  .set_affinity =          pic_set_affinity
+};
+
+static unsigned int rsvd_pic_handler_1_1(unsigned int irq)
+{
+	rmi_dbg_msg("Requesting a reserved irq (%d)??", irq);
+	return -EBUSY;
+}
+
+static void rsvd_pic_handler_1(unsigned int irq)
+{
+	rmi_dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static void rsvd_pic_handler_2(unsigned int irq, cpumask_t mask)
+{
+	rmi_dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static struct hw_interrupt_type phnx_rsvd_pic = {
+  .typename     =          "Phoenix-RSVD-PIC",
+  .startup      =          rsvd_pic_handler_1_1,
+  .shutdown     =          rsvd_pic_handler_1,
+  .enable       =          rsvd_pic_handler_1,
+  .disable      =          rsvd_pic_handler_1,
+  .ack          =          rsvd_pic_handler_1,
+  .end          =          rsvd_pic_handler_1,
+  .set_affinity =          rsvd_pic_handler_2
+};
+
+static irqreturn_t phnx_rsvd_irq_handler(int irq, void *dev_id, 
+			struct pt_regs *regs)
+{
+	rmi_dbg_msg("handler for reserved irq %d\n", irq);
+	return IRQ_NONE;
+}
+
+static struct irqaction phnx_rsvd_action = {
+  .handler = phnx_rsvd_irq_handler,
+  .flags = 0,
+  .mask = CPU_MASK_NONE,
+  .name = "phnx_rsvd_action", 
+  .dev_id = 0,
+  .next = 0
+};
+
+void __init init_phoenix_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0,
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &phnx_pic;
+	}
+
+#ifdef CONFIG_SMP
+	irq_desc[IRQ_IPI_SMP_FUNCTION].handler = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &phnx_rsvd_action;
+
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].handler = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &phnx_rsvd_action;
+
+	phnx_irq_mask |= 
+		((1ULL<<IRQ_IPI_SMP_FUNCTION)|(1ULL<<IRQ_IPI_SMP_RESCHEDULE));
+#endif
+
+	/* msgring interrupt */
+	irq_desc[IRQ_MSGRING].handler = &phnx_rsvd_pic;
+	irq_desc[IRQ_MSGRING].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL<<IRQ_MSGRING);
+
+	/* msgring timeout interrupt */
+	irq_desc[PIC_TIMER_0_IRQ].handler = &phnx_rsvd_pic;
+	irq_desc[PIC_TIMER_0_IRQ].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL<<PIC_TIMER_0_IRQ);
+
+	/* timekeeping timer interrupt for cpu 0 */
+	irq_desc[PIC_TIMER_7_IRQ].handler = &phnx_rsvd_pic;
+	irq_desc[PIC_TIMER_7_IRQ].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL<<PIC_TIMER_7_IRQ);
+
+	/* profiling/process accounting timer interrupt for non-zero cpus */
+	irq_desc[IRQ_TIMER].handler = &phnx_rsvd_pic;
+	irq_desc[IRQ_TIMER].action = &phnx_rsvd_action;
+
+	/* The driver installs a handler so, don't reserve it */
+	phnx_irq_mask |= (1ULL<<IRQ_DUMMY_UART);
+
+	/* unmask all PIC related interrupts. If no handler is installed by the 
+	 * drivers, it'll just ack the interrupt and return 
+	 */
+	for(i=PIC_IRT_FIRST_IRQ;i<=PIC_IRT_LAST_IRQ;i++) 
+		phnx_irq_mask |= (1ULL << i);
+	
+}
+ 
+extern void phoenix_timer_interrupt(struct pt_regs *regs, int irq);
+void do_phnx_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+	/* first process timer interrupts */
+	if (irq == IRQ_TIMER || irq == PIC_TIMER_7_IRQ) {
+		phoenix_timer_interrupt(regs, irq);
+		return;
+	}
+
+#ifdef CONFIG_SMP
+	if  (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
+		phoenix_ipi_handler(irq, regs);
+		return;
+	}
+#endif
+	if (irq == IRQ_MSGRING || irq == PIC_TIMER_0_IRQ) 
+		phnx_msgring_int_handler(irq, regs);
+	else 
+		do_IRQ(irq, regs);
+}
+
+extern void phoenix_smp_time_init(void);
+void __init phoenix_smp_init(void)
+{
+	/* Set up kseg0 to be cachable coherent */
+	change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
+
+	/* set interrupt mask for non-zero cpus */
+	write_64bit_cp0_eimr(phnx_irq_mask | (1<<IRQ_TIMER));
+
+	phoenix_smp_time_init();
+}
+
+void __init arch_init_irq(void)
+{
+	/* Defined in arch/mips/rmi/phoenix/irq_handler.S */
+	extern void phoenix_irq_handler(void);
+
+	/* TODO:
+	 * Initialize the irq registers on the PIC to route
+	 * interrupts to appropriate pins
+	 */
+	
+	/* Initialize the irq descriptors */
+	init_phoenix_irqs();
+
+	write_64bit_cp0_eimr(phnx_irq_mask);
+
+	set_except_vector(0, phoenix_irq_handler);
+
+}
+
Index: linux-2.6.10/arch/mips/rmi/phoenix/irq_handler.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/irq_handler.S
@@ -0,0 +1,94 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#include <linux/config.h>
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>	
+#include <asm/stackframe.h>
+
+#include <asm/rmi/interrupt.h>
+
+	.text
+	.set	push
+	.set	noreorder
+	.set	mips64
+	.align	5
+	NESTED(phoenix_irq_handler, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+
+	/* Read EIRR :	 */
+	/* dmfc0 s0, eirr */
+	.word   0x40304806        
+		
+	/* If no interrupts, return */
+	beqz    s0, _done
+	nop
+
+	/* Check for IP7 (Count - Compare interrupt) specially */
+	andi    s1, s0, (1 << IRQ_TIMER)
+	beqz    s1, 1f
+	nop
+	
+	/* No need to clear the EIRR here. the handler is gonna
+	 *  write to compare which clears eirr also
+	 */
+	
+	/* phoenix_timer_interrupt((a0 = sp)) */
+	li	a1, IRQ_TIMER
+	move    a0, sp
+	jal     phoenix_timer_interrupt
+	nop
+	j       ret_from_irq
+	nop
+
+	/* All other interrupts */
+1:
+	/* retrieve the highest priority interrupt */
+	.word   0x72118824        /* dclz s1 s0 */
+	dsubu   a0, zero, s1
+	daddiu  a0, a0, 63
+	/* a0 now has irq# */
+	move    a1, sp
+	/* a1 now has sp */
+
+	/* first things first :	clear the irq in eirr
+	*  note that setting a bit in eirr actually clears it
+	*/
+	li      s0, 1
+	dsllv   s0, s0, a0
+	.word   0x40b04806        /* dmtc0 s0, eirr */  
+
+	/* a0 = irq, a1 = sp (regs) */
+	jal	do_phnx_IRQ
+	nop
+
+_done:		
+	j        ret_from_irq
+	 nop
+
+	.set pop
+	END(phoenix_irq_handler)
Index: linux-2.6.10/arch/mips/rmi/phoenix/on_chip.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/on_chip.c
@@ -0,0 +1,588 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/sim.h>
+
+unsigned long phoenix_io_base = (unsigned long)(DEFAULT_PHOENIX_IO_BASE);
+
+#define MSGRNG_CC_INIT_CPU_DEST_0(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_0_REG, cc_table_cpu_##cpu.counters[0][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_1(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_1_REG, cc_table_cpu_##cpu.counters[1][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_2(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_2_REG, cc_table_cpu_##cpu.counters[2][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_3(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_3_REG, cc_table_cpu_##cpu.counters[3][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_4(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_4_REG, cc_table_cpu_##cpu.counters[4][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_5(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_5_REG, cc_table_cpu_##cpu.counters[5][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_6(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_6_REG, cc_table_cpu_##cpu.counters[6][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_7(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_7_REG, cc_table_cpu_##cpu.counters[7][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_8(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_8_REG, cc_table_cpu_##cpu.counters[8][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_9(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_9_REG, cc_table_cpu_##cpu.counters[9][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_10(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_10_REG, cc_table_cpu_##cpu.counters[10][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_11(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_11_REG, cc_table_cpu_##cpu.counters[11][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_12(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_12_REG, cc_table_cpu_##cpu.counters[12][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_13(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_13_REG, cc_table_cpu_##cpu.counters[13][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_14(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_14_REG, cc_table_cpu_##cpu.counters[14][7], 7 ); \
+} while(0)
+
+#define MSGRNG_CC_INIT_CPU_DEST_15(cpu) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_15_REG, cc_table_cpu_##cpu.counters[15][7], 7 ); \
+} while(0)
+
+/* Initialized CC for cpu 0 to send to all buckets at 0-7 cpus */
+#define MSGRNG_CC_INIT_CPU(cpu) \
+do { \
+  MSGRNG_CC_INIT_CPU_DEST_0(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_1(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_2(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_3(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_4(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_5(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_6(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_7(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_8(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_9(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_10(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_11(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_12(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_13(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_14(cpu); \
+  MSGRNG_CC_INIT_CPU_DEST_15(cpu); \
+} while (0)
+
+#define MSGRNG_BUCKETSIZE_INIT_CPU(base) \
+do { \
+  msgrng_write_bucksize(0, bucket_sizes.bucket[base+0]); \
+  msgrng_write_bucksize(1, bucket_sizes.bucket[base+1]); \
+  msgrng_write_bucksize(2, bucket_sizes.bucket[base+2]); \
+  msgrng_write_bucksize(3, bucket_sizes.bucket[base+3]); \
+  msgrng_write_bucksize(4, bucket_sizes.bucket[base+4]); \
+  msgrng_write_bucksize(5, bucket_sizes.bucket[base+5]); \
+  msgrng_write_bucksize(6, bucket_sizes.bucket[base+6]); \
+  msgrng_write_bucksize(7, bucket_sizes.bucket[base+7]); \
+} while(0);
+
+
+void phoenix_msgring_cpu_init(void)
+{
+  int id = cpu_logical_map(smp_processor_id());
+	unsigned long flags;
+
+	/* if not thead 0 */
+	if ((id & 0x03)!=0) return;
+
+	prom_dbg_msg("Initializing message ring for cpu_%d\n", id);
+
+	msgrng_flags_save(flags);
+	          
+	/* Message Stations are shared among all threads in a cpu core
+	 * Assume, thread 0 on all cores are always active when more than
+	 * 1 thread is active in a core
+	 */
+	if (id == 0) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(0);
+		MSGRNG_CC_INIT_CPU(0);
+	} else if (id == 4) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(8);
+		MSGRNG_CC_INIT_CPU(1);
+	} else if (id == 8) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(16);
+		MSGRNG_CC_INIT_CPU(2);
+	} else if (id == 12) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(24);
+		MSGRNG_CC_INIT_CPU(3);
+	} else if (id == 16) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(32);
+		MSGRNG_CC_INIT_CPU(4);
+	} else if (id == 20) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(40);
+		MSGRNG_CC_INIT_CPU(5);
+	} else if (id == 24) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(48);
+		MSGRNG_CC_INIT_CPU(6);
+	} else if (id == 28) {
+		MSGRNG_BUCKETSIZE_INIT_CPU(56);
+		MSGRNG_CC_INIT_CPU(7);
+	}  
+
+	msgrng_flags_restore(flags);
+}
+
+
+struct tx_stn_handler {
+  void (*action)(int, int, int, int, struct msgrng_msg *, void *);
+  void *dev_id;
+};
+
+struct tx_stn {
+  struct tx_stn_handler handler;
+};
+
+static struct tx_stn tx_stns[MAX_TX_STNS];
+
+static int rxstn_to_txstn_map[128] = {
+  [0 ... 7] = TX_STN_CPU_0,
+  [8 ... 15] = TX_STN_CPU_1,
+  [16 ... 23] = TX_STN_CPU_2,
+  [24 ... 31] = TX_STN_CPU_3,
+  [32 ... 39] = TX_STN_CPU_4,
+  [40 ... 47] = TX_STN_CPU_5,
+  [48 ... 55] = TX_STN_CPU_6,
+  [56 ... 63] = TX_STN_CPU_7,
+  [64 ... 95] = TX_STN_INVALID,
+  [96 ... 103] = TX_STN_GMAC,
+  [104 ... 107] = TX_STN_DMA,
+  [108 ... 111] = TX_STN_INVALID,
+  [112 ... 113] = TX_STN_XGS_0,
+  [114 ... 115] = TX_STN_XGS_1,
+  [116 ... 119] = TX_STN_INVALID,
+  [120 ... 127] = TX_STN_SEC
+};
+
+static spinlock_t msgrng_lock;
+static rwlock_t phnx_msgrng_reg_lock = RW_LOCK_UNLOCKED;
+static phnx_atomic_t msgring_int_enabled;
+
+static int    msgring_pop_num_buckets;
+static __u32  msgring_pop_bucket_mask;
+static int    msgring_int_type;
+static int    msgring_watermark_count;
+static __u32  msgring_thread_mask;
+
+struct xlr_user_mac_config xlr_user_mac;
+__u32 rmios_user_mac_thr_mask = 0;
+
+void phnx_msgring_config(void)
+{
+	if (xlr_user_mac_rmios()) {
+		msgring_int_type = 0x2;
+		msgring_pop_num_buckets = 4;
+		msgring_pop_bucket_mask = 0x0f;
+	} else {
+		msgring_int_type = 0x02;
+		msgring_pop_num_buckets = 8;
+		msgring_pop_bucket_mask = 0xff;
+	}
+
+	msgring_watermark_count = 1;
+	msgring_thread_mask = 0x01;
+/* 	printk("[%s]: int_type = 0x%x, pop_num_buckets=%d, pop_bucket_mask=%x" */
+/* 	       "watermark_count=%d, thread_mask=%x\n", __FUNCTION__, */
+/* 	       msgring_int_type, msgring_pop_num_buckets, msgring_pop_bucket_mask, */
+/* 	       msgring_watermark_count, msgring_thread_mask); */
+}
+
+
+__u32 msgrng_msg_cycles = 0;
+void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
+{
+	unsigned long mflags;
+	int bucket=0;
+	int size=0, code=0, rx_stid=0, tx_stid=0;
+	struct msgrng_msg msg;
+	struct tx_stn_handler *handler=0;
+	unsigned int bucket_empty_bm = 0;
+	unsigned int status=0;
+	
+	if (irq == PIC_TIMER_0_IRQ) {
+		phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+
+		/* msgring timeout interrupt */
+		phnx_inc_counter(MSGRNG_PIC_INT);
+		/* ack the pic */
+		phoenix_write_reg(mmio, PIC_INT_ACK, 
+				(1 << (PIC_TIMER_0_IRQ - PIC_IRQ_BASE) ));
+#ifdef CONFIG_PHOENIX_USER_MAC
+		if(xlr_hybrid_user_mac())  phoenix_user_mac_update_time();
+#endif
+	}
+	else {
+		/* normal message ring interrupt */
+		phnx_inc_counter(MSGRNG_INT);
+	}
+
+	irq_enter();
+
+	msgrng_flags_save(mflags);
+
+	/* First Drain all the high priority messages */
+	for(;;) {
+		bucket_empty_bm = (msgrng_read_status() >> 24) & msgring_pop_bucket_mask;
+		if (bucket_empty_bm == msgring_pop_bucket_mask) break; /* all buckets empty */
+
+		for(bucket=0;bucket<msgring_pop_num_buckets;bucket++) {      
+			if ((bucket_empty_bm & (1 << bucket))/*empty*/) 
+				continue;
+
+			status = message_receive(bucket, &size, &code, 
+					&rx_stid, &msg);
+			if (status) continue;
+      
+			phnx_inc_counter(MSGRNG_MSG);
+			msgrng_msg_cycles = read_c0_count();
+
+			tx_stid = rxstn_to_txstn_map[rx_stid];
+
+			read_lock(&phnx_msgrng_reg_lock);
+			handler = &tx_stns[tx_stid].handler;
+			if (!handler->action) {
+				printk("[%s]: No Handler for message from"
+					"stn_id=%d, dropping message\n", 
+	       				__FUNCTION__, tx_stid);
+			}
+			else {
+				(handler->action)(bucket, size, code, 
+					rx_stid, &msg, handler->dev_id);
+			}
+			read_unlock(&phnx_msgrng_reg_lock);
+		}
+	}
+  
+	phnx_set_counter(MSGRNG_EXIT_STATUS, msgrng_read_status());
+
+	msgrng_flags_restore(mflags);
+
+	irq_exit();
+}
+
+#define MSGRING_INT_TYPE          0x02
+#define MSGRING_WATERMARK_COUNT   1
+#define MSGRING_THREAD_MASK       0x01
+static void enable_msgring_int(void *info)
+{
+	unsigned long flags = 0, mflags=0;
+
+	msgrng_access_save(&msgrng_lock, flags, mflags);
+	/* enable the message ring interrupts */
+	msgrng_write_config((msgring_watermark_count<<24)|(IRQ_MSGRING<<16)
+			    |(msgring_thread_mask<<8)|msgring_int_type);
+	msgrng_access_restore(&msgrng_lock, flags, mflags);  
+}
+
+void unregister_msgring_handler(int major, void *dev_id)
+{
+	struct tx_stn_handler *handler = 0;
+	unsigned long flags = 0;
+
+	/* Check if the message station is valid, if not return error */
+	if (major >= MAX_TX_STNS) return ;
+
+	write_lock_irqsave(&phnx_msgrng_reg_lock, flags);
+	handler = &tx_stns[major].handler;
+
+	handler->action = NULL;
+	handler->dev_id = NULL;
+	write_unlock_irqrestore(&phnx_msgrng_reg_lock, flags);
+}
+extern spinlock_t phnx_pic_lock;
+int register_msgring_handler(int major, 
+	     void (*action)(int, int,int,int,struct msgrng_msg *, void *),
+	     void *dev_id)
+{
+	struct tx_stn_handler *handler = 0;
+	int ret = 1;
+	unsigned long flags = 0;
+
+	if (major >= MAX_TX_STNS) return ret;
+
+	phnx_msgring_config();
+
+	/* Check if the message station is valid, if not return error */
+	write_lock_irqsave(&phnx_msgrng_reg_lock, flags);
+
+	handler = &tx_stns[major].handler;
+
+	if (handler->action) goto out;
+
+	handler->action = action;
+	handler->dev_id = dev_id;
+
+	ret = 0;
+ out:
+	write_unlock_irqrestore(&phnx_msgrng_reg_lock, flags);
+	
+	if (!ret && phnx_test_and_set(&msgring_int_enabled)) {
+		uint32_t hard_cpu_online_map = 0;
+		phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+		int i=0;
+		__u32 msgring_global_thread_mask=0;
+
+		/* configure the msgring interrupt on all cpus */
+		on_each_cpu(enable_msgring_int, 0, 1, 1);
+
+		/* Configure PIC to deliver msgring interrupt for timeouts */
+		for (i=0;i<32;i++) {
+			if (cpu_isset(i, cpu_online_map)) 
+				hard_cpu_online_map |= (1<<cpu_logical_map(i));
+		}
+		for(i=0;i<8;i++) {
+			msgring_global_thread_mask |= (msgring_thread_mask << (i<<2));
+		}
+
+		printk("[%s]: cpu_online_map = %lx, hard_cpu_online_map=%x,"
+			       "msgring_global_thread_mask=%x\n",
+	   		__FUNCTION__, (unsigned long)cpu_online_map.bits[0], 
+			hard_cpu_online_map, msgring_global_thread_mask);
+	  
+		/* take an interrupt every 66000 pic cycles(66MHz) i.e 1ms 
+		* it is round robin across 8 cpus cores, so each cpu 
+		* (assuming all 8 cpu cores are active) takes an interrupt 
+		* every 8ms
+		*/
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_0, 66000);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_1, 0);
+		phoenix_write_reg(mmio, PIC_IRT_0_TIMER_0, 
+		      (hard_cpu_online_map & msgring_global_thread_mask));
+		phoenix_write_reg(mmio, PIC_IRT_1_TIMER_0, 
+				(1<<31)|(0<<30)|(1<<6)|(PIC_TIMER_0_IRQ));
+		pic_update_control(1<<(8+0));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+	
+	return ret;
+}
+
+static void pic_init(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	int i=0;
+	int level;
+
+	prom_dbg_msg("Initializing PIC...\n");
+	for(i=0; i<PIC_NUM_IRTS; i++) {
+		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
+
+		/* Bind all PIC irqs to cpu 0 */
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + i, 0x01);
+
+		/* Use local scheduling and high polarity for all IRTs 
+		* Invalidate all IRTs, by default
+		*/
+		phoenix_write_reg(mmio, PIC_IRT_1_BASE + i, 
+				(level<<30)|(1<<6)|(PIC_IRQ_BASE + i));
+	}
+	
+}
+
+atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS] __cacheline_aligned;
+
+void on_chip_init(void)
+{
+	int i=0, j=0;
+
+	msgring_int_enabled.value = 0;
+
+	phnx_msgring_config();
+	pic_init(); 
+
+	phoenix_msgring_cpu_init();
+
+	for(i=0;i<NR_CPUS;i++)
+		for(j=0;j<PHNX_MAX_COUNTERS;j++) 
+			atomic_set(&phnx_counters[i][j], 0);
+
+	printk("&phnx_counters = 0x%lx, sizeof(phnx_counters) = 0x%x\n", 
+	 (unsigned long)phnx_counters, (unsigned int)sizeof(phnx_counters));
+}
+
Index: linux-2.6.10/arch/mips/rmi/phoenix/smp.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/smp.c
@@ -0,0 +1,108 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <asm/addrspace.h>
+#include <asm/smp.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/msgring.h>
+
+/* ipi statistics counters for debugging */
+__u32 ipi_3_counter_tx[NR_CPUS][NR_CPUS];
+__u32 ipi_3_counter_rx[NR_CPUS];
+
+extern void save_epc(unsigned long *epc);
+extern void smp_call_function_interrupt(void);
+extern void phoenix_smp_time_init(void);
+
+static int phoenix_ipi_stats[NR_CPUS];
+static unsigned long phoenix_ipi_epc[NR_CPUS];
+
+void core_send_ipi(int logical_cpu, unsigned int action)
+{
+	int cpu = cpu_logical_map(logical_cpu);
+	__u32 ipi = 0;
+	__u32 tid = cpu & 0x3;
+	__u32 pid = (cpu >> 2) & 0x07;
+
+	if (action & SMP_CALL_FUNCTION) {
+		ipi = (tid << 16) | (pid << 20) | IRQ_IPI_SMP_FUNCTION;
+#ifdef IPI_PRINTK_DEBUG
+		printk("[%s]: cpu_%d sending ipi_3 to cpu_%d \t\t\t[->%u] \n", 
+				__FUNCTION__, smp_processor_id(), cpu, 
+				ipi_3_counter_tx[smp_processor_id()][cpu]+1);
+#endif
+		++ipi_3_counter_tx[smp_processor_id()][cpu]; 
+
+	}
+	else if (action & SMP_RESCHEDULE_YOURSELF) {
+		ipi = (tid << 16) | (pid << 20) | IRQ_IPI_SMP_RESCHEDULE;
+#ifdef IPI_PRINTK_DEBUG
+		printk("[%s]: cpu_%d sending ipi_4 to cpu_%d\n", __FUNCTION__,
+			smp_processor_id(), cpu);     
+#endif
+	}
+	else
+		BUG();
+	
+	pic_send_ipi(ipi);
+}
+
+extern __u64 phnx_irq_mask;
+
+void phoenix_smp_finish(void)
+{
+	phoenix_msgring_cpu_init();
+}
+
+void phoenix_ipi_handler(int irq, struct pt_regs *regs)
+{
+	phoenix_ipi_stats[smp_processor_id()]++;
+	save_epc(&phoenix_ipi_epc[smp_processor_id()]);
+
+	if (irq == IRQ_IPI_SMP_FUNCTION) {
+#ifdef IPI_PRINTK_DEBUG
+		printk("[%s]: cpu_%d processing ipi_%d [->%u]\n", __FUNCTION__, 
+	   		smp_processor_id(), irq, 
+			ipi_3_counter_rx[smp_processor_id()]++);
+#endif
+		++ipi_3_counter_rx[smp_processor_id()];
+		smp_call_function_interrupt();
+	}
+	else {
+#ifdef IPI_PRINTK_DEBUG
+		printk("[%s]: cpu_%d processing ipi_%d\n", __FUNCTION__, 
+			smp_processor_id(), irq);
+#endif
+
+		/* Announce that we are for reschduling */
+		set_need_resched();
+
+	}
+	phoenix_ipi_stats[smp_processor_id()]--;
+}
Index: linux-2.6.10/arch/mips/rmi/phoenix/time.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/time.c
@@ -0,0 +1,183 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/interrupt.h>
+#include <asm/rmi/mips-exts.h>
+
+extern spinlock_t phnx_pic_lock;
+
+extern void ll_local_timer_interrupt(int irq, struct pt_regs *regs);
+
+static unsigned long phoenix_timer_stats[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_diff[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_count[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_epc[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_cpu[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_gettimeoffset[NR_CPUS] ____cacheline_aligned;
+extern unsigned int mips_hpt_frequency;
+unsigned int xlr_cycles_per_jiffy;
+#ifdef CONFIG_PHOENIX_RAW_PERF_COUNTERS
+extern void phnx_read_local_perf_ctrs(void);
+extern void phnx_read_global_perf_ctrs(void);
+#endif
+void save_epc(unsigned long *epc)
+{
+	__asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			"mfc0 %0, $14\n"
+			".set pop\n"
+			: "=r" (*epc) );
+}
+
+
+void xlr_timer_ack(void)
+{
+	write_c0_count(0);
+	write_c0_compare(xlr_cycles_per_jiffy);
+	write_c0_count(0);
+}
+
+void phoenix_timer_interrupt(struct pt_regs *regs, int irq)
+{
+	int cpu = smp_processor_id();
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+
+	if (irq != PIC_TIMER_7_IRQ && irq != IRQ_TIMER) {
+		printk("cpu_%d: bad timer irq = %x\n", cpu, irq);
+		BUG();
+	}
+
+	/* PIC timer is used for cpu 0 */
+	if (cpu == 0 && irq == IRQ_TIMER) {write_c0_compare(0); return;}
+
+	phoenix_timer_stats[cpu]++;
+	phoenix_timer_diff[cpu] = read_c0_count() - phoenix_timer_count[cpu];
+	phoenix_timer_count[cpu] = read_c0_count();
+	save_epc(&phoenix_timer_epc[cpu]);
+	phoenix_timer_cpu[cpu] += irq;
+	
+	if (cpu == 0) {
+	  /* ack the pic */
+		phoenix_write_reg(mmio, PIC_INT_ACK, 
+			  (1 << (PIC_TIMER_7_IRQ - PIC_IRQ_BASE) ));
+	
+#ifdef CONFIG_PHOENIX_RAW_PERF_COUNTERS
+		/* Collect Bridge, DRAM and L2 cache counter */
+		phnx_read_global_perf_ctrs();
+#endif
+		/* global timer interrupt */
+		ll_timer_interrupt(irq, regs);
+	}  else {
+		xlr_timer_ack();
+		ll_local_timer_interrupt(irq, regs);
+	}
+#ifdef CONFIG_PHOENIX_RAW_PERF_COUNTERS
+	/* Collect COP0 perf counters which are per vCPU */
+	phnx_read_local_perf_ctrs();
+#endif
+	
+	
+}
+
+void phoenix_smp_time_init(void)
+{
+	xlr_cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
+	/* non-zero cpus use count/compare as the timer */
+	xlr_timer_ack();
+}
+
+#define PIC_CLKS_PER_SEC 66000000ULL
+// can't do floating in the kernel, so use 64 as an approximation 
+#define PIC_CLKS_PER_USEC 64 //(PIC_CLKS_PER_SEC / 1000000)
+#define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
+
+extern unsigned long (*do_gettimeoffset)(void);
+/* 
+ * this routine returns the time duration since the last timer interrupt
+ * in micro seconds
+ * irrespective of whether gettimeofday is called on cpu 0 or on a non-zero cpu, 
+ * it gets the usecs from the last timer interrupt on cpu 0 which uses the PIC
+ * timer interrupt. the count/compare interrupt on non-zero cpu is only for process
+ * accounting and such but not time keeping
+ */ 
+unsigned long phoenix_gettimeoffset(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	__u32 counter = 0;
+	__u32 maxval = PIC_CLKS_PER_TIMER_TICK;
+	
+	/* PIC TIMERs are 64-bit counters but the timeout values are small
+	 * enough to fit in 32-bit, so use only lower 32-bit regs
+	 */
+	counter = phoenix_read_reg(mmio, PIC_TIMER_7_COUNTER_0);
+
+	/* store the # of pic clks since last interrupt in counter */
+	counter = (maxval - counter) / PIC_CLKS_PER_USEC;
+
+	phoenix_timer_gettimeoffset[smp_processor_id()] = counter;
+
+	return counter;
+}
+
+void phoenix_timer_setup(void)
+{
+	__u64 maxval = PIC_CLKS_PER_TIMER_TICK;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags = 0;
+	int cpu = (phoenix_cpu_id()<<2)|phoenix_thr_id();
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+	phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_0, (maxval & 0xffffffff));
+	phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_1, 
+				(maxval >> 32) & 0xffffffff);
+	phoenix_write_reg(mmio, PIC_IRT_0_TIMER_7, (1 << cpu));
+	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_7, 
+			(1<<31)|(0<<30)|(1<<6)|(PIC_TIMER_7_IRQ));
+	/* Enable the timer */
+	pic_update_control(1<<(8+7));
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	do_gettimeoffset = phoenix_gettimeoffset;
+
+	printk("%s: phoenix_timer_stats = %p, phoenix_timer_diff = %p,"
+		"phoenix_timer_count = %p, phoenix_timer_epc = %p," 
+		"phoenix_timer_cpu = %p, phoenix_timer_gettimeoffset = %p\n",
+	 	__FUNCTION__, phoenix_timer_stats, phoenix_timer_diff, 
+		phoenix_timer_count, phoenix_timer_epc,
+	 	phoenix_timer_cpu, phoenix_timer_gettimeoffset);
+}
Index: linux-2.6.10/arch/mips/rmi/ptr/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/ptr/Makefile
@@ -0,0 +1,7 @@
+
+obj-y                   = setup.o 
+
+obj-$(CONFIG_SMP)      += smp.o smpboot.o
+
+EXTRA_AFLAGS := $(CFLAGS)
+
Index: linux-2.6.10/arch/mips/rmi/ptr/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/ptr/setup.c
@@ -0,0 +1,486 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+/*
+ * Setup code for the RMI's PTR board 
+ */
+
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <linux/interrupt.h>
+#include <asm/atomic.h>
+
+#include <asm/bootinfo.h>
+#include <asm/rmi/sim.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/phnx_mmap.h>
+#include <linux/serial.h>
+#include <asm/serial.h>
+#include <linux/serial_core.h>
+
+__u8 phoenix_base_mac_addr[6];
+
+void *phoenix_psb_shm = 0;
+unsigned int phoenix_psb_shm_size = 0;
+
+extern void phnx_msgring_config(void);
+	
+#ifndef CONFIG_PHOENIX_PSB
+volatile struct sim_control_struct   *siminfo;
+volatile struct smp_boot_info_struct *smp_boot_info;
+#endif
+
+#ifdef CONFIG_PHOENIX_PSB
+struct psb_info psb_prom_info; /* Bootloader prom_info is saved here */
+struct psb_info *prom_info = 0;
+static struct psb_info default_prom_info = {
+	.boot_level              = 2,
+	.io_base                 = DEFAULT_PHOENIX_IO_BASE,
+	.output_device           = 2,
+	.cpu_online_map          = 0x01,
+	.magic_dword             = (((__u64)0x900dbeef << 32)|PSB_INFO_VERSION),
+	.size                    = sizeof(struct psb_info),
+	.mac_addr                = 0x000102030405,
+	.cpu_frequency           = 1200000000  
+};
+static int sanity_check_prom_info(struct psb_info *info)
+{
+	if (!prom_info) return 0;
+  
+	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef) return 0;
+	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION) return 0;
+	if (prom_info->size < sizeof(struct psb_info)) return 0;
+
+	return 1;
+}
+#endif
+
+const char *DEFAULT_BOOT_PARAMS = 
+
+#ifdef CONFIG_PHOENIX_RMIOS
+"mem=176m@16m "
+#else
+//"mem=380m@16m "
+#endif
+"console=ttyS0,38400 console=tty0";
+#ifdef CONFIG_PHOENIX_PSB
+
+#ifdef CONFIG_PHOENIX_RMIOS
+#define DEFAULT_RAM_START ((unsigned long)4<<20)
+#define DEFAULT_RAM_SIZE  ((unsigned long)316<<20)
+#define PSB_START ((unsigned long)320<<20)
+#define PSB_SIZE ((unsigned long)64<<20)
+#else
+#define DEFAULT_RAM_SIZE  ((unsigned long)192<<20)
+#define DEFAULT_RAM_START ((unsigned long)1<<20)
+#endif
+
+#else
+
+#define DEFAULT_RAM_SIZE  ((unsigned long)128<<20)
+#define DEFAULT_RAM_START ((unsigned long)1<<20)
+
+#endif
+
+const char *get_system_type(void)
+{
+#ifdef CONFIG_PHOENIX_RTL
+	return "RMI Phoenix RTL";
+#else
+	return "RMI Phoenix Test Rig";
+#endif
+}
+
+extern void prom_reenter(unsigned long sp, unsigned long gp, unsigned long fn);
+
+#ifdef CONFIG_SMP
+atomic_t cpus_rebooted = ATOMIC_INIT(0);
+#endif
+
+#define GPIO_SWRESET_REG 8
+static void ptr_linux_exit(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_GPIO_OFFSET);
+
+	/* trigger a chip reset */
+	phoenix_write_reg(mmio, GPIO_SWRESET_REG, 1);
+	for(;;) cpu_wait();
+}
+
+void __init bus_error_init(void)
+{
+}
+
+int xlr_hybrid;
+
+static void xlr_initialize_setups(void)
+{
+	xlr_hybrid = XLR_HYBRID_NONE;
+	xlr_user_mac.rmios = 1;
+	xlr_user_mac.xgmac = 0;
+	xlr_user_mac.mgmt_port = -1;
+	xlr_user_mac.l4_extract = 0;
+	xlr_user_mac.flow_balance = 0;
+}
+
+static int __init xlr_hybrid_setup(char *str)
+{
+	if (strcmp(str, "=user_mac") == 0) {
+#ifdef CONFIG_PHOENIX_USER_MAC 
+		xlr_hybrid = XLR_HYBRID_USER_MAC;
+		printk("Configured for Hybrid mode with USER_MAC\n");
+		phnx_msgring_config();
+#endif
+	}
+	else if (strcmp(str, "=rmios_ipsec") == 0) {
+		xlr_hybrid = XLR_HYBRID_RMIOS_IPSEC;
+		printk("Configured for Hybrid mode with RMIOS IPSEC\n");
+	}
+	else if (strcmp(str, "=user_space_kernel") == 0) {
+		xlr_hybrid = XLR_HYBRID_USER_SPACE_KERNEL;
+		printk("Configured for Hybrid mode with USER_SPACE_KERNEL\n");
+	}
+	else {		
+		xlr_hybrid = XLR_HYBRID_NONE;
+		printk("Configured for Hybrid mode with None\n");
+	}
+
+	return 1;
+}
+
+__setup("xlr_hybrid", xlr_hybrid_setup);
+
+
+
+void ptr_time_init(void)
+{
+#ifdef CONFIG_PHOENIX_PSB
+	/* only needed for use cpu counter timer interrupt source */
+	mips_hpt_frequency = prom_info->cpu_frequency;
+#else
+	mips_hpt_frequency = 1.2 * 1000 * 1000;
+#endif
+
+  
+	printk("mips_hpt_frequency = %u\n", mips_hpt_frequency);
+}
+
+extern void phoenix_timer_setup(void);
+void __init ptr_timer_setup(struct irqaction *irq)
+{
+	/*
+	 *	a) (optional) over-write any choices made above by time_init().
+	 *	b) machine specific code should setup the timer irqaction.
+	 *	c) enable the timer interrupt
+   
+	 * Even if a machine chooses to use a low-level timer interrupt,
+	 * it still needs to setup the timer_irqaction.
+	 * In that case, it might be better to set timer_irqaction.handler
+	 * to be NULL function so that we are sure the high-level code
+	 * is not invoked accidentally.
+	 */
+	phoenix_timer_setup();
+}
+
+#ifdef CONFIG_PHOENIX_EARLY_PRINTK
+static int __init ptr_console_setup(void) 
+{
+	struct uart_port up;
+
+	memset(&up, 0, sizeof(up));
+	up.membase	= (u8*)(DEFAULT_PHOENIX_IO_BASE + 
+				PHOENIX_IO_UART_0_OFFSET);
+	up.irq		= PIC_UART_0_IRQ;
+	up.regshift	= 2;
+	up.iotype	= UPIO_MEM;
+	up.uartclk	= (66000000);
+	up.flags	= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	up.line		= 0;
+
+	if (early_serial_setup(&up))
+		printk(KERN_ERR "Early serial init of UART port 0 failed\n");
+	return 0;
+}
+console_initcall(ptr_console_setup);
+#endif
+
+//static int __init ptr_setup(void)
+void __init plat_setup(void)
+{
+	extern int panic_timeout;
+  
+	panic_timeout = 5;  
+  
+	board_time_init = ptr_time_init;
+	board_timer_setup = ptr_timer_setup;
+  
+	_machine_restart   = (void (*)(char *))ptr_linux_exit;
+	_machine_halt      = ptr_linux_exit;
+	_machine_power_off = ptr_linux_exit;
+
+	return;
+}  
+struct boot_mem_map_exclude_region {
+	unsigned long long start;
+	unsigned long long end;
+};
+
+/* The below regions should be in ascending order of the starting physical addresses */
+static struct boot_mem_map_exclude_region boot_mem_map_exclude_regions[] = {
+	[0] = { PHNX_USER_MAC_MMAP_PHYS_START, PHNX_USER_MAC_MMAP_PHYS_END},
+	[1] = { PHNX_MMAP_PHYS_START, PHNX_MMAP_PHYS_START+PHNX_MMAP_PHYS_SIZE}
+};
+
+#ifdef CONFIG_PHOENIX_USER_MAC
+#define BOOT_MEM_MAP_NUM_EXCLUDE_REGIONS (sizeof(boot_mem_map_exclude_regions)/sizeof(struct boot_mem_map_exclude_region))
+#else
+#define BOOT_MEM_MAP_NUM_EXCLUDE_REGIONS 0
+#endif
+
+void read_boot_memp_map(void)
+{
+	struct psb_mem_map *map;
+	int i,j;
+	int use_default=1;	
+        __u64 start=0, end=0, exc_start=0, exc_end=0;
+		
+	map = (struct psb_mem_map *)((unsigned long)(prom_info->psb_mem_map));
+
+  if(map->map[0].size==0x0c000000) {
+    map->map[0].size=0x0ff00000;
+  }
+
+	for(i=0; i < map->nr_map; i++) {
+		start = map->map[i].addr;
+		end = map->map[i].addr + map->map[i].size;
+
+		for(j=0; (j<BOOT_MEM_MAP_NUM_EXCLUDE_REGIONS) ; j++){
+			exc_start = boot_mem_map_exclude_regions[j].start;
+			exc_end = boot_mem_map_exclude_regions[j].end;
+
+			if(exc_start>=start && exc_start<end){
+				if(map->map[i].type == BOOT_MEM_RAM){
+					add_memory_region(start,exc_start-start, map->map[i].type);
+					prom_dbg_msg("Adding %#llx @ %#llx\n",exc_start-start,start);
+					use_default = 0;
+					start = exc_end;
+				}
+			}
+		}
+		if(start!=end){
+			if(map->map[i].type == BOOT_MEM_RAM){
+				add_memory_region(start, end-start, map->map[i].type);
+				use_default = 0;
+			}
+		}
+		prom_dbg_msg("Adding %#llx @ %#llx\n", end-start, start);
+	}
+	
+	if(use_default) {
+		prom_dbg_msg("\nUsing default memory map\n");
+		add_memory_region(DEFAULT_RAM_START, DEFAULT_RAM_SIZE,
+					BOOT_MEM_RAM);
+	}
+		
+}
+
+extern void prom_boot_cpus_secondary(void *);
+/*
+ * prom_init is called just after the cpu type is determined, from setup_arch()
+ */
+void __init prom_init(void)
+{
+	mips_machgroup = MACH_GROUP_RMI;
+
+	xlr_initialize_setups();
+	strcat(arcs_cmdline, DEFAULT_BOOT_PARAMS);
+	strcat(arcs_cmdline, " ");
+
+	{
+	/* default mac addr */
+	printk("Using default Mac address\n");
+	phoenix_base_mac_addr[0] = 0x00;
+	phoenix_base_mac_addr[1] = 0x01;
+	phoenix_base_mac_addr[2] = 0x02;
+	phoenix_base_mac_addr[3] = 0x03;
+	phoenix_base_mac_addr[4] = 0x04;
+	phoenix_base_mac_addr[5] = 0x05;
+
+	}
+
+#if !defined(CONFIG_PHOENIX_PSB)
+	/* Initialize the sim control structure */
+	siminfo = (volatile struct sim_control_struct *)(SIMINFO_ADDR);
+	smp_boot_info = 
+		(volatile struct smp_boot_info_struct *)(BOOT_CPU_INFO_ADDR);
+#else
+	{
+	int i=0;
+	int argc = (int)fw_arg0;
+	long temp;
+	char **argv;
+	char **envp;
+	int t_argc = argc;
+	char *n_argv[64];
+	struct psb_info *p_info;
+
+	temp = (int)fw_arg1;
+	argv = (char **)temp;
+	temp = (int)fw_arg2;
+	envp = (char **)temp;
+
+	temp = (int)fw_arg3;
+	p_info = (struct psb_info *)temp;
+	prom_info = &psb_prom_info;
+
+	memcpy((void *)prom_info, (void *)p_info, sizeof(struct psb_info));
+
+	prom_dbg_msg("argv = %llx envp = %llx prom_info=%llx\n", argv, envp,
+			prom_info);
+
+
+
+	if (!sanity_check_prom_info(prom_info)) {
+		printk("Sanity Check failed on prom_info @ %p\n", prom_info);
+		if (prom_info) {
+			printk("sizeof(psb_info) = %d, psb_info_version = %x, "
+	       			"magic_dword = %llx, prom_info->size = %llx\n", 
+	       			(unsigned int)sizeof(struct psb_info), 
+				(unsigned int)PSB_INFO_VERSION, 
+	       			(unsigned long long)prom_info->magic_dword, 
+				(unsigned long long)prom_info->size);
+		}
+		prom_info = &default_prom_info;
+		goto parse_args;
+	}
+	/* Get the right 64bit pointers from bootloader args */
+	prom_dbg_msg("Passed argv is %lx envp is %lx\n", argv, envp);
+	{
+		int32_t *t_argv;
+
+		t_argv = (int32_t *)argv;
+		for(i=0; i < t_argc; i++, t_argv++) {
+			n_argv[i] = (char *)(unsigned long)(*t_argv);
+			//prom_dbg_msg("Passed argv[%d] is %p\n", i, argv[i]);
+			//prom_dbg_msg("New argv[%d] is %p\n", i, n_argv[i]);
+		}
+	}
+	for(i=0; i < t_argc; i++)
+		argv[i] = n_argv[i];
+	argc = t_argc;
+
+	/* update the phoenix mac addr */
+	{
+	phoenix_base_mac_addr[0] = (prom_info->mac_addr >> 40) & 0xff;
+	phoenix_base_mac_addr[1] = (prom_info->mac_addr >> 32) & 0xff;
+	phoenix_base_mac_addr[2] = (prom_info->mac_addr >> 24) & 0xff;
+	phoenix_base_mac_addr[3] = (prom_info->mac_addr >> 16) & 0xff;
+	phoenix_base_mac_addr[4] = (prom_info->mac_addr >> 8) & 0xff;
+	phoenix_base_mac_addr[5] = (prom_info->mac_addr >> 0) & 0xff;
+	}    
+	{
+	void (*wakeup)(void *, void *, __u32) = 
+		((void (*)(void *, void *, __u32))
+		 (unsigned long)(prom_info->wakeup));
+	smp_boot.online_map = (1 << hard_smp_processor_id());
+	wakeup(prom_boot_cpus_secondary, 0, 
+			(__u32)prom_info->cpu_online_map);
+	}
+	phoenix_psb_shm = (void *)phys_to_virt((unsigned long)PHNX_USER_MAC_MMAP_PHYS_START);
+	phoenix_psb_shm_size = PHNX_USER_MAC_MMAP_PHYS_END - PHNX_USER_MAC_MMAP_PHYS_START;
+
+	parse_args:
+		prom_dbg_msg("argc=%d, argv=%lx, envp=%lx, prom_info=%lx\n", 
+		 argc, (unsigned long)argv, (unsigned long)envp, 
+		 (unsigned long)prom_info);
+
+	for(i=1;i<argc;i++) {
+		if (argv && argv[i]) {
+			strcat(arcs_cmdline, argv[i]);
+			strcat(arcs_cmdline, " ");
+		}
+		else {
+			prom_dbg_msg("bad args, i=%d\n", i);
+		}
+	}
+	  
+	prom_dbg_msg("arcs_cmdline=[%s]\n", arcs_cmdline);
+	}
+#endif
+
+	printk("MAC ADDR BASE: %02x:%02x:%02x:%02x:%02x:%02x\n",
+	 phoenix_base_mac_addr[0], phoenix_base_mac_addr[1], 
+	 phoenix_base_mac_addr[2], phoenix_base_mac_addr[3], 
+	 phoenix_base_mac_addr[4], phoenix_base_mac_addr[5]);
+
+	prom_dbg_msg("Master CPU Thread: %d of %d running on Phoenix %d\n",
+	       phoenix_thr_id(), phoenix_cpu_id(), phoenix_id());
+
+	read_boot_memp_map();
+
+	on_chip_init();
+	prom_dbg_msg("on_chip init done\n");
+}
+
+void prom_free_prom_memory(void)
+{
+	/* nothing to free */
+}
+
+void read_cp0_regs(void)
+{
+	printk("[%s]: count = 0x%x, compare = 0x%x\n"
+	 "status = 0x%x, cause = 0x%x\n"
+	 "eimr = 0x%llx, eirr = 0x%llx\n",
+	 __FUNCTION__, 
+	 read_c0_count(),
+	 read_c0_compare(),
+	 read_c0_status(),
+	 read_c0_cause(),
+	 (unsigned long long)read_64bit_cp0_eimr(),
+	 (unsigned long long)read_64bit_cp0_eirr()
+	 );
+}
+
+void prom_putchar(char ch)
+{
+#ifdef CONFIG_PHOENIX_PSB
+	if (prom_info) 
+		((void (*)(char))(unsigned long)prom_info->uart_putchar)(ch);
+#else
+	if (siminfo) siminfo->putchar = ch;
+#endif
+}
Index: linux-2.6.10/arch/mips/rmi/ptr/smp.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/ptr/smp.c
@@ -0,0 +1,226 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+
+#include <asm/mipsregs.h>
+#include <asm/mmu_context.h>
+#include <asm/atomic.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/mips-exts.h>
+
+extern volatile cpumask_t cpu_callin_map;
+extern void phoenix_smp_finish(void);
+
+extern void smp_tune_scheduling (void);
+
+int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
+
+extern __u32 rmios_user_mac_thr_mask;
+extern void asmlinkage smp_bootstrap(void);
+
+/* Boot all other cpus in the system, initialize them, and
+   bring them into the boot fn */
+void prom_boot_secondary(int logical_cpu, struct task_struct *idle)
+{
+	unsigned long gp = (unsigned long)idle->thread_info;
+	unsigned long sp = gp + THREAD_SIZE - 32;
+	int cpu = cpu_logical_map(logical_cpu);
+	int bucket = ((cpu >> 2)<<3)|(cpu & 0x03);
+
+	printk("(PROM): waking up phys cpu# %d, bucket_%d, gp = %lx\n", 
+			cpu, bucket, gp);
+  
+#ifdef CONFIG_PHOENIX_PSB
+	smp_boot.boot_info[cpu].sp = sp;
+	smp_boot.boot_info[cpu].gp = gp;
+	smp_boot.boot_info[cpu].fn = (unsigned long)&smp_bootstrap;  
+	/* barrier */
+	__sync();
+	smp_boot.boot_info[cpu].ready = 1;
+	
+#else
+	{
+	  unsigned long flags = 0, msgrng_flags=0;
+	  __u64 status = 0;
+	
+	  smp_boot_info[cpu].sp    = sp;
+	  smp_boot_info[cpu].gp    = gp;
+	  smp_boot_info[cpu].fn    = (__u32)&smp_bootstrap;
+	  /* set the ready field last! sleeping cpus poll on this field */
+	  smp_boot_info[cpu].ready = 1;  
+	
+	  /* here cpu is the bit position in BOOT_CPU_MAP_ADDR 
+	   * for now, assume that BOOT_CPU_MAP_ADDR is 8 x 4
+	   */
+	
+	  msgrng_enable(flags);
+	
+	  do {
+		status = msgrng_read_status();
+		if (!(status & 0x1)) break;
+	  }while (1);
+	
+	  msgrng_send((cpu >> 2)<<3);
+	
+	  msgrng_disable(flags);
+	}
+#endif
+
+	printk("(PROM): sent a wakeup message to bucket %d\n", bucket);
+}
+
+#ifdef CONFIG_PHOENIX_PSB
+extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
+static spinlock_t smp_boot_lock;
+struct smp_boot_info smp_boot;
+void prom_boot_cpus_secondary(void *args)
+{
+	int cpu = hard_smp_processor_id();
+	unsigned long flags;
+	
+	spin_lock_irqsave(&smp_boot_lock, flags);
+	smp_boot.online_map |= (1<<cpu);
+	spin_unlock_irqrestore(&smp_boot_lock, flags);  
+	for(;;) {
+		if (smp_boot.boot_info[cpu].ready) break;
+	}
+	__sync();
+
+#ifdef CONFIG_64BIT 
+#ifdef CONFIG_PHOENIX_USER_MAC
+	if(rmios_user_mac_thr_mask & (1<<cpu)){
+		//enable xkphys access in status register.
+		__asm__ volatile(
+		"mfc0	$8, $12\n"
+		"li $9,0x1040009f\n"
+		"or $8, $8, $9\n"
+		"li $9,0x0040001f\n"
+		"xor $8,$8,$9\n"
+		"mtc0	$8, $12\n"
+		"nop\n"
+		"nop\n"
+		);
+	}
+#endif
+#endif
+	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp, 
+		       smp_boot.boot_info[cpu].gp);
+}
+#endif
+
+extern void phoenix_smp_init(void);
+void prom_init_secondary(void)
+{
+	phoenix_smp_init();
+}
+
+void prom_smp_finish(void)
+{
+	phoenix_smp_finish();
+	local_irq_enable();
+}
+
+
+void prom_cpus_done(void)
+{
+}
+
+void __init prom_build_cpu_map(void)
+{
+	int num_cpus = 0;
+	__u32 boot_cpu_online_map = 0;
+
+	extern __u32 ipi_3_counter_tx[NR_CPUS][NR_CPUS];
+	extern __u32 ipi_3_counter_rx[NR_CPUS];
+	int i=0, j=0;
+
+	cpus_clear(phys_cpu_present_map);
+	cpu_set(0, phys_cpu_present_map);
+
+	cpus_clear(cpu_present_map);
+	cpu_set(0, cpu_present_map);
+	__cpu_number_map[0] = 0;
+	__cpu_logical_map[0] = 0;
+
+	/* Initialize the ipi debug stat variables */
+	for(i=0;i<NR_CPUS;i++) {
+		for(j=0;j<NR_CPUS;j++)
+			ipi_3_counter_tx[i][j] = 0;
+	
+		ipi_3_counter_rx[i] = 0;
+	}
+
+	/* skip the last thread in every core */
+	if (xlr_hybrid_user_mac()) {
+		int user_mac_thr = 0;
+
+		for (i=0;i<32;i+=4) {
+			for(j=i+1;j<i+4;j++) 
+				if (smp_boot.online_map & (1 << j)) user_mac_thr = j;
+			rmios_user_mac_thr_mask |= (1 << user_mac_thr);
+		}
+		boot_cpu_online_map = smp_boot.online_map & ~rmios_user_mac_thr_mask;          
+		printk("[%s]: smp_boot.online_map=%x, boot_cpu_online_map=%x, rmios_user_mac_thr_mask=%x\n",
+				__FUNCTION__, smp_boot.online_map, boot_cpu_online_map, rmios_user_mac_thr_mask);
+	}
+	else {
+
+#ifdef CONFIG_PHOENIX_PSB
+	boot_cpu_online_map = smp_boot.online_map;
+#else
+	boot_cpu_online_map = *(int *)BOOT_CPU_MAP_ADDR;
+#endif
+	}
+
+	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
+
+	for(i=1;i<NR_CPUS;i++) {
+		if (boot_cpu_online_map & (1<<i)) {
+			cpu_set(i, phys_cpu_present_map);
+			++num_cpus;
+			__cpu_number_map[i] = num_cpus;
+			__cpu_logical_map[num_cpus] = i;
+			cpu_set(num_cpus, cpu_present_map);
+		}
+	}
+
+	printk("Phys CPU present map: %lx, CPU Present map %lx\n", 
+		(unsigned long)phys_cpu_present_map.bits[0], 
+	   	(unsigned long)cpu_present_map.bits[0]);
+	
+
+	printk("Detected %i Slave CPU(s)\n", num_cpus);
+}
+
+void prom_prepare_cpus(unsigned int max_cpus)
+{
+	  prom_build_cpu_map();
+}
+
Index: linux-2.6.10/arch/mips/rmi/ptr/smpboot.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/ptr/smpboot.S
@@ -0,0 +1,46 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+NESTED(ptr_smp_boot, 16, sp)
+
+	move	sp, a1
+	move	gp, a2
+	jal	a0
+	nop
+	
+END(ptr_smp_boot)
+	
+
+NESTED(prom_reenter, 16, sp)
+	move	sp, a0
+	move	gp, a1
+	jal	a2
+	nop
+END(prom_reenter)
+
Index: linux-2.6.10/include/asm-mips/rmi/64bit.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/64bit.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2003 Raza Foundries
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef _ASM_RMI_64BIT_H
+#define _ASM_RMI_64BIT_H
+
+#include <linux/types.h>
+#include <asm/system.h>
+
+/* Implement 64bit read and write operations */
+
+static inline void out64(u64 val, unsigned long addr)
+{
+  u32 low, high, tmp;
+  unsigned long flags=0;
+
+  high = val >> 32;
+  low = val & 0xffffffff;
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# out64n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			"   dsll32 %0, %2, 0   \n"
+			"   dsll32 $1, %1, 0   \n"
+			"   dsrl32 %0, %0, 0   \n"
+			"   or     $1, $1, %0  \n"
+			"   sd $1, (%3)\n"
+			".set pop\n"
+			: "=&r" (tmp)
+			: "r" (high), "r" (low), "r" (addr));
+  local_irq_restore(flags);
+}
+
+static inline u64 in64(unsigned long addr)
+{
+  unsigned long flags;
+  u32 low, high;
+
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# in64\n"
+			".set noreorder\n"
+			".set noat     \n"
+			".set mips4    \n"
+			"  ld     %1, (%2)\n"
+			"  dsra32 %0, %1, 0\n"
+			"  sll    %1, %1, 0\n"
+			".set pop\n"
+			: "=r" (high), "=r" (low)
+			: "r" (addr));
+  local_irq_restore(flags);
+
+  return (((u64)high) << 32) | low;
+}
+
+#endif 
Index: linux-2.6.10/include/asm-mips/rmi/debug.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/debug.h
@@ -0,0 +1,90 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _ASM_RMI_DEBUG_H
+#define _ASM_RMI_DEBUG_H
+
+extern void prom_printf(char *fmt, ...);
+
+#include <asm/atomic.h>
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_BIGTLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+
+  PHNX_MAX_COUNTERS = 40
+};
+extern atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#define phnx_inc_counter(x) atomic_inc(&phnx_counters[0][(x)])
+#define phnx_dec_counter(x) atomic_dec(&phnx_counters[0][(x)])
+#define phnx_set_counter(x, value) atomic_set(&phnx_counters[0][(x)], (value))
+#define phnx_get_counter(x) atomic_read(&phnx_counters[0][(x)])
+
+#define rmi_dbg_msg(fmt, args...) printk(fmt, ##args)
+
+#define rmi_dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf(fmt, ##args)
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/devices.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/devices.h
@@ -0,0 +1,10 @@
+#ifndef _ASM_RMI_DEVICES_H
+#define _ASM_RMI_DEVICES_H
+
+#define XLR_TB_MAJOR              240
+#define XLR_USER_MAC_MAJOR        241
+#define XLR_CRYPTO_MAJOR          242
+#define XLR_BIGTLB_HEAP_MAJOR     243
+#define XLR_MSGRING_SHM_MAJOR     244
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/interrupt.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/interrupt.h
@@ -0,0 +1,38 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _ASM_RMI_INTERRUPT_H
+#define _ASM_RMI_INTERRUPT_H
+
+#include <asm/rmi/pic.h>
+
+/* Defines for the IRQ numbers */
+
+#define IRQ_DUMMY_UART           2
+#define IRQ_IPI_SMP_FUNCTION     3
+#define IRQ_IPI_SMP_RESCHEDULE   4
+#define IRQ_REMOTE_DEBUG         5
+#define IRQ_MSGRING              6
+#define IRQ_TIMER                7
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/iomap.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/iomap.h
@@ -0,0 +1,103 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _ASM_RFI_IO_H
+#define _ASM_RFI_IO_H
+
+#define DEFAULT_PHOENIX_IO_BASE 0xffffffffbef00000
+#define PHOENIX_IO_SIZE                   0x1000
+
+#define PHOENIX_IO_BRIDGE_OFFSET          0x00000
+
+#define PHOENIX_IO_DDR2_CHN0_OFFSET       0x01000
+#define PHOENIX_IO_DDR2_CHN1_OFFSET       0x02000
+#define PHOENIX_IO_DDR2_CHN2_OFFSET       0x03000
+#define PHOENIX_IO_DDR2_CHN3_OFFSET       0x04000
+
+#define PHOENIX_IO_RLD2_CHN0_OFFSET       0x05000
+#define PHOENIX_IO_RLD2_CHN1_OFFSET       0x06000
+
+#define PHOENIX_IO_SRAM_OFFSET            0x07000
+
+#define PHOENIX_IO_PIC_OFFSET             0x08000
+#define PHOENIX_IO_PCIX_OFFSET            0x09000
+#define PHOENIX_IO_HT_OFFSET              0x0A000
+
+#define PHOENIX_IO_SECURITY_OFFSET        0x0B000
+
+#define PHOENIX_IO_GMAC_0_OFFSET          0x0C000
+#define PHOENIX_IO_GMAC_1_OFFSET          0x0D000
+#define PHOENIX_IO_GMAC_2_OFFSET          0x0E000
+#define PHOENIX_IO_GMAC_3_OFFSET          0x0F000
+
+#define PHOENIX_IO_SPI4_0_OFFSET          0x10000
+#define PHOENIX_IO_XGMAC_0_OFFSET         0x11000
+#define PHOENIX_IO_SPI4_1_OFFSET          0x12000
+#define PHOENIX_IO_XGMAC_1_OFFSET         0x13000
+
+#define PHOENIX_IO_UART_0_OFFSET          0x14000
+#define PHOENIX_IO_UART_1_OFFSET          0x15000
+
+#define PHOENIX_IO_I2C_0_OFFSET           0x16000
+#define PHOENIX_IO_I2C_1_OFFSET           0x17000
+
+#define PHOENIX_IO_GPIO_OFFSET            0x18000
+
+#define PHOENIX_IO_FLASH_OFFSET           0x19000
+#define PHOENIX_IO_DMA_OFFSET             0x1A000
+
+#define PHOENIX_IO_TB_OFFSET           	  0x1C000
+#define PHOENIX_CPLD_OFFSET               0xffffffffbd840000
+
+/* Base Address (Virtual) of the PCI Config address space
+ * For now, choose 256M phys in kseg1 = 0xA0000000 + (1<<28)
+ * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
+ * ie 1<<24 = 16M
+ */ 
+#define DEFAULT_PCI_CONFIG_BASE 	0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
+
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef volatile __u32 phoenix_reg_t;
+extern unsigned long phoenix_io_base;
+
+#define phoenix_io_mmio(offset) ((phoenix_reg_t *)(phoenix_io_base+(offset)))
+
+#define phoenix_read_reg(base, offset) (be32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg(base, offset, value) ((base)[(offset)] = cpu_to_be32((value)))
+
+#define phoenix_read_reg_le32(base, offset) (le32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg_le32(base, offset, value) \
+	((base)[(offset)] = cpu_to_le32((value)))
+
+extern void on_chip_init(void);
+
+#endif
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/mips-exts.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/mips-exts.h
@@ -0,0 +1,315 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _ASM_RMI_MIPS_EXTS_H
+#define _ASM_RMI_MIPS_EXTS_H
+
+#define PHOENIX_OSS_SEL_TLB_STATS 0
+#define PHOENIX_OSS_SEL_BIGTLB_STATS 1
+#define PHOENIX_OSS_SEL_PAGEMASK 2
+#define PHOENIX_OSS_SEL_VADDR 3
+#define PHOENIX_OSS_SEL_PFN0 4
+#define PHOENIX_OSS_SEL_PFN1 5
+#define PHOENIX_OSS_SEL_K0 6
+#define PHOENIX_OSS_SEL_K1 7
+
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/rmi/interrupt.h>
+
+#define DMFC0_AT_EIRR 0x40214806
+#define DMFC0_AT_EIMR 0x40214807
+#define DMTC0_AT_EIRR 0x40a14806
+#define DMTC0_AT_EIMR 0x40a14807
+
+/* functions to write to and read from the extended 
+ * cp0 registers.
+ * EIRR : Extended Interrupt Request Register 
+ *        cp0 register 9 sel 6
+ *        bits 0...7 are same as cause register 8...15
+ * EIMR : Extended Interrupt Mask Register
+ *        cp0 register 9 sel 7
+ *        bits 0...7 are same as status register 8...15
+ */
+
+static inline __u64 read_64bit_cp0_eirr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			
+			".word 0x40214806  \n\t"			
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+			
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline __u64 read_64bit_cp0_eimr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			
+			".word 0x40214807  \n\t"			
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+			
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline void write_64bit_cp0_eirr(__u64 value) 
+{  
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14806 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}  
+
+static inline void write_64bit_cp0_eimr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14807 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+#define phoenix_id()                                            \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 10\n"                      \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_cpu_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 4\n"                       \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_thr_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "andi %0, $8, 0x0f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+static __inline__ int hard_smp_processor_id(void)
+{
+  return (phoenix_cpu_id() << 2) + phoenix_thr_id();
+}
+
+#define phoenix_cpu_to_thrid(cpu) (phys_proc_id[(cpu)] >> 2)
+#define phoenix_cpu_to_cpuid(cpu) (phys_proc_id[(cpu)] & 0x3)
+
+#define CPU_BLOCKID_IFU      0
+#define CPU_BLOCKID_ICU      1
+#define CPU_BLOCKID_IEU      2
+#define CPU_BLOCKID_LSU      3
+#define CPU_BLOCKID_MMU      4
+#define CPU_BLOCKID_PRF      5
+
+#define LSU_CERRLOG_REGID    9
+
+static __inline__ unsigned int read_32bit_phnx_ctrl_reg(int block, int reg) 
+{ 
+  unsigned int __res;                                    
+  
+  __asm__ __volatile__(                                   
+		       ".set\tpush\n\t"					
+		       ".set\tnoreorder\n\t" 
+		       "move $9, %1\n" 
+/* 		       "mfcr\t$8, $9\n\t"          */
+		       ".word 0x71280018\n"
+		       "move %0, $8\n"
+		       ".set\tpop"	 
+		       : "=r" (__res) : "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );   
+  return __res;
+}
+
+static __inline__ void write_32bit_phnx_ctrl_reg(int block, int reg, unsigned int value)
+{
+  __asm__ __volatile__(                                   
+		       ".set\tpush\n\t"					
+		       ".set\tnoreorder\n\t" 
+		       "move $8, %0\n"
+		       "move $9, %1\n"
+/* 		       "mtcr\t$8, $9\n\t"  */
+		       ".word 0x71280019\n"
+		       ".set\tpop"	 
+		       : 
+		       : "r" (value), "r"((block<<8)|reg)  
+		       : "$8", "$9"
+		       );
+}
+
+static __inline__ unsigned long long read_64bit_phnx_ctrl_reg(int block, int reg)
+{	
+	unsigned int high, low;						
+	
+	__asm__ __volatile__(					
+		".set\tmips64\n\t"				
+		"move    $9, %2\n"
+		/* "mfcr    $8, $9\n" */
+		".word   0x71280018\n"
+		"dsrl32  %0, $8, 0\n\t"			        
+		"dsll32  $8, $8, 0\n\t"                         
+		"dsrl32  %1, $8, 0\n\t"                         
+		".set mips0"					
+		: "=r" (high), "=r"(low)
+		: "r"((block<<8)|reg)
+		: "$8", "$9"
+		);	
+		
+	return ( (((unsigned long long)high)<<32) | low);
+}
+
+static __inline__ void write_64bit_phnx_ctrl_reg(int block, int reg,unsigned long long value)
+{
+	__u32 low, high;
+	high = value >> 32;
+	low = value & 0xffffffff;
+
+	__asm__ __volatile__(
+		".set push\n"
+		".set noreorder\n"
+		".set mips4\n\t"
+		/* Set up "rs" */
+		"move $9, %0\n"
+
+		/* Store 64 bit value in "rt" */
+		"dsll32 $10, %1, 0  \n\t"
+		"dsll32 $8, %2, 0  \n\t"
+		"dsrl32 $8, $8, 0  \n\t"
+		"or     $10, $8, $8 \n\t"
+
+		".word 0x71280019\n" /* mtcr $8, $9 */
+
+		".set pop\n"
+
+		:  /* No outputs */
+		: "r"((block<<8)|reg), "r" (high), "r" (low)
+		: "$8", "$9", "$10"
+		);
+}
+typedef struct { volatile int value; } phnx_atomic_t;
+
+static __inline__ int phnx_test_and_set(phnx_atomic_t *lock)
+{
+  int oldval = 0;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			"move $9, %2\n"
+			"li $8, 1\n"
+			//"swapw $8, $9\n"
+			".word 0x71280014\n"
+			"move %1, $8\n"
+			".set pop\n"
+			: "+m" (lock->value), "=r" (oldval)
+			: "r" ((unsigned long)&lock->value)
+			: "$8", "$9"
+			);
+  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
+}
+
+#endif
+
+#endif /* _ASM_RMI_MIPS_EXTS_H */
Index: linux-2.6.10/include/asm-mips/rmi/msgring.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/msgring.h
@@ -0,0 +1,528 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#ifndef _ASM_RMI_MSG_RING_H
+#define _ASM_RMI_MSG_RING_H
+
+#include <linux/types.h>
+
+#include <asm/rmi/debug.h>
+#include <asm/rmi/mips-exts.h>
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define read_32bit_cp2_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_32bit_cp2_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define read_32bit_cp2_register_sel(source, sel)                \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define write_32bit_cp2_register_sel(reg, value, sel)           \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );                          
+
+#define MSGRNG_TX_BUF_REG $0
+#define MSGRNG_RX_BUF_REG $1
+
+#define MSGRNG_MSG_STATUS_REG $2
+#define MSGRNG_MSG_CONFIG_REG $3
+
+#define MSGRNG_MSG_BUCKSIZE_REG $4
+
+#define MSGRNG_CC_0_REG  $16
+#define MSGRNG_CC_1_REG  $17
+#define MSGRNG_CC_2_REG  $18
+#define MSGRNG_CC_3_REG  $19
+#define MSGRNG_CC_4_REG  $20
+#define MSGRNG_CC_5_REG  $21
+#define MSGRNG_CC_6_REG  $22
+#define MSGRNG_CC_7_REG  $23
+#define MSGRNG_CC_8_REG  $24
+#define MSGRNG_CC_9_REG  $25
+#define MSGRNG_CC_10_REG $26
+#define MSGRNG_CC_11_REG $27
+#define MSGRNG_CC_12_REG $28
+#define MSGRNG_CC_13_REG $29
+#define MSGRNG_CC_14_REG $30
+#define MSGRNG_CC_15_REG $31
+
+#define msgrng_read_status() read_32bit_cp2_register(MSGRNG_MSG_STATUS_REG)
+
+#define msgrng_read_config() read_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG)
+#define msgrng_write_config(value) \
+		write_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG, value)
+
+#define msgrng_read_bucksize(bucket) \
+		read_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, bucket)
+#define msgrng_write_bucksize(bucket, value) \
+	write_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, value, bucket)
+
+#define msgrng_read_cc(reg, pri) read_32bit_cp2_register_sel(reg, pri)
+#define msgrng_write_cc(reg, value, pri) \
+	write_32bit_cp2_register_sel(reg, value, pri)
+
+#define read_64bit_cp2_register_sel(source, sel)			\
+({									\
+	unsigned int high, low;						\
+									\
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+			"dmfc2\t$8, "STR(source)","STR(sel)"\n\t"		\
+			"dsrl32\t%0, $8, 0\n\t"			        \
+                        "dsll32\t$8, $8, 0\n\t"                         \
+                        "dsrl32\t%1, $8, 0\n\t"                         \
+			".set\tmips0"					\
+			: "=r" (high), "=r"(low): "i"(sel) : "$8");	\
+	( (((unsigned long long)high)<<32) | low);					\
+})
+
+#define write_64bit_cp2_register_sel(source, val, sel)			\
+do {									\
+     unsigned int high = val>>32;                                       \
+     unsigned int low  = val & 0xffffffff;                              \
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+                        "dsll32 $8, %1, 0\n"                            \
+                        "dsll32 $9, %0, 0\n"                            \
+                        "dsrl32 $8, $8, 0\n"                            \
+                        "or     $8, $8, $9\n"				\
+			"dmtc2\t$8, "STR(source)", %2\n\t"		\
+			".set\tmips0"					\
+			: : "r" (high), "r" (low), "i"(sel): "$8", "$9");		\
+} while (0)
+
+
+#define msgrng_load_rx_msg0() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 0)
+#define msgrng_load_rx_msg1() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 1)
+#define msgrng_load_rx_msg2() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 2)
+#define msgrng_load_rx_msg3() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 3)
+
+#define msgrng_load_tx_msg0(value) \
+	write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 0)
+#define msgrng_load_tx_msg1(value) \
+	write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 1)
+#define msgrng_load_tx_msg2(value) \
+	write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 2)
+#define msgrng_load_tx_msg3(value) \
+	write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 3)
+
+/* Station IDs */
+#define MSGRNG_STNID_CPU0  0x00
+#define MSGRNG_STNID_CPU1  0x08
+#define MSGRNG_STNID_CPU2  0x10
+#define MSGRNG_STNID_CPU3  0x18
+#define MSGRNG_STNID_CPU4  0x20
+#define MSGRNG_STNID_CPU5  0x28
+#define MSGRNG_STNID_CPU6  0x30
+#define MSGRNG_STNID_CPU7  0x38
+
+#define MSGRNG_STNID_XGS0_TX 64
+#define MSGRNG_STNID_XMAC0_00_TX 64
+#define MSGRNG_STNID_XMAC0_01_TX 65
+#define MSGRNG_STNID_XMAC0_02_TX 66
+#define MSGRNG_STNID_XMAC0_03_TX 67
+#define MSGRNG_STNID_XMAC0_04_TX 68
+#define MSGRNG_STNID_XMAC0_05_TX 69
+#define MSGRNG_STNID_XMAC0_06_TX 70
+#define MSGRNG_STNID_XMAC0_07_TX 71
+#define MSGRNG_STNID_XMAC0_08_TX 72
+#define MSGRNG_STNID_XMAC0_09_TX 73
+#define MSGRNG_STNID_XMAC0_10_TX 74
+#define MSGRNG_STNID_XMAC0_11_TX 75
+#define MSGRNG_STNID_XMAC0_12_TX 76
+#define MSGRNG_STNID_XMAC0_13_TX 77
+#define MSGRNG_STNID_XMAC0_14_TX 78
+#define MSGRNG_STNID_XMAC0_15_TX 79
+
+#define MSGRNG_STNID_XGS1_TX 80
+#define MSGRNG_STNID_XMAC1_00_TX 80
+#define MSGRNG_STNID_XMAC1_01_TX 81
+#define MSGRNG_STNID_XMAC1_02_TX 82
+#define MSGRNG_STNID_XMAC1_03_TX 83
+#define MSGRNG_STNID_XMAC1_04_TX 84
+#define MSGRNG_STNID_XMAC1_05_TX 85
+#define MSGRNG_STNID_XMAC1_06_TX 86
+#define MSGRNG_STNID_XMAC1_07_TX 87
+#define MSGRNG_STNID_XMAC1_08_TX 88
+#define MSGRNG_STNID_XMAC1_09_TX 89
+#define MSGRNG_STNID_XMAC1_10_TX 90
+#define MSGRNG_STNID_XMAC1_11_TX 91
+#define MSGRNG_STNID_XMAC1_12_TX 92
+#define MSGRNG_STNID_XMAC1_13_TX 93
+#define MSGRNG_STNID_XMAC1_14_TX 94
+#define MSGRNG_STNID_XMAC1_15_TX 95
+
+#define MSGRNG_STNID_GMAC 96
+#define MSGRNG_STNID_GMACJFR_0  96
+#define MSGRNG_STNID_GMACRFR_0  97
+#define MSGRNG_STNID_GMACTX0  98
+#define MSGRNG_STNID_GMACTX1  99
+#define MSGRNG_STNID_GMACTX2  100
+#define MSGRNG_STNID_GMACTX3  101
+#define MSGRNG_STNID_GMACJFR_1  102
+#define MSGRNG_STNID_GMACRFR_1  103
+
+#define MSGRNG_STNID_DMA      104
+#define MSGRNG_STNID_DMA_0    104
+#define MSGRNG_STNID_DMA_1    105
+#define MSGRNG_STNID_DMA_2    106
+#define MSGRNG_STNID_DMA_3    107
+
+#define MSGRNG_STNID_XGS0FR 112
+#define MSGRNG_STNID_XMAC0JFR 112
+#define MSGRNG_STNID_XMAC0RFR 113
+
+#define MSGRNG_STNID_XGS1FR 114
+#define MSGRNG_STNID_XMAC1JFR 114
+#define MSGRNG_STNID_XMAC1RFR 115
+
+#define MSGRNG_STNID_SEC 120
+#define MSGRNG_STNID_SEC0 120
+#define MSGRNG_STNID_SEC1 121
+#define MSGRNG_STNID_SEC2 122
+#define MSGRNG_STNID_SEC3 123
+#define MSGRNG_STNID_PK0  124
+
+#define MSGRNG_CODE_MAC 0
+#define MSGRNG_CODE_SEC 0
+#define MSGRNG_CODE_XGMAC 2
+#define MSGRNG_CODE_SPI4  0x2
+#define MSGRNG_CODE_BOOT_WAKEUP 200
+
+static inline int msgrng_xgmac_stid_rfr(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0RFR : MSGRNG_STNID_XMAC1RFR;
+}
+
+static inline int msgrng_xgmac_stid_jfr(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0JFR : MSGRNG_STNID_XMAC1JFR;
+}
+
+static inline int msgrng_xgmac_stid_tx(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0_00_TX : MSGRNG_STNID_XMAC1_00_TX;
+}
+
+static inline int msgrng_gmac_stid_rfr(int id)
+{
+  return (MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_rfr_split_mode(int id)
+{
+  return ((id>>1)?MSGRNG_STNID_GMACRFR_1:MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_jfr(int id)
+{
+  return MSGRNG_STNID_GMACJFR_0;
+}
+
+static inline int msgrng_gmac_stid_jfr_split_mode(int id)
+{
+  return ((id>>1)?MSGRNG_STNID_GMACJFR_1:MSGRNG_STNID_GMACJFR_0);
+}
+
+static inline int msgrng_gmac_stid_tx(int id)
+{
+  return (MSGRNG_STNID_GMACTX0 + id);
+}
+
+static inline void msgrng_send(unsigned int  dest)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    //		    "msgsnd %0\n"
+		    "move  $8, %0\n"
+		    "c2    0x80001\n"
+		    ".set pop\n"
+		    : : "r" (dest) : "$8"
+		    );
+}
+
+static inline void msgrng_receive(unsigned int pri)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    //		    "msgld %0\n"
+		    "move $8, %0\n"
+		    "c2   0x80002\n"
+		    ".set pop\n"
+		    : : "r" (pri) : "$8"
+		    );
+}
+
+static inline void msgrng_wait(unsigned int mask)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    //		    "msgwait %0\n"
+		    "move $8, %0\n"
+		    "c2   0x80003\n"
+		    ".set pop\n"
+		    : :"r" (mask) : "$8"
+		    );
+}
+
+#define msgrng_enable(flags)                        \
+do {                                                \
+  __asm__ volatile (                                \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+} while (0)
+
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#define msgrng_flags_save(flags) msgrng_enable(flags)
+#define msgrng_flags_restore(flags) msgrng_disable(flags)
+
+struct msgrng_msg {
+  __u64 msg0;
+  __u64 msg1;
+  __u64 msg2;
+  __u64 msg3;
+};
+
+
+static inline void message_send_block_fast(int size, unsigned int code, 
+	unsigned int stid, unsigned long long msg0, 
+	unsigned long long msg1, unsigned long long msg2, 
+	unsigned long long msg3)
+{
+  __asm__ __volatile__ (".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        "dmtc2 %1, "STR(MSGRNG_TX_BUF_REG)", 0\n"
+                        "dmtc2 %2, "STR(MSGRNG_TX_BUF_REG)", 1\n"
+                        "dmtc2 %3, "STR(MSGRNG_TX_BUF_REG)", 2\n"
+                        "dmtc2 %4, "STR(MSGRNG_TX_BUF_REG)", 3\n"
+                        "move $8, %0\n"
+                        "1: c2 0x80001\n"
+                        "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
+                        "andi $8, $8, 0x6\n"
+                        "bnez $8, 1b\n"
+                        "move $8, %0\n"
+                        ".set pop\n"
+                        :
+                        : "r"(((size-1)<<16)|(code<<8)|stid), "r" (msg0), "r" (msg1), "r"(msg2), "r"(msg3)
+                        : "$8"
+                        );
+}
+
+#define message_receive_fast(bucket, size, code, stid, msg0, msg1, msg2, msg3)      \
+        ( { unsigned int _status=0, _tmp=0;                     \
+           msgrng_receive(bucket);                              \
+           while ( (_status=msgrng_read_status()) & 0x08) ;     \
+           _tmp = _status & 0x30;                               \
+           if (likely(!_tmp)) {                                 \
+                 (size)=((_status & 0xc0)>>6)+1;                \
+                 (code)=(_status & 0xff00)>>8;                  \
+                 (stid)=(_status & 0x7f0000)>>16;               \
+                 (msg0)=msgrng_load_rx_msg0();                  \
+                 (msg1)=msgrng_load_rx_msg1();                  \
+                 (msg2)=msgrng_load_rx_msg2();                  \
+                 (msg3)=msgrng_load_rx_msg3();                  \
+                 _tmp=0;                                        \
+                }                                               \
+           _tmp;                                                \
+        } )                                                     
+
+static __inline__ int message_send(unsigned int size, unsigned int code,
+				   unsigned int stid, struct msgrng_msg *msg)
+{
+  unsigned int dest = 0;
+
+  msgrng_load_tx_msg0(msg->msg0);
+  msgrng_load_tx_msg1(msg->msg1);
+  msgrng_load_tx_msg2(msg->msg2);
+  msgrng_load_tx_msg3(msg->msg3);
+
+  dest = ((size-1)<<16)|(code<<8)|(stid);
+
+
+  msgrng_send(dest);
+
+  return msgrng_read_status() & 0x06;
+}
+
+static __inline__ int message_send_retry(unsigned int size, unsigned int code, 
+				unsigned int stid, struct msgrng_msg *msg)
+{
+  int res = 0;
+  int retry = 0;
+
+  for(;;) {
+    res = message_send(size, code, stid, msg);
+    /* retry a pending fail */
+    if (res & 0x02) continue;
+    /* credit fail */
+    if (res & 0x04) retry++;
+    else break;
+    if (retry == 1) return res & 0x06;
+  }
+
+  return 0;
+}
+
+static __inline__ int message_receive(int pri, int *size, int *code, 
+			int *src_id, struct msgrng_msg *msg)
+{
+  int res = message_receive_fast(pri, *size, *code, *src_id, msg->msg0, 
+			msg->msg1, msg->msg2, msg->msg3);
+  
+#ifdef MSGRING_DUMP_MESSAGES
+  if (!res) {
+    dbg_msg("Received msg <%llx, %llx, %llx, %llx> <%d,%d,%d>\n", 
+	    msg->msg0, msg->msg1, msg->msg2, msg->msg3,
+	    *size, *code, *src_id);
+  }
+#endif
+  
+  return res;
+}
+
+#define MSGRNG_STN_RX_QSIZE 256
+
+struct stn_cc {
+  unsigned short counters[16][8];
+};
+
+struct bucket_size {
+  unsigned short bucket[128];
+};
+
+extern struct bucket_size bucket_sizes;
+
+extern struct stn_cc cc_table_cpu_0;
+extern struct stn_cc cc_table_cpu_1;
+extern struct stn_cc cc_table_cpu_2;
+extern struct stn_cc cc_table_cpu_3;
+extern struct stn_cc cc_table_cpu_4;
+extern struct stn_cc cc_table_cpu_5;
+extern struct stn_cc cc_table_cpu_6;
+extern struct stn_cc cc_table_cpu_7;
+extern struct stn_cc cc_table_xgs_0;
+extern struct stn_cc cc_table_xgs_1;
+extern struct stn_cc cc_table_gmac;
+extern struct stn_cc cc_table_dma;
+extern struct stn_cc cc_table_sec;
+
+#define msgrng_access_save(lock, iflags, mflags) do {        \
+  spin_lock_irqsave(lock, iflags);                           \
+  msgrng_flags_save(mflags);                                 \
+ }while(0)
+
+#define msgrng_access_restore(lock, iflags, mflags) do {     \
+  msgrng_flags_restore(mflags);                              \
+  spin_unlock_irqrestore(lock, iflags);                      \
+ }while(0)
+
+#define msgrng_access_enable(mflags) do {   \
+  preempt_disable();                        \
+  msgrng_flags_save(mflags);                \
+} while(0)
+
+#define msgrng_access_disable(mflags) do {   \
+  msgrng_flags_restore(mflags);              \
+  preempt_enable();                          \
+} while(0)
+
+enum {
+  TX_STN_CPU_0,
+  TX_STN_CPU_1,
+  TX_STN_CPU_2,
+  TX_STN_CPU_3,
+  TX_STN_CPU_4,
+  TX_STN_CPU_5,
+  TX_STN_CPU_6,
+  TX_STN_CPU_7,
+  
+  TX_STN_GMAC,
+  
+  TX_STN_DMA,
+
+  TX_STN_XGS_0,
+  TX_STN_XGS_1,
+
+  TX_STN_SEC,
+
+  TX_STN_INVALID,
+
+  MAX_TX_STNS
+};
+
+extern int register_msgring_handler(int major, 
+		void (*action)(int, int,int,int,struct msgrng_msg *, void *),
+		void *dev_id);
+extern void phoenix_msgring_cpu_init(void);
+
+#define cpu_to_msgring_bucket(cpu) ((((cpu) >> 2)<<3)|((cpu) & 0x03))
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/pci.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/pci.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_RMI_PCI_H
+#define _ASM_RMI_PCI_H
+
+#define RMI_PCI_VENDOR_ID            0xfecc
+#define RMI_PCI_UART_DEV_ID          2
+#define RMI_PCI_DUMMY_MAC_DEV_ID     16
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/perf_ctr.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/perf_ctr.h
@@ -0,0 +1,42 @@
+#ifndef __ASM_RMI_PERF_CTR_H
+#define __ASM_RMI_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_RMI_PERF_CTR_H */
Index: linux-2.6.10/include/asm-mips/rmi/phnx_mmap.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phnx_mmap.h
@@ -0,0 +1,13 @@
+#ifndef _ASM_RMI_PHNX_MMAP_H
+#define _ASM_RMI_PHNX_MMAP_H
+
+#define PHNX_MMAP_VIRT_START         0x40000000ULL
+
+#define PHNX_MMAP_PHYS_START         0xe0000000ULL
+
+/* the below macros go together */
+#define PHNX_MMAP_PHYS_SIZE          (512<<20)
+#define PHNX_MMAP_PMASK_SIZE         (PHNX_MMAP_PHYS_SIZE >> 1)
+#define PHNX_MMAP_PMASK_SIZE_256MB   0xffff
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/phnx_tb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phnx_tb.h
@@ -0,0 +1,68 @@
+#ifndef _RMI_PHOENIX_TB_H
+#define _RMI_PHOENIX_TB_H
+
+#include <linux/types.h>
+#include <asm-mips/rmi/iomap.h>
+#include <linux/phnx_tb.h>
+
+#define TB_REG_SIZE				4
+#define TB_NO_RDDATA_REGS		4
+#define TB_MAX_ENTRIES			256
+#define TB_ENTRY_SIZE		(TB_NO_RDDATA_REGS * TB_REG_SIZE)
+#define TB_SIZE				(TB_MAX_ENTRIES * TB_ENTRY_SIZE)
+
+/* ---------------------------------------------------------------------------- */
+/*                             RD/WR macros                                     */
+/* ---------------------------------------------------------------------------- */
+
+static inline unsigned int tb_read_reg_be32(unsigned int reg)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    return phoenix_read_reg(mmio, reg);
+}
+
+static inline void tb_write_reg_be32 (unsigned int reg, unsigned int value)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    phoenix_write_reg(mmio, reg, value);
+}
+
+static inline unsigned int tb_read_reg_le32 (unsigned int reg)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    return phoenix_read_reg_le32(mmio, reg);
+}
+
+static inline void tb_write_reg_le32 (unsigned int reg, unsigned int value)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    phoenix_write_reg_le32(mmio, reg, value);
+}
+
+#define tb_read_status_reg() tb_read_reg_be32(TB_STATUS_REG)
+#define tb_read_ctrl_reg() tb_read_reg_be32(TB_CTRL_REG)
+
+#define tb_read_reqmatch_reg(i) tb_read_reg_be32 (TB_REQMATCH_REGS + i)
+#define tb_read_raddr_reg(i) tb_read_reg_be32 (TB_RADDR_REGS + i)
+#define tb_read_rddata_reg(i) tb_read_reg_le32 (TB_RDDATA_REGS + i)
+
+#define tb_write_ctrl_reg(val) tb_write_reg_be32 (TB_CTRL_REG, val)
+#define tb_write_reqmatch_reg(i, val) tb_write_reg_be32 ((TB_REQMATCH_REGS+i), val)
+#define tb_write_raddr_reg(i, val) tb_write_reg_be32 ((TB_RADDR_REGS+i), val)
+
+#define tb_reinit(void) {tb_write_reg_be32(TB_INIT_REG, 0x0);tb_write_reg_be32(TB_INIT_REG, 0x1);}
+#define tb_pop_entry(void) tb_write_reg_be32(TB_ACCESS_REG, 0)
+#define disable_tb()    tb_write_reg_be32(TB_CTRL_REG, 0x01000000)
+
+typedef struct _tb_dev_t {
+	unsigned int	size;
+//	unsigned char   data[TB_SIZE];
+	unsigned char   *data;
+} tb_dev_t;
+
+ssize_t	tb_read (struct file *, char *, size_t, loff_t *);
+int		tb_open (struct inode *, struct file *);
+int		tb_ioctl (struct inode *, struct file *, unsigned int, unsigned long);
+int		tb_release (struct inode *, struct file *);
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/phnx_user_mac.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phnx_user_mac.h
@@ -0,0 +1,50 @@
+#ifndef _ASM_RMI_PHNX_USER_MAC_H
+#define _ASM_RMI_PHNX_USER_MAC_H
+
+#define PHNX_USER_MAC_MMAP_VIRT_START 0x60000000
+#define PHNX_USER_MAC_MMAP_PHYS_START 0x0b800000
+#define PHNX_USER_MAC_MMAP_PHYS_END   0x0c000000
+
+#ifndef __ASSEMBLY__
+#include <asm/rmi/sim.h>
+
+extern void phoenix_user_mac_update_time(void);
+
+struct xlr_user_mac_config {
+	int rmios;
+	int xgmac;
+	int mgmt_port;
+	int l4_extract;
+	int flow_balance;
+};
+
+extern struct xlr_user_mac_config xlr_user_mac;
+
+static __inline__ int xlr_user_mac_rmios(void)
+{
+	return xlr_hybrid_user_mac() && (xlr_user_mac.rmios == 1);
+}
+
+static __inline__ int xlr_user_mac_xgmac(void)
+{
+	return xlr_hybrid_user_mac() && (xlr_user_mac.xgmac == 1);
+}
+
+static __inline__ int xlr_user_mac_mgmt_port(void)
+{
+	return xlr_user_mac.mgmt_port;
+}
+
+static __inline__ int xlr_user_mac_l4_extract(void)
+{
+	return xlr_hybrid_user_mac() ? xlr_user_mac.l4_extract  : 0;
+}
+
+static __inline__ int xlr_user_mac_flow_balance(void)
+{
+	return xlr_user_mac.flow_balance == 1;
+}
+
+#endif
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/phoenix_ide.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phoenix_ide.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2004  Raza Microelectronics Inc 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __ASM_PHOENIX_H
+#define __ASM_PHOENIX_H
+
+#include <linux/config.h>
+
+#define  CONFIG_PHOENIX 1
+
+#ifdef CONFIG_PHOENIX
+#define PHOENIX_BOARD_NAME "PHOENIX -ATX1"
+#define PHOENIX_HAVE_PCMCIA 0
+#define PHOENIX_HAVE_IDE    1
+#endif
+
+
+#ifdef PHOENIX_HAVE_IDE
+#define IDE_CS          6
+#define IDE_PHYS        0x1D000000
+#define K_GPIO_GB_IDE   4
+#define K_GPIO_PC_READY 11 
+#define K_INT_GPIO_0    32 
+#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
+#endif
+
+#ifdef PHOENIX_HAVE_PCMCIA
+#define PCMCIA_CS       4
+#define PCMCIA_PHYS     0x11000000
+#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
+#endif
+
+
+#define IOADDR(a) (UNCAC_BASE + (a))
+
+#endif /* __ASM_PHOENIX_H */
Index: linux-2.6.10/include/asm-mips/rmi/phoenix_mac.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phoenix_mac.h
@@ -0,0 +1,1395 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _ASM_RMI_MAC_H
+#define _ASM_RMI_MAC_H
+
+#include <linux/types.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+
+#define MAC_SPACING                 0x400
+#define XGMAC_SPACING               0x400
+
+/* PE-MCXMAC register and bit field definitions */
+#define R_MAC_CONFIG_1                                              0x00
+#define   O_MAC_CONFIG_1__srst                                      31
+#define   O_MAC_CONFIG_1__simr                                      30
+#define   O_MAC_CONFIG_1__hrrmc                                     18
+#define   W_MAC_CONFIG_1__hrtmc                                      2
+#define   O_MAC_CONFIG_1__hrrfn                                     16
+#define   W_MAC_CONFIG_1__hrtfn                                      2
+#define   O_MAC_CONFIG_1__intlb                                      8
+#define   O_MAC_CONFIG_1__rxfc                                       5
+#define   O_MAC_CONFIG_1__txfc                                       4
+#define   O_MAC_CONFIG_1__srxen                                      3
+#define   O_MAC_CONFIG_1__rxen                                       2
+#define   O_MAC_CONFIG_1__stxen                                      1
+#define   O_MAC_CONFIG_1__txen                                       0
+#define R_MAC_CONFIG_2                                              0x01
+#define   O_MAC_CONFIG_2__prlen                                     12
+#define   W_MAC_CONFIG_2__prlen                                      4
+#define   O_MAC_CONFIG_2__speed                                      8
+#define   W_MAC_CONFIG_2__speed                                      2
+#define   O_MAC_CONFIG_2__hugen                                      5
+#define   O_MAC_CONFIG_2__flchk                                      4
+#define   O_MAC_CONFIG_2__crce                                       1
+#define   O_MAC_CONFIG_2__fulld                                      0
+#define R_IPG_IFG                                                   0x02
+#define   O_IPG_IFG__ipgr1                                          24
+#define   W_IPG_IFG__ipgr1                                           7
+#define   O_IPG_IFG__ipgr2                                          16
+#define   W_IPG_IFG__ipgr2                                           7
+#define   O_IPG_IFG__mifg                                            8
+#define   W_IPG_IFG__mifg                                            8
+#define   O_IPG_IFG__ipgt                                            0
+#define   W_IPG_IFG__ipgt                                            7
+#define R_HALF_DUPLEX                                               0x03
+#define   O_HALF_DUPLEX__abebt                                      24
+#define   W_HALF_DUPLEX__abebt                                       4
+#define   O_HALF_DUPLEX__abebe                                      19
+#define   O_HALF_DUPLEX__bpnb                                       18
+#define   O_HALF_DUPLEX__nobo                                       17
+#define   O_HALF_DUPLEX__edxsdfr                                    16
+#define   O_HALF_DUPLEX__retry                                      12
+#define   W_HALF_DUPLEX__retry                                       4
+#define   O_HALF_DUPLEX__lcol                                        0
+#define   W_HALF_DUPLEX__lcol                                       10
+#define R_MAXIMUM_FRAME_LENGTH                                      0x04
+#define   O_MAXIMUM_FRAME_LENGTH__maxf                               0
+#define   W_MAXIMUM_FRAME_LENGTH__maxf                              16
+#define R_TEST                                                      0x07
+#define   O_TEST__mbof                                               3
+#define   O_TEST__rthdf                                              2
+#define   O_TEST__tpause                                             1
+#define   O_TEST__sstct                                              0
+#define R_MII_MGMT_CONFIG                                           0x08
+#define   O_MII_MGMT_CONFIG__scinc                                   5
+#define   O_MII_MGMT_CONFIG__spre                                    4
+#define   O_MII_MGMT_CONFIG__clks                                    3
+#define   W_MII_MGMT_CONFIG__clks                                    3
+#define R_MII_MGMT_COMMAND                                          0x09
+#define   O_MII_MGMT_COMMAND__scan                                   1
+#define   O_MII_MGMT_COMMAND__rstat                                  0
+#define R_MII_MGMT_ADDRESS                                          0x0A
+#define   O_MII_MGMT_ADDRESS__fiad                                   8
+#define   W_MII_MGMT_ADDRESS__fiad                                   5
+#define   O_MII_MGMT_ADDRESS__fgad                                   5
+#define   W_MII_MGMT_ADDRESS__fgad                                   0
+#define R_MII_MGMT_WRITE_DATA                                       0x0B
+#define   O_MII_MGMT_WRITE_DATA__ctld                                0
+#define   W_MII_MGMT_WRITE_DATA__ctld                               16
+#define R_MII_MGMT_STATUS                                           0x0C
+#define R_MII_MGMT_INDICATORS                                       0x0D
+#define   O_MII_MGMT_INDICATORS__nvalid                              2
+#define   O_MII_MGMT_INDICATORS__scan                                1
+#define   O_MII_MGMT_INDICATORS__busy                                0
+#define R_INTERFACE_CONTROL                                         0x0E
+#define   O_INTERFACE_CONTROL__hrstint                              31
+#define   O_INTERFACE_CONTROL__tbimode                              27
+#define   O_INTERFACE_CONTROL__ghdmode                              26
+#define   O_INTERFACE_CONTROL__lhdmode                              25
+#define   O_INTERFACE_CONTROL__phymod                               24
+#define   O_INTERFACE_CONTROL__hrrmi                                23
+#define   O_INTERFACE_CONTROL__rspd                                 16
+#define   O_INTERFACE_CONTROL__hr100                                15
+#define   O_INTERFACE_CONTROL__frcq                                 10
+#define   O_INTERFACE_CONTROL__nocfr                                 9
+#define   O_INTERFACE_CONTROL__dlfct                                 8
+#define   O_INTERFACE_CONTROL__enjab                                 0
+#define R_INTERFACE_STATUS                                         0x0F
+#define   O_INTERFACE_STATUS__xsdfr                                  9
+#define   O_INTERFACE_STATUS__ssrr                                   8
+#define   W_INTERFACE_STATUS__ssrr                                   5
+#define   O_INTERFACE_STATUS__miilf                                  3
+#define   O_INTERFACE_STATUS__locar                                  2
+#define   O_INTERFACE_STATUS__sqerr                                  1
+#define   O_INTERFACE_STATUS__jabber                                 0
+#define R_STATION_ADDRESS_LS                                       0x10
+#define R_STATION_ADDRESS_MS                                       0x11
+
+/* A-XGMAC register and bit field definitions */
+#define R_XGMAC_CONFIG_0    0x00
+#define   O_XGMAC_CONFIG_0__hstmacrst               31
+#define   O_XGMAC_CONFIG_0__hstrstrctl              23
+#define   O_XGMAC_CONFIG_0__hstrstrfn               22
+#define   O_XGMAC_CONFIG_0__hstrsttctl              18
+#define   O_XGMAC_CONFIG_0__hstrsttfn               17
+#define   O_XGMAC_CONFIG_0__hstrstmiim              16
+#define   O_XGMAC_CONFIG_0__hstloopback             8
+#define R_XGMAC_CONFIG_1    0x01
+#define   O_XGMAC_CONFIG_1__hsttctlen               31
+#define   O_XGMAC_CONFIG_1__hsttfen                 30
+#define   O_XGMAC_CONFIG_1__hstrctlen               29
+#define   O_XGMAC_CONFIG_1__hstrfen                 28
+#define   O_XGMAC_CONFIG_1__tfen                    26
+#define   O_XGMAC_CONFIG_1__rfen                    24
+#define   O_XGMAC_CONFIG_1__hstrctlshrtp            12
+#define   O_XGMAC_CONFIG_1__hstdlyfcstx             10
+#define   W_XGMAC_CONFIG_1__hstdlyfcstx              2
+#define   O_XGMAC_CONFIG_1__hstdlyfcsrx              8
+#define   W_XGMAC_CONFIG_1__hstdlyfcsrx              2
+#define   O_XGMAC_CONFIG_1__hstppen                  7
+#define   O_XGMAC_CONFIG_1__hstbytswp                6
+#define   O_XGMAC_CONFIG_1__hstdrplt64               5
+#define   O_XGMAC_CONFIG_1__hstprmscrx               4
+#define   O_XGMAC_CONFIG_1__hstlenchk                3
+#define   O_XGMAC_CONFIG_1__hstgenfcs                2
+#define   O_XGMAC_CONFIG_1__hstpadmode               0
+#define   W_XGMAC_CONFIG_1__hstpadmode               2
+#define R_XGMAC_CONFIG_2    0x02
+#define   O_XGMAC_CONFIG_2__hsttctlfrcp             31
+#define   O_XGMAC_CONFIG_2__hstmlnkflth             27
+#define   O_XGMAC_CONFIG_2__hstalnkflth             26
+#define   O_XGMAC_CONFIG_2__rflnkflt                24
+#define   W_XGMAC_CONFIG_2__rflnkflt                 2                          
+#define   O_XGMAC_CONFIG_2__hstipgextmod            16
+#define   W_XGMAC_CONFIG_2__hstipgextmod             5
+#define   O_XGMAC_CONFIG_2__hstrctlfrcp             15
+#define   O_XGMAC_CONFIG_2__hstipgexten              5
+#define   O_XGMAC_CONFIG_2__hstmipgext               0
+#define   W_XGMAC_CONFIG_2__hstmipgext               5
+#define R_XGMAC_CONFIG_3    0x03
+#define   O_XGMAC_CONFIG_3__hstfltrfrm              31
+#define   W_XGMAC_CONFIG_3__hstfltrfrm              16
+#define   O_XGMAC_CONFIG_3__hstfltrfrmdc            15
+#define   W_XGMAC_CONFIG_3__hstfltrfrmdc            16
+#define R_XGMAC_STATION_ADDRESS_LS      0x04
+#define   O_XGMAC_STATION_ADDRESS_LS__hstmacadr0    0
+#define   W_XGMAC_STATION_ADDRESS_LS__hstmacadr0    32
+#define R_XGMAC_STATION_ADDRESS_MS      0x05
+#define R_XGMAC_MAX_FRAME_LEN           0x08
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       16
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       14
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx        0
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx       16
+#define R_XGMAC_REV_LEVEL               0x0B
+#define   O_XGMAC_REV_LEVEL__revlvl                  0
+#define   W_XGMAC_REV_LEVEL__revlvl                 15
+#define R_XGMAC_MIIM_COMMAND            0x10
+#define   O_XGMAC_MIIM_COMMAND__hstldcmd             3
+#define   O_XGMAC_MIIM_COMMAND__hstmiimcmd           0
+#define   W_XGMAC_MIIM_COMMAND__hstmiimcmd           3
+#define R_XGMAC_MIIM_FILED              0x11
+#define   O_XGMAC_MIIM_FILED__hststfield            30
+#define   W_XGMAC_MIIM_FILED__hststfield             2
+#define   O_XGMAC_MIIM_FILED__hstopfield            28
+#define   W_XGMAC_MIIM_FILED__hstopfield             2
+#define   O_XGMAC_MIIM_FILED__hstphyadx             23
+#define   W_XGMAC_MIIM_FILED__hstphyadx              5
+#define   O_XGMAC_MIIM_FILED__hstregadx             18
+#define   W_XGMAC_MIIM_FILED__hstregadx              5
+#define   O_XGMAC_MIIM_FILED__hsttafield            16
+#define   W_XGMAC_MIIM_FILED__hsttafield             2
+#define   O_XGMAC_MIIM_FILED__miimrddat              0
+#define   W_XGMAC_MIIM_FILED__miimrddat             16
+#define R_XGMAC_MIIM_CONFIG             0x12
+#define   O_XGMAC_MIIM_CONFIG__hstnopram             7
+#define   O_XGMAC_MIIM_CONFIG__hstclkdiv             0
+#define   W_XGMAC_MIIM_CONFIG__hstclkdiv             7
+#define R_XGMAC_MIIM_LINK_FAIL_VECTOR   0x13
+#define   O_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec   0
+#define   W_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec  32
+#define R_XGMAC_MIIM_INDICATOR          0x14
+#define   O_XGMAC_MIIM_INDICATOR__miimphylf          4
+#define   O_XGMAC_MIIM_INDICATOR__miimmoncplt        3
+#define   O_XGMAC_MIIM_INDICATOR__miimmonvld         2
+#define   O_XGMAC_MIIM_INDICATOR__miimmon            1
+#define   O_XGMAC_MIIM_INDICATOR__miimbusy           0
+
+/* Glue logic register and bit field definitions */
+#define R_MAC_ADDR0                                                 0x50
+#define R_MAC_ADDR1                                                 0x52
+#define R_MAC_ADDR2                                                 0x54
+#define R_MAC_ADDR3                                                 0x56
+#define R_MAC_ADDR_MASK2                                            0x58
+#define R_MAC_ADDR_MASK3                                            0x5A
+#define R_MAC_FILTER_CONFIG                                         0x5C
+#define   O_MAC_FILTER_CONFIG__BROADCAST_EN                         10
+#define   O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN                       9
+#define   O_MAC_FILTER_CONFIG__ALL_MCAST_EN                         8
+#define   O_MAC_FILTER_CONFIG__ALL_UCAST_EN                         7
+#define   O_MAC_FILTER_CONFIG__HASH_MCAST_EN                        6
+#define   O_MAC_FILTER_CONFIG__HASH_UCAST_EN                        5
+#define   O_MAC_FILTER_CONFIG__ADDR_MATCH_DISC                      4
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR3_VALID                      3
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR2_VALID                      2
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR1_VALID                      1
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID                      0
+#define R_HASH_TABLE_VECTOR                                         0x30
+#define R_TX_CONTROL                                                 0x0A0
+#define   O_TX_CONTROL__Tx15Halt                                     31
+#define   O_TX_CONTROL__Tx14Halt                                     30
+#define   O_TX_CONTROL__Tx13Halt                                     29
+#define   O_TX_CONTROL__Tx12Halt                                     28
+#define   O_TX_CONTROL__Tx11Halt                                     27
+#define   O_TX_CONTROL__Tx10Halt                                     26
+#define   O_TX_CONTROL__Tx9Halt                                      25
+#define   O_TX_CONTROL__Tx8Halt                                      24
+#define   O_TX_CONTROL__Tx7Halt                                      23
+#define   O_TX_CONTROL__Tx6Halt                                      22
+#define   O_TX_CONTROL__Tx5Halt                                      21
+#define   O_TX_CONTROL__Tx4Halt                                      20
+#define   O_TX_CONTROL__Tx3Halt                                      19
+#define   O_TX_CONTROL__Tx2Halt                                      18
+#define   O_TX_CONTROL__Tx1Halt                                      17
+#define   O_TX_CONTROL__Tx0Halt                                      16
+#define   O_TX_CONTROL__TxIdle                                       15
+#define   O_TX_CONTROL__TxEnable                                     14
+#define   O_TX_CONTROL__TxThreshold                                  0
+#define   W_TX_CONTROL__TxThreshold                                  14
+#define R_RX_CONTROL                                                 0x0A1
+#define   O_RX_CONTROL__RxHalt                                       1
+#define   O_RX_CONTROL__RxEnable                                     0
+#define R_DESC_PACK_CTRL                                            0x0A2
+#define   O_DESC_PACK_CTRL__ByteOffset                              17
+#define   W_DESC_PACK_CTRL__ByteOffset                              3
+#define   O_DESC_PACK_CTRL__PrePadEnable                            16
+#define   O_DESC_PACK_CTRL__MaxEntry                                14
+#define   W_DESC_PACK_CTRL__MaxEntry                                2
+#define   O_DESC_PACK_CTRL__RegularSize                             0
+#define   W_DESC_PACK_CTRL__RegularSize                             14
+#define R_STATCTRL                                                  0x0A3
+#define   O_STATCTRL__OverFlowEn                                    4
+#define   O_STATCTRL__GIG                                           3
+#define   O_STATCTRL__Sten                                          2
+#define   O_STATCTRL__ClrCnt                                        1
+#define   O_STATCTRL__AutoZ                                         0
+#define R_L2ALLOCCTRL                                               0x0A4
+#define   O_L2ALLOCCTRL__TxL2Allocate                               9
+#define   W_L2ALLOCCTRL__TxL2Allocate                               9
+#define   O_L2ALLOCCTRL__RxL2Allocate                               0
+#define   W_L2ALLOCCTRL__RxL2Allocate                               9
+#define R_INTMASK                                                   0x0A5
+#define   O_INTMASK__Spi4TxError                                     28
+#define   O_INTMASK__Spi4RxError                                     27
+#define   O_INTMASK__RGMIIHalfDupCollision                           27
+#define   O_INTMASK__Abort                                           26
+#define   O_INTMASK__Underrun                                        25
+#define   O_INTMASK__DiscardPacket                                   24
+#define   O_INTMASK__AsyncFifoFull                                   23
+#define   O_INTMASK__TagFull                                        22
+#define   O_INTMASK__Class3Full                                     21
+#define   O_INTMASK__C3EarlyFull                                    20
+#define   O_INTMASK__Class2Full                                     19
+#define   O_INTMASK__C2EarlyFull                                    18
+#define   O_INTMASK__Class1Full                                     17
+#define   O_INTMASK__C1EarlyFull                                    16
+#define   O_INTMASK__Class0Full                                     15
+#define   O_INTMASK__C0EarlyFull                                    14
+#define   O_INTMASK__RxDataFull                                     13
+#define   O_INTMASK__RxEarlyFull                                    12
+#define   O_INTMASK__JFreeEmpty                                     11
+#define   O_INTMASK__JFEarlyEmpty                                   10
+#define   O_INTMASK__RFreeEmpty                                     9
+#define   O_INTMASK__RFEarlyEmpty                                   8
+#define   O_INTMASK__FreeDescFull                                   5
+#define   O_INTMASK__FreeEarlyFull                                  4
+#define   O_INTMASK__TxFetchError                                   3
+#define   O_INTMASK__MDInt                                           1
+#define   O_INTMASK__TxIllegal                                      0
+#define R_INTREG                                                    0x0A6
+#define   O_INTREG__TagFull                                         22
+#define   O_INTREG__Class3Full                                      21
+#define   O_INTREG__C3EarlyFull                                     20
+#define   O_INTREG__Class2Full                                      19
+#define   O_INTREG__C2EarlyFull                                     18
+#define   O_INTREG__Class1Full                                      17
+#define   O_INTREG__C1EarlyFull                                     16
+#define   O_INTREG__Class0Full                                      15
+#define   O_INTREG__C0EarlyFull                                     14
+#define   O_INTREG__RxDataFull                                      13
+#define   O_INTREG__RxEarlyFull                                     12
+#define   O_INTREG__JFreeEmpty                                      11
+#define   O_INTREG__JFEarlyEmpty                                    10
+#define   O_INTREG__RFreeEmpty                                      9
+#define   O_INTREG__RFEarlyEmpty                                    8
+#define   O_INTREG__FreeDescFull                                    5
+#define   O_INTREG__FreeEarlyFull                                   4
+#define   O_INTREG__TxFetchError                                    3
+#define   O_INTREG__StatCarry                                       2
+#define   O_INTREG__MDInt                                           1
+#define   O_INTREG__TxIllegal                                       0
+#define R_TXRETRY                                                   0x0A7
+#define   O_TXRETRY__CollisionRetry                                 6
+#define   O_TXRETRY__BusErrorRetry                                  5
+#define   O_TXRETRY__UnderRunRetry                                  4
+#define   O_TXRETRY__Retries                                        0
+#define   W_TXRETRY__Retries                                        4
+#define R_CORECONTROL                                               0x0A8
+#define   O_CORECONTROL__ErrorThread                                4
+#define   W_CORECONTROL__ErrorThread                                7
+#define   O_CORECONTROL__Shutdown                                   2
+#define   O_CORECONTROL__Speed                                      0
+#define   W_CORECONTROL__Speed                                      2
+#define R_L2TYPE_0                                                  0x0F0
+#define   O_L2TYPE__ExtraHdrProtoSize                               26
+#define   W_L2TYPE__ExtraHdrProtoSize                               5
+#define   O_L2TYPE__ExtraHdrProtoOffset                             20
+#define   W_L2TYPE__ExtraHdrProtoOffset                             6
+#define   O_L2TYPE__ExtraHeaderSize                                 14
+#define   W_L2TYPE__ExtraHeaderSize                                 6
+#define   O_L2TYPE__ProtoOffset                                     8
+#define   W_L2TYPE__ProtoOffset                                     6
+#define   O_L2TYPE__L2HdrOffset                                     2
+#define   W_L2TYPE__L2HdrOffset                                     6
+#define   O_L2TYPE__L2Proto                                         0
+#define   W_L2TYPE__L2Proto                                         2
+#define R_L2TYPE_1                                                  0x4F0
+#define R_L2TYPE_2                                                  0x8F0
+#define R_L2TYPE_3                                                  0xCF0
+#define R_PARSERCONFIGREG                                           0x100
+#define   O_PARSERCONFIGREG__CRCHashPoly                            8
+#define   W_PARSERCONFIGREG__CRCHashPoly                            7
+#define   O_PARSERCONFIGREG__PrePadOffset                           4
+#define   W_PARSERCONFIGREG__PrePadOffset                           4
+#define   O_PARSERCONFIGREG__UseCAM                                 2
+#define   O_PARSERCONFIGREG__UseHASH                                1
+#define   O_PARSERCONFIGREG__UseProto                               0
+#define R_L3CTABLE                                                  0x140
+#define   O_L3CTABLE__Offset0                                       25
+#define   W_L3CTABLE__Offset0                                       7
+#define   O_L3CTABLE__Len0                                          21
+#define   W_L3CTABLE__Len0                                          4
+#define   O_L3CTABLE__Offset1                                       14
+#define   W_L3CTABLE__Offset1                                       7
+#define   O_L3CTABLE__Len1                                          10
+#define   W_L3CTABLE__Len1                                          4
+#define   O_L3CTABLE__Offset2                                       4
+#define   W_L3CTABLE__Offset2                                       6
+#define   O_L3CTABLE__Len2                                          0
+#define   W_L3CTABLE__Len2                                          4
+#define   O_L3CTABLE__L3HdrOffset                                   26
+#define   W_L3CTABLE__L3HdrOffset                                   6
+#define   O_L3CTABLE__L4ProtoOffset                                 20
+#define   W_L3CTABLE__L4ProtoOffset                                 6
+#define   O_L3CTABLE__IPChksumCompute                               19
+#define   O_L3CTABLE__L4Classify                                    18
+#define   O_L3CTABLE__L2Proto                                       16
+#define   W_L3CTABLE__L2Proto                                       2
+#define   O_L3CTABLE__L3ProtoKey                                    0
+#define   W_L3CTABLE__L3ProtoKey                                    16
+#define R_L4CTABLE                                                  0x160
+#define   O_L4CTABLE__Offset0                                       21
+#define   W_L4CTABLE__Offset0                                       6
+#define   O_L4CTABLE__Len0                                          17
+#define   W_L4CTABLE__Len0                                          4
+#define   O_L4CTABLE__Offset1                                       11
+#define   W_L4CTABLE__Offset1                                       6
+#define   O_L4CTABLE__Len1                                          7
+#define   W_L4CTABLE__Len1                                          4
+#define   O_L4CTABLE__TCPChksumEnable                               0
+#define R_CAM4X128TABLE                                             0x172
+#define   O_CAM4X128TABLE__ClassId                                  7
+#define   W_CAM4X128TABLE__ClassId                                  2
+#define   O_CAM4X128TABLE__BucketId                                 1
+#define   W_CAM4X128TABLE__BucketId                                 6
+#define   O_CAM4X128TABLE__UseBucket                                0
+#define R_CAM4X128KEY                                               0x180
+#define R_TRANSLATETABLE                                            0x1A0
+#define R_DMACR0                                                    0x200
+#define   O_DMACR0__Data0WrMaxCr                                    27
+#define   W_DMACR0__Data0WrMaxCr                                    3
+#define   O_DMACR0__Data0RdMaxCr                                    24
+#define   W_DMACR0__Data0RdMaxCr                                    3
+#define   O_DMACR0__Data1WrMaxCr                                    21
+#define   W_DMACR0__Data1WrMaxCr                                    3
+#define   O_DMACR0__Data1RdMaxCr                                    18
+#define   W_DMACR0__Data1RdMaxCr                                    3
+#define   O_DMACR0__Data2WrMaxCr                                    15
+#define   W_DMACR0__Data2WrMaxCr                                    3
+#define   O_DMACR0__Data2RdMaxCr                                    12
+#define   W_DMACR0__Data2RdMaxCr                                    3
+#define   O_DMACR0__Data3WrMaxCr                                    9
+#define   W_DMACR0__Data3WrMaxCr                                    3
+#define   O_DMACR0__Data3RdMaxCr                                    6
+#define   W_DMACR0__Data3RdMaxCr                                    3
+#define   O_DMACR0__Data4WrMaxCr                                    3
+#define   W_DMACR0__Data4WrMaxCr                                    3
+#define   O_DMACR0__Data4RdMaxCr                                    0
+#define   W_DMACR0__Data4RdMaxCr                                    3
+#define R_DMACR1                                                    0x201
+#define   O_DMACR1__Data5WrMaxCr                                    27
+#define   W_DMACR1__Data5WrMaxCr                                    3
+#define   O_DMACR1__Data5RdMaxCr                                    24
+#define   W_DMACR1__Data5RdMaxCr                                    3
+#define   O_DMACR1__Data6WrMaxCr                                    21
+#define   W_DMACR1__Data6WrMaxCr                                    3
+#define   O_DMACR1__Data6RdMaxCr                                    18
+#define   W_DMACR1__Data6RdMaxCr                                    3
+#define   O_DMACR1__Data7WrMaxCr                                    15
+#define   W_DMACR1__Data7WrMaxCr                                    3
+#define   O_DMACR1__Data7RdMaxCr                                    12
+#define   W_DMACR1__Data7RdMaxCr                                    3
+#define   O_DMACR1__Data8WrMaxCr                                    9
+#define   W_DMACR1__Data8WrMaxCr                                    3
+#define   O_DMACR1__Data8RdMaxCr                                    6
+#define   W_DMACR1__Data8RdMaxCr                                    3
+#define   O_DMACR1__Data9WrMaxCr                                    3
+#define   W_DMACR1__Data9WrMaxCr                                    3
+#define   O_DMACR1__Data9RdMaxCr                                    0
+#define   W_DMACR1__Data9RdMaxCr                                    3
+#define R_DMACR2                                                    0x202
+#define   O_DMACR2__Data10WrMaxCr                                   27
+#define   W_DMACR2__Data10WrMaxCr                                   3
+#define   O_DMACR2__Data10RdMaxCr                                   24
+#define   W_DMACR2__Data10RdMaxCr                                   3
+#define   O_DMACR2__Data11WrMaxCr                                   21
+#define   W_DMACR2__Data11WrMaxCr                                   3
+#define   O_DMACR2__Data11RdMaxCr                                   18
+#define   W_DMACR2__Data11RdMaxCr                                   3
+#define   O_DMACR2__Data12WrMaxCr                                   15
+#define   W_DMACR2__Data12WrMaxCr                                   3
+#define   O_DMACR2__Data12RdMaxCr                                   12
+#define   W_DMACR2__Data12RdMaxCr                                   3
+#define   O_DMACR2__Data13WrMaxCr                                   9
+#define   W_DMACR2__Data13WrMaxCr                                   3
+#define   O_DMACR2__Data13RdMaxCr                                   6
+#define   W_DMACR2__Data13RdMaxCr                                   3
+#define   O_DMACR2__Data14WrMaxCr                                   3
+#define   W_DMACR2__Data14WrMaxCr                                   3
+#define   O_DMACR2__Data14RdMaxCr                                   0
+#define   W_DMACR2__Data14RdMaxCr                                   3
+#define R_DMACR3                                                    0x203
+#define   O_DMACR3__Data15WrMaxCr                                   27
+#define   W_DMACR3__Data15WrMaxCr                                   3
+#define   O_DMACR3__Data15RdMaxCr                                   24
+#define   W_DMACR3__Data15RdMaxCr                                   3
+#define   O_DMACR3__SpClassWrMaxCr                                  21
+#define   W_DMACR3__SpClassWrMaxCr                                  3
+#define   O_DMACR3__SpClassRdMaxCr                                  18
+#define   W_DMACR3__SpClassRdMaxCr                                  3
+#define   O_DMACR3__JumFrInWrMaxCr                                  15
+#define   W_DMACR3__JumFrInWrMaxCr                                  3
+#define   O_DMACR3__JumFrInRdMaxCr                                  12
+#define   W_DMACR3__JumFrInRdMaxCr                                  3
+#define   O_DMACR3__RegFrInWrMaxCr                                  9
+#define   W_DMACR3__RegFrInWrMaxCr                                  3
+#define   O_DMACR3__RegFrInRdMaxCr                                  6
+#define   W_DMACR3__RegFrInRdMaxCr                                  3
+#define   O_DMACR3__FrOutWrMaxCr                                    3
+#define   W_DMACR3__FrOutWrMaxCr                                    3
+#define   O_DMACR3__FrOutRdMaxCr                                    0
+#define   W_DMACR3__FrOutRdMaxCr                                    3
+#define R_REG_FRIN_SPILL_MEM_START_0                                0x204
+#define   O_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0        0
+#define   W_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0       32
+#define R_REG_FRIN_SPILL_MEM_START_1                                0x205
+#define   O_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        0
+#define   W_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        3
+#define R_REG_FRIN_SPILL_MEM_SIZE                                   0x206
+#define   O_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize             0
+#define   W_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize            32
+#define R_FROUT_SPILL_MEM_START_0                                   0x207
+#define   O_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0             0
+#define   W_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0            32
+#define R_FROUT_SPILL_MEM_START_1                                   0x208
+#define   O_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             0
+#define   W_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             3
+#define R_FROUT_SPILL_MEM_SIZE                                      0x209
+#define   O_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                  0
+#define   W_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                 32
+#define R_CLASS0_SPILL_MEM_START_0                                  0x20A
+#define   O_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0           0
+#define   W_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0          32
+#define R_CLASS0_SPILL_MEM_START_1                                  0x20B
+#define   O_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           0
+#define   W_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           3
+#define R_CLASS0_SPILL_MEM_SIZE                                     0x20C
+#define   O_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize                0
+#define   W_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize               32
+#define R_JUMFRIN_SPILL_MEM_START_0                                 0x20D
+#define   O_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0          0
+#define   W_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0         32
+#define R_JUMFRIN_SPILL_MEM_START_1                                 0x20E
+#define   O_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         0
+#define   W_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         3
+#define R_JUMFRIN_SPILL_MEM_SIZE                                    0x20F
+#define   O_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize              0
+#define   W_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize             32
+#define R_CLASS1_SPILL_MEM_START_0                                  0x210
+#define   O_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0           0
+#define   W_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0          32
+#define R_CLASS1_SPILL_MEM_START_1                                  0x211
+#define   O_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           0
+#define   W_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           3
+#define R_CLASS1_SPILL_MEM_SIZE                                     0x212
+#define   O_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize                0
+#define   W_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize               32
+#define R_CLASS2_SPILL_MEM_START_0                                  0x213
+#define   O_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0           0
+#define   W_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0          32
+#define R_CLASS2_SPILL_MEM_START_1                                  0x214
+#define   O_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           0
+#define   W_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           3
+#define R_CLASS2_SPILL_MEM_SIZE                                     0x215
+#define   O_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize                0
+#define   W_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize               32
+#define R_CLASS3_SPILL_MEM_START_0                                  0x216
+#define   O_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0           0
+#define   W_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0          32
+#define R_CLASS3_SPILL_MEM_START_1                                  0x217
+#define   O_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           0
+#define   W_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           3
+#define R_CLASS3_SPILL_MEM_SIZE                                     0x218
+#define   O_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize                0
+#define   W_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize               32
+#define R_REG_FRIN1_SPILL_MEM_START_0                               0x219
+#define R_REG_FRIN1_SPILL_MEM_START_1                               0x21a
+#define R_REG_FRIN1_SPILL_MEM_SIZE                                  0x21b
+#define R_SPIHNGY0                                                  0x219
+#define   O_SPIHNGY0__EG_HNGY_THRESH_0                              24
+#define   W_SPIHNGY0__EG_HNGY_THRESH_0                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_1                              16
+#define   W_SPIHNGY0__EG_HNGY_THRESH_1                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_2                              8
+#define   W_SPIHNGY0__EG_HNGY_THRESH_2                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_3                              0
+#define   W_SPIHNGY0__EG_HNGY_THRESH_3                              7
+#define R_SPIHNGY1                                                  0x21A
+#define   O_SPIHNGY1__EG_HNGY_THRESH_4                              24
+#define   W_SPIHNGY1__EG_HNGY_THRESH_4                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_5                              16
+#define   W_SPIHNGY1__EG_HNGY_THRESH_5                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_6                              8
+#define   W_SPIHNGY1__EG_HNGY_THRESH_6                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_7                              0
+#define   W_SPIHNGY1__EG_HNGY_THRESH_7                              7
+#define R_SPIHNGY2                                                  0x21B
+#define   O_SPIHNGY2__EG_HNGY_THRESH_8                              24
+#define   W_SPIHNGY2__EG_HNGY_THRESH_8                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_9                              16
+#define   W_SPIHNGY2__EG_HNGY_THRESH_9                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_10                             8
+#define   W_SPIHNGY2__EG_HNGY_THRESH_10                             7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_11                             0
+#define   W_SPIHNGY2__EG_HNGY_THRESH_11                             7
+#define R_SPIHNGY3                                                  0x21C
+#define   O_SPIHNGY3__EG_HNGY_THRESH_12                             24
+#define   W_SPIHNGY3__EG_HNGY_THRESH_12                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_13                             16
+#define   W_SPIHNGY3__EG_HNGY_THRESH_13                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_14                             8
+#define   W_SPIHNGY3__EG_HNGY_THRESH_14                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_15                             0
+#define   W_SPIHNGY3__EG_HNGY_THRESH_15                             7
+#define R_SPISTRV0                                                  0x21D
+#define   O_SPISTRV0__EG_STRV_THRESH_0                              24
+#define   W_SPISTRV0__EG_STRV_THRESH_0                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_1                              16
+#define   W_SPISTRV0__EG_STRV_THRESH_1                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_2                              8
+#define   W_SPISTRV0__EG_STRV_THRESH_2                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_3                              0
+#define   W_SPISTRV0__EG_STRV_THRESH_3                              7
+#define R_SPISTRV1                                                  0x21E
+#define   O_SPISTRV1__EG_STRV_THRESH_4                              24
+#define   W_SPISTRV1__EG_STRV_THRESH_4                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_5                              16
+#define   W_SPISTRV1__EG_STRV_THRESH_5                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_6                              8
+#define   W_SPISTRV1__EG_STRV_THRESH_6                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_7                              0
+#define   W_SPISTRV1__EG_STRV_THRESH_7                              7
+#define R_SPISTRV2                                                  0x21F
+#define   O_SPISTRV2__EG_STRV_THRESH_8                              24
+#define   W_SPISTRV2__EG_STRV_THRESH_8                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_9                              16
+#define   W_SPISTRV2__EG_STRV_THRESH_9                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_10                             8
+#define   W_SPISTRV2__EG_STRV_THRESH_10                             7
+#define   O_SPISTRV2__EG_STRV_THRESH_11                             0
+#define   W_SPISTRV2__EG_STRV_THRESH_11                             7
+#define R_SPISTRV3                                                  0x220
+#define   O_SPISTRV3__EG_STRV_THRESH_12                             24
+#define   W_SPISTRV3__EG_STRV_THRESH_12                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_13                             16
+#define   W_SPISTRV3__EG_STRV_THRESH_13                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_14                             8
+#define   W_SPISTRV3__EG_STRV_THRESH_14                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_15                             0
+#define   W_SPISTRV3__EG_STRV_THRESH_15                             7
+#define R_TXDATAFIFO0                                               0x221
+#define   O_TXDATAFIFO0__Tx0DataFifoStart                           24
+#define   W_TXDATAFIFO0__Tx0DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx0DataFifoSize                            16
+#define   W_TXDATAFIFO0__Tx0DataFifoSize                            7
+#define   O_TXDATAFIFO0__Tx1DataFifoStart                           8
+#define   W_TXDATAFIFO0__Tx1DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx1DataFifoSize                            0
+#define   W_TXDATAFIFO0__Tx1DataFifoSize                            7
+#define R_TXDATAFIFO1                                               0x222
+#define   O_TXDATAFIFO1__Tx2DataFifoStart                           24
+#define   W_TXDATAFIFO1__Tx2DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx2DataFifoSize                            16
+#define   W_TXDATAFIFO1__Tx2DataFifoSize                            7
+#define   O_TXDATAFIFO1__Tx3DataFifoStart                           8
+#define   W_TXDATAFIFO1__Tx3DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx3DataFifoSize                            0
+#define   W_TXDATAFIFO1__Tx3DataFifoSize                            7
+#define R_TXDATAFIFO2                                               0x223
+#define   O_TXDATAFIFO2__Tx4DataFifoStart                           24
+#define   W_TXDATAFIFO2__Tx4DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx4DataFifoSize                            16
+#define   W_TXDATAFIFO2__Tx4DataFifoSize                            7
+#define   O_TXDATAFIFO2__Tx5DataFifoStart                           8
+#define   W_TXDATAFIFO2__Tx5DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx5DataFifoSize                            0
+#define   W_TXDATAFIFO2__Tx5DataFifoSize                            7
+#define R_TXDATAFIFO3                                               0x224
+#define   O_TXDATAFIFO3__Tx6DataFifoStart                           24
+#define   W_TXDATAFIFO3__Tx6DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx6DataFifoSize                            16
+#define   W_TXDATAFIFO3__Tx6DataFifoSize                            7
+#define   O_TXDATAFIFO3__Tx7DataFifoStart                           8
+#define   W_TXDATAFIFO3__Tx7DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx7DataFifoSize                            0
+#define   W_TXDATAFIFO3__Tx7DataFifoSize                            7
+#define R_TXDATAFIFO4                                               0x225
+#define   O_TXDATAFIFO4__Tx8DataFifoStart                           24
+#define   W_TXDATAFIFO4__Tx8DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx8DataFifoSize                            16
+#define   W_TXDATAFIFO4__Tx8DataFifoSize                            7
+#define   O_TXDATAFIFO4__Tx9DataFifoStart                           8
+#define   W_TXDATAFIFO4__Tx9DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx9DataFifoSize                            0
+#define   W_TXDATAFIFO4__Tx9DataFifoSize                            7
+#define R_TXDATAFIFO5                                               0x226
+#define   O_TXDATAFIFO5__Tx10DataFifoStart                          24
+#define   W_TXDATAFIFO5__Tx10DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx10DataFifoSize                           16
+#define   W_TXDATAFIFO5__Tx10DataFifoSize                           7
+#define   O_TXDATAFIFO5__Tx11DataFifoStart                          8
+#define   W_TXDATAFIFO5__Tx11DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx11DataFifoSize                           0
+#define   W_TXDATAFIFO5__Tx11DataFifoSize                           7
+#define R_TXDATAFIFO6                                               0x227
+#define   O_TXDATAFIFO6__Tx12DataFifoStart                          24
+#define   W_TXDATAFIFO6__Tx12DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx12DataFifoSize                           16
+#define   W_TXDATAFIFO6__Tx12DataFifoSize                           7
+#define   O_TXDATAFIFO6__Tx13DataFifoStart                          8
+#define   W_TXDATAFIFO6__Tx13DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx13DataFifoSize                           0
+#define   W_TXDATAFIFO6__Tx13DataFifoSize                           7
+#define R_TXDATAFIFO7                                               0x228
+#define   O_TXDATAFIFO7__Tx14DataFifoStart                          24
+#define   W_TXDATAFIFO7__Tx14DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx14DataFifoSize                           16
+#define   W_TXDATAFIFO7__Tx14DataFifoSize                           7
+#define   O_TXDATAFIFO7__Tx15DataFifoStart                          8
+#define   W_TXDATAFIFO7__Tx15DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx15DataFifoSize                           0
+#define   W_TXDATAFIFO7__Tx15DataFifoSize                           7
+#define R_RXDATAFIFO0                                               0x229
+#define   O_RXDATAFIFO0__Rx0DataFifoStart                           24
+#define   W_RXDATAFIFO0__Rx0DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx0DataFifoSize                            16
+#define   W_RXDATAFIFO0__Rx0DataFifoSize                            7
+#define   O_RXDATAFIFO0__Rx1DataFifoStart                           8
+#define   W_RXDATAFIFO0__Rx1DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx1DataFifoSize                            0
+#define   W_RXDATAFIFO0__Rx1DataFifoSize                            7
+#define R_RXDATAFIFO1                                               0x22A
+#define   O_RXDATAFIFO1__Rx2DataFifoStart                           24
+#define   W_RXDATAFIFO1__Rx2DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx2DataFifoSize                            16
+#define   W_RXDATAFIFO1__Rx2DataFifoSize                            7
+#define   O_RXDATAFIFO1__Rx3DataFifoStart                           8
+#define   W_RXDATAFIFO1__Rx3DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx3DataFifoSize                            0
+#define   W_RXDATAFIFO1__Rx3DataFifoSize                            7
+#define R_RXDATAFIFO2                                               0x22B
+#define   O_RXDATAFIFO2__Rx4DataFifoStart                           24
+#define   W_RXDATAFIFO2__Rx4DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx4DataFifoSize                            16
+#define   W_RXDATAFIFO2__Rx4DataFifoSize                            7
+#define   O_RXDATAFIFO2__Rx5DataFifoStart                           8
+#define   W_RXDATAFIFO2__Rx5DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx5DataFifoSize                            0
+#define   W_RXDATAFIFO2__Rx5DataFifoSize                            7
+#define R_RXDATAFIFO3                                               0x22C
+#define   O_RXDATAFIFO3__Rx6DataFifoStart                           24
+#define   W_RXDATAFIFO3__Rx6DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx6DataFifoSize                            16
+#define   W_RXDATAFIFO3__Rx6DataFifoSize                            7
+#define   O_RXDATAFIFO3__Rx7DataFifoStart                           8
+#define   W_RXDATAFIFO3__Rx7DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx7DataFifoSize                            0
+#define   W_RXDATAFIFO3__Rx7DataFifoSize                            7
+#define R_RXDATAFIFO4                                               0x22D
+#define   O_RXDATAFIFO4__Rx8DataFifoStart                           24
+#define   W_RXDATAFIFO4__Rx8DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx8DataFifoSize                            16
+#define   W_RXDATAFIFO4__Rx8DataFifoSize                            7
+#define   O_RXDATAFIFO4__Rx9DataFifoStart                           8
+#define   W_RXDATAFIFO4__Rx9DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx9DataFifoSize                            0
+#define   W_RXDATAFIFO4__Rx9DataFifoSize                            7
+#define R_RXDATAFIFO5                                               0x22E
+#define   O_RXDATAFIFO5__Rx10DataFifoStart                          24
+#define   W_RXDATAFIFO5__Rx10DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx10DataFifoSize                           16
+#define   W_RXDATAFIFO5__Rx10DataFifoSize                           7
+#define   O_RXDATAFIFO5__Rx11DataFifoStart                          8
+#define   W_RXDATAFIFO5__Rx11DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx11DataFifoSize                           0
+#define   W_RXDATAFIFO5__Rx11DataFifoSize                           7
+#define R_RXDATAFIFO6                                               0x22F
+#define   O_RXDATAFIFO6__Rx12DataFifoStart                          24
+#define   W_RXDATAFIFO6__Rx12DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx12DataFifoSize                           16
+#define   W_RXDATAFIFO6__Rx12DataFifoSize                           7
+#define   O_RXDATAFIFO6__Rx13DataFifoStart                          8
+#define   W_RXDATAFIFO6__Rx13DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx13DataFifoSize                           0
+#define   W_RXDATAFIFO6__Rx13DataFifoSize                           7
+#define R_RXDATAFIFO7                                               0x230
+#define   O_RXDATAFIFO7__Rx14DataFifoStart                          24
+#define   W_RXDATAFIFO7__Rx14DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx14DataFifoSize                           16
+#define   W_RXDATAFIFO7__Rx14DataFifoSize                           7
+#define   O_RXDATAFIFO7__Rx15DataFifoStart                          8
+#define   W_RXDATAFIFO7__Rx15DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx15DataFifoSize                           0
+#define   W_RXDATAFIFO7__Rx15DataFifoSize                           7
+#define R_FREEQCARVE                                                0x233
+#define R_SPI4STATICDELAY0                                          0x240
+#define   O_SPI4STATICDELAY0__DataLine7                             28
+#define   W_SPI4STATICDELAY0__DataLine7                             4
+#define   O_SPI4STATICDELAY0__DataLine6                             24
+#define   W_SPI4STATICDELAY0__DataLine6                             4
+#define   O_SPI4STATICDELAY0__DataLine5                             20
+#define   W_SPI4STATICDELAY0__DataLine5                             4
+#define   O_SPI4STATICDELAY0__DataLine4                             16
+#define   W_SPI4STATICDELAY0__DataLine4                             4
+#define   O_SPI4STATICDELAY0__DataLine3                             12
+#define   W_SPI4STATICDELAY0__DataLine3                             4
+#define   O_SPI4STATICDELAY0__DataLine2                             8
+#define   W_SPI4STATICDELAY0__DataLine2                             4
+#define   O_SPI4STATICDELAY0__DataLine1                             4
+#define   W_SPI4STATICDELAY0__DataLine1                             4
+#define   O_SPI4STATICDELAY0__DataLine0                             0
+#define   W_SPI4STATICDELAY0__DataLine0                             4
+#define R_SPI4STATICDELAY1                                          0x241
+#define   O_SPI4STATICDELAY1__DataLine15                            28
+#define   W_SPI4STATICDELAY1__DataLine15                            4
+#define   O_SPI4STATICDELAY1__DataLine14                            24
+#define   W_SPI4STATICDELAY1__DataLine14                            4
+#define   O_SPI4STATICDELAY1__DataLine13                            20
+#define   W_SPI4STATICDELAY1__DataLine13                            4
+#define   O_SPI4STATICDELAY1__DataLine12                            16
+#define   W_SPI4STATICDELAY1__DataLine12                            4
+#define   O_SPI4STATICDELAY1__DataLine11                            12
+#define   W_SPI4STATICDELAY1__DataLine11                            4
+#define   O_SPI4STATICDELAY1__DataLine10                            8
+#define   W_SPI4STATICDELAY1__DataLine10                            4
+#define   O_SPI4STATICDELAY1__DataLine9                             4
+#define   W_SPI4STATICDELAY1__DataLine9                             4
+#define   O_SPI4STATICDELAY1__DataLine8                             0
+#define   W_SPI4STATICDELAY1__DataLine8                             4
+#define R_SPI4STATICDELAY2                                          0x242
+#define   O_SPI4STATICDELAY0__TxStat1                               8
+#define   W_SPI4STATICDELAY0__TxStat1                               4
+#define   O_SPI4STATICDELAY0__TxStat0                               4
+#define   W_SPI4STATICDELAY0__TxStat0                               4
+#define   O_SPI4STATICDELAY0__RxControl                             0
+#define   W_SPI4STATICDELAY0__RxControl                             4
+#define R_SPI4CONTROL                                               0x243
+#define   O_SPI4CONTROL__StaticDelay                                2
+#define   O_SPI4CONTROL__LVDS_LVTTL                                 1
+#define   O_SPI4CONTROL__SPI4Enable                                 0
+#define R_CLASSWATERMARKS                                           0x244
+#define   O_CLASSWATERMARKS__Class0Watermark                        24
+#define   W_CLASSWATERMARKS__Class0Watermark                        5
+#define   O_CLASSWATERMARKS__Class1Watermark                        16
+#define   W_CLASSWATERMARKS__Class1Watermark                        5
+#define   O_CLASSWATERMARKS__Class3Watermark                        0
+#define   W_CLASSWATERMARKS__Class3Watermark                        5
+#define R_RXWATERMARKS1                                              0x245
+#define   O_RXWATERMARKS__Rx0DataWatermark                          24
+#define   W_RXWATERMARKS__Rx0DataWatermark                          7
+#define   O_RXWATERMARKS__Rx1DataWatermark                          16
+#define   W_RXWATERMARKS__Rx1DataWatermark                          7
+#define   O_RXWATERMARKS__Rx3DataWatermark                          0
+#define   W_RXWATERMARKS__Rx3DataWatermark                          7
+#define R_RXWATERMARKS2                                              0x246
+#define   O_RXWATERMARKS__Rx4DataWatermark                          24
+#define   W_RXWATERMARKS__Rx4DataWatermark                          7
+#define   O_RXWATERMARKS__Rx5DataWatermark                          16
+#define   W_RXWATERMARKS__Rx5DataWatermark                          7
+#define   O_RXWATERMARKS__Rx6DataWatermark                          8
+#define   W_RXWATERMARKS__Rx6DataWatermark                          7
+#define   O_RXWATERMARKS__Rx7DataWatermark                          0
+#define   W_RXWATERMARKS__Rx7DataWatermark                          7
+#define R_RXWATERMARKS3                                              0x247
+#define   O_RXWATERMARKS__Rx8DataWatermark                          24
+#define   W_RXWATERMARKS__Rx8DataWatermark                          7
+#define   O_RXWATERMARKS__Rx9DataWatermark                          16
+#define   W_RXWATERMARKS__Rx9DataWatermark                          7
+#define   O_RXWATERMARKS__Rx10DataWatermark                         8
+#define   W_RXWATERMARKS__Rx10DataWatermark                         7
+#define   O_RXWATERMARKS__Rx11DataWatermark                         0
+#define   W_RXWATERMARKS__Rx11DataWatermark                         7
+#define R_RXWATERMARKS4                                              0x248
+#define   O_RXWATERMARKS__Rx12DataWatermark                         24
+#define   W_RXWATERMARKS__Rx12DataWatermark                         7
+#define   O_RXWATERMARKS__Rx13DataWatermark                         16
+#define   W_RXWATERMARKS__Rx13DataWatermark                         7
+#define   O_RXWATERMARKS__Rx14DataWatermark                         8
+#define   W_RXWATERMARKS__Rx14DataWatermark                         7
+#define   O_RXWATERMARKS__Rx15DataWatermark                         0
+#define   W_RXWATERMARKS__Rx15DataWatermark                         7
+#define R_FREEWATERMARKS                                            0x249
+#define   O_FREEWATERMARKS__FreeOutWatermark                        16
+#define   W_FREEWATERMARKS__FreeOutWatermark                        16
+#define   O_FREEWATERMARKS__JumFrWatermark                          8
+#define   W_FREEWATERMARKS__JumFrWatermark                          7
+#define   O_FREEWATERMARKS__RegFrWatermark                          0
+#define   W_FREEWATERMARKS__RegFrWatermark                          7
+
+#define TYPE_GMAC       0
+#define TYPE_XGMAC      1
+#define TYPE_SPI4       2
+
+#define CTRL_RES0           0
+#define CTRL_RES1           1
+#define CTRL_REG_FREE       2
+#define CTRL_JUMBO_FREE     3
+#define CTRL_CONT           4
+#define CTRL_EOP            5
+#define CTRL_START          6
+#define CTRL_SNGL           7
+
+
+#define R_ROUND_ROBIN_TABLE                 0
+#define R_PDE_CLASS_0                       0x300
+#define R_PDE_CLASS_1                       0x302
+#define R_PDE_CLASS_2                       0x304
+#define R_PDE_CLASS_3                       0x306
+
+#define R_MSG_TX_THRESHOLD                  0x308
+
+#define R_GMAC_JFR0_BUCKET_SIZE              0x320
+#define R_GMAC_RFR0_BUCKET_SIZE              0x321
+#define R_GMAC_TX0_BUCKET_SIZE              0x322
+#define R_GMAC_TX1_BUCKET_SIZE              0x323
+#define R_GMAC_TX2_BUCKET_SIZE              0x324
+#define R_GMAC_TX3_BUCKET_SIZE              0x325
+#define R_GMAC_JFR1_BUCKET_SIZE              0x326
+#define R_GMAC_RFR1_BUCKET_SIZE              0x327
+
+#define R_XGS_TX0_BUCKET_SIZE               0x320
+#define R_XGS_TX1_BUCKET_SIZE               0x321
+#define R_XGS_TX2_BUCKET_SIZE               0x322
+#define R_XGS_TX3_BUCKET_SIZE               0x323
+#define R_XGS_TX4_BUCKET_SIZE               0x324
+#define R_XGS_TX5_BUCKET_SIZE               0x325
+#define R_XGS_TX6_BUCKET_SIZE               0x326
+#define R_XGS_TX7_BUCKET_SIZE               0x327
+#define R_XGS_TX8_BUCKET_SIZE               0x328
+#define R_XGS_TX9_BUCKET_SIZE               0x329
+#define R_XGS_TX10_BUCKET_SIZE              0x32A
+#define R_XGS_TX11_BUCKET_SIZE              0x32B
+#define R_XGS_TX12_BUCKET_SIZE              0x32C
+#define R_XGS_TX13_BUCKET_SIZE              0x32D
+#define R_XGS_TX14_BUCKET_SIZE              0x32E
+#define R_XGS_TX15_BUCKET_SIZE              0x32F
+#define R_XGS_JFR_BUCKET_SIZE               0x330
+#define R_XGS_RFR_BUCKET_SIZE               0x331
+
+#define R_CC_CPU0_0                         0x380
+#define R_CC_CPU1_0                         0x388
+#define R_CC_CPU2_0                         0x390
+#define R_CC_CPU3_0                         0x398
+#define R_CC_CPU4_0                         0x3a0
+#define R_CC_CPU5_0                         0x3a8
+#define R_CC_CPU6_0                         0x3b0
+#define R_CC_CPU7_0                         0x3b8
+
+enum tsv_rsv_reg{
+  TX_RX_64_BYTE_FRAME = 0x20,
+  TX_RX_64_127_BYTE_FRAME,
+  TX_RX_128_255_BYTE_FRAME,
+  TX_RX_256_511_BYTE_FRAME,
+  TX_RX_512_1023_BYTE_FRAME,
+  TX_RX_1024_1518_BYTE_FRAME,
+  TX_RX_1519_1522_VLAN_BYTE_FRAME,
+
+  RX_BYTE_COUNTER = 0x27,
+  RX_PACKET_COUNTER,
+  RX_FCS_ERROR_COUNTER,
+  RX_MULTICAST_PACKET_COUNTER,
+  RX_BROADCAST_PACKET_COUNTER,
+  RX_CONTROL_FRAME_PACKET_COUNTER,
+  RX_PAUSE_FRAME_PACKET_COUNTER,
+  RX_UNKNOWN_OP_CODE_COUNTER,
+  RX_ALIGNMENT_ERROR_COUNTER,
+  RX_FRAME_LENGTH_ERROR_COUNTER,
+  RX_CODE_ERROR_COUNTER,
+  RX_CARRIER_SENSE_ERROR_COUNTER,
+  RX_UNDERSIZE_PACKET_COUNTER,
+  RX_OVERSIZE_PACKET_COUNTER,
+  RX_FRAGMENTS_COUNTER,
+  RX_JABBER_COUNTER,
+  RX_DROP_PACKET_COUNTER,
+
+  TX_BYTE_COUNTER   = 0x38,
+  TX_PACKET_COUNTER,
+  TX_MULTICAST_PACKET_COUNTER,
+  TX_BROADCAST_PACKET_COUNTER,
+  TX_PAUSE_CONTROL_FRAME_COUNTER,
+  TX_DEFERRAL_PACKET_COUNTER,
+  TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
+  TX_SINGLE_COLLISION_PACKET_COUNTER,
+  TX_MULTI_COLLISION_PACKET_COUNTER,
+  TX_LATE_COLLISION_PACKET_COUNTER,
+  TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
+  TX_TOTAL_COLLISION_COUNTER,
+  TX_PAUSE_FRAME_HONERED_COUNTER,
+  TX_DROP_FRAME_COUNTER,
+  TX_JABBER_FRAME_COUNTER,
+  TX_FCS_ERROR_COUNTER,
+  TX_CONTROL_FRAME_COUNTER,
+  TX_OVERSIZE_FRAME_COUNTER,
+  TX_UNDERSIZE_FRAME_COUNTER,
+  TX_FRAGMENT_FRAME_COUNTER,
+
+  CARRY_REG_1 = 0x4c,
+  CARRY_REG_2 = 0x4d,
+};
+
+struct size_1_desc {
+  uint64_t entry0;
+};
+
+struct size_2_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+};
+
+struct size_3_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+  uint64_t entry2;
+};
+
+struct size_4_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+  uint64_t entry2;
+  uint64_t entry3;
+};
+
+struct fr_desc {
+  struct size_1_desc d1;
+};
+
+union rx_tx_desc {
+  struct size_2_desc d2;
+};
+
+static inline int mac_make_a0_desc_rfr(struct msgrng_msg *msg, int id, int type,
+				    unsigned long addr)
+{
+  int stid = 0;
+  
+  if ((type == TYPE_XGMAC) || (type == TYPE_SPI4)) stid = msgrng_xgmac_stid_rfr(id);
+  else  {
+#ifdef MAC_SPLIT_MODE
+    stid =  msgrng_gmac_stid_rfr_split_mode(id);
+#else
+    stid = msgrng_gmac_stid_rfr(id);
+#endif 
+  }
+  msg->msg0 = (((uint64_t)CTRL_REG_FREE << 61) | 
+	       ((uint64_t)stid<<52) | 
+	       (uint64_t)addr);
+  msg->msg1 = msg->msg2 = msg->msg3 = 0;
+  
+  return stid;
+}
+static inline int mac_make_b0_desc_rfr(struct msgrng_msg *msg, int id, int type,
+		                                       unsigned long addr)
+{
+	int stid = 0;
+
+	if (type == TYPE_XGMAC) stid = msgrng_xgmac_stid_rfr(id);
+	else  {
+#ifdef MAC_SPLIT_MODE
+		stid =  msgrng_gmac_stid_rfr_split_mode(id);
+#else
+		stid = msgrng_gmac_stid_rfr(id);
+#endif
+	}
+
+	msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
+	msg->msg1 = msg->msg2 = msg->msg3 = 0;
+
+	return stid;
+}
+
+static inline int mac_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
+				    unsigned long addr)
+{
+	if(xlr_revision_a0())
+		return mac_make_a0_desc_rfr(msg, id, type, addr);
+	else
+		return mac_make_b0_desc_rfr(msg, id, type, addr);
+}
+
+
+
+
+#define MAC_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
+static inline int mac_make_a0_desc_tx(struct msgrng_msg *msg, int id, int type,
+				   unsigned long addr, int len, int frid)
+{
+  int tx_stid = 0;
+  int desc_offset = addr & MAC_TX_DESC_ALIGNMENT;
+
+  if (type == TYPE_XGMAC) {
+    tx_stid = msgrng_xgmac_stid_tx(id);
+    frid = 0;
+  }
+  else 
+    tx_stid = msgrng_gmac_stid_tx(id);
+
+  msg->msg0 = ( ((uint64_t)CTRL_SNGL << 61) | 
+	        ((uint64_t)desc_offset << 40) | 
+		((uint64_t)tx_stid << 52) |
+	        ((uint64_t)addr & ~MAC_TX_DESC_ALIGNMENT)
+		);
+  msg->msg1 = ( ( (uint64_t)CTRL_EOP << 61) |  
+	        ( ((uint64_t)frid) << 54) | 
+		( (uint64_t)len << 40)
+		);
+		
+  msg->msg2 = msg->msg3 = 0;
+
+  return tx_stid;
+}
+static inline int mac_make_b0_desc_tx(struct msgrng_msg *msg, int id, int type,
+				unsigned long addr, int len, int frid)
+{
+	int tx_stid = 0;
+
+	if (type == TYPE_XGMAC) {
+		tx_stid = msgrng_xgmac_stid_tx(id);
+		frid = 0;
+	}
+	else 
+		tx_stid = msgrng_gmac_stid_tx(id);
+
+	msg->msg0 = ( ((uint64_t)1 << 63) | ( ((uint64_t)frid) << 54) |
+			((uint64_t)len << 40) | 
+			((uint64_t)addr & 0xffffffffffULL));
+	msg->msg1 = msg->msg2 = msg->msg3 = 0;
+	return tx_stid;
+}
+
+static inline int mac_make_desc_tx(struct msgrng_msg *msg, int id, int type,
+				   unsigned long addr, int len, int frid)
+{
+	if(xlr_revision_a0())
+		return mac_make_a0_desc_tx(msg, id, type, addr, len, frid);
+	else 
+		return mac_make_b0_desc_tx(msg, id, type, addr, len, frid);
+	
+
+
+}
+static inline int mac_make_desc_jfr(struct msgrng_msg *msg, int id, int type,
+                                    unsigned long addr)
+{
+  int stid = 0;
+                                                                                    
+  if (type == TYPE_GMAC) stid = msgrng_gmac_stid_jfr(id);
+  else stid = msgrng_xgmac_stid_jfr(id);
+                                                                                    
+                                                                                    
+  msg->msg0 = (((uint64_t)CTRL_JUMBO_FREE << 61) |
+               ((uint64_t)stid<<52) |
+               (uint64_t)addr);
+                                                                                    
+  return stid;
+}
+
+extern __u8 phoenix_base_mac_addr[];
+
+
+typedef struct _mac_tx_stats
+{
+  unsigned long tx_bytes;
+  unsigned char tx_bytes_carry;
+
+  unsigned long tx_pkts;
+  unsigned char tx_pkts_carry;
+
+  unsigned long tx_multicast_pkts;
+  unsigned char tx_multicast_pkts_carry;
+
+  unsigned long tx_broadcast_pkts;
+  unsigned char tx_broadcast_pkts_carry;
+
+  unsigned long tx_pause_control_frame_counter;
+  unsigned char tx_pause_control_frame_counter_carry;
+
+  unsigned long tx_deferral_pkt_counter;
+  unsigned char tx_deferral_pkt_counter_carry;
+
+  unsigned long tx_excessive_deferral_pkt_counter;
+  unsigned char tx_excessive_deferral_pkt_counter_carry;
+
+  unsigned long tx_single_collision_pkt_counter;
+  unsigned char tx_single_collision_pkt_counter_carry;
+
+  unsigned long tx_multi_collision_pkt_counter;
+  unsigned char tx_multi_collision_pkt_counter_carry;
+
+  unsigned long tx_late_collision_pkt_counter;
+  unsigned char tx_late_collision_pkt_counter_carry;
+
+  unsigned long tx_excessive_collision_pkt_counter;
+  unsigned char tx_excessive_collision_pkt_counter_carry;
+
+  unsigned long tx_total_collision_counter;
+  unsigned char tx_total_collision_counter_carry;
+
+  unsigned long tx_pause_frame_honered_counter;
+  unsigned char tx_pause_frame_honered_counter_carry;
+
+  unsigned long tx_drop_frame_counter;
+  unsigned char tx_drop_frame_counter_carry;
+
+  unsigned long tx_jabber_frame_counter;
+  unsigned char tx_jabber_frame_counter_carry;
+
+  unsigned long tx_fcs_error_counter;
+  unsigned char tx_fcs_error_counter_carry;
+
+  unsigned long tx_control_frame_counter;
+  unsigned char tx_control_frame_counter_carry;
+
+  unsigned long tx_oversize_frame_counter;
+  unsigned char tx_oversize_frame_counter_carry;
+
+  unsigned long tx_undersize_frame_counter;
+  unsigned char tx_undersize_frame_counter_carry;
+
+  unsigned long tx_fragment_frame_counter;
+  unsigned char tx_fragment_frame_counter_carry;
+}mac_tx_statistics;
+
+
+typedef struct _mac_rx_stats
+{
+  unsigned long rx_bytes;
+  unsigned char rx_bytes_carry;
+  unsigned long rx_pkts;
+  unsigned char rx_pkts_carry;
+  unsigned long rx_fcs_error_counter;
+  unsigned char rx_fcs_error_counter_carry;
+  unsigned long rx_multicast_pkt_counter;
+  unsigned char rx_multicast_pkt_counter_carry;
+  unsigned long rx_broadcast_pkt_counter;
+  unsigned char rx_broadcast_pkt_counter_carry;
+  unsigned long rx_control_frame_pkt_counter;
+  unsigned char rx_control_frame_pkt_counter_carry;
+  unsigned long rx_pause_frame_pkt_counter;
+  unsigned char rx_pause_frame_pkt_counter_carry;
+  unsigned long rx_unknown_opcode_pkt_counter;
+  unsigned char rx_unknown_opcode_pkt_counter_carry;
+  unsigned long rx_alignment_error_counter;
+  unsigned char rx_alignment_error_counter_carry;
+  unsigned long rx_frame_length_error_counter;
+  unsigned char rx_frame_length_error_counter_carry;
+  unsigned long rx_code_error_counter;
+  unsigned char rx_code_error_counter_carry;
+  unsigned long rx_carrier_sense_error_counter;
+  unsigned char rx_carrier_sense_error_counter_carry;
+  unsigned long rx_undersize_pkt_counter;
+  unsigned char rx_undersize_pkt_counter_carry;
+  unsigned long rx_oversize_pkt_counter;
+  unsigned char rx_oversize_pkt_counter_carry;
+  unsigned long rx_fragments_counter;
+  unsigned char rx_fragments_counter_carry;
+  unsigned long rx_jabber_counter;
+  unsigned char rx_jabber_counter_carry;
+  unsigned long rx_drop_pkt_counter;
+  unsigned char rx_drop_pkt_counter_carry;
+
+}mac_rx_statistics;
+
+typedef struct _mac_tx_rx_statistics
+{
+  unsigned long tx_rx_64_byte_frame;
+  unsigned long tx_rx_64_byte_frame_carry;
+  unsigned long tx_rx_65_127_byte_frame;
+  unsigned long tx_rx_65_127_byte_frame_carry;
+  unsigned long tx_rx_128_255_byte_frame;
+  unsigned long tx_rx_128_255_byte_frame_carry;
+  unsigned long tx_rx_256_511_byte_frame;
+  unsigned long tx_rx_256_511_byte_frame_carry;
+  unsigned long tx_rx_512_1023_byte_frame;
+  unsigned long tx_rx_512_1023_byte_frame_carry;
+  unsigned long tx_rx_1024_1518_byte_frame;
+  unsigned long tx_rx_1024_1518_byte_frame_carry;
+  unsigned long tx_rx_1519_1522_byte_frame;
+  unsigned long tx_rx_1519_1522_byte_frame_carry;
+
+}mac_tx_rx_statistics;
+
+typedef struct _phnx_tx_stats
+{
+  unsigned long long tx_bytes;
+  unsigned char tx_bytes_carry;
+
+  unsigned long long tx_pkts;
+  unsigned char tx_pkts_carry;
+
+  unsigned long long tx_multicast_pkts;
+  unsigned char tx_multicast_pkts_carry;
+
+  unsigned long long tx_broadcast_pkts;
+  unsigned char tx_broadcast_pkts_carry;
+
+  unsigned long long tx_pause_control_frame_counter;
+  unsigned char tx_pause_control_frame_counter_carry;
+
+  unsigned long long tx_deferral_pkt_counter;
+  unsigned char tx_deferral_pkt_counter_carry;
+
+  unsigned long long tx_excessive_deferral_pkt_counter;
+  unsigned char tx_excessive_deferral_pkt_counter_carry;
+
+  unsigned long long tx_single_collision_pkt_counter;
+  unsigned char tx_single_collision_pkt_counter_carry;
+
+  unsigned long long tx_multi_collision_pkt_counter;
+  unsigned char tx_multi_collision_pkt_counter_carry;
+
+  unsigned long long tx_late_collision_pkt_counter;
+  unsigned char tx_late_collision_pkt_counter_carry;
+
+  unsigned long long tx_excessive_collision_pkt_counter;
+  unsigned char tx_excessive_collision_pkt_counter_carry;
+
+  unsigned long long tx_total_collision_counter;
+  unsigned char tx_total_collision_counter_carry;
+
+  unsigned long long tx_pause_frame_honered_counter;
+  unsigned char tx_pause_frame_honered_counter_carry;
+
+  unsigned long long tx_drop_frame_counter;
+  unsigned char tx_drop_frame_counter_carry;
+
+  unsigned long long tx_jabber_frame_counter;
+  unsigned char tx_jabber_frame_counter_carry;
+
+  unsigned long long tx_fcs_error_counter;
+  unsigned char tx_fcs_error_counter_carry;
+
+  unsigned long long tx_control_frame_counter;
+  unsigned char tx_control_frame_counter_carry;
+
+  unsigned long long tx_oversize_frame_counter;
+  unsigned char tx_oversize_frame_counter_carry;
+
+  unsigned long long tx_undersize_frame_counter;
+  unsigned char tx_undersize_frame_counter_carry;
+
+  unsigned long long tx_fragment_frame_counter;
+  unsigned char tx_fragment_frame_counter_carry;
+}phnx_tx_stats;
+
+typedef struct _phnx_rx_stats
+{
+  unsigned long long rx_bytes;
+  unsigned char rx_bytes_carry;
+  unsigned long long rx_pkts;
+  unsigned char rx_pkts_carry;
+  unsigned long long rx_fcs_error_counter;
+  unsigned char rx_fcs_error_counter_carry;
+  unsigned long long rx_multicast_pkt_counter;
+  unsigned char rx_multicast_pkt_counter_carry;
+  unsigned long long rx_broadcast_pkt_counter;
+  unsigned char rx_broadcast_pkt_counter_carry;
+  unsigned long long rx_control_frame_pkt_counter;
+  unsigned char rx_control_frame_pkt_counter_carry;
+  unsigned long long rx_pause_frame_pkt_counter;
+  unsigned char rx_pause_frame_pkt_counter_carry;
+  unsigned long long rx_unknown_opcode_pkt_counter;
+  unsigned char rx_unknown_opcode_pkt_counter_carry;
+  unsigned long long rx_alignment_error_counter;
+  unsigned char rx_alignment_error_counter_carry;
+  unsigned long long rx_frame_length_error_counter;
+  unsigned char rx_frame_length_error_counter_carry;
+  unsigned long long rx_code_error_counter;
+  unsigned char rx_code_error_counter_carry;
+  unsigned long long rx_carrier_sense_error_counter;
+  unsigned char rx_carrier_sense_error_counter_carry;
+  unsigned long long rx_undersize_pkt_counter;
+  unsigned char rx_undersize_pkt_counter_carry;
+  unsigned long long rx_oversize_pkt_counter;
+  unsigned char rx_oversize_pkt_counter_carry;
+  unsigned long long rx_fragments_counter;
+  unsigned char rx_fragments_counter_carry;
+  unsigned long long rx_jabber_counter;
+  unsigned char rx_jabber_counter_carry;
+  unsigned long long rx_drop_pkt_counter;
+  unsigned char rx_drop_pkt_counter_carry;
+
+}phnx_rx_stats;
+
+typedef struct _phnx_tx_rx_statistics
+{
+  unsigned long long tx_rx_64_byte_frame;
+  unsigned char tx_rx_64_byte_frame_carry;
+  unsigned long long tx_rx_65_127_byte_frame;
+  unsigned char tx_rx_65_127_byte_frame_carry;
+  unsigned long long tx_rx_128_255_byte_frame;
+  unsigned char tx_rx_128_255_byte_frame_carry;
+  unsigned long long tx_rx_256_511_byte_frame;
+  unsigned char tx_rx_256_511_byte_frame_carry;
+  unsigned long long tx_rx_512_1023_byte_frame;
+  unsigned char tx_rx_512_1023_byte_frame_carry;
+  unsigned long long tx_rx_1024_1518_byte_frame;
+  unsigned char tx_rx_1024_1518_byte_frame_carry;
+  unsigned long long tx_rx_1519_1522_byte_frame;
+  unsigned char tx_rx_1519_1522_byte_frame_carry;
+
+}phnx_tx_rx_stats;
+
+typedef struct _phnx_stats
+{
+  phnx_tx_stats    tx_stats;
+  phnx_rx_stats    rx_stats;
+  phnx_tx_rx_stats tx_rx_stats;
+}phnx_stats;
+
+
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/phxdesc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phxdesc.h
@@ -0,0 +1,2225 @@
+/*
+ **  Raza Microelectronics Incorporated
+ **  Phoenix Security Engine driver for Linux
+ **
+ **  Copyright (C) 2003 Raza Foundries
+ **  Author: Dave Koplos;  dkoplos@razafoundries.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * RMI Phoenix Security Engine
+ *
+ * phxdesc.h:  Security Engine descriptors for the PHXSEC Software Reference
+ *             Library.
+ *
+ * Revision History:
+ *
+ * 04/01/2004  DPK   Created
+ */
+
+#ifndef _PHXDESC_H_
+#define _PHXDESC_H_
+
+#include <asm/semaphore.h>
+
+#define ONE_BIT              0x0000000000000001ULL
+#define TWO_BITS             0x0000000000000003ULL
+#define THREE_BITS           0x0000000000000007ULL
+#define FOUR_BITS            0x000000000000000fULL
+#define FIVE_BITS            0x000000000000001fULL
+#define SEVEN_BITS           0x000000000000007fULL
+#define EIGHT_BITS           0x00000000000000ffULL
+#define NINE_BITS            0x00000000000001ffULL
+#define ELEVEN_BITS          0x00000000000007ffULL
+#define TWELVE_BITS          0x0000000000000fffULL
+#define FOURTEEN_BITS        0x0000000000003fffULL
+#define TWENTYFOUR_BITS      0x0000000000ffffffULL
+#define THIRTY_TWO_BITS      0x00000000ffffffffULL
+#define THIRTY_FIVE_BITS     0x00000007ffffffffULL
+#define FOURTY_BITS          0x000000ffffffffffULL
+
+#define MSG_IN_CTL_LEN_BASE  40
+#define MSG_IN_CTL_ADDR_BASE 0
+
+#define GET_FIELD(word,field) \
+(((word) & (field ## _MASK)) >> (field ## _LSB))
+
+#define FIELD_VALUE(field,value) (((value) & (field ## _BITS)) << (field ## _LSB))
+
+	/*
+	 * NOTE: this macro expects 'word' to be uninitialized (i.e. zeroed)
+	 */
+#define SET_FIELD(word,field,value) \
+{ (word) |=  (((value) & (field ## _BITS)) << (field ## _LSB)); }
+
+/*
+ * This macro clears 'word', then sets the value
+ */
+#define CLEAR_SET_FIELD(word,field,value) \
+{ (word) &= ~((field ## _BITS) << (field ## _LSB)); \
+	(word) |=  (((value) & (field ## _BITS)) << (field ## _LSB)); }
+
+	/*
+	 * NOTE: May be used to build value specific mask 
+	 *        (e.g.  GEN_MASK(CTL_DSC_CPHR_3DES,CTL_DSC_CPHR_LSB)
+	 */
+#define GEN_MASK(bits,lsb) ((bits) << (lsb))
+
+
+
+
+	/*
+	 * Security block data and control exchange
+	 *
+	 * A 2-word message ring descriptor is used to pass a pointer to the control descriptor data structure
+	 * and a pointer to the packet descriptor data structure:
+	 *
+#ifdef B0
+	 *  63  61 60                 54      53      52    49 48            45 44    40
+	 *  39                                                     5 4                 0
+	 *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+	 * | Ctrl | Resp Dest Id Entry0 | IF_L2ALLOC | UNUSED | Control Length | UNUSED
+	 * | 35 MSB of address of control descriptor data structure | Software Scratch0
+	 * |
+	 *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+	 *    3              7                1          4             4           5
+	 *    35                                       5
+#else * B0 *
+	 *  63  61 60                 54      53      52    49 48            45 44    40 39                                                     5 4                 0
+	 *  ---------------------------------------------------------------------------------------------------------------------------------
+	 * | Ctrl | UNUSED | IF_L2ALLOC | UNUSED | Control Length | UNUSED | 35 MSB of address of control descriptor data structure | UNUSED |
+	 *  ---------------------------------------------------------------------------------------------------------------------------------
+	 *    3       7          1          5             4           5                              35                                 5
+#endif * B0 *
+	 *
+	 *  63  61 60    54     53          52             51        50    46      45       44    40 39                                                    5 4      0
+	 *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+	 * | Ctrl | UNUSED | WRB_COH | WRB_L2ALLOC | DF_PTR_L2ALLOC | UNUSED | Data Length | UNUSED | 35 MSB of address of packet descriptor data structure | UNUSED |
+	 *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+	 *    3       7         1          1               1            5           1          5                                35                              5
+	 *
+	 * Addresses assumed to be cache-line aligned, i.e., Address[4:0] ignored (using 5'h00 instead)
+	 *
+#ifdef B0
+	 * Control length is the number of control cachelines to be read so user needs
+	 * to round up
+	 * the control length to closest integer multiple of 32 bytes. Note that at
+	 * present (08/12/04)
+	 * the longest (sensical) ctrl structure is <= 416 bytes, i.e., 13 cachelines.
+#else * B0 *
+	 * Control length is the number of control cachelines to be read so user needs to round up
+	 * the control length to closest integer multiple of 32 bytes. Note that at present (03/18/04)
+	 * the longest (sensical) ctrl structure is <= 128 bytes.
+#endif * B0 *
+	 *
+	 * The packet descriptor data structure size is fixed at 1 cacheline (32 bytes).
+	 * This effectively makes "Data Length" a Load/NoLoad bit. NoLoad causes an abort.
+	 *
+	 *
+	 * Upon completion of operation, the security block returns a 2-word free descriptor
+	 * in the following format:
+	 *
+	 *  63  61 60            54 53   52 51       49   48   47               40 39                                                  0
+	 *  ----------------------------------------------------------------------------------------------------------------------------
+	 * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 | Instruction Error |    Address of control descriptor data structure     |
+	 *  ----------------------------------------------------------------------------------------------------------------------------
+	 * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 |     Data Error    |    Address of packet descriptor data structure      |
+	 *  ----------------------------------------------------------------------------------------------------------------------------
+	 *
+	 * The Instruction and Data Error codes are enumerated in the 
+	 * controldescriptor and PacketDescriptor sections below
+	 *
+	 */
+
+
+	/*
+	 * Operating assumptions
+	 * =====================
+	 *
+	 * 
+	 *	        -> For all IpSec ops, I assume that all the IP/IPSec/TCP headers
+	 *		   and the data are present at the specified source addresses.
+	 *		   I also assume that all necessary header data already exists
+	 *		   at the destination. Additionally, in AH I assume that all
+	 *		   mutable fields (IP.{TOS, Flags, Offset, TTL, Header_Checksum}) 
+	 *		   and the AH.Authentication_Data have been zeroed by the client.
+	 *
+	 *
+	 *		-> In principle, the HW can calculate TCP checksums on both
+	 *		   incoming and outgoing data; however, since the TCP header
+	 *		   contains the TCP checksum of the plain payload and the header
+	 *		   is encrypted, two passes would be necessary to do checksum + encryption
+	 *                 for outgoing messages;
+	 *		   therefore the checksum engine will likely only be used during decryption
+	 *                 (incoming).
+	 *
+	 *
+	 *		-> For all operations involving TCP checksum, I assume the client has filled
+	 *		   the TCP checksum field with the appropriate value:
+	 *
+	 *			    - 0 for generation phase
+	 *			    - actual value for verification phase (expecting 0 result)
+	 *
+	 *
+	 *		-> For ESP tunnel, the original IP header exists between the end of the
+	 *		   ESP header and the beginning of the TCP header; it is assumed that the
+	 *		   maximum length of this header is 16 k(32bit)words (used in CkSum_Offset).
+	 *
+	 *
+	 *		-> The authentication data is merely written to the destination address;
+	 *		   the client is left with the task of comparing to the data in packet
+	 *		   in decrypt.
+	 *
+	 *              -> packetdescriptor_t.dstLLWMask relevant to AES CTR mode only but it will
+	 *                 affect all AES-related operations. It will not affect DES/3DES/bypass ops.
+	 *                 The mask is applied to data as it emerges from the AES engine for the sole
+	 *                 purpose of providing the authenticator and cksum engines with correct data.
+	 *                 CAVEAT: the HW does not mask the incoming data. It is the user's responsibility
+	 *                 to set to 0 the corresponding data in memory. If the surplus data is not masked
+	 *                 in memory, cksum/auth results will be incorrect if those engines receive data
+	 *                 straight from memory (i.e., not from cipher, as it happens while decoding)
+	 */
+
+#ifdef B0
+	/*
+	 * Fragmentation and offset related notes
+	 * ======================================
+	 *
+	 *
+	 *      A) Rebuilding packets from fragments on dword boundaries. The discussion
+	 *         below is exemplified by tests memcpy_all_off_frags and memcpy_same_off_frags
+	 * 
+	 *	        1) The Offset before data/iv on first fragment is ALWAYS written back
+	 *                 Non-zero dst dword or global offsets may cause more data to be 
+	 *                 written than the user-specified length.
+	 *
+	 *
+	 *                 Example:
+	 *                 --------
+	 *
+	 *                 Below is a source (first fragment) packet (@ ADD0 cache-aligned address).
+	 *                 Assume we just copy it and relevant data starts on
+	 *                 dword 3 so Cipher_Offset = IV_Offset = 3 (dwords).
+	 *                 D0X denotes relevant data and G denotes dont care data.
+	 *                 Offset data is also copied so Packet_Legth = 9 (dwords) * 8 = 72 (bytes)
+	 *                 Segment_src_address = ADD0
+	 *
+	 *                 If we want to, e.g., copy so that the relevant (i.e., D0X) data
+	 *                 starts at (cache-aligned address) ADD1, we need to specify
+	 *                 Dst_dword_offset = 1 so D00 is moved from dword position 3 to 0 on next cache-line
+	 *                 Cipher_dst_address = ADD1 - 0x20 so D00 is written to ADD1
+	 *
+	 *                 Note that the security engine always writes full cachelines
+	 *                 therefore, data written to dword0 0 of ADD1 (denoted w/ ?) is what the sec pipe
+	 *                 write back buffer contained from previous op.
+	 *
+	 *
+	 *                      SOURCE:                                                 DESTINATION:
+	 *                      -------                                                 ------------
+	 *
+	 *                      Segment_src_address = ADD0                              Cipher_dst_address = ADD1 - 0x20
+	 *                      Packet_Legth        = 72                                Dst_dword_offset   = 1
+	 *                      Cipher_Offset       = 3
+	 *                      IV_Offset           = 3
+	 *                      Use_IV              = ANY
+	 *                      
+	 *
+	 *
+	 *                         3     2     1     0                                  3     2     1     0
+	 *                       -----------------------                              -----------------------
+	 *                      | D00 | G   | G   | G   | <- ADD0                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+	 *                       -----------------------                              -----------------------
+	 *                      | D04 | D03 | D02 | D01 |                            | D03 | D02 | D01 | D00 | <- ADD1
+	 *                       -----------------------                              -----------------------
+	 *                      |     |     |     | D05 |                            |     |     | D05 | D04 |
+	 *                       -----------------------                              -----------------------
+	 * 
+	 *	        2) On fragments following the first, IV_Offset is overloaded to mean data offset
+	 *                 (number of dwords to skip from beginning of cacheline before starting processing)
+	 *                 and Use_IV is overloaded to mean do writeback the offset (in the clear).
+	 *                 These fields in combination with Dst_dword_offset allow packet fragments with
+	 *                 arbitrary boundaries/lengthd to be reasembled.
+	 *
+	 *
+	 *                 Example:
+	 *                 --------
+	 *
+	 *                 Assume data above was first fragment of a packet we'd like to merge to
+	 *                 (second) fragment below located at ADD2. The written data should follow
+	 *                 the previous data without gaps or overwrites. To achieve this, one should
+	 *                 assert the "Next" field on the previous fragment and use self-explanatory
+	 *                 set of parameters below
+	 *
+	 *
+	 *                      SOURCE:                                                 DESTINATION:
+	 *                      -------                                                 ------------
+	*
+	*                      Segment_src_address = ADD2                              Cipher_dst_address = ADD1 + 0x20
+	*                      Packet_Legth        = 104                               Dst_dword_offset   = 1
+	*                      IV_Offset           = 1
+	*                      Use_IV              = 0
+	*                      
+	*
+	*
+	*                         3     2     1     0                                  3     2     1     0
+	*                       -----------------------                              -----------------------
+	*                      | D12 | D11 | D10 | G   | <- ADD2                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+	*                       -----------------------                              -----------------------
+	*                      | D16 | D15 | D14 | D13 |                            | D03 | D02 | D01 | D00 | <- ADD1
+	*                       -----------------------                              -----------------------
+	*                      | D1a | D19 | D18 | D17 |                            | D11 | D10 | D05 | D04 | <- ADD1 + 0x20
+	*                       -----------------------                              -----------------------
+	*                      |     |     |     | D1b |                            | D15 | D14 | D13 | D12 |
+	*                       -----------------------                              -----------------------
+	*                                                                           | D19 | D18 | D17 | D16 |
+	*                                                                            -----------------------
+	*                                                                           |     |     | D1b | D1a |
+	*                                                                            -----------------------
+	*
+	*                 It is note-worthy that the merging can only be achieved if Use_IV is 0. Indeed, the security
+	*                 engine always writes full lines, therefore ADD1 + 0x20 will be re-written. Setting Use_IV to 0
+	*                 will allow the sec pipe write back buffer to preserve D04, D05 from previous frag and only
+	*                 receive D10, D11 thereby preserving the integrity of the previous data.
+	* 
+	*	        3) On fragments following the first, !UseIV in combination w/ Dst_dword_offset >= (4 - IV_Offset)
+*                 will cause a wraparound of the write thus achieving all 16 possible (Initial_Location, Final_Location)
+	*                 combinations for the data.
+	*
+	*
+	*                 Example:
+	*                 --------
+	*
+	*                 Contiguously merging 2 data sets above with a third located at ADD3. If this is the last fragment, 
+	*                 reset its Next bit.
+	*
+	*
+	*                      SOURCE:                                                 DESTINATION:
+	*                      -------                                                 ------------
+	*
+	*                      Segment_src_address = ADD3                              Cipher_dst_address = ADD1 + 0x80
+	*                      Packet_Legth        = 152                               Dst_dword_offset   = 3
+	*                      IV_Offset           = 3
+	*                      Use_IV              = 0
+	*                      
+	*
+	*
+	*                         3     2     1     0                                  3     2     1     0
+	*                       -----------------------                              -----------------------
+	*                      | D20 | G   | G   | G   | <- ADD2                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+	*                       -----------------------                              -----------------------
+	*                      | D24 | D23 | D22 | D21 |                            | D03 | D02 | D01 | D00 | <- ADD1
+	*                       -----------------------                              -----------------------
+	*                      | D28 | D27 | D26 | D25 |                            | D11 | D10 | D05 | D04 | <- ADD1 + 0x20
+	*                       -----------------------                              -----------------------
+	*                      | D2c | D2b | D2a | D29 |                            | D15 | D14 | D13 | D12 |
+	*                       -----------------------                              -----------------------
+	*                      |     | D2f | D2e | D2d |                            | D19 | D18 | D17 | D16 |
+	*                       -----------------------                              -----------------------
+	*                                                                           | D21 | D20 | D1b | D1a | <- ADD1 + 0x80
+	*                                                                            -----------------------
+	*                                                                           | D25 | D24 | D23 | D22 | 
+	*                                                                            -----------------------
+	*                                                                           | D29 | D28 | D27 | D26 | 
+	*                                                                            -----------------------
+	*                                                                           | D2d | D2c | D2b | D2a | 
+	*                                                                            -----------------------
+	*                                                                           |(D2d)|(D2c)| D2f | D2e | 
+	*                                                                            -----------------------
+	*
+	*                 It is worth noticing that always writing full-lines causes the last 2 dwords in the reconstituted
+*                 packet to be unnecessarily written: (D2d) and (D2c)
+	*
+	*
+	*
+	*      B) Implications of fragmentation on AES
+	* 
+	*	        1) AES is a 128 bit block cipher; therefore it requires an even dword total data length
+	*                 Data fragments (provided there are more than 1) are allowed to have odd dword
+	*                 data lengths provided the total length (cumulated over fragments) is an even dword
+	*                 count; an error will be generated otherwise, upon receiving the last fragment descriptor
+	*                 (see error conditions below).
+	*
+	*              2) While using fragments with AES, a fragment (other than first) starting with a != 0 (IV) offset
+	*                 while the subsequent total dword count given to AES is odd may not be required to write
+	*                 its offset (UseIV). Doing so will cause an error (see error conditions below).
+	*
+	*
+	*                 Example:
+	*                 --------
+	*
+*                 Suppose the first fragment has an odd DATA dword count and USES AES (as seen below)
+	*
+	*                      SOURCE:                                                 DESTINATION:
+	*                      -------                                                 ------------
+	*
+	*                      Segment_src_address = ADD0                              Cipher_dst_address = ADD1
+	*                      Packet_Legth        = 64                                Dst_dword_offset   = 1
+	*                      Cipher_Offset       = 3
+	*                      IV_Offset           = 1
+	*                      Use_IV              = 1
+	*                      Cipher              = Any AES
+	*                      Next                = 1
+	*                      
+	*
+	* 
+	*
+	*                         3     2     1     0                                  3     2     1     0
+	*                       -----------------------                              -----------------------
+	*                      | D00 | IV1 | IV0 | G   | <- ADD0                    | E00 | IV1 | IV0 | G   | <- ADD1
+	*                       -----------------------                              -----------------------
+	*                      | D04 | D03 | D02 | D01 |                            | X   | E03 | E02 | E01 |
+	*                       -----------------------                              -----------------------
+	*
+	*                 At the end of processing of the previous fragment, the AES engine input buffer has D04
+	*                 and waits for next dword, therefore the writeback buffer cannot finish writing the fragment
+	*                 to destination (X instead of E04).
+	*
+	*                 If a second fragment now arrives with a non-0 offset and requires the offset data to be
+	*                 written to destination, the previous write (still needing the arrival of the last dword
+			*                 required by the AES to complete the previous operation) cannot complete before the present
+	*                 should start causing a deadlock.
+	*/
+#endif /* B0 */
+
+	/*
+	 *  Command Control Word for Message Ring Descriptor
+	 */
+
+	/* #define MSG_CMD_CTL_CTL       */
+#define MSG_CMD_CTL_CTL_LSB   61
+#define MSG_CMD_CTL_CTL_BITS  THREE_BITS
+#define MSG_CMD_CTL_CTL_MASK  (MSG_CMD_CTL_CTL_BITS << MSG_CMD_CTL_CTL_LSB)
+
+	/* #define MSG_CMD_CTL_ID */
+#define MSG_CMD_CTL_ID_LSB    54
+#define MSG_CMD_CTL_ID_BITS   SEVEN_BITS
+#define MSG_CMD_CTL_ID_MASK   (MSG_CMD_CTL_ID_BITS << MSG_CMD_CTL_ID_LSB)
+
+	/* #define MSG_CMD_CTL_LEN */
+#define MSG_CMD_CTL_LEN_LSB   45
+#ifdef B0
+#define MSG_CMD_CTL_LEN_BITS  FOUR_BITS
+#else /* B0 */
+#define MSG_CMD_CTL_LEN_BITS  THREE_BITS
+#endif /* B0*/
+#define MSG_CMD_CTL_LEN_MASK  (MSG_CMD_CTL_LEN_BITS << MSG_CMD_CTL_LEN_LSB)
+
+
+	/* #define MSG_CMD_CTL_ADDR */
+#define MSG_CMD_CTL_ADDR_LSB  0 
+#define MSG_CMD_CTL_ADDR_BITS FOURTY_BITS
+#define MSG_CMD_CTL_ADDR_MASK (MSG_CMD_CTL_ADDR_BITS << MSG_CMD_CTL_ADDR_LSB)
+
+#define MSG_CMD_CTL_MASK      (MSG_CMD_CTL_CTL_MASK | \
+		MSG_CMD_CTL_LEN_MASK | MSG_CMD_CTL_ADDR_MASK)
+
+/*
+ *  Command Data Word for Message Ring Descriptor
+ */
+
+/* #define MSG_IN_DATA_CTL */
+#define MSG_CMD_DATA_CTL_LSB   61
+#define MSG_CMD_DATA_CTL_BITS  THREE_BITS
+#define MSG_CMD_DATA_CTL_MASK  (MSG_CMD_DATA_CTL_BITS  << MSG_CMD_DATA_CTL_LSB)
+
+/* #define MSG_CMD_DATA_LEN */
+#define MSG_CMD_DATA_LEN_LOAD  1
+#define MSG_CMD_DATA_LEN_LSB   45
+#define MSG_CMD_DATA_LEN_BITS  ONE_BIT
+#define MSG_CMD_DATA_LEN_MASK  (MSG_CMD_DATA_LEN_BITS << MSG_CMD_DATA_LEN_LSB)
+
+/* #define MSG_CMD_DATA_ADDR */
+#define MSG_CMD_DATA_ADDR_LSB  0 
+#define MSG_CMD_DATA_ADDR_BITS FOURTY_BITS 
+#define MSG_CMD_DATA_ADDR_MASK (MSG_CMD_DATA_ADDR_BITS << MSG_CMD_DATA_ADDR_LSB)
+
+#define MSG_CMD_DATA_MASK      (MSG_CMD_DATA_CTL_MASK | \
+		MSG_CMD_DATA_LEN_MASK | MSG_CMD_DATA_ADDR_MASK)
+
+
+/*
+ * Upon completion of operation, the Sec block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49  48          40 39             0
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address |
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   |
+ *  ----------------------------------------------------------------------------
+ *
+ * The Control and Data Error codes are enumerated below
+ *
+ *                                Error conditions
+ *                                ================
+ *
+ *             Control Error Code                  Control Error Condition
+ *             ------------------                  ---------------------------
+ *             9'h000                              No Error
+ *             9'h001                              Unknown Cipher Op                      ( Cipher == 3'h{6,7})
+ *             9'h002                              Unknown or Illegal Mode                ((Mode   == 3'h{2,3,4} & !AES) | (Mode   == 3'h{5,6,7}))
+ *             9'h004                              Unsupported CkSum Src                  (CkSum_Src   == 2'h{2,3} & CKSUM)
+ *             9'h008                              Forbidden CFB Mask                     (AES & CFBMode & UseNewKeysCFBMask & CFBMask[7] & (| CFBMask[6:0]))
+ *             9'h010                              Unknown Ctrl Op                        ((| Ctrl[63:37]) | (| Ctrl[15:14]))
+ *             9'h020                              UNUSED
+ *             9'h040                              UNUSED
+ *             9'h080                              Data Read Error
+ *             9'h100                              Descriptor Ctrl Field Error            (D0.Ctrl != SOP || D1.Ctrl != EOP)
+ *
+ *             Data Error Code                     Data Error Condition
+ *             ---------------                     --------------------
+ *             9'h000                              No Error
+ *             9'h001                              Insufficient Data To Cipher            (Packet_Length <= (Cipher_Offset or IV_Offset))
+ *             9'h002                              Illegal IV Location                    ((Cipher_Offset <  IV_Offset) | (Cipher_Offset <= IV_Offset & AES & ~CTR))
+ *             9'h004                              Illegal Wordcount To AES               (Packet_Length[3] != Cipher_Offset[0] & AES)
+ *             9'h008                              Illegal Pad And ByteCount Spec         (Hash_Byte_Count != 0 & !Pad_Hash)
+ *             9'h010                              Insufficient Data To CkSum             ({Packet_Length, 1'b0} <= CkSum_Offset)
+ *             9'h020                              Unknown Data Op                        ((| dstLLWMask[63:60]) | (| dstLLWMask[57:40]) | (| authDst[63:40]) | (| ckSumDst[63:40]))
+ *             9'h040                              Insufficient Data To Auth              ({Packet_Length} <= Auth_Offset)
+ *             9'h080                              Data Read Error
+ *             9'h100                              UNUSED
+ */
+
+/*
+ * Result Control Word for Message Ring Descriptor
+ */
+
+/* #define MSG_RSLT_CTL_CTL */
+#define MSG_RSLT_CTL_CTL_LSB      61
+#define MSG_RSLT_CTL_CTL_BITS     THREE_BITS
+#define MSG_RSLT_CTL_CTL_MASK \
+(MSG_RSLT_CTL_CTL_BITS << MSG_RSLT_CTL_CTL_LSB)
+
+	/* #define MSG_RSLT_CTL_DST_ID */
+#define MSG_RSLT_CTL_DST_ID_LSB   54
+#define MSG_RSLT_CTL_DST_ID_BITS  SEVEN_BITS
+#define MSG_RSLT_CTL_DST_ID_MASK \
+(MSG_RSLT_CTL_DST_ID_BITS << MSG_RSLT_CTL_DST_ID_LSB)
+
+	/* #define MSG_RSLT_CTL_DSC_CTL */
+#define MSG_RSLT_CTL_DSC_CTL_LSB  49
+#define MSG_RSLT_CTL_DSC_CTL_BITS THREE_BITS
+#define MSG_RSLT_CTL_DSC_CTL_MASK \
+(MSG_RSLT_CTL_DSC_CTL_BITS << MSG_RSLT_CTL_DSC_CTL_LSB)
+
+	/* #define MSG_RSLT_CTL_INST_ERR */
+#define MSG_RSLT_CTL_INST_ERR_LSB      40
+#define MSG_RSLT_CTL_INST_ERR_BITS     EIGHT_BITS
+#define MSG_RSLT_CTL_INST_ERR_MASK \
+(MSG_RSLT_CTL_INST_ERR_BITS << MSG_RSLT_CTL_INST_ERR_LSB)
+
+	/* #define MSG_RSLT_CTL_DSC_ADDR */
+#define MSG_RSLT_CTL_DSC_ADDR_LSB      0
+#define MSG_RSLT_CTL_DSC_ADDR_BITS     FOURTY_BITS
+#define MSG_RSLT_CTL_DSC_ADDR_MASK \
+(MSG_RSLT_CTL_DSC_ADDR_BITS << MSG_RSLT_CTL_DSC_ADDR_LSB)
+
+	/* #define MSG_RSLT_CTL_MASK */
+#define MSG_RSLT_CTL_MASK \
+	(MSG_RSLT_CTL_CTRL_MASK | MSG_RSLT_CTL_DST_ID_MASK | \
+	 MSG_RSLT_CTL_DSC_CTL_MASK | MSG_RSLT_CTL_INST_ERR_MASK | \
+	 MSG_RSLT_CTL_DSC_ADDR_MASK)
+
+	/*
+	 * Result Data Word for Message Ring Descriptor
+	 */
+	/* #define MSG_RSLT_DATA_CTL */
+#define MSG_RSLT_DATA_CTL_LSB     61
+#define MSG_RSLT_DATA_CTL_BITS    THREE_BITS
+#define MSG_RSLT_DATA_CTL_MASK \
+(MSG_RSLT_DATA_CTL_BITS << MSG_RSLT_DATA_CTL_LSB)
+
+	/* #define MSG_RSLT_DATA_DST_ID */
+#define MSG_RSLT_DATA_DST_ID_LSB  54
+#define MSG_RSLT_DATA_DST_ID_BITS SEVEN_BITS
+#define MSG_RSLT_DATA_DST_ID_MASK \
+(MSG_RSLT_DATA_DST_ID_BITS << MSG_RSLT_DATA_DST_ID_LSB)
+
+	/* #define MSG_RSLT_DATA_DSC_CTL */
+#define MSG_RSLT_DATA_DSC_CTL_LSB       49
+#define MSG_RSLT_DATA_DSC_CTL_BITS      THREE_BITS
+#define MSG_RSLT_DATA_DSC_CTL_MASK \
+(MSG_RSLT_DATA_DSC_CTL_BITS << MSG_RSLT_DATA_DSC_CTL_LSB)
+
+	/* #define MSG_RSLT_DATA_INST_ERR */
+#define MSG_RSLT_DATA_INST_ERR_LSB      40
+#define MSG_RSLT_DATA_INST_ERR_BITS     EIGHT_BITS
+#define MSG_RSLT_DATA_INST_ERR_MASK \
+(MSG_RSLT_DATA_INST_ERR_BITS << MSG_RSLT_DATA_INST_ERR_LSB)
+
+	/* #define MSG_RSLT_DATA_DSC_ADDR */
+#define MSG_RSLT_DATA_DSC_ADDR_LSB      0
+#define MSG_RSLT_DATA_DSC_ADDR_BITS     FOURTY_BITS
+#define MSG_RSLT_DATA_DSC_ADDR_MASK     \
+(MSG_RSLT_DATA_DSC_ADDR_BITS << MSG_RSLT_DATA_DSC_ADDR_LSB)
+
+#define MSG_RSLT_DATA_MASK   \
+	(MSG_RSLT_DATA_CTRL_MASK | MSG_RSLT_DATA_DST_ID_MASK | \
+	 MSG_RSLT_DATA_DSC_CTL_MASK | MSG_RSLT_DATA_INST_ERR_MASK | \
+	 MSG_RSLT_DATA_DSC_ADDR_MASK)
+
+
+	/*
+	 * Common Message Definitions
+	 *
+	 */
+
+	/* #define MSG_CTL_OP_ADDR */
+#define MSG_CTL_OP_ADDR_LSB      0
+#define MSG_CTL_OP_ADDR_BITS     FOURTY_BITS
+#define MSG_CTL_OP_ADDR_MASK     (MSG_CTL_OP_ADDR_BITS << MSG_CTL_OP_ADDR_LSB)
+
+#define MSG_CTL_OP_TYPE
+#define MSG_CTL_OP_TYPE_LSB             3
+#define MSG_CTL_OP_TYPE_BITS            TWO_BITS
+#define MSG_CTL_OP_TYPE_MASK            \
+(MSG_CTL_OP_TYPE_BITS << MSG_CTL_OP_TYPE_LSB)
+
+#define MSG0_CTL_OP_ENGINE_SYMKEY       0x01
+#define MSG0_CTL_OP_ENGINE_PUBKEY       0x02
+
+#define MSG1_CTL_OP_SYMKEY_PIPE0        0x00
+#define MSG1_CTL_OP_SYMKEY_PIPE1        0x01
+#define MSG1_CTL_OP_SYMKEY_PIPE2        0x02
+#define MSG1_CTL_OP_SYMKEY_PIPE3        0x03
+
+#define MSG1_CTL_OP_PUBKEY_PIPE0        0x00
+#define MSG1_CTL_OP_PUBKEY_PIPE1        0x01
+#define MSG1_CTL_OP_PUBKEY_PIPE2        0x02
+#define MSG1_CTL_OP_PUBKEY_PIPE3        0x03
+
+
+	/*       /----------------------------------------\
+	 *       |                                        |
+	 *       |   controldescriptor_s datastructure    |
+	 *       |                                        |
+	 *       \----------------------------------------/
+	 *
+#ifdef B0
+	 *
+	 *       controldescriptor_t.Instruction
+	 *       -------------------------------
+	 *
+	 *   63    43         42            41              40         39        35 34    32 31  29     28      27    24    23   22  21     20      19    17    16     15     0
+	 *  --------------------------------------------------------------------------------------------------------------------------------------------------------------------
+	 * || UNUSED || Arc4Wait4Save | SaveArc4State | LoadArc4State | Arc4KeyLen | Cipher | Mode | InCp_Key || UNUSED || HMAC | Hash | InHs_Key || UNUSED || CkSum || UNUSED ||
+	 *  --------------------------------------------------------------------------------------------------------------------------------------------------------------------
+	 *      21            1              1               1               5          3       3        1         4        1      2         1          3        1        16
+	 *            <-----------------------------------------CIPHER---------------------------------------->          <----------HASH---------->
+	 *
+	 *  X0  CIPHER.Arc4Wait4Save   =                   If op is Arc4 and it requires state saving, then
+	 *                                                 setting this bit will cause the current op to
+	 *                                                 delay subsequent op loading until saved state data
+	 *                                                 becomes visible.
+	 *  X0         SaveArc4State   =                   Save Arc4 state at the end of Arc4 operation
+	 *  X0         LoadArc4State   =                   Load Arc4 state at the beginning of an Arc4 operation
+	 *                                                 This overriden by the InCp_Key setting for Arc4
+	 *             Arc4KeyLen      =                   Length in bytes of Arc4 key (0 is interpreted as 32)
+	 *                                                 Ignored for other ciphers
+	 *                                                 For ARC4, IFetch/IDecode will always read exactly 4
+	 *                                                 consecutive dwords into its CipherKey{0,3} regardless
+	 *                                                 of this quantity; it will however only use the specified
+	 *                                                 number of bytes.        
+	 *             Cipher          =        3'b000     Bypass
+	 *                                      3'b001     DES
+	 *                                      3'b010     3DES
+	 *                                      3'b011     AES 128-bit key
+	 *                                      3'b100     AES 192-bit key
+	 *                                      3'b101     AES 256-bit key
+	 *                                      3'b110     ARC4
+	 *                                      Remainder  UNDEFINED
+	 *             Mode            =        3'b000     ECB
+	 *                                      3'b001     CBC
+	 *                                      3'b010     CFB (AES only, otherwise undefined)
+	 *                                      3'b011     OFB (AES only, otherwise undefined)
+	 *                                      3'b100     CTR (AES only, otherwise undefined)
+	 *                                      Remainder  UNDEFINED
+	 *             InCp_Key        =        1'b0       Preserve old Cipher Keys
+	 *                                      1'b1       Load new Cipher Keys from memory to local registers
+	 *                                                 and recalculate the Arc4 Sbox if Arc4 Cipher chosen;
+	 *                                                 This overrides LoadArc4State setting.
+	 *        HASH.HMAC            =        1'b0       Hash without HMAC
+	 *                                      1'b1       Hash with HMAC 
+	 *             Hash            =        2'b00      Hash NOP
+	 *                                      2'b01      MD5
+	 *                                      2'b10      SHA-1
+	 *                                      2'b11      SHA-256
+	 *             InHs_Key        =        1'b0       Preserve old HMAC Keys
+	 *                                      1'b1       Load new HMAC Keys from memory to local registers
+	 *                                                 Setting this bit while Cipher=Arc4 and LoadArc4State=1
+	 *                                                 causes the decoder to load the Arc4 state from the
+	 *                                                 cacheline following the HMAC keys (Whether HASH.HMAC
+	 *                                                 is set or not).
+	 *    CHECKSUM.CkSum           =        1'b0       CkSum NOP
+	 *                                      1'b1       INTERNET_CHECKSUM
+	 *
+	 *
+#else * B0 *
+	 *
+	 *       controldescriptor_t.Instruction
+	 *       -------------------------------
+	 *
+	 *   63        37   36   35   34    32 31  29 28         27 26           24
+	 *  ------------------------------------------------------------------------
+	* ||   UNUSED   || V || E/D | Cipher | Mode | Init_Cipher | Cipher_Offset ||   ... CONT ...
+	*  ------------------------------------------------------------------------
+	*        28        1     1      3       3          2              3        
+	*               <CTRL><--------------------CIPHER----------------------->
+	*
+	*
+	*     23   22  21      20     19         18     17        16    15   14 13           2 1         0
+	*  -----------------------------------------------------------------------------------------------
+	* || HMAC | Hash | Init_Hash | Hash_Offset | Hash_Src || CkSum |  N/U  | CkSum_Offset | CkSum_Src ||
+	*  -----------------------------------------------------------------------------------------------
+	*     1      2         1            2            1         1       2         12            2
+	*   <-----------------------HASH--------------------->  <-----------CHECKSUM-------------------->
+	*
+	*
+	*
+	*      CTRL.V                 =        1'b0       Instruction invalid
+	*                                      1'b1       Instruction valid
+	*      CIPHER.E/D             =        1'b0       Decrypt
+	*                                      1'b1       Encrypt
+	*             Cipher          =        3'b000     Bypass
+	*                                      3'b001     DES
+	*                                      3'b010     3DES
+	*                                      3'b011     AES 128-bit key
+	*                                      3'b100     AES 192-bit key
+	*                                      3'b101     AES 256-bit key
+	*                                      Remainder  UNDEFINED
+	*             Mode            =        3'b000     ECB
+	*                                      3'b001     CBC
+	*                                      3'b010     CFB (AES only, otherwise undefined)
+	*                                      3'b011     OFB (AES only, otherwise undefined)
+	*                                      3'b100     CTR (AES only, otherwise undefined)
+	*                                      Remainder  UNDEFINED
+	*             Init_Cipher     =        2'b00      Preserve old IV/(Keys,NonceCFBMask)
+	*                                      2'b01      Load new IV use old Keys,NonceCFBMask
+	*                                      2'b10      Load new Keys,NonceCFBMask use old IV (?)
+	*                                      2'b11      Load new IV/(Keys,NonceCFBMask)
+	*             Cipher_Offset   =                   Nb of words between the first data segment 
+	*                                                 and word on which to start cipher operation
+*                                                 (64 BIT WORDS !!!)
+	*        HASH.HMAC            =        1'b0       Hash without HMAC
+	*                                      1'b1       Hash with HMAC 
+	*             Hash            =        2'b00      Hash NOP
+	*                                      2'b01      MD5
+	*                                      2'b10      SHA-1
+	*                                      2'b11      SHA-256
+	*             Init_Hash       =        1'b0       Preserve old key HMAC key stored in ID registers (moot if HASH.HMAC == 0)
+	*                                      1'b1       Load new HMAC key from memory ctrl section to ID registers
+	*             Hash_Offset     =                   Nb of words between the first data segment
+	*                                                 and word on which to start hashing 
+*                                                 (64 bit words)
+	*             Hash_Src        =        1'b0       DMA channel
+	*                                      1'b1       Cipher if word count exceeded Cipher_Offset; 
+	*                                                 DMA channel otherwise
+	*    CHECKSUM.CkSum           =        1'b0       CkSum NOP
+	*                                      1'b1       INTERNET_CHECKSUM
+	*             N/U             =        2'bx       Field not used
+	*             CkSum_Offset    =                   Nb of words between the first data segment 
+	*                                                 and word on which to start 
+*                                                 checksum calculation (32 BIT WORDS !!!)
+	*             CkSum_Src       =        2'b00      DMA channel if word count exceeded CkSum_Offset
+	*                                      2'b01      Cipher if word count exceeded CkSum_Offset,
+	*                                      2'b10      UNDEFINED
+	*                                      2'b11      UNDEFINED
+	*
+	*
+	*             OLD !!!
+	*             CkSum_Src       =        2'b00      0
+	*                                      2'b01      Cipher if word count exceeded CkSum_Offset,
+	*                                                 0 otherwise
+	*                                      2'b10      DMA channel if word count exceeded 
+	*                                                 CkSum_Offset, 0 otherwise
+	*                                      2'b11      UNDEFINED
+	*
+	*
+	*       controldescriptor_t.cipherHashInfo.infoAES256ModeHMAC
+	*       -----------------------------------------------------
+	*  
+	*  -----------------------------------------------------------------
+	* ||63              AES Key0                                      0||
+	*  -----------------------------------------------------------------
+	*                   .
+	*                   .
+	*                   .
+	*  -----------------------------------------------------------------
+	* ||63              AES Key3                                      0||
+	*  -----------------------------------------------------------------
+	*                   .
+	*                   .
+	*                   .
+	*  -----------------------------------------------------------------
+	* ||63              HMAC Key0                                      0||
+	*  -----------------------------------------------------------------
+	*                   .
+	*                   .
+	*                   .
+	*  -----------------------------------------------------------------
+	* ||63              HMAC Key7                                      0||
+	*  -----------------------------------------------------------------
+	*
+	*   63        40  39                   8  7                       0
+	*  -----------------------------------------------------------------
+	* ||   UNUSED   || Nonce (AES/CTR only) || CFB_Mask (AES/CFB only) ||
+	*  -----------------------------------------------------------------
+	*        24                 32                       8
+#endif * B0 *
+	*
+	*/
+#ifdef B0
+
+	/* #define CTRL_DSC_ARC4_WAIT4SAVE */
+#define CTL_DSC_ARC4_WAIT4SAVE_OFF       0
+#define CTL_DSC_ARC4_WAIT4SAVE_ON        1
+#define CTL_DSC_ARC4_WAIT4SAVE_LSB       42
+#define CTL_DSC_ARC4_WAIT4SAVE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_WAIT4SAVE_MASK      (CTL_DSC_ARC4_WAIT4SAVE_BITS << CTL_DSC_ARC4_WAIT4SAVE_LSB)
+
+	/* #define CTRL_DSC_ARC4_SAVESTATE */
+#define CTL_DSC_ARC4_SAVESTATE_OFF       0
+#define CTL_DSC_ARC4_SAVESTATE_ON        1
+#define CTL_DSC_ARC4_SAVESTATE_LSB       41
+#define CTL_DSC_ARC4_SAVESTATE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_SAVESTATE_MASK      (CTL_DSC_ARC4_SAVESTATE_BITS << CTL_DSC_ARC4_SAVESTATE_LSB)
+
+	/* #define CTRL_DSC_ARC4_LOADSTATE */
+#define CTL_DSC_ARC4_LOADSTATE_OFF       0
+#define CTL_DSC_ARC4_LOADSTATE_ON        1
+#define CTL_DSC_ARC4_LOADSTATE_LSB       40
+#define CTL_DSC_ARC4_LOADSTATE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_LOADSTATE_MASK      (CTL_DSC_ARC4_LOADSTATE_BITS << CTL_DSC_ARC4_LOADSTATE_LSB)
+
+	/* #define CTRL_DSC_ARC4_KEYLEN */
+#define CTL_DSC_ARC4_KEYLEN_LSB          35
+#define CTL_DSC_ARC4_KEYLEN_BITS         FIVE_BITS
+#define CTL_DSC_ARC4_KEYLEN_MASK         (CTL_DSC_ARC4_KEYLEN_BITS << CTL_DSC_ARC4_KEYLEN_LSB)
+
+	/* #define CTL_DSC_CPHR  (cipher) */
+#define CTL_DSC_CPHR_BYPASS       0 /* undefined */
+#define CTL_DSC_CPHR_DES          1
+#define CTL_DSC_CPHR_3DES         2
+#define CTL_DSC_CPHR_AES128       3
+#define CTL_DSC_CPHR_AES192       4
+#define CTL_DSC_CPHR_AES256       5
+#define CTL_DSC_CPHR_ARC4         6
+#define CTL_DSC_CPHR_UNDEF3       7 /* undefined */
+#define CTL_DSC_CPHR_LSB          32
+#define CTL_DSC_CPHR_BITS         THREE_BITS
+#define CTL_DSC_CPHR_MASK         (CTL_DSC_CPHR_BITS << CTL_DSC_CPHR_LSB)
+
+	/* #define CTL_DSC_MODE  */
+#define CTL_DSC_MODE_ECB          0
+#define CTL_DSC_MODE_CBC          1
+#define CTL_DSC_MODE_CFB          2
+#define CTL_DSC_MODE_OFB          3
+#define CTL_DSC_MODE_CTR          4
+#define CTL_DSC_MODE_LSB          29
+#define CTL_DSC_MODE_BITS         THREE_BITS
+#define CTL_DSC_MODE_MASK         (CTL_DSC_MODE_BITS << CTL_DSC_MODE_LSB)
+
+	/* #define CTL_DSC_ICPHR */
+#define CTL_DSC_ICPHR_OKY          0 /* Old Keys */
+#define CTL_DSC_ICPHR_NKY          1 /* New Keys */
+#define CTL_DSC_ICPHR_LSB          28
+#define CTL_DSC_ICPHR_BITS         ONE_BIT
+#define CTL_DSC_ICPHR_MASK         (CTL_DSC_ICPHR_BITS << CTL_DSC_ICPHR_LSB)
+
+	/* #define CTL_DSC_HMAC */
+#define CTL_DSC_HMAC_OFF          0
+#define CTL_DSC_HMAC_ON           1
+#define CTL_DSC_HMAC_LSB          23
+#define CTL_DSC_HMAC_BITS         ONE_BIT
+#define CTL_DSC_HMAC_MASK         (CTL_DSC_HMAC_BITS << CTL_DSC_HMAC_LSB)
+
+	/* #define CTL_DSC_HASH */
+#define CTL_DSC_HASH_NOP          0
+#define CTL_DSC_HASH_MD5          1
+#define CTL_DSC_HASH_SHA1         2
+#define CTL_DSC_HASH_SHA256       3
+#define CTL_DSC_HASH_LSB          21
+#define CTL_DSC_HASH_BITS         TWO_BITS
+#define CTL_DSC_HASH_MASK         (CTL_DSC_HASH_BITS << CTL_DSC_HASH_LSB)
+
+	/* #define CTL_DSC_IHASH */
+#define CTL_DSC_IHASH_OLD         0
+#define CTL_DSC_IHASH_NEW         1
+#define CTL_DSC_IHASH_LSB         20
+#define CTL_DSC_IHASH_BITS        ONE_BIT
+#define CTL_DSC_IHASH_MASK        (CTL_DSC_IHASH_BITS << CTL_DSC_IHASH_LSB)
+
+	/* #define CTL_DSC_CKSUM */
+#define CTL_DSC_CKSUM_NOP         0
+#define CTL_DSC_CKSUM_IP          1
+#define CTL_DSC_CKSUM_LSB         16
+#define CTL_DSC_CKSUM_BITS        ONE_BIT
+#define CTL_DSC_CKSUM_MASK        (CTL_DSC_CKSUM_BITS << CTL_DSC_CKSUM_LSB)
+
+#else /* B0 */
+
+
+	/* #define CTL_DSC_VALID (valid descriptor flag) */
+#define CTL_DSC_CTL_INVALID  0
+#define CTL_DSC_CTL_VALID    1
+#define CTL_DSC_CTL_LSB      36
+#define CTL_DSC_CTL_BITS     ONE_BIT
+#define CTL_DSC_CTL_MASK     (CTL_DSC_CTL_BITS << CTL_DSC_CTL_LSB)
+
+	/* #define CTL_DSC_SYM_OP (symmetric key operation) */
+#define CTL_DSC_SYM_OP_DECRYPT    0
+#define CTL_DSC_SYM_OP_ENCRYPT    1
+#define CTL_DSC_SYM_OP_LSB        35
+#define CTL_DSC_SYM_OP_BITS       ONE_BIT
+#define CTL_DSC_SYM_OP_MASK       (CTL_DSC_SYM_OP_BITS << CTL_DSC_SYM_OP_LSB)
+
+
+	/* #define CTL_DSC_CPHR  (cipher) */
+#define CTL_DSC_CPHR_BYPASS       0 /* undefined */
+#define CTL_DSC_CPHR_DES          1
+#define CTL_DSC_CPHR_3DES         2
+#define CTL_DSC_CPHR_AES128       3
+#define CTL_DSC_CPHR_AES192       4
+#define CTL_DSC_CPHR_AES256       5
+#define CTL_DSC_CPHR_UNDEF2       6 /* undefined */
+#define CTL_DSC_CPHR_UNDEF3       7 /* undefined */
+#define CTL_DSC_CPHR_LSB          32
+#define CTL_DSC_CPHR_BITS         THREE_BITS
+#define CTL_DSC_CPHR_MASK         (CTL_DSC_CPHR_BITS << CTL_DSC_CPHR_LSB)
+
+	/* #define CTL_DSC_MODE  */
+#define CTL_DSC_MODE_ECB          0
+#define CTL_DSC_MODE_CBC          1
+#define CTL_DSC_MODE_CFB          2
+#define CTL_DSC_MODE_OFB          3
+#define CTL_DSC_MODE_CTR          4
+#define CTL_DSC_MODE_LSB          29
+#define CTL_DSC_MODE_BITS         THREE_BITS
+#define CTL_DSC_MODE_MASK         (CTL_DSC_MODE_BITS << CTL_DSC_MODE_LSB)
+
+	/* #define CTL_DSC_ICPHR */
+#define CTL_DSC_ICPHR_OIV_OKY_ON   0 /* 2-bits,00=Old IV,Old Keys, Old Nonce */
+#define CTL_DSC_ICPHR_NIV_OKY_ON   1 /* 2-bits,01=New IV,Old Keys, Old Nonce */
+#define CTL_DSC_ICPHR_OIV_NKY_NN   2 /* 2-bits,10=Old IV,New Keys, New Nonce */
+#define CTL_DSC_ICPHR_NIV_NKY_NN   3 /* 2-bits,11=New IV,New Keys, New Nonce */
+#define CTL_DSC_ICPHR_LSB          27
+#define CTL_DSC_ICPHR_BITS         TWO_BITS
+#define CTL_DSC_ICPHR_MASK         (CTL_DSC_ICPHR_BITS << CTL_DSC_ICPHR_LSB)
+
+	/* Cipher_Offset:
+	 *   Nb of words between the first data segment and word on which to 
+	 *   start cipher operation (64 BIT WORDS !!!)
+	 */
+	/* #define CTL_DSC_CPHROFF */
+#define CTL_DSC_CPHROFF_LSB        24
+#define CTL_DSC_CPHROFF_BITS       THREE_BITS
+#define CTL_DSC_CPHROFF_MASK       (CTL_DSC_CPHROFF_BITS << CTL_DSC_CPHROFF_LSB)
+
+	/* #define CTL_DSC_HMAC */
+#define CTL_DSC_HMAC_OFF          0
+#define CTL_DSC_HMAC_ON           1
+#define CTL_DSC_HMAC_LSB          23
+#define CTL_DSC_HMAC_BITS         ONE_BIT
+#define CTL_DSC_HMAC_MASK         (CTL_DSC_HMAC_BITS << CTL_DSC_HMAC_LSB)
+
+	/* #define CTL_DSC_HASH */
+#define CTL_DSC_HASH_NOP          0
+#define CTL_DSC_HASH_MD5          1
+#define CTL_DSC_HASH_SHA1         2
+#define CTL_DSC_HASH_SHA256       3
+#define CTL_DSC_HASH_LSB          21
+#define CTL_DSC_HASH_BITS         TWO_BITS
+#define CTL_DSC_HASH_MASK         (CTL_DSC_HASH_BITS << CTL_DSC_HASH_LSB)
+
+	/* #define CTL_DSC_IHASH */
+#define CTL_DSC_IHASH_OLD         0
+#define CTL_DSC_IHASH_NEW         1
+#define CTL_DSC_IHASH_LSB         20 
+#define CTL_DSC_IHASH_BITS        ONE_BIT
+#define CTL_DSC_IHASH_MASK        (CTL_DSC_IHASH_BITS << CTL_DSC_IHASH_LSB)
+
+	/* #define CTL_DSC_HASHOFF */
+#define CTL_DSC_HASHOFF_LSB       18
+#define CTL_DSC_HASHOFF_BITS      TWO_BITS
+#define CTL_DSC_HASHOFF_MASK      (CTL_DSC_HASHOFF_BITS << CTL_DSC_HASHOFF_LSB)
+
+	/* #define CTL_DSC_HASHSRC */
+#define CTL_DSC_HASHSRC_DMA       0
+#define CTL_DSC_HASHSRC_CIPHER    1
+#define CTL_DSC_HASHSRC_LSB       17
+#define CTL_DSC_HASHSRC_BITS      ONE_BIT
+#define CTL_DSC_HASHSRC_MASK      (CTL_DSC_HASHSRC_BITS << CTL_DSC_HASHSRC_LSB)
+
+	/* #define CTL_DSC_CKSUM */
+#define CTL_DSC_CKSUM_NOP         0
+#define CTL_DSC_CKSUM_IP          1
+#define CTL_DSC_CKSUM_LSB         16
+#define CTL_DSC_CKSUM_BITS        ONE_BIT
+#define CTL_DSC_CKSUM_MASK        (CTL_DSC_CKSUM_BITS << CTL_DSC_CKSUM_LSB)
+
+	/* #define CTL_DSC_CKSUMOFF */
+#define CTL_DSC_CKSUMOFF_LSB      2
+#define CTL_DSC_CKSUMOFF_BITS     TWELVE_BITS
+#define CTL_DSC_CKSUMOFF_MASK   (CTL_DSC_CKSUMOFF_BITS << CTL_DSC_CKSUMOFF_LSB)
+
+	/* #define CTL_DSC_CKSUMSRC */
+#define CTL_DSC_CKSUMSRC_0        0   /* !!MARK!!  ??? */
+#define CTL_DSC_CKSUMSRC_CIPHER   1
+#define CTL_DSC_CKSUMSRC_DMA      2
+#define CTL_DSC_CKSUMSRC_UNDEF    3
+#define CTL_DSC_CKSUMSRC_LSB      0
+#define CTL_DSC_CKSUMSRC_BITS     TWO_BITS
+#define CTL_DSC_CKSUMSRC_MASK   (CTL_DSC_CKSUMSRC_BITS << CTL_DSC_CKSUMSRC_LSB)
+
+#endif /* B0 */
+
+#ifndef B0
+	/* 
+	 * **********************************************************************
+	 *       controldescriptor_t.cipherHashInfo.infoAES256ModeHMAC
+	 * **********************************************************************
+	 */
+
+	/* #define CTL_DSC_NONCE */
+#define CTL_DSC_NONCE_LSB         8
+#define CTL_DSC_NONCE_BITS        THIRTY_TWO_BITS
+#define CTL_DSC_NONCE_MASK        (CTL_DSC_NONCE_BITS << CTL_DSC_NONCE_LSB)
+
+	/* #define CTL_DSC_CFB_MASK */
+#define CTL_DSC_CFB_MASK_LSB      0
+#define CTL_DSC_CFB_MASK_BITS     EIGHT_BITS
+#define CTL_DSC_CFB_MASK_MASK     \
+(CTL_DSC_CFB_MASK_BITS << CTL_DSC_CFB_MASK_LSB)
+#endif /* B0 */
+
+
+	/*
+	 * Component strcts and unions defining CipherHashInfo_u
+	 */
+
+	/* All AES256 possibilities */
+	/* AES256, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-256)      - 104 bytes */
+	typedef struct AES256ModeHMAC_s {
+		uint64_t             cipherKey0;
+		uint64_t             cipherKey1;
+		uint64_t             cipherKey2;
+		uint64_t             cipherKey3;
+		uint64_t             hmacKey0;
+		uint64_t             hmacKey1;
+		uint64_t             hmacKey2;
+		uint64_t             hmacKey3;
+		uint64_t             hmacKey4;
+		uint64_t             hmacKey5;
+		uint64_t             hmacKey6;
+		uint64_t             hmacKey7;
+#ifndef B0
+		uint64_t             nonceCFBMask;
+#endif /* B0 */
+	} AES256ModeHMAC_t, *AES256ModeHMAC_pt;
+
+/* AES256, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-256)  - 40  bytes */
+typedef struct AES256Mode_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+#ifndef B0
+	uint64_t             nonceCFBMask;
+#endif /* B0 */
+} AES256Mode_t, *AES256Mode_pt;
+
+/* AES256, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-256)      - 96  bytes */
+typedef struct AES256HMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} AES256HMAC_t, *AES256HMAC_pt;
+
+/* AES256, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct AES256_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+} AES256_t, *AES256_pt;
+
+
+/* All AES192 possibilities */
+
+/* AES192, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-192)      - 96  bytes */
+typedef struct AES192ModeHMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+#ifndef B0
+	uint64_t             nonceCFBMask;
+#endif /* B0 */
+} AES192ModeHMAC_t, *AES192ModeHMAC_pt;
+
+/* AES192, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-192)  - 32  bytes */
+typedef struct AES192Mode_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+#ifndef B0
+	uint64_t             nonceCFBMask;
+#endif /* B0 */
+} AES192Mode_t, *AES192Mode_pt;
+
+/* AES192, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-192)      - 88  bytes */
+typedef struct AES192HMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} AES192HMAC_t, *AES192HMAC_pt;
+
+/* AES192, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-192)  - 24  bytes */
+typedef struct AES192_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+} AES192_t, *AES192_pt;
+
+
+/* All AES128 possibilities */
+
+/* AES128, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-128)      - 88  bytes */
+typedef struct AES128ModeHMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+#ifndef B0
+	uint64_t             nonceCFBMask;
+#endif /* B0 */
+} AES128ModeHMAC_t, *AES128ModeHMAC_pt;
+
+/* AES128, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-128)  - 24  bytes */
+typedef struct AES128Mode_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+#ifndef B0
+	uint64_t             nonceCFBMask;
+#endif /* B0 */
+} AES128Mode_t, *AES128Mode_pt;
+
+/* AES128, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-128)      - 80  bytes */
+typedef struct AES128HMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} AES128HMAC_t, *AES128HMAC_pt;
+
+/* AES128, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-128)  - 16  bytes */
+typedef struct AES128_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+} AES128_t, *AES128_pt;
+
+
+/* All DES possibilities */
+
+/* DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)              - 72  bytes */
+typedef struct DESHMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} DESHMAC_t, *DESHMAC_pt;
+
+/* DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)          - 9   bytes */
+typedef struct DES_s {
+	uint64_t             cipherKey0;
+} DES_t, *DES_pt;
+
+
+/* All 3DES possibilities */
+
+/* 3DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)             - 88  bytes */
+typedef struct DES3HMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} DES3HMAC_t, *DES3HMAC_pt;
+
+/* 3DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)         - 24  bytes */
+typedef struct DES3_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+} DES3_t, *DES3_pt;
+
+
+/* HMAC only - no cipher */
+
+/* HMAC (MD5, SHA-1, SHA-128)                               - 64  bytes */
+typedef struct HMAC_s {
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} HMAC_t, *HMAC_pt;
+
+#ifdef B0
+/* All ARC4 possibilities */
+/* ARC4, HMAC (MD5, SHA-1, SHA-256)      - 96 bytes */
+typedef struct ARC4ModeHMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+} ARC4ModeHMAC_t, *ARC4ModeHMAC_pt;
+
+/* ARC4, HMAC (MD5, SHA-1, SHA-256)      - 408 bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateModeHMAC_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+	uint64_t             hmacKey0;
+	uint64_t             hmacKey1;
+	uint64_t             hmacKey2;
+	uint64_t             hmacKey3;
+	uint64_t             hmacKey4;
+	uint64_t             hmacKey5;
+	uint64_t             hmacKey6;
+	uint64_t             hmacKey7;
+	uint64_t             PAD0;
+	uint64_t             PAD1;
+	uint64_t             PAD2;
+	uint64_t             Arc4SboxData0;
+	uint64_t             Arc4SboxData1;
+	uint64_t             Arc4SboxData2;
+	uint64_t             Arc4SboxData3;
+	uint64_t             Arc4SboxData4;
+	uint64_t             Arc4SboxData5;
+	uint64_t             Arc4SboxData6;
+	uint64_t             Arc4SboxData7;
+	uint64_t             Arc4SboxData8;
+	uint64_t             Arc4SboxData9;
+	uint64_t             Arc4SboxData10;
+	uint64_t             Arc4SboxData11;
+	uint64_t             Arc4SboxData12;
+	uint64_t             Arc4SboxData13;
+	uint64_t             Arc4SboxData14;
+	uint64_t             Arc4SboxData15;
+	uint64_t             Arc4SboxData16;
+	uint64_t             Arc4SboxData17;
+	uint64_t             Arc4SboxData18;
+	uint64_t             Arc4SboxData19;
+	uint64_t             Arc4SboxData20;
+	uint64_t             Arc4SboxData21;
+	uint64_t             Arc4SboxData22;
+	uint64_t             Arc4SboxData23;
+	uint64_t             Arc4SboxData24;
+	uint64_t             Arc4SboxData25;
+	uint64_t             Arc4SboxData26;
+	uint64_t             Arc4SboxData27;
+	uint64_t             Arc4SboxData28;
+	uint64_t             Arc4SboxData29;
+	uint64_t             Arc4SboxData30;
+	uint64_t             Arc4SboxData31;
+	uint64_t             Arc4IJData;
+	uint64_t             PAD3;
+	uint64_t             PAD4;
+	uint64_t             PAD5;
+} ARC4StateModeHMAC_t, *ARC4StateModeHMAC_pt;
+
+/* ARC4, Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct ARC4Mode_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+} ARC4Mode_t, *ARC4Mode_pt;
+
+/* ARC4, Non-HMAC (MD5, SHA-1, SHA-256)  - 344  bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateMode_s {
+	uint64_t             cipherKey0;
+	uint64_t             cipherKey1;
+	uint64_t             cipherKey2;
+	uint64_t             cipherKey3;
+	uint64_t             PAD0;
+	uint64_t             PAD1;
+	uint64_t             PAD2;
+	uint64_t             Arc4SboxData0;
+	uint64_t             Arc4SboxData1;
+	uint64_t             Arc4SboxData2;
+	uint64_t             Arc4SboxData3;
+	uint64_t             Arc4SboxData4;
+	uint64_t             Arc4SboxData5;
+	uint64_t             Arc4SboxData6;
+	uint64_t             Arc4SboxData7;
+	uint64_t             Arc4SboxData8;
+	uint64_t             Arc4SboxData9;
+	uint64_t             Arc4SboxData10;
+	uint64_t             Arc4SboxData11;
+	uint64_t             Arc4SboxData12;
+	uint64_t             Arc4SboxData13;
+	uint64_t             Arc4SboxData14;
+	uint64_t             Arc4SboxData15;
+	uint64_t             Arc4SboxData16;
+	uint64_t             Arc4SboxData17;
+	uint64_t             Arc4SboxData18;
+	uint64_t             Arc4SboxData19;
+	uint64_t             Arc4SboxData20;
+	uint64_t             Arc4SboxData21;
+	uint64_t             Arc4SboxData22;
+	uint64_t             Arc4SboxData23;
+	uint64_t             Arc4SboxData24;
+	uint64_t             Arc4SboxData25;
+	uint64_t             Arc4SboxData26;
+	uint64_t             Arc4SboxData27;
+	uint64_t             Arc4SboxData28;
+	uint64_t             Arc4SboxData29;
+	uint64_t             Arc4SboxData30;
+	uint64_t             Arc4SboxData31;
+	uint64_t             Arc4IJData;
+	uint64_t             PAD3;
+	uint64_t             PAD4;
+	uint64_t             PAD5;
+} ARC4StateMode_t, *ARC4StateMode_pt;
+#endif /* B0 */
+
+typedef union CipherHashInfo_u {
+	AES256ModeHMAC_t     infoAES256ModeHMAC;
+	AES256Mode_t         infoAES256Mode;
+	AES256HMAC_t         infoAES256HMAC;
+	AES256_t             infoAES256;
+	AES192ModeHMAC_t     infoAES192ModeHMAC;
+	AES192Mode_t         infoAES192Mode;
+	AES192HMAC_t         infoAES192HMAC;
+	AES192_t             infoAES192;
+	AES128ModeHMAC_t     infoAES128ModeHMAC;
+	AES128Mode_t         infoAES128Mode;
+	AES128HMAC_t         infoAES128HMAC;
+	AES128_t             infoAES128;
+	DESHMAC_t            infoDESHMAC;
+	DES_t                infoDES;
+	DES3HMAC_t           info3DESHMAC;
+	DES3_t               info3DES;
+	HMAC_t               infoHMAC;
+#ifdef B0
+	ARC4ModeHMAC_t       infoARC4ModeHMAC;
+	ARC4StateModeHMAC_t  infoARC4StateModeHMAC;
+	ARC4Mode_t           infoARC4Mode;
+	ARC4StateMode_t      infoARC4StateMode;
+	// this makes this structure 408 bytes long, so when we add the 8-byte
+	// instruction (see just below), the result is 416 (13 cache lines)
+	// and we add 3 double words to make it an integer number of cache lines
+	uint64_t             infoDwords[51];
+#else /* B0 */
+	// this makes this structure 120 bytes long, so when we add the 8-byte
+	// instruction (see just below), the result is 128 (4 cache lines)
+	uint64_t             infoDwords[15];
+#endif /* B0 */
+} CipherHashInfo_t, *CipherHashInfo_pt;
+
+
+/* 
+ * 
+ *    controldescriptor_s datastructure 
+ * 
+ */
+
+typedef struct controldescriptor_s {
+	uint64_t            instruction;
+	CipherHashInfo_t    cipherHashInfo;
+} controldescriptor_t, *controldescriptor_pt;
+
+
+
+
+/* **********************************************************************
+ *       packetdescriptor_t
+ * **********************************************************************
+ */
+
+/*       /--------------------------------------------\
+ *       |                                            |
+ *       |    New PacketDescriptor_s datastructure    |
+ *       |                                            |
+ *       \--------------------------------------------/
+ *
+ *
+#ifdef B0
+ *
+ *       packetdescriptor_t.srcLengthIVOffUseIVNext
+ *       ------------------------------------------
+ *
+ *           63           62      61             59    58        57    56       54  53           43 
+ *  ------------------------------------------------------------------------------------------------
+ * || Load HMAC key || Pad Hash || Hash Byte Count || Next || Use IV || IV Offset || Packet length ||   ... CONT ...
+ *  ------------------------------------------------------------------------------------------------
+ *           1            1           3                1        1          3              11
+ *
+ *
+ *      42        41      40    39                  5  4      3  2                      0
+ *  --------------------------------------------------------------------------------------
+ * || UNUSED || Break || Wait || Segment src address || UNUSED || Global src data offset ||
+ *  --------------------------------------------------------------------------------------
+ *      1         1       1             35                2                 3
+ *  
+ *
+ *
+ *             Load HMAC key           =        1'b0       Preserve old HMAC key stored in Auth engine (moot if HASH.HMAC == 0)
+ *                                              1'b1       Load HMAC key from ID registers at beginning of op
+ *             Pad Hash                =        1'b0       HASH will assume the data was padded to be a multiple
+ *                                                         of 512 bits in length and that the last 64 bit word
+ *                                                         expresses the total datalength in bits seen by HASH engine
+ *                                              1'b1       The data was not padded to be a multiple of 512 bits in length;
+ *                                                         The Hash engine will do its own padding to generate the correct digest.
+ *             Hash Byte Count                             Number of BYTES on last 64-bit data word to use in digest calculation RELEVANT ONLY IF Pad Hash IS SET
+ *                                              3'b000     Use all 8
+ *                                              3'b001     Use first (MS) byte only (0-out rest), i.e., 0xddXXXXXXXXXXXXXX
+ *                                              3'b010     Use first 2 bytes only (0-out rest), i.e., 0xddddXXXXXXXXXXXX     ... etc
+ *             Next                    =        1'b0       Finish (return msg descriptor) at end of operation
+ *                                              1'b1       Grab the next PacketDescriptor (i.e. next cache-line) when the current is complete.
+ *                                                         This allows for fragmentation/defragmentation and processing of large (>16kB) packets.
+ *                                                         The sequence of adjacent PacketDescriptor acts as a contiguous linked list of
+ *                                                         pointers to the actual packets with Next==0 on the last PacketDescriptor to end processing.
+ *             Use IV                  =        1'b0       On first frag:           Use old IV
+ *                                                         On subsequent frags:     Do not write out to DST the (dword) offset data
+ *                                              1'b1       On first frag:           Use data @ Segment_address + IV_Offset as IV
+ *                                                         On subsequent frags:     Do write out to DST the (dword) offset data
+ *             IV Offset               =                   On first frag:           Offset IN NB OF 8 BYTE WORDS (dwords) from beginning of packet
+ *                                                                                  (i.e. (Potentially byte-shifted) Segment address) to cipher IV
+ *                                                         On subsequent frags:     Offset to beginning of data to process; data to offset won't 
+ *                                                                                  be given to engines and will be written out to dst in the clear.
+ *                                                                                  ON SUBSEQUENT FRAGS, IV_Offset MAY NOT EXCEED 3; LARGER VALUES WILL CAUSE AN ERROR
+ *                                                                                  SEE ERROR CONDITIONS BELOW
+ *             Packet length           =                   Nb double words to stream in (Including Segment address->CP/IV/Auth/CkSum offsets)
+ *                                                         This is the total amount of data (x8 in bytes) read    (+1 dword if "Global src data offset" != 0)
+ *                                                         This is the total amount of data (x8 in bytes) written (+1 dword if "Global dst data offset" != 0, if Dst dword offset == 0)
+ *                                                         If Packet length == 11'h7ff and (Global src data offset != 0 or Global dst data offset != 0)
+ *                                                         the operation is aborted (no mem writes occur)
+ *             Break                   =                   Break a wait (see below) state - causes the operation to be flushed and free descriptor to be returned.
+ *                                                         Activated if DFetch blocked by Wait and Wait still active.
+ *                                                         AS OF 02/10/2005 THIS FEATURE IS EXPERIMENTAL
+ *             Wait                    =                   Setting that bit causes the operation to block in DFetch stage.
+ *                                                         DFetch will keep polling the memory location until the bit is reset at which time
+ *                                                         the pipe resumes normal operation. This feature is convenient for software dealing with fragmented packets.
+ *                                                         AS OF 02/10/2005 THIS FEATURE IS EXPERIMENTAL
+ *             Segment src address     =                   35 MSB of pointer to src data (i.e., cache-line aligned)
+ *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *
+ *       packetdescriptor_t.dstDataSettings
+ *       ----------------------------------
+ *
+*       63    62           60  59   58           56  55         54     53      52          41     40
+*  -------------------------------------------------------------------------------------------------------
+* || UNUSED || Arc4ByteCount | E/D | Cipher_Offset || Hash_Offset | Hash_Src || CkSum_Offset | CkSum_Src ||   ... CONT ...
+*  -------------------------------------------------------------------------------------------------------
+*       1            3          1          3               2           1             12            1
+*            <---------------CIPHER----------------><---------HASH-----------><-------CHECKSUM----------->
+*
+*   39                 5  4                3  2                      0
+*  --------------------------------------------------------------------
+* || Cipher dst address || Dst dword offset || Global dst data offset ||
+*  --------------------------------------------------------------------
+*            35                    2                     3
+*
+*
+*  X0         Arc4ByteCount           =                   Number of BYTES on last 64-bit data word to encrypt
+*                                              3'b000     Encrypt all 8
+*                                              3'b001     Encrypt first (MS) byte only i.e., 0xddXXXXXXXXXXXXXX
+*                                              3'b010     Encrypt first 2 bytes only i.e., 0xddddXXXXXXXXXXXX     ... etc
+*                                                         In reality, all are encrypted, however, the SBOX
+*                                                         is not written past the last byte to encrypt
+*             E/D                     =        1'b0       Decrypt
+*                                              1'b1       Encrypt
+*             Cipher_Offset           =                   Nb of words between the first data segment 
+	*                                                         and word on which to start cipher operation
+*                                                         (64 BIT WORDS !!!)
+	*             Hash_Offset             =                   Nb of words between the first data segment
+	*                                                         and word on which to start hashing 
+*                                                         (64 bit words)
+	*             Hash_Src                =        1'b0       DMA channel
+	*                                              1'b1       Cipher if word count exceeded Cipher_Offset; 
+	*                                                         DMA channel otherwise
+	*             CkSum_Offset            =                   Nb of words between the first data segment 
+	*                                                         and word on which to start 
+*                                                         checksum calculation (32 BIT WORDS !!!)
+	*             CkSum_Src               =        1'b0       DMA channel
+	*                                              1'b1       Cipher if word count exceeded Cipher_Offset
+	*                                                         DMA channel otherwise
+*             Cipher dst address      =                   35 MSB of pointer to dst location (i.e., cache-line aligned)
+	*             Dst dword offset        =                   Nb of double-words to left-shift data from spec'ed Cipher dst address before writing it to memory
+	*             Global dst data offset  =                   Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+	*
+	*
+	*       packetdescriptor_t.authDstNonceLow
+	*       ----------------------------------
+	*
+	*   63       40  39               5  4                0   
+	*  -----------------------------------------------------
+	* || Nonce_Low || Auth_dst_address || Cipher_Offset_Hi ||
+	*  -----------------------------------------------------
+	*        24             35                    5
+	*
+	*
+	*
+	*             Nonce_Low         =                 Nonce[23:0] 24 least significant bits of 32-bit long nonce
+	*                                                 Used by AES in counter mode
+*             Auth_dst_address  =                 35 MSB of pointer to authentication dst location (i.e., cache-line aligned)
+	* X0          Cipher_Offset_Hi  =                 On first frag:           5 MSB of 8-bit Cipher_offset; will be concatenated to
+	*                                                                          the top of packetdescriptor_t.dstDataSettings.Cipher_Offset
+	*                                                 On subsequent frags:     Ignored
+	*
+	*
+	*       packetdescriptor_t.ckSumDstNonceHiCFBMaskLLWMask
+	*       ------------------------------------------------
+	*
+	*   63    58  57     56  55      48  47      40  39                5  4            0
+	*  ----------------------------------------------------------------------------------
+	* || UNUSED || LLWMask || CFB_Mask || Nonce_Hi || CkSum_dst_address || IV_Offset_Hi ||
+	*  ----------------------------------------------------------------------------------
+	*      6          2          8           8                35                 5
+	*
+	*
+	*   LLWMask, aka, Last_long_word_mask =   2'b00      Give last 128 bit word from AES engine to auth/cksum/wrbbufer as is - applicable in AES CTR only
+	*                                         2'b11      Mask (zero-out) 32 least significant bits
+	*                                         2'b10      Mask 64 LSBs
+	*                                         2'b01      Mask 96 LSBs
+	*                 CFB_Mask            =              8 bit mask used by AES in CFB mode
+	*                 Nonce_Hi            =              Nonce[31:24] 8 most significant bits of 32-bit long nonce
+	*                                                    Used by AES in counter mode
+*                 CkSum_dst_address   =              35 MSB of pointer to cksum dst location (i.e., cache-line aligned)
+	*  X0             IV_Offset_Hi        =              On first frag:           5 MSB of 8-bit IV offset; will be concatenated to
+	*                                                                             the top of packetdescriptor_t.srcLengthIVOffUseIVNext.IV_Offset
+	*                                                    On subsequent frags:     Ignored
+#else * B0 *
+	*       packetdescriptor_t.srcLengthIVOffUseIVNext
+	*       ------------------------------------------
+	*
+	*           63           62      61             59    58        57    56       54  53           43  42    40  39                  5  4      3  2                      0
+	*  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
+	* || Load HMAC key || Pad Hash || Hash Byte Count || Next || Use IV || IV Offset || Packet length || UNUSED || Segment src address || UNUSED || Global src data offset || 
+	*  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
+	*           1            1           3                1        1          3              11            3             35                 2                 3
+	*
+	*
+	*             Load HMAC key           =        1'b0       Preserve old HMAC key stored in Auth engine (moot if HASH.HMAC == 0)
+	*                                              1'b1       Load HMAC key from ID registers at beginning of op
+	*             Pad Hash                =        1'b0       HASH will assume the data was padded to be a multiple
+	*                                                         of 512 bits in length and that the last 64 bit word
+	*                                                         expresses the total datalength in bits seen by HASH engine
+	*                                              1'b1       The data was not padded to be a multiple of 512 bits in length;
+	*                                                         The Hash engine will do its own padding to generate the correct digest.
+	*             Hash Byte Count                             Number of BYTES on last 64-bit data word to use in digest calculation RELEVANT ONLY IF Pad Hash IS SET
+	*                                              3'b000     Use all 8
+	*                                              3'b001     Use first (MS) byte only (0-out rest), i.e., 0xddXXXXXXXXXXXXXX
+	*                                              3'b010     Use first 2 bytes only (0-out rest), i.e., 0xddddXXXXXXXXXXXX     ... etc
+	*             Next                    =        1'b0       Finish (return msg descriptor) at end of operation
+	*                                              1'b1       Grab the next PacketDescriptor (i.e. next cache-line) - NOT YET IMPLEMENTED !!!
+	*             Use IV                  =        1'b0       Use old IV
+	*                                              1'b1       Use data @ Segment_address + IV_Offset as IV
+	*             IV Offset               =                   Offset IN NB OF 8 BYTE WORDS from beginning of packet
+	*                                                         (i.e. (Potentially shifted) Segment address) to cipher IV
+*             Packet length           =                   Nb double words to stream in (Including Segment address->CP/IV/Auth/CkSum offsets)
+	*                                                         This is the total amount of data (x8 in bytes) read    (+1 dword if "Global src data offset" != 0)
+	*                                                         This is the total amount of data (x8 in bytes) written (+1 dword if "Global dst data offset" != 0)
+	*                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+	*                                                         If Packet length == 11'h7ff and (Global src data offset != 0 or Global dst data offset != 0)
+	*                                                         the operation is aborted (no mem writes occur)
+*             Segment src address     =                   35 MSB of pointer to src data (i.e., cache-line aligned)
+	*             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
+	*                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+	*
+	*       packetdescriptor_t.dstLLWMask
+	*       -----------------------------
+	*
+	*   63    60  59                 58  57    40  39                 5  4      3  2                      0
+	*  -----------------------------------------------------------------------------------------------------
+	* || UNUSED || Last long word mask || UNUSED || Cipher dst address || UNUSED || Global dst data offset ||
+	*  -----------------------------------------------------------------------------------------------------
+	*      4                2               18              35              2                 3
+	*
+	*
+	*             Last long word mask     =   2'b00      Give last 128 bit word to AES/HAMC/CKSUM engines as is
+	*                                         2'b11      Mask (zero-out) 32 least significant bits
+	*                                         2'b10      Mask 64 LSBs
+	*                                         2'b01      Mask 96 LSBs
+*             Cipher dst address      =              35 MSB of pointer to dst location (i.e., cache-line aligned)
+	*             Global dst data offset  =              Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+#endif * B0 *
+	*/
+
+	/* #define PKT_DSC_LOADHMACKEY */
+#define PKT_DSC_LOADHMACKEY_OLD   0
+#define PKT_DSC_LOADHMACKEY_LOAD  1
+#define PKT_DSC_LOADHMACKEY_LSB   63
+#define PKT_DSC_LOADHMACKEY_BITS  ONE_BIT
+#define PKT_DSC_LOADHMACKEY_MASK  \
+(PKT_DSC_LOADHMACKEY_BITS << PKT_DSC_LOADHMACKEY_LSB)
+
+	/* #define PKT_DSC_PADHASH */
+#define PKT_DSC_PADHASH_PADDED    0
+#define PKT_DSC_PADHASH_PAD       1    /* requires padding */
+#define PKT_DSC_PADHASH_LSB       62
+#define PKT_DSC_PADHASH_BITS      ONE_BIT
+#define PKT_DSC_PADHASH_MASK      (PKT_DSC_PADHASH_BITS << PKT_DSC_PADHASH_LSB)
+
+	/* #define PKT_DSC_HASHBYTES */
+#define PKT_DSC_HASHBYTES_ALL8    0
+#define PKT_DSC_HASHBYTES_MSB     1
+#define PKT_DSC_HASHBYTES_MSW     2
+#define PKT_DSC_HASHBYTES_LSB     59
+#define PKT_DSC_HASHBYTES_BITS    THREE_BITS
+#define PKT_DSC_HASHBYTES_MASK    \
+(PKT_DSC_HASHBYTES_BITS << PKT_DSC_HASHBYTES_LSB)
+
+	/* #define PKT_DSC_NEXT */
+#define PKT_DSC_NEXT_FINISH       0
+#define PKT_DSC_NEXT_DO           1
+#define PKT_DSC_NEXT_LSB          58
+#define PKT_DSC_NEXT_BITS         ONE_BIT
+#define PKT_DSC_NEXT_MASK         (PKT_DSC_NEXT_BITS << PKT_DSC_NEXT_LSB)
+
+	/* #define PKT_DSC_IV */
+#define PKT_DSC_IV_OLD            0
+#define PKT_DSC_IV_NEW            1
+#define PKT_DSC_IV_LSB            57
+#define PKT_DSC_IV_BITS           ONE_BIT
+#define PKT_DSC_IV_MASK           (PKT_DSC_IV_BITS << PKT_DSC_IV_LSB)
+
+	/* #define PKT_DSC_IVOFF */
+#define PKT_DSC_IVOFF_LSB         54
+#define PKT_DSC_IVOFF_BITS        THREE_BITS
+#define PKT_DSC_IVOFF_MASK        (PKT_DSC_IVOFF_BITS << PKT_DSC_IVOFF_LSB)
+
+	/* #define PKT_DSC_PKTLEN */
+#define PKT_DSC_PKTLEN_LSB         43
+#define PKT_DSC_PKTLEN_BITS        ELEVEN_BITS
+#define PKT_DSC_PKTLEN_MASK        (PKT_DSC_PKTLEN_BITS << PKT_DSC_PKTLEN_LSB)
+
+#ifdef B0
+	/* #define PKT_DSC_BREAK */
+#define PKT_DSC_BREAK_OLD          0
+#define PKT_DSC_BREAK_NEW          1
+#define PKT_DSC_BREAK_LSB          41
+#define PKT_DSC_BREAK_BITS         ONE_BIT
+#define PKT_DSC_BREAK_MASK         (PKT_DSC_BREAK_BITS << PKT_DSC_BREAK_LSB)
+
+	/* #define PKT_DSC_WAIT */
+#define PKT_DSC_WAIT_OLD           0
+#define PKT_DSC_WAIT_NEW           1
+#define PKT_DSC_WAIT_LSB           41
+#define PKT_DSC_WAIT_BITS          ONE_BIT
+#define PKT_DSC_WAIT_MASK          (PKT_DSC_WAIT_BITS << PKT_DSC_WAIT_LSB)
+#endif /* B0 */
+
+	/* #define PKT_DSC_SEGADDR */
+#define PKT_DSC_SEGADDR_LSB        0 
+#define PKT_DSC_SEGADDR_BITS       FOURTY_BITS
+#define PKT_DSC_SEGADDR_MASK       \
+(PKT_DSC_SEGADDR_BITS << PKT_DSC_SEGADDR_LSB)
+
+#define PKT_DSC_SEGOFFSET_LSB        0
+#define PKT_DSC_SEGOFFSET_BITS       THREE_BITS
+#define PKT_DSC_SEGOFFSET_MASK       \
+(PKT_DSC_SEGOFFSET_BITS << PKT_DSC_SEGOFFSET_LSB)
+
+#ifdef B0
+	/* **********************************************************************
+	 *       packetdescriptor_t.dstDataSettings
+	 * **********************************************************************
+	 */
+	/* #define PKT_DSC_ARC4BYTECOUNT */
+#define PKT_DSC_ARC4BYTECOUNT_ALL8    0
+#define PKT_DSC_ARC4BYTECOUNT_MSB     1
+#define PKT_DSC_ARC4BYTECOUNT_MSW     2
+#define PKT_DSC_ARC4BYTECOUNT_LSB     60
+#define PKT_DSC_ARC4BYTECOUNT_BITS    THREE_BITS
+#define PKT_DSC_ARC4BYTECOUNT_MASK    (PKT_DSC_ARC4BYTECOUNT_BITS << PKT_DSC_ARC4BYTECOUNT_LSB)
+
+	/* #define PKT_DSC_SYM_OP (symmetric key operation) */
+#define PKT_DSC_SYM_OP_DECRYPT    0
+#define PKT_DSC_SYM_OP_ENCRYPT    1
+#define PKT_DSC_SYM_OP_LSB        59
+#define PKT_DSC_SYM_OP_BITS       ONE_BIT
+#define PKT_DSC_SYM_OP_MASK       (PKT_DSC_SYM_OP_BITS << PKT_DSC_SYM_OP_LSB)
+
+	/* #define PKT_DSC_CPHROFF */
+#define PKT_DSC_CPHROFF_LSB        56
+#define PKT_DSC_CPHROFF_BITS       THREE_BITS
+#define PKT_DSC_CPHROFF_MASK       (PKT_DSC_CPHROFF_BITS << PKT_DSC_CPHROFF_LSB)
+
+	/* #define PKT_DSC_HASHOFF */
+#define PKT_DSC_HASHOFF_LSB       54
+#define PKT_DSC_HASHOFF_BITS      TWO_BITS
+#define PKT_DSC_HASHOFF_MASK      (PKT_DSC_HASHOFF_BITS << PKT_DSC_HASHOFF_LSB)
+
+	/* #define PKT_DSC_HASHSRC */
+#define PKT_DSC_HASHSRC_DMA       0
+#define PKT_DSC_HASHSRC_CIPHER    1
+#define PKT_DSC_HASHSRC_LSB       53
+#define PKT_DSC_HASHSRC_BITS      ONE_BIT
+#define PKT_DSC_HASHSRC_MASK      (PKT_DSC_HASHSRC_BITS << PKT_DSC_HASHSRC_LSB)
+
+	/* #define PKT_DSC_CKSUMOFF */
+#define PKT_DSC_CKSUMOFF_LSB      41
+#define PKT_DSC_CKSUMOFF_BITS     TWELVE_BITS
+#define PKT_DSC_CKSUMOFF_MASK   (PKT_DSC_CKSUMOFF_BITS << PKT_DSC_CKSUMOFF_LSB)
+
+	/* #define PKT_DSC_CKSUMSRC */
+#define PKT_DSC_CKSUMSRC_DMA      0
+#define PKT_DSC_CKSUMSRC_CIPHER   1
+#define PKT_DSC_CKSUMSRC_LSB      40
+#define PKT_DSC_CKSUMSRC_BITS     ONE_BIT
+#define PKT_DSC_CKSUMSRC_MASK   (PKT_DSC_CKSUMSRC_BITS << PKT_DSC_CKSUMSRC_LSB)
+
+	/* #define PKT_DSC_CPHR_DST_ADDR */
+#define PKT_DSC_CPHR_DST_ADDR_LSB  0
+#define PKT_DSC_CPHR_DST_ADDR_BITS FOURTY_BITS
+#define PKT_DSC_CPHR_DST_ADDR_MASK \
+(PKT_DSC_CPHR_DST_ADDR_BITS << PKT_DSC_CPHR_DST_ADDR_LSB)
+
+	/* #define PKT_DSC_CPHR_DST_DWOFFSET */
+#define PKT_DSC_CPHR_DST_DWOFFSET_LSB   3
+#define PKT_DSC_CPHR_DST_DWOFFSET_BITS  TWO_BITS
+#define PKT_DSC_CPHR_DST_DWOFFSET_MASK \
+(PKT_DSC_CPHR_DST_DWOFFSET_BITS << PKT_DSC_CPHR_DST_DWOFFSET_LSB)
+
+	/* #define PKT_DSC_CPHR_DST_OFFSET */
+#define PKT_DSC_CPHR_DST_OFFSET_LSB   0
+#define PKT_DSC_CPHR_DST_OFFSET_BITS  THREE_BITS
+#define PKT_DSC_CPHR_DST_OFFSET_MASK \
+(PKT_DSC_CPHR_DST_OFFSET_BITS << PKT_DSC_CPHR_DST_OFFSET_LSB)
+
+	/* **********************************************************************
+	 *       packetdescriptor_t.authDstNonceLow
+	 * **********************************************************************
+	 */
+	/* #define PKT_DSC_NONCE_LOW */
+#define PKT_DSC_NONCE_LOW_LSB  40
+#define PKT_DSC_NONCE_LOW_BITS TWENTYFOUR_BITS
+#define PKT_DSC_NONCE_LOW_MASK \
+(PKT_DSC_NONCE_LOW_BITS << PKT_DSC_NONCE_LOW_LSB)
+
+	/* #define PKT_DSC_AUTH_DST_ADDR */
+#define PKT_DSC_AUTH_DST_ADDR_LSB  0
+#define PKT_DSC_AUTH_DST_ADDR_BITS FOURTY_BITS
+#define PKT_DSC_AUTH_DST_ADDR_MASK \
+(PKT_DSC_AUTH_DST_ADDR_BITS << PKT_DSC_AUTH_DST_ADDR_LSB)
+
+	/* #define PKT_DSC_CIPH_OFF_HI */
+#define PKT_DSC_CIPH_OFF_HI_LSB      0
+#define PKT_DSC_CIPH_OFF_HI_BITS     FIVE_BITS
+#define PKT_DSC_CIPH_OFF_HI_MASK   (PKT_DSC_CIPH_OFF_HI_BITS << PKT_DSC_CIPH_OFF_HI_LSB)
+
+	/* **********************************************************************
+	 *       packetdescriptor_t.ckSumDstNonceHiCFBMaskLLWMask
+	 * **********************************************************************
+	 */
+	/* #define PKT_DSC_LASTWORD */
+#define PKT_DSC_LASTWORD_128       0
+#define PKT_DSC_LASTWORD_96MASK    1
+#define PKT_DSC_LASTWORD_64MASK    2
+#define PKT_DSC_LASTWORD_32MASK    3
+#define PKT_DSC_LASTWORD_LSB       56
+#define PKT_DSC_LASTWORD_BITS      TWO_BITS
+#define PKT_DSC_LASTWORD_MASK      (PKT_DSC_LASTWORD_BITS << PKT_DSC_LASTWORD_LSB)
+
+	/* #define PKT_DSC_CFB_MASK */
+#define PKT_DSC_CFB_MASK_LSB      48
+#define PKT_DSC_CFB_MASK_BITS     EIGHT_BITS
+#define PKT_DSC_CFB_MASK_MASK     (PKT_DSC_CFB_MASK_BITS << PKT_DSC_CFB_MASK_LSB)
+
+	/* #define PKT_DSC_NONCE_HI */
+#define PKT_DSC_NONCE_HI_LSB      40
+#define PKT_DSC_NONCE_HI_BITS     EIGHT_BITS
+#define PKT_DSC_NONCE_HI_MASK (PKT_DSC_NONCE_HI_BITS << PKT_DSC_NONCE_HI_LSB)
+
+	/* #define PKT_DSC_CKSUM_DST_ADDR */
+#define PKT_DSC_CKSUM_DST_ADDR_LSB  5
+#define PKT_DSC_CKSUM_DST_ADDR_BITS THIRTY_FIVE_BITS
+#define PKT_DSC_CKSUM_DST_ADDR_MASK (PKT_DSC_CKSUM_DST_ADDR_BITS << PKT_DSC_CKSUM_DST_ADDR_LSB)
+
+	/* #define PKT_DSC_IV_OFF_HI */
+#define PKT_DSC_IV_OFF_HI_LSB      0
+#define PKT_DSC_IV_OFF_HI_BITS     FIVE_BITS
+#define PKT_DSC_IV_OFF_HI_MASK   (PKT_DSC_IV_OFF_HI_BITS << PKT_DSC_IV_OFF_HI_LSB)
+
+#else /* B0 */
+
+	/* **********************************************************************
+	 *       packetdescriptor_t.dstLLWMask
+	 * **********************************************************************
+	 */
+
+	/* #define PKT_DSC_LASTWORD */
+#define PKT_DSC_LASTWORD_128       0
+#define PKT_DSC_LASTWORD_96MASK    1
+#define PKT_DSC_LASTWORD_64MASK    2
+#define PKT_DSC_LASTWORD_32MASK    3
+#define PKT_DSC_LASTWORD_LSB       58
+#define PKT_DSC_LASTWORD_BITS      TWO_BITS
+#define PKT_DSC_LASTWORD_MASK      \
+(PKT_DSC_LASTWORD_BITS << PKT_DSC_LASTWORD_LSB)
+
+	/* #define PKT_DSC_CPHR_DST_ADDR */
+#define PKT_DSC_CPHR_DST_ADDR_LSB  0
+#define PKT_DSC_CPHR_DST_ADDR_BITS FOURTY_BITS
+#define PKT_DSC_CPHR_DST_ADDR_MASK \
+(PKT_DSC_CPHR_DST_ADDR_BITS << PKT_DSC_CPHR_DST_ADDR_LSB)
+
+	/* #define PKT_DSC_CPHR_DST_OFFSET */
+#define PKT_DSC_CPHR_DST_OFFSET_LSB   0
+#define PKT_DSC_CPHR_DST_OFFSET_BITS  THREE_BITS
+#define PKT_DSC_CPHR_DST_OFFSET_MASK \
+(PKT_DSC_CPHR_DST_OFFSET_BITS << PKT_DSC_CPHR_DST_OFFSET_LSB)
+#endif /* B0 */
+
+
+	/* ******************************************************************
+	 *             Control Error Code and Conditions
+	 * ******************************************************************
+	 */
+#define CTL_ERR_NONE         0x0000   /* No Error */
+#define CTL_ERR_CIPHER_OP    0x0001   /* Unknown Cipher Op */
+#define CTL_ERR_MODE         0x0002   /* Unknown or Not Allowed Mode */
+#define CTL_ERR_CHKSUM_SRC   0x0004   /* Unknown CkSum Src - B0 UNUSED */
+#define CTL_ERR_CFB_MASK     0x0008   /* Forbidden CFB Mask - B0 UNUSED */
+#define CTL_ERR_OP           0x0010   /* Unknown Ctrl Op - B0 UNUSED */
+#define CTL_ERR_UNDEF1       0x0020   /* UNUSED */
+#define CTL_ERR_UNDEF2       0x0040   /* UNUSED */
+#define CTL_ERR_DATA_READ    0x0080   /* Data Read Error */
+#define CTL_ERR_DESC_CTRL    0x0100   /* Descriptor Ctrl Field Error */
+
+#define CTL_ERR_TIMEOUT      0x1000   /* Message Response Timeout */ 
+
+	/* ******************************************************************
+	 *             Data Error Code and Conditions
+	 * ******************************************************************
+	 */
+#define DATA_ERR_NONE        0x0000   /* No Error */
+#define DATA_ERR_LEN_CIPHER  0x0001   /* Not Enough Data To Cipher */
+#define DATA_ERR_IV_ADDR     0x0002   /* Illegal IV Loacation */
+#define DATA_ERR_WD_LEN_AES  0x0004   /* Illegal Nb Words To AES */
+#define DATA_ERR_BYTE_COUNT  0x0008   /* Illegal Pad And ByteCount Spec */
+#define DATA_ERR_LEN_CKSUM   0x0010   /* Not Enough Data To CkSum */
+#define DATA_ERR_OP          0x0020   /* Unknown Data Op */
+#define DATA_ERR_UNDEF1      0x0040   /* UNUSED */
+#define DATA_ERR_READ        0x0080   /* Data Read Error */
+#define DATA_ERR_WRITE       0x0100   /* Data Write Error */
+
+
+	/*
+	 * Common Descriptor 
+	 * NOTE:  Size of struct is size of cacheline.
+	 */
+
+	typedef struct OperationDescriptor_s {
+		uint64_t             phys_self;
+		uint32_t             stn_id;
+		uint32_t             flags;
+		uint32_t             cpu;
+		uint32_t             seq_num;
+		uint64_t             reserved;
+	} operationdescriptor_t, *OperationDescriptor_pt;
+
+
+/*
+ * This defines the security data descriptor format
+ */
+typedef struct PacketDescriptor_s {
+	uint64_t             srcLengthIVOffUseIVNext;
+#ifdef B0
+	uint64_t             dstDataSettings;
+	uint64_t             authDstNonceLow;
+	uint64_t             ckSumDstNonceHiCFBMaskLLWMask;
+#else /* B0 */
+	uint64_t             dstLLWMask;
+	uint64_t             authDst;
+	uint64_t             ckSumDst;
+#endif /* B0 */
+} packetdescriptor_t, *PacketDescriptor_pt;
+
+typedef struct {
+	__u8 *user_auth;
+	__u8 *user_src;
+	__u8 *user_dest;
+	__u8 *user_state;
+	__u8 *kern_auth; 
+	__u8 *kern_src; 
+	__u8 *kern_dest;
+	__u8 *kern_state;
+	__u8 *aligned_auth;
+	__u8 *aligned_src;
+	__u8 *aligned_dest;
+	__u8 *aligned_state;
+}  phxdrv_user_t, *phxdrv_user_pt;
+
+typedef struct symkey_desc {
+	operationdescriptor_t   op_ctl;    /* size is cacheline */
+	packetdescriptor_t      pkt_desc;  /* size is cacheline  */
+	controldescriptor_t     ctl_desc;  /*  makes this aligned */
+	__u64                   control;   /* message word0 */
+	__u64                   data;		/* message word1 */
+	__u64                   ctl_result;
+	__u64                   data_result; 
+	struct symkey_desc      *alloc;    /* real allocated addr */
+	phxdrv_user_t           user;
+	volatile atomic_t       flag_complete;
+	struct semaphore        sem_complete;
+	wait_queue_t            submit_wait;
+} symkey_desc_t, *symkey_desc_pt;
+
+
+/*
+ * **************************************************************************
+ *                                 RSA Block
+ * **************************************************************************
+ */
+
+/*
+ *                                 RSA Block
+ *                                 =========
+ *
+ * A 2-word message ring descriptor is used to pass all information
+ * pertaining to the RSA operation:
+ *
+ *  63  61 60    54     53            52            51       50            40 39          5 4      3 2                      0
+ *  -------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | UNUSED | Valid Op | Block Width | Load Constant | Exponent Width | Source Addr | UNUSED | Global src data offset |
+ *  -------------------------------------------------------------------------------------------------------------------------
+ *    3       7         1             1             1              11              35          2                3
+ *
+ *
+ *  63  61 60    54     53         52             51     50           40 39        5 4      3 2                      0
+ *  ------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | UNUSED | WRB_COH | WRB_L2ALLOC | DF_L2ALLOC | Modulus Width | Dest Addr | UNUSED | Global dst data offset |
+ *  ------------------------------------------------------------------------------------------------------------------
+ *    3       7         1          1              1            11           35         2                3
+ *
+ *
+ *             Valid Op                =        1'b1       Will cause operation to start; descriptors sent back at end of operation
+ *                                              1'b0       No operation performed; descriptors sent back right away
+ *             Block Width             =        1'b1       1024 bit op
+ *                                     =        1'b0       512  bit op
+ *             Load Constant           =        1'b1       Load constant from data structure
+ *                                              1'b0       Preserve old constant (this assumes Source Addr points to RSAData_pt->Exponent
+ *                                                         or that the length of Constant is 0)
+ *             Exponent Width          =                   11-bit expression of exponent width EXPRESSED IN NUMBER OF BITS
+ *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engine
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *             Source Addr             =                   35 MSB of pointer to source address (i.e., cache-line aligned)
+ *             Modulus Width           =                   11-bit expression of modulus width EXPRESSED IN NUMBER OF BITS
+ *             Global dst data offset  =                   Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+ *             Dest Addr               =                   35 MSB of pointer to destination address (i.e., cache-line aligned)
+ */
+
+/* #define PUBKEY_CTL_CTL */
+#define PUBKEY_CTL_CTL_LSB         61
+#define PUBKEY_CTL_CTL_BITS        THREE_BITS
+#define PUBKEY_CTL_CTL_MASK        (PUBKEY_CTL_CTL_BITS << PUBKEY_CTL_CTL_LSB)
+
+/* #define PUBKEY_CTL_VALID */
+#define PUBKEY_CTL_VALID_FALSE     0
+#define PUBKEY_CTL_VALID_TRUE      1
+#define PUBKEY_CTL_VALID_LSB       53
+#define PUBKEY_CTL_VALID_BITS      ONE_BIT
+#define PUBKEY_CTL_VALID_MASK      \
+(PUBKEY_CTL_VALID_BITS << PUBKEY_CTL_VALID_LSB)
+
+	/* #define PUBKEY_CTL_BLKWIDTH */
+#define PUBKEY_CTL_BLKWIDTH_512    0
+#define PUBKEY_CTL_BLKWIDTH_1024   1
+#define PUBKEY_CTL_BLKWIDTH_LSB    52
+#define PUBKEY_CTL_BLKWIDTH_BITS   ONE_BIT
+#define PUBKEY_CTL_BLKWIDTH_MASK   \
+(PUBKEY_CTL_BLKWIDTH_BITS << PUBKEY_CTL_BLKWIDTH_LSB)
+
+	/* #define PUBKEY_CTL_LD_CONST */
+#define PUBKEY_CTL_LD_CONST_OLD    0
+#define PUBKEY_CTL_LD_CONST_NEW    1
+#define PUBKEY_CTL_LD_CONST_LSB    51
+#define PUBKEY_CTL_LD_CONST_BITS   ONE_BIT
+#define PUBKEY_CTL_LD_CONST_MASK   \
+(PUBKEY_CTL_LD_CONST_BITS << PUBKEY_CTL_LD_CONST_LSB)
+
+	/* #define PUBKEY_CTL_EXPWIDTH */
+#define PUBKEY_CTL_EXPWIDTH_LSB    40
+#define PUBKEY_CTL_EXPWIDTH_BITS   ELEVEN_BITS
+#define PUBKEY_CTL_EXPWIDTH_MASK   \
+(PUBKEY_CTL_EXPWIDTH_BITS << PUBKEY_CTL_EXPWIDTH_LSB)
+
+	/* #define PUBKEY_CTL_SRCADDR */
+#define PUBKEY_CTL_SRCADDR_LSB     0  
+#define PUBKEY_CTL_SRCADDR_BITS    FOURTY_BITS
+#define PUBKEY_CTL_SRCADDR_MASK    \
+(PUBKEY_CTL_SRCADDR_BITS << PUBKEY_CTL_SRCADDR_LSB)
+
+	/* #define PUBKEY_CTL_SRC_OFFSET */
+#define PUBKEY_CTL_SRC_OFFSET_LSB  0  
+#define PUBKEY_CTL_SRC_OFFSET_BITS THREE_BITS
+#define PUBKEY_CTL_SRC_OFFSET_MASK \
+(PUBKEY_CTL_SRC_OFFSET_BITS << PUBKEY_CTL_SRC_OFFSET_LSB)
+
+
+	/* #define PUBKEY_CTL1_CTL */
+#define PUBKEY_CTL1_CTL_LSB        61
+#define PUBKEY_CTL1_CTL_BITS       THREE_BITS
+#define PUBKEY_CTL1_CTL_MASK       (PUBKEY_CTL_CTL_BITS << PUBKEY_CTL_CTL_LSB)
+
+	/* #define PUBKEY_CTL1_MODWIDTH */
+#define PUBKEY_CTL1_MODWIDTH_LSB   40     
+#define PUBKEY_CTL1_MODWIDTH_BITS  ELEVEN_BITS
+#define PUBKEY_CTL1_MODWIDTH_MASK  \
+(PUBKEY_CTL1_MODWIDTH_BITS << PUBKEY_CTL1_MODWIDTH_LSB)
+
+	/* #define PUBKEY_CTL1_DSTADDR */
+#define PUBKEY_CTL1_DSTADDR_LSB    0
+#define PUBKEY_CTL1_DSTADDR_BITS   FOURTY_BITS
+#define PUBKEY_CTL1_DSTADDR_MASK   \
+(PUBKEY_CTL1_DSTADDR_BITS << PUBKEY_CTL1_DSTADDR_LSB)
+
+	/* #define PUBKEY_CTL1_DST_OFFSET */
+#define PUBKEY_CTL1_DST_OFFSET_LSB    0
+#define PUBKEY_CTL1_DST_OFFSET_BITS   THREE_BITS
+#define PUBKEY_CTL1_DST_OFFSET_MASK   \
+(PUBKEY_CTL1_DST_OFFSET_BITS << PUBKEY_CTL1_DST_OFFSET_LSB)
+
+	/*
+	 * Upon completion of operation, the RSA block returns a 2-word free descriptor
+	 * in the following format:
+	 *
+	 *  63  61 60            54 53   52 51       49  48          40 39             0
+	 *  ----------------------------------------------------------------------------
+	 * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address |
+	 *  ----------------------------------------------------------------------------
+	 * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   |
+	 *  ----------------------------------------------------------------------------
+	 *
+	 * The Control and Data Error codes are enumerated below
+	 *
+	 *                                Error conditions
+	 *                                ================
+	 *
+	 *             Control Error Code                  Control Error Condition
+	 *             ------------------                  -----------------------
+	 *             9'h000                              No Error
+	 *             9'h001                              UNUSED
+	 *             9'h002                              UNUSED
+	 *             9'h004                              UNUSED
+	 *             9'h008                              UNUSED
+	 *             9'h010                              UNUSED
+	 *             9'h020                              UNUSED
+	 *             9'h040                              UNUSED
+	 *             9'h080                              Data Read Error
+	 *             9'h100                              Descriptor Ctrl Field Error        (D0.Ctrl != SOP || D1.Ctrl != EOP)
+	 *
+	 *             Data Error Code                     Data Error Condition
+	 *             ---------------                     --------------------
+	 *             9'h000                              No Error
+	 *             9'h001                              Exponent Width > Block Width
+	 *             9'h002                              Modulus Width  > Block Width
+	 *             9'h004                              UNUSED
+	 *             9'h008                              UNUSED
+	 *             9'h010                              UNUSED
+	 *             9'h020                              UNUSED
+	 *             9'h040                              UNUSED
+	 *             9'h080                              Data Read Error
+	 *             9'h100                              UNUSED
+	 */
+
+	/*
+	 * Result Data Word for Message Ring Descriptor
+	 */
+
+	/* #define PUBKEY_RSLT_CTL_CTL */
+#define PUBKEY_RSLT_CTL_CTL_LSB        61
+#define PUBKEY_RSLT_CTL_CTL_BITS       THREE_BITS
+#define PUBKEY_RSLT_CTL_CTL_MASK       \
+(PUBKEY_RSLT_CTL_CTL_BITS << PUBKEY_RSLT_CTL_CTL_LSB)
+
+	/* #define PUBKEY_RSLT_CTL_DST_ID */
+#define PUBKEY_RSLT_CTL_DST_ID_LSB     54
+#define PUBKEY_RSLT_CTL_DST_ID_BITS    SEVEN_BITS
+#define PUBKEY_RSLT_CTL_DST_ID_MASK    \
+(PUBKEY_RSLT_CTL_DST_ID_BITS << PUBKEY_RSLT_CTL_DST_ID_LSB)
+
+	/* #define PUBKEY_RSLT_CTL_DESC_CTL */
+#define PUBKEY_RSLT_CTL_DESC_CTL_LSB   49
+#define PUBKEY_RSLT_CTL_DESC_CTL_BITS  THREE_BITS
+#define PUBKEY_RSLT_CTL_DESC_CTL_MASK  \
+(PUBKEY_RSLT_CTL_DESC_CTL_BITS << PUBKEY_RSLT_CTL_DESC_CTL_LSB)
+
+
+	/* #define PUBKEY_RSLT_CTL_ERROR */
+#define PUBKEY_RSLT_CTL_ERROR_LSB      40
+#define PUBKEY_RSLT_CTL_ERROR_BITS     NINE_BITS
+#define PUBKEY_RSLT_CTL_ERROR_MASK     \
+(PUBKEY_RSLT_CTL_ERROR_BITS << PUBKEY_RSLT_CTL_ERROR_LSB)
+
+	/* #define PUBKEY_RSLT_CTL_SRCADDR */
+#define PUBKEY_RSLT_CTL_SRCADDR_LSB    0
+#define PUBKEY_RSLT_CTL_SRCADDR_BITS   FOURTY_BITS
+#define PUBKEY_RSLT_CTL_SRCADDR_MASK   \
+(PUBKEY_RSLT_CTL_SRCADDR_BITS << PUBKEY_RSLT_CTL_SRCADDR_LSB)
+
+
+	/* #define PUBKEY_RSLT_DATA_CTL */
+#define PUBKEY_RSLT_DATA_CTL_LSB       61
+#define PUBKEY_RSLT_DATA_CTL_BITS      THREE_BITS
+#define PUBKEY_RSLT_DATA_CTL_MASK      \
+(PUBKEY_RSLT_DATA_CTL_BITS << PUBKEY_RSLT_DATA_CTL_LSB)
+
+	/* #define PUBKEY_RSLT_DATA_DST_ID */
+#define PUBKEY_RSLT_DATA_DST_ID_LSB    54
+#define PUBKEY_RSLT_DATA_DST_ID_BITS   SEVEN_BITS
+#define PUBKEY_RSLT_DATA_DST_ID_MASK   \
+(PUBKEY_RSLT_DATA_DST_ID_BITS << PUBKEY_RSLT_DATA_DST_ID_LSB)
+
+	/* #define PUBKEY_RSLT_DATA_DESC_CTL */
+#define PUBKEY_RSLT_DATA_DESC_CTL_LSB  49
+#define PUBKEY_RSLT_DATA_DESC_CTL_BITS THREE_BITS
+#define PUBKEY_RSLT_DATA_DESC_CTL_MASK \
+(PUBKEY_RSLT_DATA_DESC_CTL_BITS << PUBKEY_RSLT_DATA_DESC_CTL_LSB)
+
+	/* #define PUBKEY_RSLT_DATA_ERROR */
+#define PUBKEY_RSLT_DATA_ERROR_LSB     40
+#define PUBKEY_RSLT_DATA_ERROR_BITS    NINE_BITS
+#define PUBKEY_RSLT_DATA_ERROR_MASK    \
+(PUBKEY_RSLT_DATA_ERROR_BITS << PUBKEY_RSLT_DATA_ERROR_LSB)
+
+	/* #define PUBKEY_RSLT_DATA_DSTADDR */
+#define PUBKEY_RSLT_DATA_DSTADDR_LSB   40
+#define PUBKEY_RSLT_DATA_DSTADDR_BITS  FOURTY_BITS
+#define PUBKEY_RSLT_DATA_DSTADDR_MASK  \
+(PUBKEY_RSLT_DATA_DSTADDR_BITS << PUBKEY_RSLT_DATA_DSTADDR_LSB)
+
+	/* 
+	 * ******************************************************************
+	 *             RSA Block - Data Error Code and Conditions
+	 * ******************************************************************
+	 */
+
+#define PK_CTL_ERR_NONE        0x0000   /* No Error */
+#define PK_CTL_ERR_READ        0x0080   /* Data Read Error */
+#define PK_CTL_ERR_DESC        0x0100   /* Descriptor Ctrl Field Error  (D0.Ctrl != SOP || D1.Ctrl != EOP) */
+#define PK_CTL_ERR_TIMEOUT     0x1000   /* Message Responce Timeout */ 
+
+#define PK_DATA_ERR_NONE       0x0000   /* No Error */
+#define PK_DATA_ERR_EXP_WIDTH  0x0001   /* Exponent Width > Block Width */
+#define PK_DATA_ERR_MOD_WIDTH  0x0002   /* Modulus Width  > Block Width */
+#define PK_DATA_ERR_READ       0x0080   /* Data Read Error */
+
+
+	/*
+	 * This defines the RSA data format
+	 */
+	/*
+	 * typedef struct RSAData_s {
+	 *  uint64_t            Constant;
+	 *  uint64_t            Exponent;
+	 *  uint64_t            Modulus;
+	 * uint64_t            Message;
+	 *} RSAData_t, *RSAData_pt;
+	 *
+	 * typedef RSAData_t DHData_t;
+	 * typedef RSAData_pt DHData_pt;
+	 */
+
+	typedef struct UserPubData_s {
+		uint8_t            *source;
+		uint8_t            *user_result;
+		uint32_t           result_length;
+	} UserPubData_t, *UserPubData_pt;
+
+typedef struct pubkey_desc {
+	operationdescriptor_t   op_ctl;    /* size is cacheline */
+	uint8_t                 source[1024];
+	uint8_t                 dest[256];    /* 1024 makes cacheline-aligned */
+	__u64                   control0;
+	__u64                   control1;
+	__u64                   ctl_result;
+	__u64                   data_result; 
+	struct pubkey_desc      *alloc;
+	UserPubData_t           kern;       /* ptrs for temp buffers */
+	volatile atomic_t       flag_complete;
+	struct semaphore        sem_complete;
+	wait_queue_t            submit_wait;
+} pubkey_desc_t, *pubkey_desc_pt;
+
+
+#endif /* _PHXDESC_H_ */
Index: linux-2.6.10/include/asm-mips/rmi/phxdrv.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phxdrv.h
@@ -0,0 +1,688 @@
+/*
+ **  Raza Microelectronics Incorporated
+ **  Phoenix Security Engine driver for Linux
+ **
+ **  Copyright (C) 2003 Raza Foundries
+ **  Author: Dave Koplos;  dkoplos@razafoundries.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * RMI Phoenix Security Engine
+ *
+ * phxdrv.h: Defintions for the Phoenix Security Engine driver.
+ *
+ * Revision History:
+ *
+ * 04/01/2004  DPK   Created
+ */
+
+#ifndef _PHXDRV_H_
+#define _PHXDRV_H_
+
+#include <asm/rmi/msgring.h>
+
+/*
+ *   Message Ring Specifics
+ */
+
+#define SEC_MSGRING_WORDSIZE      2
+
+#if 0
+#define CTRL_RES0           0
+#define CTRL_RES1           1
+#define CTRL_REG_FREE       2
+#define CTRL_JUMBO_FREE     3
+#define CTRL_CONT           4
+#define CTRL_EOP            5
+#define CTRL_START          6
+#define CTRL_SNGL           7
+#endif
+
+/*
+ *
+ * 
+ * rwR      31  30 29     27 26    24 23      21 20     18     
+ *         |  NA  | RSA0Out | Rsa0In | Pipe3Out | Pipe3In | ... 
+ *
+ *          17       15 14     12 11      9 8       6 5        3 2       0
+ *         |  Pipe2Out | Pipe2In | Pipe1In | Pipe1In | Pipe0Out | Pipe0In |
+ *
+ * DMA CREDIT REG -
+ *   NUMBER OF CREDITS PER PIPE
+ */
+#define SEC_DMA_CREDIT_RSA0_OUT_FOUR   0x20000000
+#define SEC_DMA_CREDIT_RSA0_OUT_TWO    0x10000000
+#define SEC_DMA_CREDIT_RSA0_OUT_ONE    0x08000000
+
+#define SEC_DMA_CREDIT_RSA0_IN_FOUR    0x04000000
+#define SEC_DMA_CREDIT_RSA0_IN_TWO     0x02000000
+#define SEC_DMA_CREDIT_RSA0_IN_ONE     0x01000000
+
+#define SEC_DMA_CREDIT_PIPE3_OUT_FOUR  0x00800000
+#define SEC_DMA_CREDIT_PIPE3_OUT_TWO   0x00400000
+#define SEC_DMA_CREDIT_PIPE3_OUT_ONE   0x00200000
+
+#define SEC_DMA_CREDIT_PIPE3_IN_FOUR   0x00100000
+#define SEC_DMA_CREDIT_PIPE3_IN_TWO    0x00080000
+#define SEC_DMA_CREDIT_PIPE3_IN_ONE    0x00040000 
+
+#define SEC_DMA_CREDIT_PIPE2_OUT_FOUR  0x00020000
+#define SEC_DMA_CREDIT_PIPE2_OUT_TWO   0x00010000
+#define SEC_DMA_CREDIT_PIPE2_OUT_ONE   0x00008000
+
+#define SEC_DMA_CREDIT_PIPE2_IN_FOUR   0x00004000
+#define SEC_DMA_CREDIT_PIPE2_IN_TWO    0x00002000
+#define SEC_DMA_CREDIT_PIPE2_IN_ONE    0x00001000 
+
+#define SEC_DMA_CREDIT_PIPE1_OUT_FOUR  0x00000800
+#define SEC_DMA_CREDIT_PIPE1_OUT_TWO   0x00000400
+#define SEC_DMA_CREDIT_PIPE1_OUT_ONE   0x00000200
+
+#define SEC_DMA_CREDIT_PIPE1_IN_FOUR   0x00000100
+#define SEC_DMA_CREDIT_PIPE1_IN_TWO    0x00000080
+#define SEC_DMA_CREDIT_PIPE1_IN_ONE    0x00000040
+
+#define SEC_DMA_CREDIT_PIPE0_OUT_FOUR  0x00000020
+#define SEC_DMA_CREDIT_PIPE0_OUT_TWO   0x00000010
+#define SEC_DMA_CREDIT_PIPE0_OUT_ONE   0x00000008
+
+#define SEC_DMA_CREDIT_PIPE0_IN_FOUR   0x00000004
+#define SEC_DMA_CREDIT_PIPE0_IN_TWO    0x00000002
+#define SEC_DMA_CREDIT_PIPE0_IN_ONE    0x00000001
+
+/*
+ *  Currently, FOUR credits per PIPE
+ *  0x24924924  
+ */
+#define SEC_DMA_CREDIT_CONFIG          SEC_DMA_CREDIT_RSA0_OUT_FOUR | \
+SEC_DMA_CREDIT_RSA0_IN_FOUR | \
+	SEC_DMA_CREDIT_PIPE3_OUT_FOUR | \
+	SEC_DMA_CREDIT_PIPE3_IN_FOUR | \
+	SEC_DMA_CREDIT_PIPE2_OUT_FOUR | \
+	SEC_DMA_CREDIT_PIPE2_IN_FOUR | \
+	SEC_DMA_CREDIT_PIPE1_OUT_FOUR | \
+	SEC_DMA_CREDIT_PIPE1_IN_FOUR | \
+	SEC_DMA_CREDIT_PIPE0_OUT_FOUR | \
+	SEC_DMA_CREDIT_PIPE0_IN_FOUR 
+
+	/*
+	 * CONFIG2  
+	 *    31   5         4                   3            
+	 *   |  NA  | PIPE3_DEF_DBL_ISS | PIPE2_DEF_DBL_ISS | ...
+	 *
+	 *                 2                   1                   0
+	 *   ... | PIPE1_DEF_DBL_ISS | PIPE0_DEF_DBL_ISS | ROUND_ROBIN_MODE |
+	 *
+	 *  DBL_ISS - mode for SECENG and DMA controller which slows down transfers 
+	 *             (to be conservativei; 0=Disable,1=Enable).
+	 *  ROUND_ROBIN - mode where SECENG dispatches operations to PIPE0-PIPE3 
+	 *                and all messages are sent to PIPE0.
+	 *
+	 */
+
+#define SEC_CFG2_PIPE3_DBL_ISS_ON      0x00000010 
+#define SEC_CFG2_PIPE3_DBL_ISS_OFF     0x00000000 
+#define SEC_CFG2_PIPE2_DBL_ISS_ON      0x00000008 
+#define SEC_CFG2_PIPE2_DBL_ISS_OFF     0x00000000 
+#define SEC_CFG2_PIPE1_DBL_ISS_ON      0x00000004 
+#define SEC_CFG2_PIPE1_DBL_ISS_OFF     0x00000000 
+#define SEC_CFG2_PIPE0_DBL_ISS_ON      0x00000002 
+#define SEC_CFG2_PIPE0_DBL_ISS_OFF     0x00000000 
+#define SEC_CFG2_ROUND_ROBIN_ON        0x00000001 
+#define SEC_CFG2_ROUND_ROBIN_OFF       0x00000000
+
+
+
+	enum sec_pipe_config {
+
+		SEC_PIPE_CIPHER_KEY0_L0            = 0x00,
+		SEC_PIPE_CIPHER_KEY0_HI,
+		SEC_PIPE_CIPHER_KEY1_LO,
+		SEC_PIPE_CIPHER_KEY1_HI,
+		SEC_PIPE_CIPHER_KEY2_LO,
+		SEC_PIPE_CIPHER_KEY2_HI,
+		SEC_PIPE_CIPHER_KEY3_LO,
+		SEC_PIPE_CIPHER_KEY3_HI,
+		SEC_PIPE_HMAC_KEY0_LO,
+		SEC_PIPE_HMAC_KEY0_HI,
+		SEC_PIPE_HMAC_KEY1_LO,
+		SEC_PIPE_HMAC_KEY1_HI,
+		SEC_PIPE_HMAC_KEY2_LO,
+		SEC_PIPE_HMAC_KEY2_HI,
+		SEC_PIPE_HMAC_KEY3_LO,
+		SEC_PIPE_HMAC_KEY3_HI,
+		SEC_PIPE_HMAC_KEY4_LO,
+		SEC_PIPE_HMAC_KEY4_HI,
+		SEC_PIPE_HMAC_KEY5_LO,
+		SEC_PIPE_HMAC_KEY5_HI,
+		SEC_PIPE_HMAC_KEY6_LO,
+		SEC_PIPE_HMAC_KEY6_HI,
+		SEC_PIPE_HMAC_KEY7_LO,
+		SEC_PIPE_HMAC_KEY7_HI,
+		SEC_PIPE_NCFBM_LO,
+		SEC_PIPE_NCFBM_HI,
+		SEC_PIPE_INSTR_LO,
+		SEC_PIPE_INSTR_HI,
+		SEC_PIPE_RSVD0,
+		SEC_PIPE_RSVD1,
+		SEC_PIPE_RSVD2,
+		SEC_PIPE_RSVD3,
+
+		SEC_PIPE_DF_PTRS0,
+		SEC_PIPE_DF_PTRS1,
+		SEC_PIPE_DF_PTRS2,
+		SEC_PIPE_DF_PTRS3,
+		SEC_PIPE_DF_PTRS4,
+		SEC_PIPE_DF_PTRS5,
+		SEC_PIPE_DF_PTRS6,
+		SEC_PIPE_DF_PTRS7,
+
+		SEC_PIPE_DU_DATA_IN_LO,
+		SEC_PIPE_DU_DATA_IN_HI,
+		SEC_PIPE_DU_DATA_IN_CTRL,
+		SEC_PIPE_DU_DATA_OUT_LO,
+		SEC_PIPE_DU_DATA_OUT_HI,
+		SEC_PIPE_DU_DATA_OUT_CTRL,
+
+		SEC_PIPE_STATE0,
+		SEC_PIPE_STATE1,
+		SEC_PIPE_STATE2,
+		SEC_PIPE_STATE3,
+		SEC_PIPE_STATE4,
+		SEC_PIPE_INCLUDE_MASK0,
+		SEC_PIPE_INCLUDE_MASK1,
+		SEC_PIPE_INCLUDE_MASK2,
+		SEC_PIPE_INCLUDE_MASK3,
+		SEC_PIPE_INCLUDE_MASK4,
+		SEC_PIPE_EXCLUDE_MASK0,
+		SEC_PIPE_EXCLUDE_MASK1,
+		SEC_PIPE_EXCLUDE_MASK2,
+		SEC_PIPE_EXCLUDE_MASK3,
+		SEC_PIPE_EXCLUDE_MASK4,
+	};
+
+enum sec_pipe_base_config {
+
+	SEC_PIPE0_BASE = 0x00,
+	SEC_PIPE1_BASE = 0x40,
+	SEC_PIPE2_BASE = 0x80,
+	SEC_PIPE3_BASE = 0xc0
+
+};
+
+enum sec_rsa_config {
+
+	SEC_RSA_PIPE0_DU_DATA_IN_LO = 0x100,
+	SEC_RSA_PIPE0_DU_DATA_IN_HI,
+	SEC_RSA_PIPE0_DU_DATA_IN_CTRL,
+	SEC_RSA_PIPE0_DU_DATA_OUT_LO,
+	SEC_RSA_PIPE0_DU_DATA_OUT_HI,
+	SEC_RSA_PIPE0_DU_DATA_OUT_CTRL,
+	SEC_RSA_RSVD0,
+	SEC_RSA_RSVD1,
+
+	SEC_RSA_PIPE0_STATE0,
+	SEC_RSA_PIPE0_STATE1,
+	SEC_RSA_PIPE0_STATE2,
+	SEC_RSA_PIPE0_INCLUDE_MASK0,
+	SEC_RSA_PIPE0_INCLUDE_MASK1,
+	SEC_RSA_PIPE0_INCLUDE_MASK2,
+	SEC_RSA_PIPE0_EXCLUDE_MASK0,
+	SEC_RSA_PIPE0_EXCLUDE_MASK1,
+	SEC_RSA_PIPE0_EXCLUDE_MASK2,
+	SEC_RSA_PIPE0_EVENT_CTR
+
+};
+
+enum sec_config {
+
+	SEC_DMA_CREDIT = 0x140,
+	SEC_CONFIG1,
+	SEC_CONFIG2,
+	SEC_CONFIG3,  
+
+};
+
+enum sec_debug_config {
+
+	SEC_DW0_DESCRIPTOR0_LO  = 0x180,
+	SEC_DW0_DESCRIPTOR0_HI,
+	SEC_DW0_DESCRIPTOR1_LO,
+	SEC_DW0_DESCRIPTOR1_HI,
+	SEC_DW1_DESCRIPTOR0_LO,
+	SEC_DW1_DESCRIPTOR0_HI,
+	SEC_DW1_DESCRIPTOR1_LO,
+	SEC_DW1_DESCRIPTOR1_HI,
+	SEC_DW2_DESCRIPTOR0_LO,
+	SEC_DW2_DESCRIPTOR0_HI,
+	SEC_DW2_DESCRIPTOR1_LO,
+	SEC_DW2_DESCRIPTOR1_HI,
+	SEC_DW3_DESCRIPTOR0_LO,
+	SEC_DW3_DESCRIPTOR0_HI,
+	SEC_DW3_DESCRIPTOR1_LO,
+	SEC_DW3_DESCRIPTOR1_HI,
+
+	SEC_STATE0,
+	SEC_STATE1,  
+	SEC_STATE2,
+	SEC_INCLUDE_MASK0,
+	SEC_INCLUDE_MASK1,
+	SEC_INCLUDE_MASK2,
+	SEC_EXCLUDE_MASK0,
+	SEC_EXCLUDE_MASK1,
+	SEC_EXCLUDE_MASK2,
+	SEC_EVENT_CTR
+
+};
+
+//enum sec_perf_config {
+
+//  SEC_PERF0  = 0x1c0
+
+//};
+
+enum sec_msgring_bucket_config {
+
+	SEC_BIU_CREDITS = 0x308,
+
+	SEC_MSG_BUCKET0_SIZE = 0x320,
+	SEC_MSG_BUCKET1_SIZE,
+	SEC_MSG_BUCKET2_SIZE,
+	SEC_MSG_BUCKET3_SIZE,
+	SEC_MSG_BUCKET4_SIZE,
+	SEC_MSG_BUCKET5_SIZE,
+	SEC_MSG_BUCKET6_SIZE,
+	SEC_MSG_BUCKET7_SIZE,
+};
+
+enum sec_msgring_credit_config {
+
+	SEC_CC_CPU0_0                        = 0x380,
+	SEC_CC_CPU1_0                        = 0x388,
+	SEC_CC_CPU2_0                        = 0x390,
+	SEC_CC_CPU3_0                        = 0x398,
+	SEC_CC_CPU4_0                        = 0x3a0,
+	SEC_CC_CPU5_0                        = 0x3a8,
+	SEC_CC_CPU6_0                        = 0x3b0,
+	SEC_CC_CPU7_0                        = 0x3b8
+
+};
+
+enum sec_engine_id {
+	SEC_PIPE0,
+	SEC_PIPE1,
+	SEC_PIPE2,
+	SEC_PIPE3,
+	SEC_RSA
+};
+
+enum sec_cipher {
+	SEC_AES256_MODE_HMAC,
+	SEC_AES256_MODE,
+	SEC_AES256_HMAC,
+	SEC_AES256,
+	SEC_AES192_MODE_HMAC,
+	SEC_AES192_MODE,
+	SEC_AES192_HMAC,
+	SEC_AES192,
+	SEC_AES128_MODE_HMAC,
+	SEC_AES128_MODE,
+	SEC_AES128_HMAC,
+	SEC_AES128,
+	SEC_DES_HMAC,
+	SEC_DES,
+	SEC_3DES,
+	SEC_3DES_HMAC,
+	SEC_HMAC
+};
+
+enum sec_msgrng_msg_ctrl_config {
+	SEC_EOP=5,
+	SEC_SOP=6,
+};
+
+
+/*
+ *  STRUCTS
+ */
+
+typedef struct phx_sec_stats {
+	__u32    operations;
+} phx_sec_stats_t;
+
+
+typedef struct driver_data {
+
+	phx_sec_stats_t                stats;
+	spinlock_t                     lock;
+	__u32                          pending_ops;
+
+	volatile unsigned long         *mmio;
+
+	unsigned long                  mem_end;
+
+	__u32                          base_address;
+	__u16                          irq;
+
+	int                            id;
+	int                            type;
+	int                            instance;
+
+} driver_data_t, *driver_data_pt;
+
+
+symkey_desc_pt phxsec_alloc_symkey_desc(void);
+void phxsec_free_symkey_desc(symkey_desc_pt desc);
+pubkey_desc_pt phxsec_alloc_pubkey_desc(void);
+void phxsec_free_pubkey_desc(pubkey_desc_pt desc);
+void phxsec_msgring_handler(int bucket, int size, int code, int stid,
+		struct msgrng_msg *msg, void *data);
+phxsec_error_t phxsec_submit_op_wait(symkey_desc_pt desc);
+phxsec_error_t phxsec_submit_pkop_wait(pubkey_desc_pt desc);
+
+phxsec_status_t phxsec_init_device(unsigned short dev_id,
+		unsigned long base_address,  unsigned int irq,
+		unsigned int num_descriptors,
+		dev_info_pt dev_ctx);
+
+phxsec_status_t phxsec_shutdown(dev_info_pt dev_ctx);
+phxsec_status_t phxsec_reset(dev_info_pt dev_ctx);
+
+/* Stats-related section */
+
+#define PHXDRV_PROFILE_DES                 0x00000001
+#define PHXDRV_PROFILE_3DES                0x00000002
+#define PHXDRV_PROFILE_AES                 0x00000004
+#ifdef B0
+#define PHXDRV_PROFILE_ARC4                 0x00000008
+#endif /* B0 */
+#define PHXDRV_PROFILE_MD5                 0x00000010
+#define PHXDRV_PROFILE_SHA1                0x00000020
+#define PHXDRV_PROFILE_SHA256              0x00000040
+#define PHXDRV_PROFILE_MODEXP              0x00000080
+#define PHXDRV_PROFILE_COMBINED            0x00000100
+#define PHXDRV_PROFILE_HMAC_REVERTS        0x00010000
+#define PHXDRV_PROFILE_CPHR_REVERTS        0x00020000
+#define PHXDRV_PROFILE_UNALIGNED_AUTH_DEST 0x10000000
+
+typedef struct hmac_stats
+{
+	unsigned long md5_count;
+	unsigned long long md5_bytes;
+	unsigned long sha1_count;
+	unsigned long long sha1_bytes;
+	unsigned long sha256_count;
+	unsigned long long sha256_bytes;
+	unsigned long reverts;
+	unsigned long long reverts_bytes;
+} hmac_stats_t, *hmac_stats_pt;
+
+typedef struct cipher_stats
+{
+	unsigned long des_encrypts;
+	unsigned long long des_encrypt_bytes;
+	unsigned long des_decrypts;
+	unsigned long long des_decrypt_bytes;
+	unsigned long des3_encrypts;
+	unsigned long long des3_encrypt_bytes;
+	unsigned long des3_decrypts;
+	unsigned long long des3_decrypt_bytes;
+	unsigned long aes_encrypts;
+	unsigned long long aes_encrypt_bytes;
+	unsigned long aes_decrypts;
+	unsigned long long aes_decrypt_bytes;
+#ifdef B0
+	unsigned long arc4_encrypts;
+	unsigned long long arc4_encrypt_bytes;
+	unsigned long arc4_decrypts;
+	unsigned long long arc4_decrypt_bytes;
+#endif /* B0 */
+	unsigned long reverts;
+	unsigned long long reverts_bytes;
+} cipher_stats_t, *cipher_stats_pt;
+
+typedef struct modexp_stats
+{
+	unsigned long modexp_512s;
+	unsigned long modexp_1024s;
+} modexp_stats_t, *modexp_stats_pt;
+
+typedef struct opt_stats
+{
+	unsigned long combined;
+	unsigned long unaligned_auth_dest;
+	unsigned long sym_failed;
+	unsigned long modexp_failed;
+} opt_stats_t, *opt_stats_pt;
+
+typedef struct rmisec_stats
+{
+	unsigned int stats_mask;
+	unsigned int control_mask;
+	rwlock_t rmisec_control_lock;
+	rwlock_t rmisec_stats_lock;
+	char clear_start[0];
+	hmac_stats_t hmac;
+	cipher_stats_t cipher;
+	modexp_stats_t modexp;
+	opt_stats_t opt;
+} rmisec_stats_t, *rmisec_stats_pt;
+
+/* Control-related section */
+
+#define PHXDRV_CONTROL_HW_DES          0x00000001
+#define PHXDRV_CONTROL_HW_3DES         0x00000002
+#define PHXDRV_CONTROL_HW_AES          0x00000004
+#ifdef B0
+#define PHXDRV_CONTROL_HW_ARC4         0x00000008
+#endif /* B0 */
+#define PHXDRV_CONTROL_HW_MD5          0x00000010
+#define PHXDRV_CONTROL_HW_SHA1         0x00000020
+#define PHXDRV_CONTROL_HW_SHA256       0x00000040
+#define PHXDRV_CONTROL_HW_COMBINED     0x00008000
+#define PHXDRV_CONTROL_SILENT          0x20000000
+#define PHXDRV_CONTROL_VERBOSE         0x40000000
+#define PHXDRV_CONTROL_VVERBOSE        0x80000000
+
+#define PHXDRV_VERY_VERBOSE            2
+#define PHXDRV_VERBOSE                 1
+#define PHXDRV_NORMAL                  0
+#define PHXDRV_SILENT                 -1
+
+/* stats routines */
+
+static void inline phxdrv_record_des(rmisec_stats_pt stats, int enc,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_DES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.des_encrypts++;
+			stats->cipher.des_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.des_decrypts++;
+			stats->cipher.des_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_3des(rmisec_stats_pt stats, int enc,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_3DES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.des3_encrypts++;
+			stats->cipher.des3_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.des3_decrypts++;
+			stats->cipher.des3_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_aes(rmisec_stats_pt stats, int enc,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_AES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.aes_encrypts++;
+			stats->cipher.aes_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.aes_decrypts++;
+			stats->cipher.aes_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+#ifdef B0
+static void inline phxdrv_record_arc4(rmisec_stats_pt stats, int enc,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_ARC4) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.arc4_encrypts++;
+			stats->cipher.arc4_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.arc4_decrypts++;
+			stats->cipher.arc4_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+#endif /* B0 */
+
+static void inline phxdrv_record_modexp(rmisec_stats_pt stats, 
+		int blksize)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_MODEXP) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (blksize == 512) {
+			stats->modexp.modexp_512s++;
+		}
+		if (blksize == 1024) {
+			stats->modexp.modexp_1024s++;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_cipher_revert(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_CPHR_REVERTS) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->cipher.reverts++;
+		stats->cipher.reverts_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_hmac_revert(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_HMAC_REVERTS) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.reverts++;
+		stats->hmac.reverts_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_md5(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_MD5) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.md5_count++;
+		stats->hmac.md5_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha1(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA1) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha1_count++;
+		stats->hmac.sha1_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha256(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA256) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha256_count++;
+		stats->hmac.sha256_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_unaligned_auth_dest(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_UNALIGNED_AUTH_DEST) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.unaligned_auth_dest++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_combined(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.combined++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sym_failed(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.sym_failed++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_modexp_failed(rmisec_stats_pt stats,
+		int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.modexp_failed++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+#endif /* _PHXDRV_H_ */
Index: linux-2.6.10/include/asm-mips/rmi/phxsec.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/phxsec.h
@@ -0,0 +1,643 @@
+/*
+ * Copyright (C) 2003 Raza Foundries
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef _PHXSEC_H_
+#define _PHXSEC_H_
+
+
+/* 
+ *  Wrapper OS types.
+ */
+#ifndef OS_DeviceInfo_t
+#define OS_DeviceInfo_t void *
+#endif
+
+#ifndef OS_MemHandle_t
+#define OS_MemHandle_t uint64_t 
+#endif
+
+#ifdef __KERNEL__
+
+#include <linux/completion.h>
+
+#ifndef OS_ALLOC_KERNEL
+#include <linux/gfp.h>
+#define OS_ALLOC_KERNEL(size) kmalloc((size), GFP_KERNEL)
+#endif
+
+#ifndef OS_FREE
+#define OS_FREE(mem) kfree((mem))
+#endif
+
+#ifndef OS_SEMAPHORE_INIT
+#define OS_SEMAPHORE_INIT(sema) sema_init((sema),0)
+#endif
+
+#ifndef OS_SEMAPHORE_GET
+#define OS_SEMAPHORE_GET(sema) down_interruptible((sema))
+#endif
+
+#ifndef OS_SEMAPHORE_SET
+#define OS_SEMAPHORE_SET(sema) up((sema))
+#endif
+
+
+#ifndef OS_WAIT_INIT
+#define OS_WAIT_INIT(event) init_completion((event))
+#endif
+
+#ifndef OS_WAIT
+#define OS_WAIT(event) wait_for_completion((event))
+#endif
+
+#ifndef OS_WAIT_END
+#define OS_WAIT_END(event) complete((event))
+#endif
+
+#ifndef OS_WAIT_US
+#include <asm/delay.h>
+#define OS_WAIT_US(us) udelay((us))
+#endif
+
+#endif /* __KERNEL__ */
+
+/* 
+ * Version of the device library
+ */
+#define PHXSEC_VERSION_MAJOR 0x1
+#define PHXSEC_VERSION_MINOR 0x0
+/* Single alphanumeric character, start with blank, then a,b,c... */
+#define PHXSEC_VERSION_REV   ' '  
+
+/*
+ * Cryptographic parameter definitions
+ */
+#define PHXSEC_DES_KEY_LENGTH        8  /* Bytes */
+#define PHXSEC_3DES_KEY_LENGTH       24 /* Bytes */
+#define PHXSEC_AES128_KEY_LENGTH     16 /* Bytes */
+#define PHXSEC_AES192_KEY_LENGTH     24 /* Bytes */
+#define PHXSEC_AES256_KEY_LENGTH     32 /* Bytes */
+#define PHXSEC_MAX_CRYPT_KEY_LENGTH  PHXSEC_AES256_KEY_LENGTH
+
+#define PHXSEC_DES_IV_LENGTH         8  /* Bytes */
+#define PHXSEC_AES_IV_LENGTH         16 /* Bytes */
+#ifdef B0
+#define PHXSEC_ARC4_IV_LENGTH        0  /* Bytes */
+#endif /* B0 */
+#define PHXSEC_MAX_IV_LENGTH         16 /* Bytes */
+#define PHXSEC_IV_LENGTH_BYTES       8  /* Bytes */
+
+#define PHXSEC_AES_BLOCK_SIZE        16 /* Bytes */
+#define PHXSEC_DES_BLOCK_SIZE        8  /* Bytes */
+#define PHXSEC_3DES_BLOCK_SIZE       8  /* Bytes */
+
+#define PHXSEC_MD5_BLOCK_SIZE        64 /* Bytes */
+#define PHXSEC_SHA1_BLOCK_SIZE       64 /* Bytes */
+#define PHXSEC_SHA256_BLOCK_SIZE     64 /* Bytes */
+#define PHXSEC_MAX_BLOCK_SIZE        64 /* Max of MD5/SHA */
+#define PHXSEC_MD5_LENGTH            16 /* Bytes */
+#define PHXSEC_SHA1_LENGTH           20 /* Bytes */
+#define PHXSEC_SHA256_LENGTH         32 /* Bytes */
+#define PHXSEC_HMAC_LENGTH           32 /* Max of MD5/SHA */
+#ifdef B0
+#define PHXSEC_MAX_RC4_STATE_SIZE    264 /* char s[256], int i, int j */
+#endif /* B0 */
+
+
+/* Status code is used by the SRL to indicate status */
+typedef long phxsec_status_t;
+
+/*
+ * Status codes
+ */
+#define PHXSEC_STATUS_SUCCESS              0
+#define PHXSEC_STATUS_NO_DEVICE           -1
+#define PHXSEC_STATUS_TIMEOUT             -2
+#define PHXSEC_STATUS_INVALID_PARAMETER   -3
+#define PHXSEC_STATUS_DEVICE_FAILED       -4
+#define PHXSEC_STATUS_DEVICE_BUSY         -5
+#define PHXSEC_STATUS_NO_RESOURCE         -6
+#define PHXSEC_STATUS_CANCELLED           -7
+
+
+/* Error code is used to indicate any errors */
+typedef long phxsec_error_t;
+
+/*
+ */
+#define PHXSEC_ERR_NONE                    0
+#define PHXSEC_ERR_CIPHER_OP              -1
+#define PHXSEC_ERR_CIPHER_TYPE            -2
+#define PHXSEC_ERR_CIPHER_MODE            -3
+#define PHXSEC_ERR_CIPHER_INIT            -4
+#define PHXSEC_ERR_DIGEST_TYPE            -5
+#define PHXSEC_ERR_DIGEST_INIT            -6
+#define PHXSEC_ERR_DIGEST_SRC             -7
+#define PHXSEC_ERR_CKSUM_TYPE             -8
+#define PHXSEC_ERR_CKSUM_SRC              -9
+#define PHXSEC_ERR_ALLOC                  -10
+#define PHXSEC_ERR_CONTROL_VECTOR         -11
+#define PHXSEC_ERR_LOADHMACKEY_MODE       -12
+#define PHXSEC_ERR_PADHASH_MODE           -13
+#define PHXSEC_ERR_HASHBYTES_MODE         -14
+#define PHXSEC_ERR_NEXT_MODE              -15
+#define PHXSEC_ERR_PKT_IV_MODE            -16
+#define PHXSEC_ERR_LASTWORD_MODE          -17
+#define PHXSEC_ERR_PUBKEY_OP              -18
+#define PHXSEC_ERR_SYMKEY_MSGSND          -19
+#define PHXSEC_ERR_PUBKEY_MSGSND          -20
+#define PHXSEC_ERR_SYMKEY_GETSEM          -21
+#define PHXSEC_ERR_PUBKEY_GETSEM          -22
+#define PHXSEC_ERR_SYMKEY_OP              -23
+
+
+/*
+ * Descriptor Vector quantities 
+ *  (helps to identify descriptor type per operation)
+ */
+#define PHX_VECTOR_CIPHER_DES             0x0001
+#define PHX_VECTOR_CIPHER_3DES            0x0002
+#define PHX_VECTOR_CIPHER_AES128          0x0004
+#define PHX_VECTOR_CIPHER_AES192          0x0008
+#define PHX_VECTOR_CIPHER_AES256          0x0010
+#ifdef B0
+#define PHX_VECTOR_CIPHER_ARC4            0x0020
+#endif /* B0 */
+#define PHX_VECTOR_CIPHER_AES             (PHX_VECTOR_CIPHER_AES128 | \
+		PHX_VECTOR_CIPHER_AES192 | \
+		PHX_VECTOR_CIPHER_AES256)
+#ifdef B0
+#define PHX_VECTOR_CIPHER                 (PHX_VECTOR_CIPHER_DES | \
+		PHX_VECTOR_CIPHER_3DES | \
+		PHX_VECTOR_CIPHER_AES128 | \
+		PHX_VECTOR_CIPHER_AES192 | \
+		PHX_VECTOR_CIPHER_AES256 | \
+		PHX_VECTOR_CIPHER_ARC4)
+#else /* B0 */
+
+#define PHX_VECTOR_CIPHER                 (PHX_VECTOR_CIPHER_DES | \
+		PHX_VECTOR_CIPHER_3DES | \
+		PHX_VECTOR_CIPHER_AES128 | \
+		PHX_VECTOR_CIPHER_AES192 | \
+		PHX_VECTOR_CIPHER_AES256)
+#endif /* B0 */
+
+#define PHX_VECTOR_HMAC                   0x0040
+#define PHX_VECTOR_MAC                    0x0080
+#define PHX_VECTOR_MODE_CTR_CFB           0x0100
+#define PHX_VECTOR_MODE_ECB_CBC_OFB       0x0200
+#define PHX_VECTOR_MODE_ECB_CBC           0x0400
+#ifdef B0
+#define PHX_VECTOR_STATE                  0x0800
+#endif /* B0 */
+
+
+#ifdef B0
+#define PHX_VECTOR_CIPHER_ARC4__HMAC  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC)
+#define PHX_VECTOR_CIPHER_ARC4__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_STATE)
+#define PHX_VECTOR_CIPHER_ARC4__HMAC__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC | PHX_VECTOR_STATE)
+#endif /* B0 */
+
+#define PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+
+
+
+
+	/*
+	 * Cipher Modes
+	 */
+	typedef enum {
+		PHX_CIPHER_MODE_NONE = 0,
+		PHX_CIPHER_MODE_PASS = 1,
+		PHX_CIPHER_MODE_ECB,
+		PHX_CIPHER_MODE_CBC, 
+		PHX_CIPHER_MODE_OFB,
+		PHX_CIPHER_MODE_CTR,
+		PHX_CIPHER_MODE_CFB
+	} PHX_CIPHER_MODE;
+
+typedef enum {
+	PHX_CIPHER_OP_NONE = 0,
+	PHX_CIPHER_OP_ENCRYPT = 1,
+	PHX_CIPHER_OP_DECRYPT
+} PHX_CIPHER_OP;
+
+typedef enum {
+	PHX_CIPHER_TYPE_UNSUPPORTED = -1,
+	PHX_CIPHER_TYPE_NONE = 0,
+	PHX_CIPHER_TYPE_DES,
+	PHX_CIPHER_TYPE_3DES,
+	PHX_CIPHER_TYPE_AES128,
+	PHX_CIPHER_TYPE_AES192,
+	PHX_CIPHER_TYPE_AES256,
+#ifdef B0
+	PHX_CIPHER_TYPE_ARC4
+#endif /* B0 */
+} PHX_CIPHER_TYPE;
+
+typedef enum {
+#ifdef B0
+	PHX_CIPHER_INIT_OK = 1,   /* Preserve old Keys */
+	PHX_CIPHER_INIT_NK        /*Load new Keys */
+#else /* B0 */
+		PHX_CIPHER_INIT_OVKM = 1, /*Preserve old IV/(Keys,NonceCFBMask)*/
+	PHX_CIPHER_INIT_NV_OKM,   /*Preserve old IV/(Keys,NonceCFBMask)*/
+	PHX_CIPHER_INIT_NKM_OV,   /*Load new Keys,NonceCFBMask use old IV*/
+	PHX_CIPHER_INIT_NVKM      /*Load new IV/(Keys,NonceCFBMask)*/
+#endif /* B0 */
+} PHX_CIPHER_INIT;
+
+
+/*
+ *  Hash Modes
+ */
+typedef enum {
+	PHX_DIGEST_TYPE_UNSUPPORTED = -1,
+	PHX_DIGEST_TYPE_NONE = 0,
+	PHX_DIGEST_TYPE_MD5,
+	PHX_DIGEST_TYPE_SHA1,
+	PHX_DIGEST_TYPE_SHA256,
+	PHX_DIGEST_TYPE_HMAC_MD5,
+	PHX_DIGEST_TYPE_HMAC_SHA1,
+	PHX_DIGEST_TYPE_HMAC_SHA256,
+	PHX_DIGEST_TYPE_HMAC_AES_CBC,
+	PHX_DIGEST_TYPE_HMAC_AES_XCBC
+} PHX_DIGEST_TYPE;
+
+typedef enum {
+	PHX_DIGEST_INIT_OLDKEY = 1, /* Preserve old key HMAC key stored in ID registers (moot if HASH.HMAC == 0) */
+	PHX_DIGEST_INIT_NEWKEY      /*Load new HMAC key from memory ctrl section to ID registers */
+} PHX_DIGEST_INIT;
+
+typedef enum {
+	PHX_DIGEST_SRC_DMA = 1, /* DMA channel */
+	PHX_DIGEST_SRC_CPHR     /*Cipher if word count exceeded Cipher_Offset; else DMA */
+} PHX_DIGEST_SRC;
+
+/*
+ *  Checksum Modes
+ */
+typedef enum {
+	PHX_CKSUM_TYPE_NOP = 1,
+	PHX_CKSUM_TYPE_IP
+} PHX_CKSUM_TYPE;
+
+typedef enum {
+	PHX_CKSUM_SRC_DMA    = 1,
+	PHX_CKSUM_SRC_CIPHER
+} PHX_CKSUM_SRC;
+
+
+/*
+ *  Packet Modes
+ */
+typedef enum {
+	PHX_LOADHMACKEY_MODE_OLD = 1,
+	PHX_LOADHMACKEY_MODE_LOAD
+} PHX_LOADHMACKEY_MODE;
+
+typedef enum {
+	PHX_PADHASH_PADDED = 1,
+	PHX_PADHASH_PAD
+} PHX_PADHASH_MODE;
+
+typedef enum {
+	PHX_HASHBYTES_ALL8 = 1,
+	PHX_HASHBYTES_MSB,
+	PHX_HASHBYTES_MSW
+} PHX_HASHBYTES_MODE;
+
+typedef enum {
+	PHX_NEXT_FINISH = 1,
+	PHX_NEXT_DO
+} PHX_NEXT_MODE;
+
+typedef enum {
+	PHX_PKT_IV_OLD = 1,
+	PHX_PKT_IV_NEW
+} PHX_PKT_IV_MODE;
+
+typedef enum {
+	PHX_LASTWORD_128 = 1,
+	PHX_LASTWORD_96MASK,
+	PHX_LASTWORD_64MASK,
+	PHX_LASTWORD_32MASK
+} PHX_LASTWORD_MODE;
+
+
+/*
+ *  Public Key
+ */
+typedef enum {
+	RMIPK_BLKWIDTH_512 = 1,
+	RMIPK_BLKWIDTH_1024 
+} RMIPK_BLKWIDTH_MODE;
+
+typedef enum {
+	RMIPK_LDCONST_OLD = 1,
+	RMIPK_LDCONST_NEW
+} RMIPK_LDCONST_MODE;
+
+
+/*
+ * Bulk encryption/decryption ioctl
+ */
+typedef struct phxsec_io_s {
+	uint32_t                  command;
+	uint32_t          result_status;
+	uint32_t          flags;
+	uint32_t          session_num;
+	uint32_t          use_callback;
+	uint32_t         time_us;
+	uint32_t         user_context[2];/*usable for anything by caller*/
+	uint32_t         command_context; /* Context (ID) of this command). */
+
+	unsigned char         initial_vector[PHXSEC_MAX_IV_LENGTH];
+	unsigned char         crypt_key[PHXSEC_MAX_CRYPT_KEY_LENGTH]; 
+	unsigned char         mac_key[PHXSEC_MAX_BLOCK_SIZE]; 
+
+	PHX_CIPHER_OP         cipher_op;
+	PHX_CIPHER_MODE       cipher_mode;
+	PHX_CIPHER_TYPE       cipher_type;
+	PHX_CIPHER_INIT       cipher_init;
+	uint32_t          cipher_offset;
+
+	PHX_DIGEST_TYPE       digest_type;
+	PHX_DIGEST_INIT       digest_init;
+	PHX_DIGEST_SRC        digest_src;
+	uint32_t          digest_offset;
+
+	PHX_CKSUM_TYPE        cksum_type;
+	PHX_CKSUM_SRC         cksum_src;
+	uint32_t          cksum_offset;
+
+	PHX_LOADHMACKEY_MODE  pkt_hmac;
+	PHX_PADHASH_MODE      pkt_hash;
+	PHX_HASHBYTES_MODE    pkt_hashbytes;
+	PHX_NEXT_MODE         pkt_next;
+	PHX_PKT_IV_MODE       pkt_iv;
+	PHX_LASTWORD_MODE     pkt_lastword;
+
+	uint32_t         nonce;
+	uint32_t          cfb_mask;
+
+	uint32_t          iv_offset;
+	uint16_t        pad_type;
+#ifdef B0
+	uint16_t        rc4_key_len;
+#endif /* B0 */
+
+	uint32_t          num_packets;
+	uint32_t          num_fragments;
+
+	uint64_t        source_buf;
+	uint32_t          source_buf_size;
+	uint64_t         dest_buf;
+	uint32_t          dest_buf_size;
+
+	uint64_t         auth_dest;
+	uint64_t        cksum_dest;
+
+#ifdef B0
+	uint16_t        rc4_loadstate;
+	uint16_t        rc4_savestate;
+	uint64_t         rc4_state;
+#endif /* B0 */
+
+} phxsec_io_t, *phxsec_io_pt;
+
+
+
+/*
+ * The long key type is used as a generic type to hold public
+ * key information.
+ * KeyValue points to an array of 32-bit integers. The convention of these keys
+ * is such that element[0] of this array holds the least significant part of
+ * the "bignum" (multi-precision integer).
+ * Keylength holds the number of significant bits in the key, i.e. the bit
+ * position of the most significant "1" bit, plus 1.
+ * For example, the multi-precision integer ("key")
+ *    0x0102030405060708090A0B0C0D0E0F00
+ * has 121 significant bits (KeyLength), and would be arranged in the N-element 
+ * array (pointed to by KeyLength) of 32-bit integers as
+ *    array[0] = 0x0D0E0F00
+ *    array[1] = 0x090A0B0C
+ *    array[2] = 0x05060708
+ *    array[3] = 0x01020304
+ *    array[4] = 0x00000000
+ *        ...
+ *    array[N-1] = 0x00000000
+ */
+typedef struct phxsec_LongKey_s {
+	unsigned long   KeyLength;	/* length in bits */
+	OS_MemHandle_t  KeyValue;	/* pointer to 32-bit integer "key" array */
+} phxsec_LongKey_t,*phxsec_LongKey_pt;
+
+
+
+/*
+ * The bignum type is used as a generic type to hold the multi-precision integer
+ * values used in public key calculations.
+ * bignum points to an array of 32-bit integers. The convention of these keys
+ * is such that element[0] of this array holds the least significant part of
+ * the "bignum".
+ * bignum_length holds the number of significant bits in the key, i.e. the bit
+ * position of the most significant "1" bit, plus 1.
+ * For example, the multi-precision integer ("bignum")
+ *    0x0102030405060708090A0B0C0D0E0F00
+ * has 121 significant bits (bignum_length), 
+ *  and would be arranged in the N-element  array 
+ *  (pointed to by bignum) of 32-bit integers as
+ *    array[0] = 0x0D0E0F00
+ *    array[1] = 0x090A0B0C
+ *    array[2] = 0x05060708
+ *    array[3] = 0x01020304
+ *    array[4] = 0x00000000
+ *        ...
+ *    array[N-1] = 0x00000000
+ */
+typedef struct phxsec_bignum_s {
+	uint32_t   bignum_length;   /* length in bits */
+	OS_MemHandle_t  bignum;          /* pointer to 32-bit integer array */
+} phxsec_bignum_t,*phxsec_bignum_pt;
+
+
+/*
+ * Diffie-Hellman parameter type definition.
+ */
+typedef struct phxsec_DH_Params_t {
+	phxsec_bignum_t Y;		/* Public value, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t X;		/* Secret value, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t K;		/* Shared secret value, out (PHXSEC_DH_SHARED) */
+	phxsec_bignum_t N;   		/* Modulus, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t G;	  	/* Generator, in (PHXSEC_DH_PUBLIC) */
+} phxsec_DH_op_t,*phxsec_DH_op_pt;
+
+
+/*
+ * RSA parameter type definition.
+ */
+typedef struct phxsec_RSA_Params_t {
+	uint64_t   data_in;    /* InputKeyInfo - Input data. */
+	uint64_t   data_out;   /* OutputKeyInfo - Output data. */
+	uint16_t  data_in_len; 
+	uint16_t  data_out_len; 
+	phxsec_bignum_t constant;   /* RMI: Montgomery Product */
+	phxsec_bignum_t modulus;    /* ModN - Modulo N value to be applied */
+	phxsec_bignum_t exponent;   /* ExpE - BaseG value to be applied. */
+} phxsec_RSA_op_t, *phxsec_RSA_op_pt;
+
+
+typedef enum {
+	PHX_PUBKEY_DH_PUBLIC = 1,
+	PHX_PUBKEY_DH_SHARED,
+	PHX_PUBKEY_RSA_PUBLIC,
+	PHX_PUBKEY_RSA_PRIVATE
+} PHX_PUBKEY_CMD;
+
+
+/* 
+ * Generic key command parameters
+ */
+typedef union phxsec_pubkey_u {
+	phxsec_DH_op_t  DH_params;   /* DH parameters  */
+	phxsec_RSA_op_t RSA_params;  /* RSA Parameters */
+} phxsec_pubkey_t;
+typedef  phxsec_pubkey_t *phxsec_pubkey_pt;
+
+
+/*
+ * Key setup ioctl
+ */
+typedef struct phxsec_key_io_s {
+	uint32_t                command;
+	uint32_t        result_status;
+	uint32_t       command_context; /* Context (ID) of this command). */
+	uint32_t      time_us;
+	uint32_t       user_context[2]; /* usable for anything by caller */
+	phxsec_pubkey_t     key;
+} phxsec_key_io_t;
+typedef phxsec_key_io_t *phxsec_key_io_pt;
+
+
+/*
+ * PHXDRV Statistics information contains all statistics 
+ * maintained by the driver.
+ */
+/*
+   typedef struct phxsec_Statistics_s {
+   unsigned long BlocksEncryptedCount;
+   unsigned long BlocksDecryptedCount;
+   unsigned long BytesEncryptedCount;
+   unsigned long BytesDecryptedCount;
+   unsigned long CryptoFailedCount;
+   unsigned long DHPublicCount;
+   unsigned long DHSharedCount;
+   unsigned long RSAPublicCount;
+   unsigned long RSAPrivateCount;
+   unsigned long DMAErrorCount;
+   } phxsec_Statistics_t, *phxsec_Statistics_pt;
+ */
+
+
+int phxsec_cipherdigestuserop(void *ctx, phxsec_io_pt op);
+int phxsec_publickeyuserop(void *ctx,  phxsec_key_io_pt op);
+
+/* this initializes CryptoAPI interface */
+int phxcrypto_init(void *ctx);
+
+/* these functions are used by the CryptoAPI to alloc/dealloc descriptors */
+void *phxsec_AllocateDescriptor(void *ctx);
+int phxsec_FreeDescriptor(void *ctx, void *desc);
+
+/* this is used by the CryptoAPI to fill in descriptors */
+phxsec_error_t phxsec_FillDescriptor(phxsec_io_pt op, void *desc, unsigned int *cfg_vector);
+
+/* this is passed to packet setup to optimize */
+#define PHX_SETUP_OP_CIPHER              0x00000001
+#define PHX_SETUP_OP_HMAC                0x00000002
+#define PHX_SETUP_OP_CIPHER_HMAC         (PHX_SETUP_OP_CIPHER | PHX_SETUP_OP_HMAC)
+/* this is passed to control_setup to update w/preserving existing keys */
+#define PHX_SETUP_OP_PRESERVE_HMAC_KEY    0x80000000
+#define PHX_SETUP_OP_PRESERVE_CIPHER_KEY  0x40000000
+#define PHX_SETUP_OP_UPDATE_KEYS          0x00000010
+#define PHX_SETUP_OP_FLIP_3DES_KEY        0x00000020
+
+/* this sets up per-packet descriptor */
+phxsec_error_t phxsec_SetupDescriptor(phxsec_io_pt op, unsigned int flags,
+		void *desc,
+		unsigned int vector);
+
+/* this processes the packet */
+int phxsec_ProcessPacket(void *ctx, void *desc, unsigned int cfg_vector);
+
+/* debugging function */
+void phxsec_DecodeDescriptor (void *desc, unsigned int cfg_vector);
+
+#endif /* _PHXSEC_H_ */
Index: linux-2.6.10/include/asm-mips/rmi/pic.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/pic.h
@@ -0,0 +1,200 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+#ifndef _ASM_RMI_PIC_H
+#define _ASM_RMI_PIC_H
+
+#include <asm/rmi/iomap.h>
+
+/**************************************************************/
+#define PIC_IRT_WD_INDEX     0
+#define PIC_IRT_TIMER_0_INDEX      1
+#define PIC_IRT_TIMER_1_INDEX      2
+#define PIC_IRT_TIMER_2_INDEX      3
+#define PIC_IRT_TIMER_3_INDEX      4
+#define PIC_IRT_TIMER_4_INDEX      5
+#define PIC_IRT_TIMER_5_INDEX      6
+#define PIC_IRT_TIMER_6_INDEX      7
+#define PIC_IRT_TIMER_7_INDEX      8
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_UART_0_INDEX       9
+#define PIC_IRT_UART_1_INDEX       10
+#define PIC_IRT_I2C_0_INDEX       11
+#define PIC_IRT_I2C_1_INDEX       12
+#define PIC_IRT_PCMCIA_INDEX           13
+#define PIC_IRT_GPIO_INDEX             14
+#define PIC_IRT_HYPER_INDEX            15
+#define PIC_IRT_PCIX_INDEX             16
+#define PIC_IRT_GMAC0_INDEX            17
+#define PIC_IRT_GMAC1_INDEX            18
+#define PIC_IRT_GMAC2_INDEX            19
+#define PIC_IRT_GMAC3_INDEX            20
+#define PIC_IRT_XGS0_INDEX             21
+#define PIC_IRT_XGS1_INDEX             22
+#define PIC_IRT_HYPER_FATAL_INDEX      23
+#define PIC_IRT_PCIX_FATAL_INDEX       24
+#define PIC_IRT_BRIDGE_AERR_INDEX      25
+#define PIC_IRT_BRIDGE_BERR_INDEX     26
+#define PIC_IRT_BRIDGE_TB_INDEX        27
+#define PIC_IRT_BRIDGE_AERR_NMI_INDEX  28
+#define PIC_NUM_IRTS                   32
+
+#define PIC_SYS_TIMER_MAXVAL_0_BASE 0x100
+#define PIC_SYS_TIMER_MAXVAL_1_BASE 0x110
+
+#define PIC_SYS_TIMER_0_BASE 0x120
+#define PIC_SYS_TIMER_1_BASE 0x130
+
+#define PIC_CLOCK_TIMER 7
+
+#define PIC_CTRL    0x00
+#define PIC_IPI     0x04
+#define PIC_INT_ACK 0x06
+
+#define WD_MAX_VAL_0 0x08
+#define WD_MAX_VAL_1 0x09
+#define WD_MASK_0    0x0a
+#define WD_MASK_1    0x0b
+#define WD_HEARBEAT_0 0x0c
+#define WD_HEARBEAT_1 0x0d
+
+#define PIC_IRT_0_BASE 0x40
+#define PIC_IRT_1_BASE 0x80
+
+#define PIC_IRT_0_WD     (PIC_IRT_0_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_1_WD     (PIC_IRT_1_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_0_TIMER_0     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_1_TIMER_0     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_0_TIMER_1     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_1_TIMER_1     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_0_TIMER_2     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_1_TIMER_2     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_0_TIMER_3     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_1_TIMER_3     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_0_TIMER_4     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_1_TIMER_4     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_0_TIMER_5     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_1_TIMER_5     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_0_TIMER_6     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_1_TIMER_6     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_0_TIMER_7     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_1_TIMER_7     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_0_CLOCK       (PIC_IRT_0_TIMER_7)
+#define PIC_IRT_1_CLOCK       (PIC_IRT_1_TIMER_7)
+#define PIC_IRT_0_UART_0 (PIC_IRT_0_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_1_UART_0 (PIC_IRT_1_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_0_UART_1 (PIC_IRT_0_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_1_UART_1 (PIC_IRT_1_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_0_I2C_0 (PIC_IRT_0_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_1_I2C_0 (PIC_IRT_1_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_0_I2C_1 (PIC_IRT_0_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_IRT_1_I2C_1 (PIC_IRT_1_BASE + PIC_IRT_I2C_1_INDEX)
+
+#define PIC_TIMER_0_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 0)
+#define PIC_TIMER_0_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 0)
+#define PIC_TIMER_0_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 0)
+#define PIC_TIMER_0_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 0)
+#define PIC_TIMER_7_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 7)
+#define PIC_TIMER_7_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 7)
+#define PIC_TIMER_7_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 7)
+#define PIC_TIMER_7_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 7)
+
+#define PIC_IRQ_BASE      8
+#define PIC_IRT_FIRST_IRQ PIC_IRQ_BASE
+#define PIC_WD_IRQ      (PIC_IRQ_BASE + PIC_IRT_WD_INDEX)
+#define PIC_TIMER_0_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ   (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_UART_1_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_I2C_0_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_PCMCIA_IRQ           (PIC_IRQ_BASE + PIC_IRT_PCMCIA_INDEX)
+#define PIC_GPIO_IRQ             (PIC_IRQ_BASE + PIC_IRT_GPIO_INDEX)
+#define PIC_HYPER_IRQ            (PIC_IRQ_BASE + PIC_IRT_HYPER_INDEX)
+#define PIC_PCIX_IRQ             (PIC_IRQ_BASE + PIC_IRT_PCIX_INDEX)
+#define PIC_GMAC_0_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC0_INDEX)
+#define PIC_GMAC_1_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC1_INDEX)
+#define PIC_GMAC_2_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC2_INDEX)
+#define PIC_GMAC_3_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC3_INDEX)
+#define PIC_XGS_0_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS0_INDEX)
+#define PIC_XGS_1_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS1_INDEX)
+#define PIC_HYPER_FATAL_IRQ      (PIC_IRQ_BASE + PIC_IRT_HYPER_FATAL_INDEX)
+#define PIC_PCIX_FATAL_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIX_FATAL_INDEX)
+#define PIC_BRIDGE_AERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_INDEX)
+#define PIC_BRIDGE_BERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_BERR_INDEX)
+#define PIC_BRIDGE_TB_IRQ        (PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_INDEX)
+#define PIC_BRIDGE_AERR_NMI_IRQ  (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_NMI_INDEX)
+#define PIC_IRT_LAST_IRQ  PIC_BRIDGE_AERR_NMI_IRQ
+
+/***************************************************************/
+
+/**************************************************************/
+/***************************************************************/
+#ifndef __ASSEMBLY__
+static __inline__ void pic_send_ipi(__u32 ipi)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_IPI, ipi);
+}
+
+static __inline__ __u32 pic_read_control(void)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  return phoenix_read_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void pic_write_control(__u32 control)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_CTRL, control);
+}
+static __inline__ void pic_update_control(__u32 control)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_CTRL, (control | phoenix_read_reg(mmio, PIC_CTRL)));
+}
+
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) \
+		( ((irq)>=PIC_TIMER_0_IRQ) && ((irq)<=PIC_TIMER_7_IRQ) )
+
+#define PIC_IRQ_IS_IRT(irq) \
+		( ((irq)>=PIC_IRT_FIRST_IRQ) && ((irq)<=PIC_IRT_LAST_IRQ) )
+
+#define PIC_PCMCIA_STATUS_1	0xffffffffBD0001f7
+#define PIC_PCMCIA_STATUS_2	0xffffffffBEF19180
+
+struct pt_regs;
+extern void phoenix_ipi_handler(int irq, struct pt_regs *regs);
+extern void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
+
+#endif
+
+#endif
Index: linux-2.6.10/include/asm-mips/rmi/rmios_user_mac.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/rmios_user_mac.h
@@ -0,0 +1,34 @@
+#ifndef _ASM_RMI_RMIOS_USER_MAC_H
+#define _ASM_RMI_RMIOS_USER_MAC_H
+
+#define RMIOS_USER_MAC_BUCKET 4
+
+#define RMIOS_USER_MAC_PERF_EVT_0            0
+#define RMIOS_USER_MAC_PERF_EVT_1            1
+#define RMIOS_USER_MAC_PERF_TOTAL_PKTS       2
+#define RMIOS_USER_MAC_PERF_DROPPED_PKTS     3
+#define RMIOS_USER_MAC_PERF_RX_TIMEOUT       4
+#define RMIOS_USER_MAC_PERF_NUM_CTRS         5
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+
+extern __u64 rmios_user_mac_perf_ctrs[32][RMIOS_USER_MAC_PERF_NUM_CTRS];
+
+extern int rmios_user_mac_balance_num_flows;
+
+#define RMIOS_USER_MAC_RX_TIMEOUT 672
+
+extern __u32 rmios_user_mac_rx_timeout[32];
+
+extern int rmios_user_mac_perf;
+extern int rmios_user_mac_perf_q_thr;
+extern int rmios_user_mac_perf_global;
+extern int rmios_user_mac_perf_evt_0;
+extern int rmios_user_mac_perf_evt_1;
+
+extern void rmios_user_mac_init(void);
+#endif
+
+#endif /* _ASM_RMI_RMIOS_USER_MAC_H */
Index: linux-2.6.10/include/asm-mips/rmi/rmisec.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/rmisec.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2003 Raza Foundries
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#define RMI_SECENG_DEV_ID     4444
+#define RMI_SECENG_IRQ        0
+
+#define RMI_MAX_DESCRIPTORS   20
+
+
+typedef struct device_info_s {
+	void               *context;
+	void               *completion_handler;
+	struct semaphore   dev_sem;
+	volatile uint32_t  dev_status;
+	uint32_t           dev_features;
+} dev_info_t, *dev_info_pt;
+
+
+
+
Index: linux-2.6.10/include/asm-mips/rmi/sim.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/rmi/sim.h
@@ -0,0 +1,249 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+
+
+#ifndef _ASM_SIM_H
+#define _ASM_SIM_H
+
+#include <linux/types.h>
+#include <asm/cpu.h>
+
+
+#ifdef CONFIG_PHOENIX_PSB
+
+#define RMI_PHOENIX_BOARD_ARIZONA_I   1
+#define RMI_PHOENIX_BOARD_ARIZONA_II  2
+#define RMI_PHOENIX_BOARD_ARIZONA_III 3
+
+
+#define PSB_INFO_VERSION 0x0001
+
+struct psb_info {
+  uint64_t boot_level;
+  uint64_t io_base;
+  uint64_t output_device;
+  uint64_t uart_print;
+  uint64_t led_output;
+  uint64_t init;
+  uint64_t exit;
+  uint64_t warm_reset;
+  uint64_t wakeup;
+  uint64_t cpu_online_map;
+  uint64_t master_reentry_sp;
+  uint64_t master_reentry_gp;
+  uint64_t master_reentry_fn;
+  uint64_t slave_reentry_fn;
+  uint64_t magic_dword;
+  uint64_t uart_putchar;
+  uint64_t size;
+  uint64_t uart_getchar;
+  uint64_t nmi_handler;
+  uint64_t psb_version;
+  uint64_t mac_addr;
+  uint64_t cpu_frequency;
+  uint64_t board_version;
+  uint64_t malloc;
+  uint64_t free;
+  uint64_t alloc_pbuf;
+  uint64_t free_pbuf;
+  uint64_t psb_os_cpu_map;
+  uint64_t userapp_cpu_map;
+  uint64_t wakeup_os;
+  uint64_t psb_mem_map;
+  uint64_t board_major_version;
+  uint64_t board_minor_version;
+  uint64_t board_manf_revision;
+  uint64_t board_serial_number;
+};
+
+struct boot1_info {
+  uint64_t boot_level;
+  uint64_t io_base;
+  uint64_t output_device;
+  uint64_t uart_print;
+  uint64_t led_output;
+  uint64_t init;
+  uint64_t exit;
+  uint64_t warm_reset;
+  uint64_t wakeup;
+  uint64_t cpu_online_map;
+  uint64_t master_reentry_sp;
+  uint64_t master_reentry_gp;
+  uint64_t master_reentry_fn;
+  uint64_t slave_reentry_fn;
+  uint64_t magic_dword;
+  uint64_t uart_putchar;  
+  uint64_t size;
+  uint64_t uart_getchar;
+  uint64_t nmi_handler;
+  uint64_t psb_version;
+  uint64_t mac_addr;
+  uint64_t cpu_frequency;
+  uint64_t board_version;
+  uint64_t malloc;
+  uint64_t free;
+  uint64_t alloc_pbuf;
+  uint64_t free_pbuf;
+  uint64_t psb_os_cpu_map;
+  uint64_t userapp_cpu_map;
+  uint64_t wakeup_os;
+  uint64_t psb_mem_map;
+};
+
+extern struct psb_info *prom_info;
+
+struct smp_boot_info_percpu {
+  volatile unsigned long ready;
+  volatile unsigned long sp;
+  volatile unsigned long gp;
+  volatile unsigned long fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_percpu boot_info[32];
+  __u32 online_map;
+};
+
+#define PSB_MEM_MAP_MAX 32
+struct psb_mem_map {
+	int nr_map;
+	struct psb_mem_map_entry {
+		uint64_t addr;    /* start of memory segment */
+		uint64_t size;    /* size of memory segment */
+		uint32_t type;      /* type of memory segment */
+	} map[PSB_MEM_MAP_MAX];
+};
+
+extern struct smp_boot_info smp_boot;
+extern void prom_boot_cpus_secondary(void *);
+
+static __inline__ int xlr_revision_a0(void)
+{
+	return (read_c0_prid() & 0xffffff) == PRID_COMP_RMI;
+}
+
+static __inline__ int xlr_board_atx_i(void)
+{
+	return prom_info->board_major_version == RMI_PHOENIX_BOARD_ARIZONA_I;
+}
+
+static __inline__ int xlr_board_atx_ii(void)
+{
+	return prom_info->board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II;
+}
+
+static __inline__ int xlr_board_atx_iii(void)
+{
+	return prom_info->board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III;
+}
+
+static __inline__ int xlr_board_atx_iii_256(void)
+{
+	return (prom_info->board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (prom_info->board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iii_512(void)
+{
+	return (prom_info->board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (prom_info->board_minor_version == 1);
+}
+#define XLR_HYBRID_NONE              0
+#define XLR_HYBRID_USER_MAC          1
+#define XLR_HYBRID_RMIOS_IPSEC       2
+#define XLR_HYBRID_USER_SPACE_KERNEL 3
+
+extern int xlr_hybrid;
+
+static __inline__ int xlr_hybrid_user_mac(void)
+{
+	return xlr_hybrid == XLR_HYBRID_USER_MAC;
+}
+
+static __inline__ int xlr_hybrid_none(void)
+{
+	return xlr_hybrid == XLR_HYBRID_NONE;
+}
+
+
+#else
+
+/* structures and addresses shared with the RMI's 
+ * Architectural Simulator
+ */
+
+/* Address of the simulator control structure */
+#define SIMINFO_ADDR         0xFFFFFFFF9F400000
+
+struct sim_control_struct {
+  volatile char               putchar;
+  volatile char               getchar;
+  volatile char               uart_status;
+  volatile char               getchar_cpunum;
+  volatile unsigned long      time;
+  volatile unsigned long long ipi;
+  volatile char               putsocket;
+  volatile char               getsocket;
+  volatile char               socket_status;
+  volatile char               socket_cpunum;
+  volatile char               cache_disable;
+  volatile char               shutdown;
+};
+
+extern volatile struct sim_control_struct   *siminfo;
+
+#define BOOT_CPU_MAP_ADDR    0x9f501000
+#define UART_RX_RDY 0x1
+#define UART_ENABLE 0x80
+
+static __inline__ void shutdown(void)
+{
+  siminfo->shutdown = 1;
+}
+
+
+struct smp_boot_info_struct {
+  volatile __u32 ready;
+  volatile __u32 sp;
+  volatile __u32 gp;
+  volatile __u32 fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_struct start[64];
+  unsigned long online_map;
+};
+
+extern volatile struct smp_boot_info_struct *smp_boot_info;
+
+/* Addresses at which the Slave cpus read their sp, gp and 
+ * start function
+ */
+#define BOOT_CPU_INFO_ADDR   0xFFFFFFFF9F500000
+
+#endif
+
+
+
+#endif
Index: linux-2.6.10/include/linux/i2c-algo-palm.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/i2c-algo-palm.h
@@ -0,0 +1,39 @@
+/*
+ *
+ * Copyright  2005 Raza Microelectronics, Inc. (.RMI.)
+ *
+ * This program is free software.  You may use it, redistribute it 
+ * and/or modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version two of the 
+ * License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that you will find it useful.  
+ * Notwithstanding the foregoing, you understand and agree that this program 
+ * is provided by RMI .as is,. and without any warranties, whether express, 
+ * implied or statutory, including without limitation any implied warranty of 
+ * non-infringement, merchantability or fitness for a particular purpose.  
+ * In no event will RMI be liable for any loss of data, lost profits, cost 
+ * of procurement of substitute technology or services or for any direct, 
+ * indirect, incidental, consequential or special damages arising from the 
+ * use of this program, however caused.  Your unconditional agreement to 
+ * these terms and conditions is an express condition to, and shall be deemed 
+ * to occur upon, your use, redistribution and/or modification of this program.
+ *
+ * See the GNU General Public License for more details.  
+ */
+#ifndef _LINUX_I2C_ALGO_PALM_H
+#define _LINUX_I2C_ALGO_PALM_H
+
+#define WORD	1
+
+struct i2c_algo_palm_data {
+	void (*write)(int ctl, int val);
+	unsigned int  (*read) (int ctl);
+};
+
+#define I2C_PCA_ADAP_MAX	16
+
+int i2c_palm_add_bus(struct i2c_adapter *);
+int i2c_palm_del_bus(struct i2c_adapter *);
+
+#endif /* _LINUX_I2C_ALGO_PALM_H */
Index: linux-2.6.10/include/linux/i2c-id.h
===================================================================
--- linux-2.6.10.orig/include/linux/i2c-id.h
+++ linux-2.6.10/include/linux/i2c-id.h
@@ -269,6 +269,9 @@
 /* --- SGI adapters							*/
 #define I2C_HW_SGI_VINO	0x00
 #define I2C_HW_SGI_MACE	0x01
+
+/* PALMCHIP */
+#define I2C_HW_PALM_BK3220	0x170000
  
 /* --- XSCALE on-chip adapters                          */
 #define I2C_HW_IOP3XX 0x00
Index: linux-2.6.10/include/linux/phnx_tb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/phnx_tb.h
@@ -0,0 +1,143 @@
+#ifndef __USER_MIPS_RMI_PHNXTB_H
+#define __USER_MIPS_RMI_PHNXTB_H
+
+#include <asm/ioctl.h>
+
+/* Trace Buffer registers */
+
+#define    TB_REQMATCH_REGS         0x00
+#define    TB_REQMATCH_REG_1        0x00
+#define    TB_REQMATCH_REG_2        0x01
+#define    TB_RADDR_REGS            0x02
+#define    TB_RADDR_REG_1           0x02
+#define    TB_RADDR_REG_2           0x03
+#define    TB_CTRL_REG              0x04
+#define    TB_INIT_REG              0x05
+#define    TB_ACCESS_REG            0x06
+#define    TB_RDDATA_REGS           0x07
+#define    TB_WRDATA_REGS           0x0b
+#define    TB_STATUS_REG            0x0f
+
+// values
+#define    TB_REQMATCH_RCMD_WR             0x01
+#define    TB_REQMATCH_RCMD_RD             0x02
+#define    TB_REQMATCH_RCMD_RDEX           0x03
+#define    TB_REQMATCH_RCMD_UPGRD          0x04
+#define    TB_REQMATCH_RCMD_INV            0x05
+#define    TB_REQMATCH_RCMD_MASK           0x00000007
+#define    TB_SET_RCMD(reg, val)    \
+               reg |= (val & TB_REQMATCH_RCMD_MASK)
+#define    TB_GET_RCMD(reg) \
+               (reg & TB_REQMATCH_RCMD_MASK)
+
+// Node ID
+#define    TB_REQMATCH_RCONNID_SHIFT       4 
+#define    TB_REQMATCH_RCONNID_MASK        0x0000001f
+#define    TB_SET_RCONNID(reg, nodeId)     \
+                reg |= (nodeId & TB_REQMATCH_RCONNID_MASK) << TB_REQMATCH_RCONNID_SHIFT
+#define    TB_GET_RCONNID(reg) \
+                ((reg >> TB_REQMATCH_RCONNID_SHIFT) & TB_REQMATCH_RCONNID_MASK)
+
+// Transaction ID
+#define    TB_REQMATCH_RTHREADID_SHIFT     12
+#define    TB_REQMATCH_RTHREADID_MASK      0x0000008f
+#define    TB_SET_REQMATCH_RTHREADID(reg, transId)    \
+               reg |= (transId & TB_REQMATCH_RTHREADID_MASK) << TB_REQMATCH_RTHREADID_SHIFT
+#define    TB_GET_REQMATCH_RTHREADID(reg) \
+               ((reg >> TB_REQMATCH_RTHREADID_SHIFT) & TB_REQMATCH_RTHREADID_MASK)
+
+// Snoop Status
+#define    TB_REQMATCH_SSTAT
+#define    TB_REQMATCH_SSTAT_BRIDGE            0x00100000
+#define    TB_REQMATCH_SSTAT_L1TAG             0x00200000
+#define    TB_REQMATCH_SSTAT_L2CTAG            0x00400000
+#define    TB_REQMATCH_SSTAT_L2UCTAG           0x00800000
+
+#define    TB_SET_REQMATCH_SSTAT(x, val)       x |= val
+#define    TB_IS_SET_REQMATCH_SSTAT(x, val)    (x & val)
+
+// Cacheable?
+#define    TB_REQMATCH_RCACHE              0x01000000
+#define    TB_SET_REQMATCH_CACHEABLE(x)    x |=  TB_REQMATCH_RCACHE
+#define    TB_IS_REQMATCH_CACHEABLE(x)     (x & TB_REQMATCH_RCACHE)
+
+// Node ID of Hit
+#define    TB_REQMATCH_RSPHITID_MASK       0x0000001f
+#define    TB_SET_REQMATCH_RSPHITID(reg, hitNodeId)    \
+               reg |= (hitNodeId & TB_REQMATCH_RSPHITID_MASK)
+#define    TB_GET_REQMATCH_RSPHITID(reg) (reg & TB_REQMATCH_RSPHITID_MASK)
+
+// Snoop Result Status
+#define    TB_REQMATCH_SRSLT_CPUSHR            0x00000100
+#define    TB_REQMATCH_SRSLT_CPUMOD            0x00000200
+#define    TB_REQMATCH_SRSLT_L2SHR             0x00000400
+#define    TB_REQMATCH_SRSLT_L2MODE            0x00000800
+
+#define    TB_SET_REQMATCH_SRSLT(x, val)       x |= val
+#define    TB_IS_SET_REQMATCH_SRSLT(x,val)     (x & val)
+
+#define    TB_CTRL_RCMD                    0x0001
+#define    TB_CTRL_RCONNID                 0x0002
+#define    TB_CTRL_RTHREADID               0x0004
+#define    TB_CTRL_SSTAT                   0x0008
+#define    TB_CTRL_RCACHE                  0x0010
+#define    TB_CTRL_SRSPHITID               0x0020
+#define    TB_CTRL_SRSLT                   0x0040
+#define    TB_CTRL_RADDR                   0x0080
+#define    TB_CTRL_COLLMODE_MATCHONLY      0x0100
+
+#define    TB_SET_CTRL(x, flag)            x |= flag
+#define    TB_IS_SET_CTRL(x, flag)         (x & flag)
+
+#define    TB_CTRL_REQCNT_SHIFT            16
+#define    TB_CTRL_REQCNT_MASK             0x000000ff
+#define    TB_SET_CTRL_REQCNT(reg, cnt)    \
+               reg |= ((cnt & TB_CTRL_REQCNT_MASK) << TB_CTRL_REQCNT_SHIFT)
+#define    TB_GET_CTRL_REQCNT(reg) \
+               ((reg >> TB_CTRL_REQCNT_SHIFT) & TB_CTRL_REQCNT_MASK)
+
+#define    TB_CTRL_DISABLE                 0x01000000
+#define    TB_SET_CTRL_DISABLE(x)          x |= TB_CTRL_DISABLE
+#define    TB_IS_CTRL_DISABLED(x)          (x & TB_CTRL_DISABLE)
+
+#define    TB_EMPTY              0x01
+#define    TB_FULL               0x02
+#define    TB_COLLECTS_BMATCH    0x10
+#define    TB_COLLECTS_AMATCH    0x20
+#define    TB_STATUS_DONE        0x40
+#define    TB_DISABLED           0x80
+
+#define    TB_IS_EMPTY(x)              (x & TB_EMPTY)
+#define    TB_IS_FULL(x)               (x & TB_FULL)
+#define    TB_IS_COLLECTS_BMATCH(x)    (x & TB_COLLECTS_BMATCH)
+#define    TB_IS_COLLECTS_AMATCH(x)    (x & TB_COLLECTS_AMATCH)
+#define    TB_IS_STATUS_DONE(x) 	   (x & TB_STATUS_DONE)
+#define    TB_IS_DISABLED(x)           (x & TB_DISABLED)
+
+#define    TB_WRPTR_SHIFT        8
+#define    TB_WRPTR_MASK         0x000000ff
+#define    TB_GET_WRPTR(reg)     \
+               ((reg >> TB_WRPTR_SHIFT) & TB_WRPTR_MASK)
+
+#define    TB_RDPTR_SHIFT        16
+#define    TB_RDPTR_MASK         0x000000ff
+#define    TB_GET_RDPTR(reg)     \
+               ((reg >> TB_RDPTR_SHIFT) & TB_RDPTR_MASK)
+
+#define    TB_FIRST_MATCH_PTR_SHIFT    24
+#define    TB_FIRST_MATCH_PTR_MASK     0x000000ff
+#define    TB_GET_FIRST_MATCH_PTR(reg)     \
+               ((reg >> TB_FIRST_MATCH_PTR_SHIFT) & TB_FIRST_MATCH_PTR_MASK) 
+
+typedef struct tb_register {
+    int             type;
+    unsigned int    val;
+} tb_register_t;
+
+#define TB_IOC_MAGIC 'T'
+
+#define    TB_IOC_GTBREG    _IOR(TB_IOC_MAGIC, 0, struct tb_register*)
+#define    TB_IOC_STBREG    _IOW(TB_IOC_MAGIC, 1, struct tb_register*)
+#define    TB_IOC_REINIT    _IO(TB_IOC_MAGIC, 2)
+
+#endif
Index: linux-2.6.10/include/linux/phnx_user_mac.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/phnx_user_mac.h
@@ -0,0 +1,200 @@
+#ifndef __USER_RMI_PHNX_USER_MAC_H
+#define __USER_RMI_PHNX_USER_MAC_H
+
+#include <asm/ioctl.h>
+
+#define USER_MAC_IOC_MAGIC 'M'
+
+#define    USER_MAC_IOC_SRXQ                _IOR(USER_MAC_IOC_MAGIC, 0, unsigned int)//
+#define    USER_MAC_IOC_GSHMPHYS            _IOR(USER_MAC_IOC_MAGIC, 1, unsigned int)
+#define    USER_MAC_IOC_GSHMVIRT            _IOR(USER_MAC_IOC_MAGIC, 2, unsigned int)
+#define    USER_MAC_IOC_GSHMSIZE            _IOR(USER_MAC_IOC_MAGIC, 3, unsigned int)
+#define    USER_MAC_IOC_GMMAP_START         _IOR(USER_MAC_IOC_MAGIC, 4, unsigned int)
+#define    USER_MAC_IOC_SPERF_Q_THR         _IOR(USER_MAC_IOC_MAGIC, 5, unsigned int)//
+#define    USER_MAC_IOC_SPERF_GLOBAL_THR    _IOR(USER_MAC_IOC_MAGIC, 6, unsigned int)//
+#define    USER_MAC_IOC_SPERF_EVENT_0       _IOR(USER_MAC_IOC_MAGIC, 7, unsigned int)//
+#define    USER_MAC_IOC_SPERF_EVENT_1       _IOR(USER_MAC_IOC_MAGIC, 8, unsigned int)//
+#define    USER_MAC_IOC_SBALANCE_NUM_FLOWS  _IOR(USER_MAC_IOC_MAGIC, 9, unsigned int)//
+#define    USER_MAC_IOC_SWRITE_REG          _IOR(USER_MAC_IOC_MAGIC, 10, unsigned int)//
+#define    USER_MAC_IOC_GREAD_REG           _IOR(USER_MAC_IOC_MAGIC, 11, unsigned int)
+#define    USER_MAC_IOC_SPERF               _IOR(USER_MAC_IOC_MAGIC, 12, unsigned int)//
+#define    USER_MAC_IOC_GPHYS_CPU_PRESENT_MAP _IOR(USER_MAC_IOC_MAGIC, 13, unsigned int)
+#define    USER_MAC_IOC_GCPU_ONLINE_MAP     _IOR(USER_MAC_IOC_MAGIC, 14, unsigned int)
+
+#define PHNX_USER_MAC_CHRDEV_NAME "xlr_user_mac"
+
+#define MAX_USER_MAC_PKTS 3072
+#define USER_MAC_FIFO_SIZE 128
+#define USER_MAC_PKT_BUF_SIZE 1600
+
+#define USER_XGMAC_STRAIGHT 1
+#define USER_XGMAC_CROSSOVER 2
+
+struct ufifo {
+  unsigned int data[USER_MAC_FIFO_SIZE];
+  int       size;
+  volatile int       head;
+  volatile int       tail;
+};
+static __inline__ void ufifo_init (struct ufifo *ufifo)
+{
+  ufifo->head = ufifo->tail = 0;
+  ufifo->size = USER_MAC_FIFO_SIZE;
+}
+
+/* TODO: Change all modulos to boolean arithmetic */
+static __inline__ int ufifo_next_index(struct ufifo *ufifo, int index)
+{
+  //return (index+1) % ufifo->size;
+  return (index+1) & (USER_MAC_FIFO_SIZE - 1);
+}
+
+static __inline__ int  ufifo_next_head(struct ufifo *ufifo) 
+{ 
+  //return (ufifo->head+1) % ufifo->size ; 
+  return (ufifo->head+1) & (USER_MAC_FIFO_SIZE - 1); 
+}
+
+static __inline__ int  ufifo_next_tail(struct ufifo *ufifo) 
+{ 
+  //return (ufifo->tail+1) % ufifo->size ; 
+  return (ufifo->tail+1) & (USER_MAC_FIFO_SIZE - 1);
+}
+
+static __inline__ int  ufifo_empty(struct ufifo *ufifo) 
+{ return (ufifo->head == ufifo->tail); }
+
+static __inline__ int  ufifo_full(struct ufifo *ufifo) 
+{ return (ufifo_next_tail(ufifo) == ufifo->head); }
+
+static __inline__ int  ufifo_count(struct ufifo *ufifo) 
+{ 
+  if (ufifo->head <= ufifo->tail)
+    return ufifo->tail - ufifo->head;
+  else
+    return (ufifo->size - ufifo->head) + (ufifo->tail - 1);
+}
+static __inline__ int ufifo_dequeue(struct ufifo *ufifo, unsigned int *data)
+{
+  if (ufifo_empty(ufifo))
+    return 0;
+
+   *data = ufifo->data[ufifo->head];
+  ufifo->head = ufifo_next_head(ufifo);
+
+  return 1;
+}
+static __inline__ int ufifo_enqueue(struct ufifo *ufifo, unsigned int data) 
+{
+  if (ufifo_full(ufifo))
+    return 0;
+
+  ufifo->data[ufifo->tail] = data;
+  ufifo->tail = ufifo_next_tail(ufifo);
+
+  return 1;
+}
+static __inline__ int ufifo_head(struct ufifo *ufifo, unsigned int *data) 
+{
+  if (ufifo_empty(ufifo)) return 0;
+  
+  *data = ufifo->data[ufifo->head];
+  return 1;
+}
+
+struct packet_data {
+  unsigned char data[USER_MAC_PKT_BUF_SIZE];
+};
+
+struct packet_desc {
+  unsigned int offset;
+  int len;
+  int port;
+  int type;
+  int xgmac; //ignore in gmac. 1 xgmac loopback, 2, xgmac crossover
+  int device; //0 xgmac0, 1 xgmac1
+  unsigned char priv[48];
+  uint64_t priv_ptr;
+};
+
+#define USER_MAC_TXQ_FREE 1
+#define USER_MAC_TXQ_TX 2
+
+struct user_mac_time {
+  unsigned int hi;
+  unsigned int lo;
+};
+
+#define MAX_USER_KERNEL_APPL 4
+#define MAX_USER_KERNEL_SYSCALL 32000
+struct user_kernel_appl {
+  char syscall_data[MAX_USER_KERNEL_SYSCALL];
+};
+
+struct user_mac_data {
+  struct packet_data pkt_data[MAX_USER_MAC_PKTS];
+  struct packet_desc pkt_desc[MAX_USER_MAC_PKTS];
+  struct ufifo rxqs[32];
+  struct ufifo txqs[32];
+  struct user_mac_time time;
+  struct user_kernel_appl appl[MAX_USER_KERNEL_APPL];
+};
+
+#ifndef CONFIG_USERSPACE
+//Ramesh: API for Load Balancing...06/30/05
+   
+typedef struct conn_tuple {
+        struct hlist_node  conn_node;
+        struct hlist_node  timer_node;
+        __u8  vcpu_id;
+        __u32 src_ip;
+        __u32 dst_ip;
+        __u32 src_seq;
+        __u32 dst_seq;
+        __u16 src_port;
+        __u16 dst_port;
+        __u8  protocol;
+        __u8  state_cli;
+        __u8  state_ser;
+} Conn_tuple;
+  
+typedef struct thread_stats {
+        __u32 flows;
+        __u32 packets;
+        __u32 bytes;
+} Thread_stats;
+  
+
+/* TCP FLAGS                */
+
+#define TCP_FLAG_ACK    0x10
+#define TCP_FLAG_PUSH   0x08
+#define TCP_FLAG_RST    0x04
+#define TCP_FLAG_SYN    0x02
+#define TCP_FLAG_FIN    0x01
+  
+#define ICMP_PROTO_NUM  1
+#define TCP_PROTO_NUM   6
+#define UDP_PROTO_NUM   17
+
+enum {
+   TCP_ESTABLISHED = 0,
+   TCP_FIN_WAIT_1,
+   TCP_FIN_WAIT_2,
+   TCP_CLOSING,
+   TCP_CLOSE_WAIT,
+   TCP_LAST_ACK,
+   TCP_TIME_WAIT,
+   TCP_CLOSED
+};
+        
+#define CONN_HTABLE_SIZE (2*1024)
+#define MAX_CONN_ENTRIES (2*1024)
+#define MSL	 	 60
+#define FLOW_TIMEOUT	 500000000
+#define TICK		 (1000000000/FLOW_TIMEOUT)
+#define TIMER_QUEUE_SIZE (TICK*2*MSL)
+
+#endif /* CONFIG_USERSPACE */
+
+#endif
Index: linux-2.6.10/arch/mips/rmi/phoenix/msgring.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/rmi/phoenix/msgring.c
@@ -0,0 +1,283 @@
+#include <asm/rmi/msgring.h> 
+
+struct bucket_size bucket_sizes = {
+	{
+		 32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  16,  16,  16,  16,  16,  16,  16, 
+		16,  16,  16,  16,  16,  16,  16,   0, 
+		32,  16,  16,  16,  16,  16,  16,  16, 
+		16,  16,  16,  16,  16,  16,  16,   0, 
+		0,  32,  32,  32,  32,  32,   0,  32, 
+		64,  64,  64,  64,   0,   0,   0,   0, 
+		0,  32,   0,  32,   0,   0,   0,   0, 
+		32,  32,  32,  32,  32,   0,   0,   0, 
+	}
+};
+
+struct stn_cc cc_table_cpu_0 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_1 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_2 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_3 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_4 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_5 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_6 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_7 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{4, 4 , 4 , 4 , 4 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_xgs_0 = {{
+		
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_xgs_1 = {{
+		
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_gmac = {{
+		
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 0 , 0 , 0 , 0 , 4 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_dma = {{
+		
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_sec = {{
+		
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
Index: linux-2.6.10/mvl_patches/pro-1310.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1310.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1310);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

