#! /usr/bin/env bash
# Patch: -common_mtd_sync_07072005
# Date: Wed Dec 28 14:55:46 2005
# Source: infradead.org
# MR: 13548
# Type: Integration
# Disposition: merged from linux-mtd@infradead.org
# Signed-off-by: Todd Poynor <tpoynor@mvista.com>
# Description:
#     Resync MTD code with infradead.org as of July 7, 2005.
# 

PATCHNUM=43
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: infradead.org
MR: 13548
Type: Integration
Disposition: merged from linux-mtd@infradead.org
Signed-off-by: Todd Poynor <tpoynor@mvista.com>
Description:
    Resync MTD code with infradead.org as of July 7, 2005.

Index: linux-2.6.10/drivers/mtd/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/Kconfig
+++ linux-2.6.10/drivers/mtd/Kconfig
@@ -1,4 +1,4 @@
-# $Id: Kconfig,v 1.7 2004/11/22 11:33:56 ijc Exp $
+# $Id: Kconfig,v 1.8 2005/03/17 19:53:57 gleixner Exp $
 
 menu "Memory Technology Devices (MTD)"
 
@@ -27,6 +27,15 @@ config MTD_DEBUG_VERBOSE
 	help
 	  Determines the verbosity level of the MTD debugging messages.
 
+config MTD_CONCAT
+	tristate "MTD concatenating support"
+	depends on MTD
+	help
+	  Support for concatenating several MTD devices into a single
+	  (virtual) one. This allows you to have -for example- a JFFS(2)
+	  file system spanning multiple physical flash chips. If unsure,
+	  say 'Y'.
+
 config MTD_PARTITIONS
 	bool "MTD partitioning support"
 	depends on MTD
@@ -40,15 +49,6 @@ config MTD_PARTITIONS
 	  devices. Partitioning on NFTL 'devices' is a different - that's the
 	  'normal' form of partitioning used on a block device.
 
-config MTD_CONCAT
-	tristate "MTD concatenating support"
-	depends on MTD
-	help
-	  Support for concatenating several MTD devices into a single
-	  (virtual) one. This allows you to have -for example- a JFFS(2)
-	  file system spanning multiple physical flash chips. If unsure,
-	  say 'Y'.
-
 config MTD_REDBOOT_PARTS
 	tristate "RedBoot partition table parsing"
 	depends on MTD_PARTITIONS
@@ -253,6 +253,16 @@ config INFTL
 	  permitted to copy, modify and distribute the code as you wish. Just
 	  not use it.
 
+config RFD_FTL
+        tristate "Resident Flash Disk (Flash Translation Layer) support"
+	depends on MTD
+	---help---
+	  This provides support for the flash translation layer known 
+	  as the Resident Flash Disk (RFD), as used by the Embedded BIOS 
+	  of General Software. There is a blurb at:
+
+		http://www.gensw.com/pages/prod/bios/rfd.htm
+
 source "drivers/mtd/chips/Kconfig"
 
 source "drivers/mtd/maps/Kconfig"
Index: linux-2.6.10/drivers/mtd/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/Makefile
+++ linux-2.6.10/drivers/mtd/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_MTD_BLOCK_RO)	+= mtdblock_r
 obj-$(CONFIG_FTL)		+= ftl.o mtd_blkdevs.o
 obj-$(CONFIG_NFTL)		+= nftl.o mtd_blkdevs.o
 obj-$(CONFIG_INFTL)		+= inftl.o mtd_blkdevs.o
+obj-$(CONFIG_RFD_FTL)		+= rfd_ftl.o mtd_blkdevs.o
 
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
Index: linux-2.6.10/drivers/mtd/afs.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/afs.c
+++ linux-2.6.10/drivers/mtd/afs.c
@@ -219,7 +219,7 @@ static int parse_afs_partitions(struct m
 	 */
 	for (idx = off = 0; off < mtd->size; off += mtd->erasesize) {
 		struct image_info_struct iis;
-		u_int iis_ptr, img_ptr, size;
+		u_int iis_ptr, img_ptr;
 
 		/* Read the footer. */
 		ret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);
@@ -236,21 +236,9 @@ static int parse_afs_partitions(struct m
 			continue;
 
 		strcpy(str, iis.name);
-		size = mtd->erasesize + off - img_ptr;
-
-		/*
-		 * In order to support JFFS2 partitions on this layout,
-		 * we must lie to MTD about the real size of JFFS2
-		 * partitions; this ensures that the AFS flash footer
-		 * won't be erased by JFFS2.  Please ensure that your
-		 * JFFS2 partitions are given image numbers between
-		 * 1000 and 2000 inclusive.
-		 */
-		if (iis.imageNumber >= 1000 && iis.imageNumber < 2000)
-			size -= mtd->erasesize;
 
 		parts[idx].name		= str;
-		parts[idx].size		= size;
+		parts[idx].size		= (iis.length + mtd->erasesize - 1) & ~(mtd->erasesize - 1);
 		parts[idx].offset	= img_ptr;
 		parts[idx].mask_flags	= 0;
 
Index: linux-2.6.10/drivers/mtd/chips/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/Kconfig
+++ linux-2.6.10/drivers/mtd/chips/Kconfig
@@ -1,5 +1,5 @@
 # drivers/mtd/chips/Kconfig
-# $Id: Kconfig,v 1.11 2004/11/29 22:40:44 dwmw2 Exp $
+# $Id: Kconfig,v 1.13 2004/12/01 15:49:10 nico Exp $
 
 menu "RAM/ROM/Flash chip drivers"
 	depends on MTD!=n
Index: linux-2.6.10/drivers/mtd/chips/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/Makefile
+++ linux-2.6.10/drivers/mtd/chips/Makefile
@@ -1,7 +1,7 @@
 #
 # linux/drivers/chips/Makefile
 #
-# $Id: Makefile.common,v 1.4 2004/07/12 16:07:30 dwmw2 Exp $
+# $Id: Makefile.common,v 1.3 2003/09/25 14:40:34 thayne Exp $
 
 #                       *** BIG UGLY NOTE ***
 #
Index: linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0001.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/cfi_cmdset_0001.c
+++ linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0001.c,v 1.164 2004/11/16 18:29:00 dwmw2 Exp $
+ * $Id: cfi_cmdset_0001.c,v 1.177 2005/05/19 17:01:57 nico Exp $
  *
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
@@ -56,6 +56,7 @@ static int cfi_intelext_erase_varsize(st
 static void cfi_intelext_sync (struct mtd_info *);
 static int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
 static int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
+#ifdef CONFIG_MTD_OTP
 static int cfi_intelext_read_fact_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_intelext_read_user_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_intelext_write_user_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
@@ -64,6 +65,7 @@ static int cfi_intelext_get_fact_prot_in
 					    struct otp_info *, size_t);
 static int cfi_intelext_get_user_prot_info (struct mtd_info *,
 					    struct otp_info *, size_t);
+#endif
 static int cfi_intelext_suspend (struct mtd_info *);
 static void cfi_intelext_resume (struct mtd_info *);
 static int cfi_intelext_reboot (struct notifier_block *, unsigned long, void *);
@@ -1701,44 +1703,34 @@ static int __xipram do_erase_oneblock(st
 
 	/* check for lock bit */
 	if (map_word_bitsset(map, status, CMD(0x3a))) {
-		unsigned char chipstatus;
+		unsigned long chipstatus;
 
 		/* Reset the error bits */
 		map_write(map, CMD(0x50), adr);
 		map_write(map, CMD(0x70), adr);
 		xip_enable(map, chip, adr);
 
-		chipstatus = status.x[0];
-		if (!map_word_equal(map, status, CMD(chipstatus))) {
-			int i, w;
-			for (w=0; w<map_words(map); w++) {
-				for (i = 0; i<cfi_interleave(cfi); i++) {
-					chipstatus |= status.x[w] >> (cfi->device_type * 8);
-				}
-			}
-			printk(KERN_WARNING "Status is not identical for all chips: 0x%lx. Merging to give 0x%02x\n",
-			       status.x[0], chipstatus);
-		}
+		chipstatus = MERGESTATUS(status);
 
 		if ((chipstatus & 0x30) == 0x30) {
-			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%x\n", chipstatus);
+			printk(KERN_NOTICE "Chip reports improper command sequence: status 0x%lx\n", chipstatus);
 			ret = -EIO;
 		} else if (chipstatus & 0x02) {
 			/* Protection bit set */
 			ret = -EROFS;
 		} else if (chipstatus & 0x8) {
 			/* Voltage */
-			printk(KERN_WARNING "Chip reports voltage low on erase: status 0x%x\n", chipstatus);
+			printk(KERN_WARNING "Chip reports voltage low on erase: status 0x%lx\n", chipstatus);
 			ret = -EIO;
 		} else if (chipstatus & 0x20) {
 			if (retries--) {
-				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x. Retrying...\n", adr, chipstatus);
+				printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%lx. Retrying...\n", adr, chipstatus);
 				timeo = jiffies + HZ;
 				put_chip(map, chip, adr);
 				spin_unlock(chip->mutex);
 				goto retry;
 			}
-			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%x\n", adr, chipstatus);
+			printk(KERN_DEBUG "Chip erase failed at 0x%08lx: status 0x%lx\n", adr, chipstatus);
 			ret = -EIO;
 		}
 	} else {
Index: linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0002.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/cfi_cmdset_0002.c
+++ linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -17,7 +17,7 @@
  *
  * This code is GPL
  *
- * $Id: cfi_cmdset_0002.c,v 1.114 2004/12/11 15:43:53 dedekind Exp $
+ * $Id: cfi_cmdset_0002.c,v 1.117 2005/06/06 23:04:35 tpoynor Exp $
  *
  */
 
@@ -48,6 +48,7 @@
 #define MANUFACTURER_AMD	0x0001
 #define MANUFACTURER_SST	0x00BF
 #define SST49LF004B	        0x0060
+#define SST49LF008A		0x005a
 
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -78,6 +79,7 @@ static struct mtd_chip_driver cfi_amdstd
 
 /* #define DEBUG_CFI_FEATURES */
 
+
 #ifdef DEBUG_CFI_FEATURES
 static void cfi_tell_features(struct cfi_pri_amdstd *extp)
 {
@@ -195,6 +197,7 @@ static struct cfi_fixup cfi_fixup_table[
 };
 static struct cfi_fixup jedec_fixup_table[] = {
 	{ MANUFACTURER_SST, SST49LF004B, fixup_use_fwh_lock, NULL, },
+	{ MANUFACTURER_SST, SST49LF008A, fixup_use_fwh_lock, NULL, },
 	{ 0, 0, NULL, NULL }
 };
 
@@ -405,6 +408,32 @@ static int __xipram chip_ready(struct ma
 	return map_word_equal(map, d, t);
 }
 
+/*
+ * Return true if the chip is ready and has the correct value.
+ *
+ * Ready is one of: read mode, query mode, erase-suspend-read mode (in any
+ * non-suspended sector) and it is indicated by no bits toggling.
+ *
+ * Error are indicated by toggling bits or bits held with the wrong value,
+ * or with bits toggling.
+ *
+ * Note that anything more complicated than checking if no bits are toggling
+ * (including checking DQ5 for an error status) is tricky to get working
+ * correctly and is therefore not done	(particulary with interleaved chips
+ * as each chip must be checked independantly of the others).
+ *
+ */
+static int __xipram chip_good(struct map_info *map, unsigned long addr, map_word expected)
+{
+	map_word oldd, curd;
+
+	oldd = map_read(map, addr);
+	curd = map_read(map, addr);
+
+	return	map_word_equal(map, oldd, curd) && 
+		map_word_equal(map, curd, expected);
+}
+
 static int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode)
 {
 	DECLARE_WAITQUEUE(wait, current);
@@ -552,7 +581,7 @@ static void put_chip(struct map_info *ma
  * didn't emit calls to its own support functions). Also configuring MTD CFI
  * support to a single buswidth and a single interleave is also recommended.
  */
-#include <asm/hardware.h>
+
 static void xip_disable(struct map_info *map, struct flchip *chip,
 			unsigned long adr)
 {
@@ -595,7 +624,7 @@ static void __xipram xip_udelay(struct m
 	struct cfi_pri_amdstd *extp = cfi->cmdset_priv;
 	map_word status, OK = CMD(0x80);
 	unsigned long suspended, start = xip_currtime();
-	flstate_t oldstate, newstate;
+	flstate_t oldstate;
 
 	do {
 		cpu_relax();
@@ -611,8 +640,6 @@ static void __xipram xip_udelay(struct m
 			 * operation while another chip suspended it, then
 			 * we resume the whole thing at once).  Yes, it
 			 * can happen!
-			 * Write-suspend seems to be broken, so no write-
-			 * suspend support here.
 			 */
 			map_write(map, CMD(0xb0), adr);
 			usec -= xip_elapsed_since(start);
@@ -632,13 +659,10 @@ static void __xipram xip_udelay(struct m
 
 			/* Suspend succeeded */
 			oldstate = chip->state;
-			if (oldstate == FL_ERASING) {
-				if (!map_word_bitsset(map, status, CMD(0x40)))
-					break;
-				newstate = FL_XIP_WHILE_ERASING;
-				chip->erase_suspended = 1;
-			}
-			chip->state = newstate;
+			if (!map_word_bitsset(map, status, CMD(0x40)))
+				break;
+			chip->state = FL_XIP_WHILE_ERASING;
+			chip->erase_suspended = 1;
 			map_write(map, CMD(0xf0), adr);
 			(void) map_read(map, adr);
 			asm volatile (".rep 8; nop; .endr");
@@ -654,7 +678,7 @@ static void __xipram xip_udelay(struct m
 			 * until it's done.
 			 */
 			spin_lock(chip->mutex);
-			while (chip->state != newstate) {
+			while (chip->state != FL_XIP_WHILE_ERASING) {
 				DECLARE_WAITQUEUE(wait, current);
 				set_current_state(TASK_UNINTERRUPTIBLE);
 				add_wait_queue(&chip->wq, &wait);
@@ -981,27 +1005,32 @@ static int __xipram do_write_oneword(str
 		}
 
 		if (chip_ready(map, adr))
-			goto op_done;
+			break;
 
-		if (time_after(jiffies, timeo))
+		if (time_after(jiffies, timeo)) {
+			xip_enable(map, chip, adr);
+			printk(KERN_WARNING "MTD %s(): software timeout\n", __func__);
+			xip_disable(map, chip, adr);
                         break;
+		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1);
 	}
+	/* Did we succeed? */
+	if (!chip_good(map, adr, datum)) {
+		/* reset on all failures. */
+		map_write( map, CMD(0xF0), chip->start );
+		/* FIXME - should have reset delay before continuing */
 
-	printk(KERN_WARNING "MTD %s(): software timeout\n", __func__);
-
-	/* reset on all failures. */
-	map_write( map, CMD(0xF0), chip->start );
-	/* FIXME - should have reset delay before continuing */
-	if (++retry_cnt <= MAX_WORD_RETRIES) 
-		goto retry;
+		if (++retry_cnt <= MAX_WORD_RETRIES) 
+			goto retry;
 
-	ret = -EIO;
+		ret = -EIO;
+	}
+	xip_enable(map, chip, adr);
  op_done:
 	chip->state = FL_READY;
-	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 
@@ -1154,8 +1183,9 @@ static int cfi_amdstd_write_words(struct
 /*
  * FIXME: interleaved mode not tested, and probably not supported!
  */
-static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip, 
-				  unsigned long adr, const u_char *buf, int len)
+static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
+				    unsigned long adr, const u_char *buf, 
+				    int len)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo = jiffies + HZ;
@@ -1184,7 +1214,7 @@ static int __xipram do_write_buffer(stru
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
 	ENABLE_VPP(map);
 	xip_disable(map, chip, cmd_adr);
-
+	
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	//cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
@@ -1235,27 +1265,29 @@ static int __xipram do_write_buffer(stru
 			continue;
 		}
 
-		if (chip_ready(map, adr))
+		if (chip_ready(map, adr)) {
+			xip_enable(map, chip, adr);
 			goto op_done;
+		}
 		    
 		if( time_after(jiffies, timeo))
 			break;
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		UDELAY(map, chip, cmd_adr, 1);
+		UDELAY(map, chip, adr, 1);
 	}
 
-	printk(KERN_WARNING "MTD %s(): software timeout\n",
-	       __func__ );
-
 	/* reset on all failures. */
 	map_write( map, CMD(0xF0), chip->start );
+	xip_enable(map, chip, adr);
 	/* FIXME - should have reset delay before continuing */
 
+	printk(KERN_WARNING "MTD %s(): software timeout\n",
+	       __func__ );
+
 	ret = -EIO;
  op_done:
 	chip->state = FL_READY;
-	xip_enable(map, chip, cmd_adr);
 	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 
@@ -1407,24 +1439,26 @@ static int __xipram do_erase_chip(struct
 		}
 
 		if (chip_ready(map, adr))
-			goto op_done;
+			break;
 
-		if (time_after(jiffies, timeo))
+		if (time_after(jiffies, timeo)) {
+			printk(KERN_WARNING "MTD %s(): software timeout\n",
+				__func__ );
 			break;
+		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
-		UDELAY(map, chip, adr, 1000);
+		UDELAY(map, chip, adr, 1000000/HZ);
 	}
+	/* Did we succeed? */
+	if (!chip_good(map, adr, map_word_ff(map))) {
+		/* reset on all failures. */
+		map_write( map, CMD(0xF0), chip->start );
+		/* FIXME - should have reset delay before continuing */
 
-	/* reset on all failures. */
-	map_write( map, CMD(0xF0), chip->start );
-	/* FIXME - should have reset delay before continuing */
-
-	printk(KERN_WARNING "MTD %s(): software timeout\n",
-	       __func__ );
+		ret = -EIO;
+	}
 
-	ret = -EIO;
- op_done:
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
@@ -1492,27 +1526,31 @@ static int __xipram do_erase_oneblock(st
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr))
-			goto op_done;
+		if (chip_ready(map, adr)) {
+			xip_enable(map, chip, adr);
+			break;
+		}
 
-		if (time_after(jiffies, timeo))
+		if (time_after(jiffies, timeo)) {
+			xip_enable(map, chip, adr);
+			printk(KERN_WARNING "MTD %s(): software timeout\n",
+				__func__ );
 			break;
+		}
 
 		/* Latency issues. Drop the lock, wait a while and retry */
 		UDELAY(map, chip, adr, 1000000/HZ);
 	}
+	/* Did we succeed? */
+	if (!chip_good(map, adr, map_word_ff(map))) {
+		/* reset on all failures. */
+		map_write( map, CMD(0xF0), chip->start );
+		/* FIXME - should have reset delay before continuing */
 
-	/* reset on all failures. */
-	map_write( map, CMD(0xF0), chip->start );
-	/* FIXME - should have reset delay before continuing */
+		ret = -EIO;
+	}
 
-	printk(KERN_WARNING "MTD %s(): software timeout\n",
-	       __func__ );
-	
-	ret = -EIO;
- op_done:
 	chip->state = FL_READY;
-	xip_enable(map, chip, adr);
 	put_chip(map, chip, adr);
 	spin_unlock(chip->mutex);
 	return ret;
Index: linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0020.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/cfi_cmdset_0020.c
+++ linux-2.6.10/drivers/mtd/chips/cfi_cmdset_0020.c
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0020.c,v 1.17 2004/11/20 12:49:04 dwmw2 Exp $
+ * $Id: cfi_cmdset_0020.c,v 1.16 2004/11/16 18:29:00 dwmw2 Exp $
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
  * 	- completely revamped method functions so they are aware and
Index: linux-2.6.10/drivers/mtd/chips/cfi_probe.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/cfi_probe.c
+++ linux-2.6.10/drivers/mtd/chips/cfi_probe.c
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: cfi_probe.c,v 1.83 2004/11/16 18:19:02 nico Exp $
+   $Id: cfi_probe.c,v 1.82 2004/11/16 17:26:01 rmk Exp $
 */
 
 #include <linux/config.h>
Index: linux-2.6.10/drivers/mtd/chips/cfi_util.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/cfi_util.c
+++ linux-2.6.10/drivers/mtd/chips/cfi_util.c
@@ -7,7 +7,7 @@
  *
  * This code is covered by the GPL.
  *
- * $Id: cfi_util.c,v 1.8 2004/12/14 19:55:56 nico Exp $
+ * $Id: cfi_util.c,v 1.7 2004/11/05 22:41:05 nico Exp $
  *
  */
 
Index: linux-2.6.10/drivers/mtd/chips/gen_probe.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/gen_probe.c
+++ linux-2.6.10/drivers/mtd/chips/gen_probe.c
@@ -162,7 +162,7 @@ static int genprobe_new_chip(struct map_
 	int max_chips = map_bankwidth(map); /* And minimum 1 */
 	int nr_chips, type;
 
-	for (nr_chips = min_chips; nr_chips <= max_chips; nr_chips <<= 1) {
+	for (nr_chips = max_chips; nr_chips >= min_chips; nr_chips >>= 1) {
 
 		if (!cfi_interleave_supported(nr_chips))
 		    continue;
Index: linux-2.6.10/drivers/mtd/chips/jedec.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/jedec.c
+++ linux-2.6.10/drivers/mtd/chips/jedec.c
@@ -529,7 +529,7 @@ static int jedec_probe32(struct map_info
 static int jedec_read(struct mtd_info *mtd, loff_t from, size_t len, 
 		      size_t *retlen, u_char *buf)
 {
-   struct map_info *map = (struct map_info *)mtd->priv;
+   struct map_info *map = mtd->priv;
    
    map_copy_from(map, buf, from, len);
    *retlen = len;
@@ -541,8 +541,8 @@ static int jedec_read(struct mtd_info *m
 static int jedec_read_banked(struct mtd_info *mtd, loff_t from, size_t len, 
 			     size_t *retlen, u_char *buf)
 {
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
 
    *retlen = 0;
    while (len > 0)
@@ -593,8 +593,8 @@ static int flash_erase(struct mtd_info *
    unsigned long NoTime = 0;
    unsigned long start = instr->addr, len = instr->len;
    unsigned int I;
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
 
    // Verify the arguments..
    if (start + len > mtd->size ||
@@ -800,8 +800,8 @@ static int flash_write(struct mtd_info *
    #define flread(x) map_read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    #define flwrite(v,x) map_write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    
-   struct map_info *map = (struct map_info *)mtd->priv;
-   struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
+   struct map_info *map = mtd->priv;
+   struct jedec_private *priv = map->fldrv_priv;
    unsigned long base;
    unsigned long off;
    size_t save_len = len;
Index: linux-2.6.10/drivers/mtd/chips/jedec_probe.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/jedec_probe.c
+++ linux-2.6.10/drivers/mtd/chips/jedec_probe.c
@@ -1,7 +1,7 @@
 /* 
    Common Flash Interface probe code.
    (C) 2000 Red Hat. GPL'd.
-   $Id: jedec_probe.c,v 1.61 2004/11/19 20:52:16 thayne Exp $
+   $Id: jedec_probe.c,v 1.64 2005/03/14 20:34:13 bjd Exp $
    See JEDEC (http://www.jedec.org/) standard JESD21C (section 3.5)
    for the standard this probe goes back to.
 
@@ -32,6 +32,7 @@
 #define MANUFACTURER_HYUNDAI	0x00AD
 #define MANUFACTURER_INTEL	0x0089
 #define MANUFACTURER_MACRONIX	0x00C2
+#define MANUFACTURER_NEC	0x0010
 #define MANUFACTURER_PMC	0x009D
 #define MANUFACTURER_SST	0x00BF
 #define MANUFACTURER_ST		0x0020
@@ -115,6 +116,9 @@
 #define MX29F004T	0x0045
 #define MX29F004B	0x0046
 
+/* NEC */
+#define UPD29F064115	0x221C
+
 /* PMC */
 #define PM49FL002	0x006D
 #define PM49FL004	0x006E
@@ -138,6 +142,7 @@
 #define SST29LE512	0x003d
 #define SST39LF800	0x2781
 #define SST39LF160	0x2782
+#define SST39VF1601	0x234b
 #define SST39LF512	0x00D4
 #define SST39LF010	0x00D5
 #define SST39LF020	0x00D6
@@ -1130,6 +1135,22 @@ static const struct amd_flash_info jedec
 			ERASEINFO(0x04000,1)
 		}
 	}, {
+		.mfr_id		= MANUFACTURER_NEC,
+		.dev_id		= UPD29F064115,
+		.name		= "NEC uPD29F064115",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0555_0x02AA,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_8MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 3,
+		.regions	= {
+			ERASEINFO(0x2000,8),
+			ERASEINFO(0x10000,126),
+			ERASEINFO(0x2000,8),
+		}
+	}, {
 		.mfr_id		= MANUFACTURER_MACRONIX,
 		.dev_id		= MX29LV160B,
 		.name		= "MXIC MX29LV160B",
@@ -1282,7 +1303,8 @@ static const struct amd_flash_info jedec
  		.DevSize	= SIZE_256KiB,
  		.CmdSet		= P_ID_SST_PAGE,
  		.NumEraseRegions= 1,
- 		regions: {ERASEINFO(0x01000,64),
+ 		.regions	= {
+			ERASEINFO(0x01000,64),
  		}
          }, {
  		.mfr_id		= MANUFACTURER_SST,
@@ -1294,7 +1316,8 @@ static const struct amd_flash_info jedec
  		.DevSize	= SIZE_256KiB,
  		.CmdSet		= P_ID_SST_PAGE,
  		.NumEraseRegions= 1,
- 		regions: {ERASEINFO(0x01000,64),
+ 		.regions	= {
+			ERASEINFO(0x01000,64),
  		}
 	}, {
 		.mfr_id		= MANUFACTURER_SST,
@@ -1428,6 +1451,21 @@ static const struct amd_flash_info jedec
                        ERASEINFO(0x1000,256),
                        ERASEINFO(0x1000,256)
                }
+	}, {
+               .mfr_id         = MANUFACTURER_SST,     /* should be CFI */
+               .dev_id         = SST39VF1601,
+               .name           = "SST 39VF1601",
+               .uaddr          = {
+                       [0] = MTD_UADDR_0x5555_0x2AAA,  /* x8 */
+                       [1] = MTD_UADDR_0x5555_0x2AAA   /* x16 */
+               },
+               .DevSize        = SIZE_2MiB,
+               .CmdSet         = P_ID_AMD_STD,
+               .NumEraseRegions= 2,
+               .regions        = {
+                       ERASEINFO(0x1000,256),
+                       ERASEINFO(0x1000,256)
+               }
 
        }, {
 		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
@@ -1836,6 +1874,16 @@ static inline int jedec_match( __u32 bas
 	case CFI_DEVICETYPE_X8:
 		mfr = (__u8)finfo->mfr_id;
 		id = (__u8)finfo->dev_id;
+
+		/* bjd: it seems that if we do this, we can end up
+		 * detecting 16bit flashes as an 8bit device, even though
+		 * there aren't.
+		 */
+		if (finfo->dev_id > 0xff) {
+			DEBUG( MTD_DEBUG_LEVEL3, "%s(): ID is not 8bit\n",
+			       __func__);
+			goto match_done;
+		}
 		break;
 	case CFI_DEVICETYPE_X16:
 		mfr = (__u16)finfo->mfr_id;
Index: linux-2.6.10/drivers/mtd/chips/map_absent.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/map_absent.c
+++ linux-2.6.10/drivers/mtd/chips/map_absent.c
@@ -1,7 +1,7 @@
 /*
  * Common code to handle absent "placeholder" devices
  * Copyright 2001 Resilience Corporation <ebrower@resilience.com>
- * $Id: map_absent.c,v 1.5 2004/11/16 18:29:00 dwmw2 Exp $
+ * $Id: map_absent.c,v 1.4 2003/05/28 12:51:49 dwmw2 Exp $
  *
  * This map driver is used to allocate "placeholder" MTD
  * devices on systems that have socketed/removable media. 
Index: linux-2.6.10/drivers/mtd/chips/map_ram.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/map_ram.c
+++ linux-2.6.10/drivers/mtd/chips/map_ram.c
@@ -83,7 +83,7 @@ static struct mtd_info *map_ram_probe(st
 
 static int mapram_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_from(map, buf, from, len);
 	*retlen = len;
@@ -92,7 +92,7 @@ static int mapram_read (struct mtd_info 
 
 static int mapram_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_to(map, to, buf, len);
 	*retlen = len;
@@ -103,7 +103,7 @@ static int mapram_erase (struct mtd_info
 {
 	/* Yeah, it's inefficient. Who cares? It's faster than a _real_
 	   flash erase. */
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 	map_word allff;
 	unsigned long i;
 
Index: linux-2.6.10/drivers/mtd/chips/map_rom.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/map_rom.c
+++ linux-2.6.10/drivers/mtd/chips/map_rom.c
@@ -57,7 +57,7 @@ static struct mtd_info *map_rom_probe(st
 
 static int maprom_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-	struct map_info *map = (struct map_info *)mtd->priv;
+	struct map_info *map = mtd->priv;
 
 	map_copy_from(map, buf, from, len);
 	*retlen = len;
Index: linux-2.6.10/drivers/mtd/chips/sharp.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/chips/sharp.c
+++ linux-2.6.10/drivers/mtd/chips/sharp.c
@@ -4,7 +4,7 @@
  * Copyright 2000,2001 David A. Schleef <ds@schleef.org>
  *           2000,2001 Lineo, Inc.
  *
- * $Id: sharp.c,v 1.14 2004/08/09 13:19:43 dwmw2 Exp $
+ * $Id: sharp.c,v 1.13 2004/07/12 14:06:34 dwmw2 Exp $
  *
  * Devices supported:
  *   LH28F016SCT Symmetrical block flash memory, 2Mx8
Index: linux-2.6.10/drivers/mtd/cmdlinepart.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/cmdlinepart.c
+++ linux-2.6.10/drivers/mtd/cmdlinepart.c
@@ -239,7 +239,8 @@ static int mtdpart_setup_real(char *s)
 				&num_parts,	/* out: number of parts */
 				0,		/* first partition */
 				(unsigned char**)&this_mtd, /* out: extra mem */
-				mtd_id_len + 1 + sizeof(*this_mtd));
+				mtd_id_len + 1 + sizeof(*this_mtd) + 
+				sizeof(void*)-1 /*alignment*/);
 		if(!parts)
 		{
 			/*
@@ -252,6 +253,9 @@ static int mtdpart_setup_real(char *s)
 			 return 0;
 		 }
 
+		/* align this_mtd */
+		this_mtd = (struct cmdline_mtd_partition *) 
+			ALIGN((unsigned long)this_mtd, sizeof(void*));
 		/* enter results */	    
 		this_mtd->parts = parts;
 		this_mtd->num_parts = num_parts;
Index: linux-2.6.10/drivers/mtd/devices/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/Kconfig
+++ linux-2.6.10/drivers/mtd/devices/Kconfig
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id: Kconfig,v 1.14 2004/11/29 22:40:45 dwmw2 Exp $
+# $Id: Kconfig,v 1.16 2005/01/06 15:15:47 dwmw2 Exp $
 
 menu "Self-contained MTD device drivers"
 	depends on MTD!=n
@@ -47,11 +47,6 @@ config MTD_MS02NV
 	  accelerator.  Say Y here if you have a DECstation 5000/2x0 or a
 	  DECsystem 5900 equipped with such a module.
 
-	  If you want to compile this driver as a module ( = code which can be
-	  inserted in and removed from the running kernel whenever you want),
-	  say M here and read <file:Documentation/modules.txt>.  The module will
-	  be called ms02-nv.o.
-
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	depends on MTD
@@ -78,12 +73,6 @@ config MTD_LART
 	  not need any mapping/chip driver for LART. This one does it all
 	  for you, so go disable all of those if you enabled some of them (:
 
-config MTD_OMAP_NOR
-        tristate "NOR Flash driver for OMAP"
-        depends on (ARCH_OMAP16XX || ARCH_OMAP24XX) && MTD
-        help
-          This enables the flash driver for OMAP 1610, OMAP1710, OMAP24XX.
-
 config MTD_MTDRAM
 	tristate "Test driver using RAM"
 	depends on MTD
@@ -124,6 +113,15 @@ config MTDRAM_ABS_POS
 	  allocating space from Linux's available memory. Otherwise, leave 
 	  this set to zero. Most people will want to leave this as zero.
 
+config RAMTD
+	tristate "MTD using dynamic memory allocation"
+	depends on MTD
+	help
+	  This driver dynamically allocates memory as the devices are written
+	  to and frees it on erases.
+
+	  If unsure, say n.
+
 config MTD_BLKMTD
 	tristate "MTD emulation using block device"
 	depends on MTD
@@ -136,6 +134,15 @@ config MTD_BLKMTD
 	  Testing MTD users (eg JFFS2) on large media and media that might
 	  be removed during a write (using the floppy drive).
 
+config MTD_BLOCK2MTD
+	tristate "MTD using block device (rewrite)"
+	depends on MTD && EXPERIMENTAL
+	help
+	  This driver is basically the same at MTD_BLKMTD above, but
+	  experienced some interface changes plus serious speedups.  In
+	  the long term, it should replace MTD_BLKMTD.  Right now, you
+	  shouldn't entrust important data to it yet.
+
 comment "Disk-On-Chip Device Drivers"
 
 config MTD_DOC2000
Index: linux-2.6.10/drivers/mtd/devices/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/Makefile
+++ linux-2.6.10/drivers/mtd/devices/Makefile
@@ -1,7 +1,7 @@
 #
 # linux/drivers/devices/Makefile
 #
-# $Id: Makefile.common,v 1.6 2004/07/12 16:07:30 dwmw2 Exp $
+# $Id: Makefile.common,v 1.7 2004/12/22 17:51:15 joern Exp $
 
 #                       *** BIG UGLY NOTE ***
 #
@@ -22,4 +22,5 @@ obj-$(CONFIG_MTD_MS02NV)	+= ms02-nv.o
 obj-$(CONFIG_MTD_MTDRAM)	+= mtdram.o
 obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
-obj-$(CONFIG_MTD_OMAP_NOR)	+= omap-nor-flash.o
+obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
+obj-$(CONFIG_RAMTD)		+= ramtd.o
Index: linux-2.6.10/drivers/mtd/devices/blkmtd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/blkmtd.c
+++ linux-2.6.10/drivers/mtd/devices/blkmtd.c
@@ -1,5 +1,5 @@
 /*
- * $Id: blkmtd.c,v 1.24 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: blkmtd.c,v 1.25 2005/03/17 19:44:27 gleixner Exp $
  *
  * blkmtd.c - use a block device as a fake MTD
  *
@@ -39,7 +39,7 @@
 
 /* Default erase size in K, always make it a multiple of PAGE_SIZE */
 #define CONFIG_MTD_BLKDEV_ERASESIZE (128 << 10)	/* 128KiB */
-#define VERSION "$Revision: 1.24 $"
+#define VERSION "$Revision: 1.25 $"
 
 /* Info for the block device */
 struct blkmtd_dev {
@@ -68,13 +68,13 @@ static int sync;
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Simon Evans <spse@secret.org.uk>");
 MODULE_DESCRIPTION("Emulate an MTD using a block device");
-MODULE_PARM(device, "1-4s");
+module_param_array(device, charp, NULL, 0);
 MODULE_PARM_DESC(device, "block device to use");
-MODULE_PARM(erasesz, "1-4i");
+module_param_array(erasesz, int, NULL, 0);
 MODULE_PARM_DESC(erasesz, "optional erase size to use in KiB. eg 4=4KiB.");
-MODULE_PARM(ro, "1-4i");
+module_param_array(ro, bool, NULL, 0);
 MODULE_PARM_DESC(ro, "1=Read only, writes and erases cause errors");
-MODULE_PARM(sync, "i");
+module_param(sync, bool, 0);
 MODULE_PARM_DESC(sync, "1=Synchronous writes");
 
 
@@ -661,7 +661,6 @@ static struct blkmtd_dev *add_device(cha
 
 	memset(dev, 0, sizeof(struct blkmtd_dev));
 	dev->blkdev = bdev;
-	atomic_set(&(dev->blkdev->bd_inode->i_mapping->truncate_count), 0);
 	if(!readonly) {
 		init_MUTEX(&dev->wrbuf_mutex);
 	}
Index: linux-2.6.10/drivers/mtd/devices/block2mtd.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/devices/block2mtd.c
@@ -0,0 +1,493 @@
+/*
+ * $Id: block2mtd.c,v 1.27 2005/03/18 01:37:31 gleixner Exp $
+ *
+ * block2mtd.c - create an mtd from a block device
+ *
+ * Copyright (C) 2001,2002	Simon Evans <spse@secret.org.uk>
+ * Copyright (C) 2004,2005	Jörn Engel <joern@wh.fh-wedel.de>
+ *
+ * Licence: GPL
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/pagemap.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/buffer_head.h>
+
+#define VERSION "$Revision: 1.27 $"
+
+
+#define ERROR(fmt, args...) printk(KERN_ERR "block2mtd: " fmt "\n" , ## args)
+#define INFO(fmt, args...) printk(KERN_INFO "block2mtd: " fmt "\n" , ## args)
+
+
+/* Info for the block device */
+struct block2mtd_dev {
+	struct list_head list;
+	struct block_device *blkdev;
+	struct mtd_info mtd;
+	struct semaphore write_mutex;
+};
+
+
+/* Static info about the MTD, used in cleanup_module */
+static LIST_HEAD(blkmtd_device_list);
+
+
+#define PAGE_READAHEAD 64
+void cache_readahead(struct address_space *mapping, int index)
+{
+	filler_t *filler = (filler_t*)mapping->a_ops->readpage;
+	int i, pagei;
+	unsigned ret = 0;
+	unsigned long end_index;
+	struct page *page;
+	LIST_HEAD(page_pool);
+	struct inode *inode = mapping->host;
+	loff_t isize = i_size_read(inode);
+
+	if (!isize) {
+		INFO("iSize=0 in cache_readahead\n");
+		return;
+	}
+
+	end_index = ((isize - 1) >> PAGE_CACHE_SHIFT);
+
+	read_lock_irq(&mapping->tree_lock);
+	for (i = 0; i < PAGE_READAHEAD; i++) {
+		pagei = index + i;
+		if (pagei > end_index) {
+			INFO("Overrun end of disk in cache readahead\n");
+			break;
+		}
+		page = radix_tree_lookup(&mapping->page_tree, pagei);
+		if (page && (!i))
+			break;
+		if (page)
+			continue;
+		read_unlock_irq(&mapping->tree_lock);
+		page = page_cache_alloc_cold(mapping);
+		read_lock_irq(&mapping->tree_lock);
+		if (!page)
+			break;
+		page->index = pagei;
+		list_add(&page->lru, &page_pool);
+		ret++;
+	}
+	read_unlock_irq(&mapping->tree_lock);
+	if (ret)
+		read_cache_pages(mapping, &page_pool, filler, NULL);
+}
+
+
+static struct page* page_readahead(struct address_space *mapping, int index)
+{
+	filler_t *filler = (filler_t*)mapping->a_ops->readpage;
+	cache_readahead(mapping, index);
+	return read_cache_page(mapping, index, filler, NULL);
+}
+
+
+/* erase a specified part of the device */
+static int _block2mtd_erase(struct block2mtd_dev *dev, loff_t to, size_t len)
+{
+	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
+	struct page *page;
+	int index = to >> PAGE_SHIFT;	// page index
+	int pages = len >> PAGE_SHIFT;
+	u_long *p;
+	u_long *max;
+
+	while (pages) {
+		page = page_readahead(mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		max = (u_long*)page_address(page) + PAGE_SIZE;
+		for (p=(u_long*)page_address(page); p<max; p++) 
+			if (*p != -1UL) {
+				lock_page(page);
+				memset(page_address(page), 0xff, PAGE_SIZE);
+				set_page_dirty(page);
+				unlock_page(page);
+				break;
+			}
+
+		page_cache_release(page);
+		pages--;
+		index++;
+	}
+	return 0;
+}
+static int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	size_t from = instr->addr;
+	size_t len = instr->len;
+	int err;
+
+	instr->state = MTD_ERASING;
+	down(&dev->write_mutex);
+	err = _block2mtd_erase(dev, from, len);
+	up(&dev->write_mutex);
+	if (err) {
+		ERROR("erase failed err = %d", err);
+		instr->state = MTD_ERASE_FAILED;
+	} else
+		instr->state = MTD_ERASE_DONE;
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	return err;
+}
+
+
+static int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	struct page *page;
+	int index = from >> PAGE_SHIFT;
+	int offset = from & (PAGE_SIZE-1);
+	int cpylen;
+
+	if (from > mtd->size)
+		return -EINVAL;
+	if (from + len > mtd->size)
+		len = mtd->size - from;
+
+	if (retlen)
+		*retlen = 0;
+
+	while (len) {
+		if ((offset + len) > PAGE_SIZE)
+			cpylen = PAGE_SIZE - offset;	// multiple pages
+		else
+			cpylen = len;	// this page
+		len = len - cpylen;
+
+		//      Get page
+		page = page_readahead(dev->blkdev->bd_inode->i_mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		memcpy(buf, page_address(page) + offset, cpylen);
+		page_cache_release(page);
+
+		if (retlen)
+			*retlen += cpylen;
+		buf += cpylen;
+		offset = 0;
+		index++;
+	}
+	return 0;
+}
+
+
+/* write data to the underlying device */
+static int _block2mtd_write(struct block2mtd_dev *dev, const u_char *buf,
+		loff_t to, size_t len, size_t *retlen)
+{
+	struct page *page;
+	struct address_space *mapping = dev->blkdev->bd_inode->i_mapping;
+	int index = to >> PAGE_SHIFT;	// page index
+	int offset = to & ~PAGE_MASK;	// page offset
+	int cpylen;
+
+	if (retlen)
+		*retlen = 0;
+	while (len) {
+		if ((offset+len) > PAGE_SIZE) 
+			cpylen = PAGE_SIZE - offset;	// multiple pages
+		else
+			cpylen = len;			// this page
+		len = len - cpylen;
+
+		//	Get page
+		page = page_readahead(mapping, index);
+		if (!page)
+			return -ENOMEM;
+		if (IS_ERR(page))
+			return PTR_ERR(page);
+
+		if (memcmp(page_address(page)+offset, buf, cpylen)) {
+			lock_page(page);
+			memcpy(page_address(page) + offset, buf, cpylen);
+			set_page_dirty(page);
+			unlock_page(page);
+		}
+		page_cache_release(page);
+
+		if (retlen)
+			*retlen += cpylen;
+
+		buf += cpylen;
+		offset = 0;
+		index++;
+	}
+	return 0;
+}
+static int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	int err;
+
+	if (!len)
+		return 0;
+	if (to >= mtd->size)
+		return -ENOSPC;
+	if (to + len > mtd->size)
+		len = mtd->size - to;
+
+	down(&dev->write_mutex);
+	err = _block2mtd_write(dev, buf, to, len, retlen);
+	up(&dev->write_mutex);
+	if (err > 0)
+		err = 0;
+	return err;
+}
+
+
+/* sync the device - wait until the write queue is empty */
+static void block2mtd_sync(struct mtd_info *mtd)
+{
+	struct block2mtd_dev *dev = mtd->priv;
+	sync_blockdev(dev->blkdev);
+	return;
+}
+
+
+static void block2mtd_free_device(struct block2mtd_dev *dev)
+{
+	if (!dev)
+		return;
+
+	kfree(dev->mtd.name);
+
+	if (dev->blkdev) {
+		invalidate_inode_pages(dev->blkdev->bd_inode->i_mapping);
+		close_bdev_excl(dev->blkdev);
+	}
+
+	kfree(dev);
+}
+
+
+/* FIXME: ensure that mtd->size % erase_size == 0 */
+static struct block2mtd_dev *add_device(char *devname, int erase_size)
+{
+	struct block_device *bdev;
+	struct block2mtd_dev *dev;
+
+	if (!devname)
+		return NULL;
+
+	dev = kmalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+	memset(dev, 0, sizeof(*dev));
+
+	/* Get a handle on the device */
+	bdev = open_bdev_excl(devname, O_RDWR, NULL);
+	if (IS_ERR(bdev)) {
+		ERROR("error: cannot open device %s", devname);
+		goto devinit_err;
+	}
+	dev->blkdev = bdev;
+
+	if (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {
+		ERROR("attempting to use an MTD device as a block device");
+		goto devinit_err;
+	}
+
+	init_MUTEX(&dev->write_mutex);
+
+	/* Setup the MTD structure */
+	/* make the name contain the block device in */
+	dev->mtd.name = kmalloc(sizeof("block2mtd: ") + strlen(devname),
+			GFP_KERNEL);
+	if (!dev->mtd.name)
+		goto devinit_err;
+
+	sprintf(dev->mtd.name, "block2mtd: %s", devname);
+
+	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
+	dev->mtd.erasesize = erase_size;
+	dev->mtd.type = MTD_RAM;
+	dev->mtd.flags = MTD_CAP_RAM;
+	dev->mtd.erase = block2mtd_erase;
+	dev->mtd.write = block2mtd_write;
+	dev->mtd.writev = default_mtd_writev;
+	dev->mtd.sync = block2mtd_sync;
+	dev->mtd.read = block2mtd_read;
+	dev->mtd.readv = default_mtd_readv;
+	dev->mtd.priv = dev;
+	dev->mtd.owner = THIS_MODULE;
+
+	if (add_mtd_device(&dev->mtd)) {
+		/* Device didnt get added, so free the entry */
+		goto devinit_err;
+	}
+	list_add(&dev->list, &blkmtd_device_list);
+	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
+			dev->mtd.name + strlen("blkmtd: "),
+			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+	return dev;
+
+devinit_err:
+	block2mtd_free_device(dev);
+	return NULL;
+}
+
+
+static int ustrtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = simple_strtoul(cp, endp, base);
+	switch (**endp) {
+	case 'G' :
+		result *= 1024;
+	case 'M':
+		result *= 1024;
+	case 'k':
+		result *= 1024;
+	/* By dwmw2 editorial decree, "ki", "Mi" or "Gi" are to be used. */
+		if ((*endp)[1] == 'i')
+			(*endp) += 2;
+	}
+	return result;
+}
+
+
+static int parse_num(size_t *num, const char *token)
+{
+	char *endp;
+	size_t n;
+
+	n = (size_t) ustrtoul(token, &endp, 0);
+	if (*endp)
+		return -EINVAL;
+
+	*num = n;
+	return 0;
+}
+
+
+static int parse_name(char **pname, const char *token, size_t limit)
+{
+	size_t len;
+	char *name;
+
+	len = strlen(token) + 1;
+	if (len > limit)
+		return -ENOSPC;
+
+	name = kmalloc(len, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	strcpy(name, token);
+
+	*pname = name;
+	return 0;
+}
+
+
+static inline void kill_final_newline(char *str)
+{
+	char *newline = strrchr(str, '\n');
+	if (newline && !newline[1])
+		*newline = 0;
+}
+
+
+#define parse_err(fmt, args...) do {		\
+	ERROR("block2mtd: " fmt "\n", ## args);	\
+	return 0;				\
+} while (0)
+
+static int block2mtd_setup(const char *val, struct kernel_param *kp)
+{
+	char buf[80+12], *str=buf; /* 80 for device, 12 for erase size */
+	char *token[2];
+	char *name;
+	size_t erase_size = PAGE_SIZE;
+	int i, ret;
+
+	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
+		parse_err("parameter too long");
+
+	strcpy(str, val);
+	kill_final_newline(str);
+
+	for (i=0; i<2; i++)
+		token[i] = strsep(&str, ",");
+
+	if (str)
+		parse_err("too many arguments");
+
+	if (!token[0])
+		parse_err("no argument");
+
+	ret = parse_name(&name, token[0], 80);
+	if (ret == -ENOMEM)
+		parse_err("out of memory");
+	if (ret == -ENOSPC)
+		parse_err("name too long");
+	if (ret)
+		return 0;
+
+	if (token[1]) {
+		ret = parse_num(&erase_size, token[1]);
+		if (ret)
+			parse_err("illegal erase size");
+	}
+
+	add_device(name, erase_size);
+
+	return 0;
+}
+
+
+module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
+MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
+
+static int __init block2mtd_init(void)
+{
+	INFO("version " VERSION);
+	return 0;
+}
+
+
+static void __devexit block2mtd_exit(void)
+{
+	struct list_head *pos, *next;
+
+	/* Remove the MTD devices */
+	list_for_each_safe(pos, next, &blkmtd_device_list) {
+		struct block2mtd_dev *dev = list_entry(pos, typeof(*dev), list);
+		block2mtd_sync(&dev->mtd);
+		del_mtd_device(&dev->mtd);
+		INFO("mtd%d: [%s] removed", dev->mtd.index,
+				dev->mtd.name + strlen("blkmtd: "));
+		list_del(&dev->list);
+		block2mtd_free_device(dev);
+	}
+}
+
+
+module_init(block2mtd_init);
+module_exit(block2mtd_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Simon Evans <spse@secret.org.uk> and others");
+MODULE_DESCRIPTION("Emulate an MTD using a block device");
Index: linux-2.6.10/drivers/mtd/devices/doc2000.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/doc2000.c
+++ linux-2.6.10/drivers/mtd/devices/doc2000.c
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.64 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: doc2000.c,v 1.65 2005/01/05 12:40:36 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -527,26 +527,26 @@ static const char im_name[] = "DoC2k_ini
  */
 static void DoC2k_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 	int maxchips;
 
 	/* We must avoid being called twice for the same device. */
 
 	if (doc2klist)
-		old = (struct DiskOnChip *) doc2klist->priv;
+		old = doc2klist->priv;
 
 	while (old) {
 		if (DoC2k_is_alias(old, this)) {
 			printk(KERN_NOTICE
 			       "Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",
 			       this->physadr);
-			iounmap((void *) this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *) old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -573,7 +573,7 @@ static void DoC2k_init(struct mtd_info *
 	default:
 		printk("Unknown ChipID 0x%02x\n", this->ChipID);
 		kfree(mtd);
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 		return;
 	}
 
@@ -612,7 +612,7 @@ static void DoC2k_init(struct mtd_info *
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = doc2klist;
 		doc2klist = mtd;
@@ -633,7 +633,7 @@ static int doc_read(struct mtd_info *mtd
 static int doc_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
 			size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip;
 	unsigned char syndrome[6];
@@ -790,7 +790,7 @@ static int doc_write_ecc(struct mtd_info
 			 size_t * retlen, const u_char * buf,
 			 u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int di; /* Yes, DI is a hangover from when I was disassembling the binary driver */
 	void __iomem *docptr = this->virtadr;
 	volatile char dummy;
@@ -1033,7 +1033,7 @@ static int doc_writev_ecc(struct mtd_inf
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
 			size_t * retlen, u_char * buf)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int len256 = 0, ret;
 	struct Nand *mychip;
 
@@ -1091,7 +1091,7 @@ static int doc_read_oob(struct mtd_info 
 static int doc_write_oob_nolock(struct mtd_info *mtd, loff_t ofs, size_t len,
 				size_t * retlen, const u_char * buf)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	int len256 = 0;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
@@ -1194,7 +1194,7 @@ static int doc_write_oob_nolock(struct m
 static int doc_write_oob(struct mtd_info *mtd, loff_t ofs, size_t len,
  			 size_t * retlen, const u_char * buf)
 {
- 	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+ 	struct DiskOnChip *this = mtd->priv;
  	int ret;
 
  	down(&this->lock);
@@ -1206,7 +1206,7 @@ static int doc_write_oob(struct mtd_info
 
 static int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *) mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
 	volatile int dummy;
@@ -1288,12 +1288,12 @@ static void __exit cleanup_doc2000(void)
 	struct DiskOnChip *this;
 
 	while ((mtd = doc2klist)) {
-		this = (struct DiskOnChip *) mtd->priv;
+		this = mtd->priv;
 		doc2klist = this->nextdoc;
 
 		del_mtd_device(mtd);
 
-		iounmap((void *) this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
Index: linux-2.6.10/drivers/mtd/devices/doc2001.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/doc2001.c
+++ linux-2.6.10/drivers/mtd/devices/doc2001.c
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001.c,v 1.46 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: doc2001.c,v 1.47 2005/01/05 12:40:36 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -335,23 +335,23 @@ static const char im_name[] = "DoCMil_in
  */
 static void DoCMil_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 
 	/* We must avoid being called twice for the same device. */
 	if (docmillist)
-		old = (struct DiskOnChip *)docmillist->priv;
+		old = docmillist->priv;
 
 	while (old) {
 		if (DoCMil_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "
 			       "0x%lX - already configured\n", this->physadr);
-			iounmap((void *)this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *)old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -392,7 +392,7 @@ static void DoCMil_init(struct mtd_info 
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = docmillist;
 		docmillist = mtd;
@@ -416,7 +416,7 @@ static int doc_read_ecc (struct mtd_info
 	int i, ret;
 	volatile char dummy;
 	unsigned char syndrome[6];
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 
@@ -542,7 +542,7 @@ static int doc_write_ecc (struct mtd_inf
 {
 	int i,ret = 0;
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[to >> (this->chipshift)];
 
@@ -677,7 +677,7 @@ static int doc_read_oob(struct mtd_info 
 	int i;
 #endif
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
@@ -729,7 +729,7 @@ static int doc_write_oob(struct mtd_info
 #endif
 	volatile char dummy;
 	int ret = 0;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem *docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 
@@ -796,7 +796,7 @@ static int doc_write_oob(struct mtd_info
 int doc_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
 	void __iomem *docptr = this->virtadr;
@@ -868,12 +868,12 @@ static void __exit cleanup_doc2001(void)
 	struct DiskOnChip *this;
 
 	while ((mtd=docmillist)) {
-		this = (struct DiskOnChip *)mtd->priv;
+		this = mtd->priv;
 		docmillist = this->nextdoc;
 			
 		del_mtd_device(mtd);
 			
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
Index: linux-2.6.10/drivers/mtd/devices/doc2001plus.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/doc2001plus.c
+++ linux-2.6.10/drivers/mtd/devices/doc2001plus.c
@@ -6,7 +6,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001plus.c,v 1.11 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: doc2001plus.c,v 1.12 2005/01/05 12:40:36 dwmw2 Exp $
  *
  * Released under GPL
  */
@@ -190,7 +190,7 @@ static int DoC_SelectFloor(void __iomem 
    may not want it */
 static unsigned int DoC_GetDataOffset(struct mtd_info *mtd, loff_t *from)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 
 	if (this->interleave) {
 		unsigned int ofs = *from & 0x3ff;
@@ -458,24 +458,24 @@ static const char im_name[] = "DoCMilPlu
  */
 static void DoCMilPlus_init(struct mtd_info *mtd)
 {
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	struct DiskOnChip *old = NULL;
 
 	/* We must avoid being called twice for the same device. */
 	if (docmilpluslist)
-		old = (struct DiskOnChip *)docmilpluslist->priv;
+		old = docmilpluslist->priv;
 
 	while (old) {
 		if (DoCMilPlus_is_alias(this, old)) {
 			printk(KERN_NOTICE "Ignoring DiskOnChip Millennium "
 				"Plus at 0x%lX - already configured\n",
 				this->physadr);
-			iounmap((void *)this->virtadr);
+			iounmap(this->virtadr);
 			kfree(mtd);
 			return;
 		}
 		if (old->nextdoc)
-			old = (struct DiskOnChip *)old->nextdoc->priv;
+			old = old->nextdoc->priv;
 		else
 			old = NULL;
 	}
@@ -514,7 +514,7 @@ static void DoCMilPlus_init(struct mtd_i
 
 	if (!this->totlen) {
 		kfree(mtd);
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 	} else {
 		this->nextdoc = docmilpluslist;
 		docmilpluslist = mtd;
@@ -530,7 +530,7 @@ static int doc_dumpblk(struct mtd_info *
 {
 	int i;
 	loff_t fofs;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 	unsigned char *bp, buf[1056];
@@ -615,7 +615,7 @@ static int doc_read_ecc(struct mtd_info 
 	volatile char dummy;
 	loff_t fofs;
 	unsigned char syndrome[6];
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[from >> (this->chipshift)];
 
@@ -754,7 +754,7 @@ static int doc_write_ecc(struct mtd_info
 	int i, before, ret = 0;
 	loff_t fto;
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[to >> (this->chipshift)];
 
@@ -880,7 +880,7 @@ static int doc_read_oob(struct mtd_info 
 			size_t *retlen, u_char *buf)
 {
 	loff_t fofs, base;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 	size_t i, size, got, want;
@@ -958,7 +958,7 @@ static int doc_write_oob(struct mtd_info
 {
 	volatile char dummy;
 	loff_t fofs, base;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	void __iomem * docptr = this->virtadr;
 	struct Nand *mychip = &this->chips[ofs >> this->chipshift];
 	size_t i, size, got, want;
@@ -1058,7 +1058,7 @@ static int doc_write_oob(struct mtd_info
 int doc_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	volatile char dummy;
-	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
 	__u32 len = instr->len;
 	void __iomem * docptr = this->virtadr;
@@ -1134,12 +1134,12 @@ static void __exit cleanup_doc2001plus(v
 	struct DiskOnChip *this;
 
 	while ((mtd=docmilpluslist)) {
-		this = (struct DiskOnChip *)mtd->priv;
+		this = mtd->priv;
 		docmilpluslist = this->nextdoc;
 			
 		del_mtd_device(mtd);
 			
-		iounmap((void *)this->virtadr);
+		iounmap(this->virtadr);
 		kfree(this->chips);
 		kfree(mtd);
 	}
Index: linux-2.6.10/drivers/mtd/devices/docecc.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/docecc.c
+++ linux-2.6.10/drivers/mtd/devices/docecc.c
@@ -7,7 +7,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: docecc.c,v 1.5 2003/05/21 15:15:06 dwmw2 Exp $
+ * $Id: docecc.c,v 1.4 2001/10/02 15:05:13 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
Index: linux-2.6.10/drivers/mtd/devices/docprobe.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/docprobe.c
+++ linux-2.6.10/drivers/mtd/devices/docprobe.c
@@ -4,7 +4,7 @@
 /* (C) 1999 Machine Vision Holdings, Inc.			*/
 /* (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>		*/
 
-/* $Id: docprobe.c,v 1.43 2004/11/16 18:29:01 dwmw2 Exp $	*/
+/* $Id: docprobe.c,v 1.44 2005/01/05 12:40:36 dwmw2 Exp $	*/
 
 
 
@@ -62,7 +62,7 @@
 
 
 static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
-MODULE_PARM(doc_config_location, "l");
+module_param(doc_config_location, ulong, 0);
 MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
 static unsigned long __initdata doc_locations[] = {
@@ -84,19 +84,19 @@ static unsigned long __initdata doc_loca
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-	0xff000000,
+        0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-	0xff000000,
-#else
+        0xff000000,
+##else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0xffffffff };
 
 /* doccheck: Probe a given memory window to see if there's a DiskOnChip present */
 
-static inline int __init doccheck(unsigned long potential, unsigned long physadr)
+static inline int __init doccheck(void __iomem *potential, unsigned long physadr)
 {
-	unsigned long window=potential;
+	void __iomem *window=potential;
 	unsigned char tmp, tmpb, tmpc, ChipID;
 #ifndef DOC_PASSIVE_PROBE
 	unsigned char tmp2;
@@ -233,7 +233,7 @@ static int docfound;
 
 static void __init DoC_Probe(unsigned long physadr)
 {
-	unsigned long docptr;
+	void __iomem *docptr;
 	struct DiskOnChip *this;
 	struct mtd_info *mtd;
 	int ChipID;
@@ -243,7 +243,7 @@ static void __init DoC_Probe(unsigned lo
 	char *im_modname = NULL;
 	void (*initroutine)(struct mtd_info *) = NULL;
 
-	docptr = (unsigned long)ioremap(physadr, DOC_IOREMAP_LEN);
+	docptr = ioremap(physadr, DOC_IOREMAP_LEN);
 	
 	if (!docptr)
 		return;
@@ -252,7 +252,7 @@ static void __init DoC_Probe(unsigned lo
 		if (ChipID == DOC_ChipID_Doc2kTSOP) {
 			/* Remove this at your own peril. The hardware driver works but nothing prevents you from erasing bad blocks */
 			printk(KERN_NOTICE "Refusing to drive DiskOnChip 2000 TSOP until Bad Block Table is correctly supported by INFTL\n");
-			iounmap((void *)docptr);
+			iounmap(docptr);
 			return;
 		}
 		docfound = 1;
@@ -260,7 +260,7 @@ static void __init DoC_Probe(unsigned lo
 
 		if (!mtd) {
 			printk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");
-			iounmap((void *)docptr);
+			iounmap(docptr);
 			return;
 		}
 		
@@ -270,7 +270,7 @@ static void __init DoC_Probe(unsigned lo
 		memset((char *)this, 0, sizeof(struct DiskOnChip));
 
 		mtd->priv = this;
-		this->virtadr = (void __iomem *)docptr;
+		this->virtadr = docptr;
 		this->physadr = physadr;
 		this->ChipID = ChipID;
 		sprintf(namebuf, "with ChipID %2.2X", ChipID);
@@ -318,7 +318,7 @@ static void __init DoC_Probe(unsigned lo
 		printk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);
 		kfree(mtd);
 	}
-	iounmap((void *)docptr);
+	iounmap(docptr);
 }
 
 
Index: linux-2.6.10/drivers/mtd/devices/lart.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/lart.c
+++ linux-2.6.10/drivers/mtd/devices/lart.c
@@ -2,7 +2,7 @@
 /*
  * MTD driver for the 28F160F3 Flash Memory (non-CFI) on LART.
  *
- * $Id: lart.c,v 1.7 2004/08/09 13:19:44 dwmw2 Exp $
+ * $Id: lart.c,v 1.6 2004/07/14 17:21:38 dwmw2 Exp $
  *
  * Author: Abraham vd Merwe <abraham@2d3d.co.za>
  *
Index: linux-2.6.10/drivers/mtd/devices/ms02-nv.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/ms02-nv.c
+++ linux-2.6.10/drivers/mtd/devices/ms02-nv.c
@@ -6,7 +6,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	$Id: ms02-nv.c,v 1.7 2004/07/29 14:16:45 macro Exp $
+ *	$Id: ms02-nv.c,v 1.9 2005/06/20 12:22:50 macro Exp $
  */
 
 #include <linux/init.h>
@@ -59,7 +59,7 @@ static struct mtd_info *root_ms02nv_mtd;
 static int ms02nv_read(struct mtd_info *mtd, loff_t from,
 			size_t len, size_t *retlen, u_char *buf)
 {
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	if (from + len > mtd->size)
 		return -EINVAL;
@@ -73,7 +73,7 @@ static int ms02nv_read(struct mtd_info *
 static int ms02nv_write(struct mtd_info *mtd, loff_t to,
 			size_t len, size_t *retlen, const u_char *buf)
 {
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	if (to + len > mtd->size)
 		return -EINVAL;
@@ -99,8 +99,8 @@ static inline uint ms02nv_probe_one(ulon
 	 * The firmware writes MS02NV_ID at MS02NV_MAGIC and also
 	 * a diagnostic status at MS02NV_DIAG.
 	 */
-	ms02nv_diagp = (ms02nv_uint *)(KSEG1ADDR(addr + MS02NV_DIAG));
-	ms02nv_magicp = (ms02nv_uint *)(KSEG1ADDR(addr + MS02NV_MAGIC));
+	ms02nv_diagp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_DIAG));
+	ms02nv_magicp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_MAGIC));
 	err = get_dbe(ms02nv_magic, ms02nv_magicp);
 	if (err)
 		return 0;
@@ -233,7 +233,7 @@ static int __init ms02nv_init_one(ulong 
 		goto err_out_csr_res;
 	}
 
-	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %uMiB.\n",
+	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %zuMiB.\n",
 		mtd->index, ms02nv_name, addr, size >> 20);
 
 	mp->next = root_ms02nv_mtd;
@@ -265,7 +265,7 @@ err_out_mod_res:
 static void __exit ms02nv_remove_one(void)
 {
 	struct mtd_info *mtd = root_ms02nv_mtd;
-	struct ms02nv_private *mp = (struct ms02nv_private *)mtd->priv;
+	struct ms02nv_private *mp = mtd->priv;
 
 	root_ms02nv_mtd = mp->next;
 
Index: linux-2.6.10/drivers/mtd/devices/ms02-nv.h
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/ms02-nv.h
+++ linux-2.6.10/drivers/mtd/devices/ms02-nv.h
@@ -10,7 +10,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  *
- *	$Id: ms02-nv.h,v 1.3 2003/08/19 09:25:36 dwmw2 Exp $
+ *	$Id: ms02-nv.h,v 1.2 2003/08/19 09:24:35 dwmw2 Exp $
  */
 
 #include <linux/ioport.h>
Index: linux-2.6.10/drivers/mtd/devices/mtdram.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/mtdram.c
+++ linux-2.6.10/drivers/mtd/devices/mtdram.c
@@ -1,14 +1,13 @@
 /*
  * mtdram - a test mtd device
- * $Id: mtdram.c,v 1.34 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: mtdram.c,v 1.36 2005/03/17 19:44:27 gleixner Exp $
  * Author: Alexander Larsson <alex@cendio.se>
  *
  * Copyright (c) 1999 Alexander Larsson <alex@cendio.se>
+ * Copyright (c) 2005 Joern Engel <joern@wh.fh-wedel.de>
  *
  * This code is GPL
- *
  */
-
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -18,213 +17,140 @@
 #include <linux/mtd/compatmac.h>
 #include <linux/mtd/mtd.h>
 
-#ifndef CONFIG_MTDRAM_ABS_POS
-  #define CONFIG_MTDRAM_ABS_POS 0
-#endif
-
-#if CONFIG_MTDRAM_ABS_POS > 0
-  #include <asm/io.h>
-#endif
-
-#ifdef MODULE
 static unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;
 static unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;
-MODULE_PARM(total_size,"l");
-MODULE_PARM_DESC(total_size, "Total device size in KiB");
-MODULE_PARM(erase_size,"l");
-MODULE_PARM_DESC(erase_size, "Device erase block size in KiB");
 #define MTDRAM_TOTAL_SIZE (total_size * 1024)
 #define MTDRAM_ERASE_SIZE (erase_size * 1024)
-#else
-#define MTDRAM_TOTAL_SIZE (CONFIG_MTDRAM_TOTAL_SIZE * 1024)
-#define MTDRAM_ERASE_SIZE (CONFIG_MTDRAM_ERASE_SIZE * 1024)
-#endif
 
+#ifdef MODULE
+module_param(total_size, ulong, 0);
+MODULE_PARM_DESC(total_size, "Total device size in KiB");
+module_param(erase_size, ulong, 0);
+MODULE_PARM_DESC(erase_size, "Device erase block size in KiB");
+#endif
 
 // We could store these in the mtd structure, but we only support 1 device..
 static struct mtd_info *mtd_info;
 
-
-static int
-ram_erase(struct mtd_info *mtd, struct erase_info *instr)
+static int ram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-  DEBUG(MTD_DEBUG_LEVEL2, "ram_erase(pos:%ld, len:%ld)\n", (long)instr->addr, (long)instr->len);
-  if (instr->addr + instr->len > mtd->size) {
-    DEBUG(MTD_DEBUG_LEVEL1, "ram_erase() out of bounds (%ld > %ld)\n", (long)(instr->addr + instr->len), (long)mtd->size);
-    return -EINVAL;
-  }
-	
-  memset((char *)mtd->priv + instr->addr, 0xff, instr->len);
-	
-  instr->state = MTD_ERASE_DONE;
-  mtd_erase_callback(instr);
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+
+	memset((char *)mtd->priv + instr->addr, 0xff, instr->len);
 
-  return 0;
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
 }
 
-static int ram_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf)
+static int ram_point(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char **mtdbuf)
 {
-  if (from + len > mtd->size)
-    return -EINVAL;
-	
-  *mtdbuf = mtd->priv + from;
-  *retlen = len;
-  return 0;
+	if (from + len > mtd->size)
+		return -EINVAL;
+
+	*mtdbuf = mtd->priv + from;
+	*retlen = len;
+	return 0;
 }
 
-static void ram_unpoint (struct mtd_info *mtd, u_char *addr, loff_t from,
-			 size_t len)
+static void ram_unpoint(struct mtd_info *mtd, u_char * addr, loff_t from,
+		size_t len)
 {
-  DEBUG(MTD_DEBUG_LEVEL2, "ram_unpoint\n");
 }
 
 static int ram_read(struct mtd_info *mtd, loff_t from, size_t len,
-	     size_t *retlen, u_char *buf)
+		size_t *retlen, u_char *buf)
 {
-  DEBUG(MTD_DEBUG_LEVEL2, "ram_read(pos:%ld, len:%ld)\n", (long)from, (long)len);
-  if (from + len > mtd->size) {
-    DEBUG(MTD_DEBUG_LEVEL1, "ram_read() out of bounds (%ld > %ld)\n", (long)(from + len), (long)mtd->size);
-    return -EINVAL;
-  }
+	if (from + len > mtd->size)
+		return -EINVAL;
 
-  memcpy(buf, mtd->priv + from, len);
+	memcpy(buf, mtd->priv + from, len);
 
-  *retlen=len;
-  return 0;
+	*retlen = len;
+	return 0;
 }
 
 static int ram_write(struct mtd_info *mtd, loff_t to, size_t len,
-	      size_t *retlen, const u_char *buf)
+		size_t *retlen, const u_char *buf)
 {
-  DEBUG(MTD_DEBUG_LEVEL2, "ram_write(pos:%ld, len:%ld)\n", (long)to, (long)len);
-  if (to + len > mtd->size) {
-    DEBUG(MTD_DEBUG_LEVEL1, "ram_write() out of bounds (%ld > %ld)\n", (long)(to + len), (long)mtd->size);
-    return -EINVAL;
-  }
+	if (to + len > mtd->size)
+		return -EINVAL;
 
-  memcpy ((char *)mtd->priv + to, buf, len);
+	memcpy((char *)mtd->priv + to, buf, len);
 
-  *retlen=len;
-  return 0;
+	*retlen = len;
+	return 0;
 }
 
 static void __exit cleanup_mtdram(void)
 {
-  if (mtd_info) {
-    del_mtd_device(mtd_info);
-#if CONFIG_MTDRAM_TOTAL_SIZE > 0
-    if (mtd_info->priv)
-#if CONFIG_MTDRAM_ABS_POS > 0
-      iounmap(mtd_info->priv);
-#else
-      vfree(mtd_info->priv);
-#endif	
-#endif
-    kfree(mtd_info);
-  }
-}
-
-int mtdram_init_device(struct mtd_info *mtd, void *mapped_address, 
-                       unsigned long size, char *name)
-{
-   memset(mtd, 0, sizeof(*mtd));
+	if (mtd_info) {
+		del_mtd_device(mtd_info);
+		if (mtd_info->priv)
+			vfree(mtd_info->priv);
+		kfree(mtd_info);
+	}
+}
+
+int mtdram_init_device(struct mtd_info *mtd, void *mapped_address,
+		unsigned long size, char *name)
+{
+	memset(mtd, 0, sizeof(*mtd));
+
+	/* Setup the MTD structure */
+	mtd->name = name;
+	mtd->type = MTD_RAM;
+	mtd->flags = MTD_CAP_RAM;
+	mtd->size = size;
+	mtd->erasesize = MTDRAM_ERASE_SIZE;
+	mtd->priv = mapped_address;
+
+	mtd->owner = THIS_MODULE;
+	mtd->erase = ram_erase;
+	mtd->point = ram_point;
+	mtd->unpoint = ram_unpoint;
+	mtd->read = ram_read;
+	mtd->write = ram_write;
+
+	if (add_mtd_device(mtd)) {
+		return -EIO;
+	}
 
-   /* Setup the MTD structure */
-   mtd->name = name;
-   mtd->type = MTD_RAM;
-   mtd->flags = MTD_CAP_RAM;
-   mtd->size = size;
-   mtd->erasesize = MTDRAM_ERASE_SIZE;
-   mtd->priv = mapped_address;
-
-   mtd->owner = THIS_MODULE;
-   mtd->erase = ram_erase;
-   mtd->point = ram_point;
-   mtd->unpoint = ram_unpoint;
-   mtd->read = ram_read;
-   mtd->write = ram_write;
-
-   if (add_mtd_device(mtd)) {
-     return -EIO;
-   }
-   
-   return 0;
+	return 0;
 }
 
-#if CONFIG_MTDRAM_TOTAL_SIZE > 0
-#if CONFIG_MTDRAM_ABS_POS > 0
 static int __init init_mtdram(void)
 {
-  void *addr;
-  int err;
-  /* Allocate some memory */
-   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-   if (!mtd_info)
-     return -ENOMEM;
-   
-  addr = ioremap(CONFIG_MTDRAM_ABS_POS, MTDRAM_TOTAL_SIZE);
-  if (!addr) {
-    DEBUG(MTD_DEBUG_LEVEL1, 
-          "Failed to ioremap) memory region of size %ld at ABS_POS:%ld\n", 
-          (long)MTDRAM_TOTAL_SIZE, (long)CONFIG_MTDRAM_ABS_POS);
-    kfree(mtd_info);
-    mtd_info = NULL;
-    return -ENOMEM;
-  }
-  err = mtdram_init_device(mtd_info, addr, 
-                           MTDRAM_TOTAL_SIZE, "mtdram test device");
-  if (err) 
-  {
-    iounmap(addr);
-    kfree(mtd_info);
-    mtd_info = NULL;
-    return err;
-  }
-  memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
-  return err;
-}
+	void *addr;
+	int err;
 
-#else /* CONFIG_MTDRAM_ABS_POS > 0 */
+	if (!total_size)
+		return -EINVAL;
 
-static int __init init_mtdram(void)
-{
-  void *addr;
-  int err;
-  /* Allocate some memory */
-   mtd_info = (struct mtd_info *)kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-   if (!mtd_info)
-     return -ENOMEM;
-
-  addr = vmalloc(MTDRAM_TOTAL_SIZE);
-  if (!addr) {
-    DEBUG(MTD_DEBUG_LEVEL1, 
-          "Failed to vmalloc memory region of size %ld\n", 
-          (long)MTDRAM_TOTAL_SIZE);
-    kfree(mtd_info);
-    mtd_info = NULL;
-    return -ENOMEM;
-  }
-  err = mtdram_init_device(mtd_info, addr, 
-                           MTDRAM_TOTAL_SIZE, "mtdram test device");
-  if (err) 
-  {
-    vfree(addr);
-    kfree(mtd_info);
-    mtd_info = NULL;
-    return err;
-  }
-  memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
-  return err;
+	/* Allocate some memory */
+	mtd_info = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	if (!mtd_info)
+		return -ENOMEM;
+
+	addr = vmalloc(MTDRAM_TOTAL_SIZE);
+	if (!addr) {
+		kfree(mtd_info);
+		mtd_info = NULL;
+		return -ENOMEM;
+	}
+	err = mtdram_init_device(mtd_info, addr, MTDRAM_TOTAL_SIZE, "mtdram test device");
+	if (err) {
+		vfree(addr);
+		kfree(mtd_info);
+		mtd_info = NULL;
+		return err;
+	}
+	memset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);
+	return err;
 }
-#endif /* !(CONFIG_MTDRAM_ABS_POS > 0) */
-
-#else /* CONFIG_MTDRAM_TOTAL_SIZE > 0 */
-
-static int __init init_mtdram(void)
-{
-  return 0;
-}
-#endif /* !(CONFIG_MTDRAM_TOTAL_SIZE > 0) */
 
 module_init(init_mtdram);
 module_exit(cleanup_mtdram);
@@ -232,4 +158,3 @@ module_exit(cleanup_mtdram);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Alexander Larsson <alexl@redhat.com>");
 MODULE_DESCRIPTION("Simulated MTD driver for testing");
-
Index: linux-2.6.10/drivers/mtd/devices/phram.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/phram.c
+++ linux-2.6.10/drivers/mtd/devices/phram.c
@@ -1,13 +1,8 @@
 /**
+ * $Id: phram.c,v 1.13 2005/03/07 20:53:25 joern Exp $
  *
- * $Id: phram.c,v 1.6 2004/11/25 16:51:09 joern Exp $
- *
- * Copyright (c) Jochen Schaeuble <psionic@psionic.de>
- * 07/2003	rewritten by Joern Engel <joern@wh.fh-wedel.de>
- *
- * DISCLAIMER:  This driver makes use of Rusty's excellent module code,
- * so it will not work for 2.4 without changes and it wont work for 2.4
- * as a module without major changes.  Oh well!
+ * Copyright (c) ????		Jochen Schäuble <psionic@psionic.de>
+ * Copyright (c) 2003-2004	Jörn Engel <joern@wh.fh-wedel.de>
  *
  * Usage:
  *
@@ -19,10 +14,8 @@
  * gigabytes.
  *
  * Example:
- *	phram=swap,896Mi,110Mi phram=test,1006Mi,1Mi
- *
+ *	phram=swap,64Mi,128Mi phram=test,900Mi,1Mi
  */
-
 #include <asm/io.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -34,17 +27,16 @@
 #define ERROR(fmt, args...) printk(KERN_ERR "phram: " fmt , ## args)
 
 struct phram_mtd_list {
+	struct mtd_info mtd;
 	struct list_head list;
-	struct mtd_info *mtdinfo;
 };
 
 static LIST_HEAD(phram_list);
 
 
-
 static int phram_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (instr->addr + instr->len > mtd->size)
 		return -EINVAL;
@@ -66,7 +58,7 @@ static int phram_erase(struct mtd_info *
 static int phram_point(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char **mtdbuf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
 	if (from + len > mtd->size)
 		return -EINVAL;
@@ -76,17 +68,21 @@ static int phram_point(struct mtd_info *
 	return 0;
 }
 
-static void phram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from, size_t len)
+static void phram_unpoint(struct mtd_info *mtd, u_char *addr, loff_t from,
+		size_t len)
 {
 }
 
 static int phram_read(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char *buf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
-	if (from + len > mtd->size)
+	if (from >= mtd->size)
 		return -EINVAL;
+
+	if (len > mtd->size - from)
+		len = mtd->size - from;
 	
 	memcpy(buf, start + from, len);
 
@@ -97,10 +93,13 @@ static int phram_read(struct mtd_info *m
 static int phram_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	u_char *start = (u_char *)mtd->priv;
+	u_char *start = mtd->priv;
 
-	if (to + len > mtd->size)
+	if (to >= mtd->size)
 		return -EINVAL;
+
+	if (len > mtd->size - to)
+		len = mtd->size - to;
 	
 	memcpy(start + to, buf, len);
 
@@ -112,12 +111,11 @@ static int phram_write(struct mtd_info *
 
 static void unregister_devices(void)
 {
-	struct phram_mtd_list *this;
+	struct phram_mtd_list *this, *safe;
 
-	list_for_each_entry(this, &phram_list, list) {
-		del_mtd_device(this->mtdinfo);
-		iounmap(this->mtdinfo->priv);
-		kfree(this->mtdinfo);
+	list_for_each_entry_safe(this, safe, &phram_list, list) {
+		del_mtd_device(&this->mtd);
+		iounmap(this->mtd.priv);
 		kfree(this);
 	}
 }
@@ -131,45 +129,39 @@ static int register_device(char *name, u
 	if (!new)
 		goto out0;
 
-	new->mtdinfo = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
-	if (!new->mtdinfo)
-		goto out1;
-	
-	memset(new->mtdinfo, 0, sizeof(struct mtd_info));
+	memset(new, 0, sizeof(*new));
 
 	ret = -EIO;
-	new->mtdinfo->priv = ioremap(start, len);
-	if (!new->mtdinfo->priv) {
+	new->mtd.priv = ioremap(start, len);
+	if (!new->mtd.priv) {
 		ERROR("ioremap failed\n");
-		goto out2;
+		goto out1;
 	}
 
 
-	new->mtdinfo->name = name;
-	new->mtdinfo->size = len;
-	new->mtdinfo->flags = MTD_CAP_RAM | MTD_ERASEABLE | MTD_VOLATILE;
-        new->mtdinfo->erase = phram_erase;
-	new->mtdinfo->point = phram_point;
-	new->mtdinfo->unpoint = phram_unpoint;
-	new->mtdinfo->read = phram_read;
-	new->mtdinfo->write = phram_write;
-	new->mtdinfo->owner = THIS_MODULE;
-	new->mtdinfo->type = MTD_RAM;
-	new->mtdinfo->erasesize = 0x0;
+	new->mtd.name = name;
+	new->mtd.size = len;
+	new->mtd.flags = MTD_CAP_RAM | MTD_ERASEABLE | MTD_VOLATILE;
+        new->mtd.erase = phram_erase;
+	new->mtd.point = phram_point;
+	new->mtd.unpoint = phram_unpoint;
+	new->mtd.read = phram_read;
+	new->mtd.write = phram_write;
+	new->mtd.owner = THIS_MODULE;
+	new->mtd.type = MTD_RAM;
+	new->mtd.erasesize = PAGE_SIZE;
 
 	ret = -EAGAIN;
-	if (add_mtd_device(new->mtdinfo)) {
+	if (add_mtd_device(&new->mtd)) {
 		ERROR("Failed to register new device\n");
-		goto out3;
+		goto out2;
 	}
 
 	list_add_tail(&new->list, &phram_list);
 	return 0;	
 
-out3:
-	iounmap(new->mtdinfo->priv);
 out2:
-	kfree(new->mtdinfo);
+	iounmap(new->mtd.priv);
 out1:
 	kfree(new);
 out0:
@@ -226,6 +218,15 @@ static int parse_name(char **pname, cons
 	return 0;
 }
 
+
+static inline void kill_final_newline(char *str)
+{
+	char *newline = strrchr(str, '\n');
+	if (newline && !newline[1])
+		*newline = 0;
+}
+
+
 #define parse_err(fmt, args...) do {	\
 	ERROR(fmt , ## args);	\
 	return 0;		\
@@ -244,6 +245,7 @@ static int phram_setup(const char *val, 
 		parse_err("parameter too long\n");
 
 	strcpy(str, val);
+	kill_final_newline(str);
 
 	for (i=0; i<3; i++)
 		token[i] = strsep(&str, ",");
@@ -276,73 +278,7 @@ static int phram_setup(const char *val, 
 }
 
 module_param_call(phram, phram_setup, NULL, NULL, 000);
-MODULE_PARM_DESC(phram, "Memory region to map. \"map=<name>,<start><length>\"");
-
-/*
- * Just for compatibility with slram, this is horrible and should go someday.
- */
-static int __init slram_setup(const char *val, struct kernel_param *kp)
-{
-	char buf[256], *str = buf;
-
-	if (!val || !val[0])
-		parse_err("no arguments to \"slram=\"\n");
-
-	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
-		parse_err("parameter too long\n");
-
-	strcpy(str, val);
-
-	while (str) {
-		char *token[3];
-		char *name;
-		uint32_t start;
-		uint32_t len;
-		int i, ret;
-
-		for (i=0; i<3; i++) {
-			token[i] = strsep(&str, ",");
-			if (token[i])
-				continue;
-			parse_err("wrong number of arguments to \"slram=\"\n");
-		}
-
-		/* name */
-		ret = parse_name(&name, token[0]);
-		if (ret == -ENOMEM)
-			parse_err("of memory\n");
-		if (ret == -ENOSPC)
-			parse_err("too long\n");
-		if (ret)
-			return 1;
-
-		/* start */
-		ret = parse_num32(&start, token[1]);
-		if (ret)
-			parse_err("illegal start address\n");
-
-		/* len */
-		if (token[2][0] == '+')
-			ret = parse_num32(&len, token[2] + 1);
-		else
-			ret = parse_num32(&len, token[2]);
-
-		if (ret)
-			parse_err("illegal device length\n");
-
-		if (token[2][0] != '+') {
-			if (len < start)
-				parse_err("end < start\n");
-			len -= start;
-		}
-
-		register_device(name, start, len);
-	}
-	return 1;
-}
-
-module_param_call(slram, slram_setup, NULL, NULL, 000);
-MODULE_PARM_DESC(slram, "List of memory regions to map. \"map=<name>,<start><length/end>\"");
+MODULE_PARM_DESC(phram,"Memory region to map. \"map=<name>,<start>,<length>\"");
 
 
 static int __init init_phram(void)
Index: linux-2.6.10/drivers/mtd/devices/pmc551.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/pmc551.c
+++ linux-2.6.10/drivers/mtd/devices/pmc551.c
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.c,v 1.29 2004/11/16 18:29:01 dwmw2 Exp $
+ * $Id: pmc551.c,v 1.30 2005/01/05 18:05:13 dwmw2 Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -113,7 +113,7 @@ static struct mtd_info *pmc551list;
 
 static int pmc551_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -176,7 +176,7 @@ out:
 
 static int pmc551_point (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi;
         u32 soff_lo;
 
@@ -217,7 +217,7 @@ static void pmc551_unpoint (struct mtd_i
 
 static int pmc551_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -279,7 +279,7 @@ out:
 
 static int pmc551_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-        struct mypriv *priv = (struct mypriv *)mtd->priv;
+        struct mypriv *priv = mtd->priv;
         u32 soff_hi, soff_lo; /* start address offset hi/lo */
         u32 eoff_hi, eoff_lo; /* end address offset hi/lo */
         unsigned long end;
@@ -630,10 +630,6 @@ static u32 fixup_pmc551 (struct pci_dev 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mark Ferrell <mferrell@mvista.com>");
 MODULE_DESCRIPTION(PMC551_VERSION);
-MODULE_PARM(msize, "i");
-MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
-MODULE_PARM(asize, "i");
-MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
 
 /*
  * Stuff these outside the ifdef so as to not bust compiled in driver support
@@ -645,6 +641,11 @@ static int asize=CONFIG_MTD_PMC551_APERT
 static int asize=0;
 #endif
 
+module_param(msize, int, 0);
+MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
+module_param(asize, int, 0);
+MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
+
 /*
  * PMC551 Card Initialization
  */
@@ -820,7 +821,7 @@ static void __exit cleanup_pmc551(void)
 	struct mypriv *priv;
 
 	while((mtd=pmc551list)) {
-		priv = (struct mypriv *)mtd->priv;
+		priv = mtd->priv;
 		pmc551list = priv->nextpmc551;
 		
 		if(priv->start) {
Index: linux-2.6.10/drivers/mtd/devices/ramtd.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/devices/ramtd.c
@@ -0,0 +1,197 @@
+/**
+ * Simple mtd driver that dynamically allocates/frees memory
+ *
+ * $Id: ramtd.c,v 1.4 2005/05/20 15:08:21 joern Exp $
+ *
+ * Copyright (c) 2005 Joern Engel <joern@wh.fh-wedel.de>
+ */
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/vmalloc.h>
+
+struct ramtd {
+	struct mtd_info mtd;
+	struct list_head list;
+	u32 size;
+	void *page[];
+};
+
+static LIST_HEAD(ramtd_list);
+static DECLARE_MUTEX(ramtd_mutex);
+
+
+static void *get_pool_page(void)
+{
+	void *ret = (void*)__get_free_page(GFP_KERNEL);
+	return ret;
+}
+
+
+static void free_pool_page(void *page)
+{
+	free_page((unsigned long)page);
+}
+
+
+static int ramtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct ramtd *ramtd = container_of(mtd, typeof(*ramtd), mtd);
+	u32 addr = instr->addr;
+	u32 len = instr->len;
+
+	if (addr + len > mtd->size)
+		return -EINVAL;
+	if (addr % PAGE_SIZE)
+		return -EINVAL;
+	if (len % PAGE_SIZE)
+		return -EINVAL;
+
+	while (len) {
+		u32 page = addr / PAGE_SIZE;
+
+		down_interruptible(&ramtd_mutex);
+		free_pool_page(ramtd->page[page]);
+		ramtd->page[page] = NULL;
+		up(&ramtd_mutex);
+
+		addr += PAGE_SIZE;
+		len -= PAGE_SIZE;
+	}
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+
+static int ramtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct ramtd *ramtd = container_of(mtd, typeof(*ramtd), mtd);
+
+	if (from >= mtd->size)
+		return -EINVAL;
+
+	if (len > mtd->size - from)
+		len = mtd->size - from;
+
+	*retlen = 0;
+	while (len) {
+		u32 page = from / PAGE_SIZE;
+		u32 ofs = from % PAGE_SIZE;
+		u32 rlen = min_t(u32, len, PAGE_SIZE - ofs);
+
+		down_interruptible(&ramtd_mutex);
+		if (!ramtd->page[page])
+			memset(buf, 0xff, rlen);
+		else
+			memcpy(buf, ramtd->page[page] + ofs, rlen);
+		up(&ramtd_mutex);
+
+		buf += rlen;
+		from += rlen;
+		*retlen += rlen;
+		len -= rlen;
+	}
+	return 0;
+}
+
+
+static int ramtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	struct ramtd *ramtd = container_of(mtd, typeof(*ramtd), mtd);
+
+	if (to >= mtd->size)
+		return -EINVAL;
+
+	if (len > mtd->size - to)
+		len = mtd->size - to;
+
+	*retlen = 0;
+	while (len) {
+		u32 page = to / PAGE_SIZE;
+		u32 ofs = to % PAGE_SIZE;
+		u32 wlen = min_t(u32, len, PAGE_SIZE - ofs);
+
+		down_interruptible(&ramtd_mutex);
+		if (!ramtd->page[page]) {
+			ramtd->page[page] = get_pool_page();
+			memset(ramtd->page[page], 0xff, PAGE_SIZE);
+		}
+		if (!ramtd->page[page])
+			return -EIO;
+
+		memcpy(ramtd->page[page] + ofs, buf, wlen);
+		up(&ramtd_mutex);
+
+		buf += wlen;
+		to += wlen;
+		*retlen += wlen;
+		len -= wlen;
+	}
+	return 0;
+}
+
+
+static int register_device(const char *name, u32 size)
+{
+	struct ramtd *new;
+	u32 pages_size;
+
+	size = PAGE_ALIGN(size);
+	pages_size = size / PAGE_SIZE * sizeof(void*);
+	new = vmalloc(sizeof(*new) + pages_size);
+	if (!new)
+		return -ENOMEM;
+	memset(new, 0, sizeof(*new) + pages_size);
+
+	new->mtd.name = (char*)name;
+	new->mtd.size = size;
+	new->mtd.flags = MTD_CAP_RAM | MTD_ERASEABLE | MTD_VOLATILE;
+	new->mtd.owner = THIS_MODULE;
+	new->mtd.type = MTD_RAM;
+	new->mtd.erasesize = PAGE_SIZE;
+	new->mtd.write = ramtd_write;
+	new->mtd.read = ramtd_read;
+	new->mtd.erase = ramtd_erase;
+
+	if (add_mtd_device(&new->mtd)) {
+		free_pool_page(new);
+		return -EAGAIN;
+	}
+
+	down_interruptible(&ramtd_mutex);
+	list_add(&new->list, &ramtd_list);
+	up(&ramtd_mutex);
+	return 0;
+}
+
+
+static int __init ramtd_init(void)
+{
+	return register_device("ramtd", 4*1024*1024); /* FIXME */
+}
+
+static void __exit ramtd_exit(void)
+{
+	struct ramtd *this, *next;
+
+	down_interruptible(&ramtd_mutex);
+	list_for_each_entry_safe(this, next, &ramtd_list, list) {
+		del_mtd_device(&this->mtd);
+		kfree(this);
+	}
+	up(&ramtd_mutex);
+}
+
+
+module_init(ramtd_init);
+module_exit(ramtd_exit);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Joern Engel <joern@wh.fh-wedel.de>");
+MODULE_DESCRIPTION("MTD using dynamic memory allocation");
Index: linux-2.6.10/drivers/mtd/devices/slram.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/slram.c
+++ linux-2.6.10/drivers/mtd/devices/slram.c
@@ -1,6 +1,6 @@
 /*======================================================================
 
-  $Id: slram.c,v 1.32 2004/11/16 18:29:01 dwmw2 Exp $
+  $Id: slram.c,v 1.34 2005/01/06 21:16:42 jwboyer Exp $
 
   This driver provides a method to access memory not used by the kernel
   itself (i.e. if the kernel commandline mem=xxx is used). To actually
@@ -50,6 +50,7 @@
 #include <linux/mtd/mtd.h>
 
 #define SLRAM_MAX_DEVICES_PARAMS 6		/* 3 parameters / device */
+#define SLRAM_BLK_SZ 0x4000
 
 #define T(fmt, args...) printk(KERN_DEBUG fmt, ## args)
 #define E(fmt, args...) printk(KERN_NOTICE fmt, ## args)
@@ -66,13 +67,13 @@ typedef struct slram_mtd_list {
 
 #ifdef MODULE
 static char *map[SLRAM_MAX_DEVICES_PARAMS];
+
+module_param_array(map, charp, NULL, 0);
+MODULE_PARM_DESC(map, "List of memory regions to map. \"map=<name>, <start>, <length / end>\"");
 #else
 static char *map;
 #endif
 
-MODULE_PARM(map, "3-" __MODULE_STRING(SLRAM_MAX_DEVICES_PARAMS) "s");
-MODULE_PARM_DESC(map, "List of memory regions to map. \"map=<name>, <start>, <length / end>\"");
-
 static slram_mtd_list_t *slram_mtdlist = NULL;
 
 static int slram_erase(struct mtd_info *, struct erase_info *);
@@ -106,7 +107,10 @@ static int slram_erase(struct mtd_info *
 static int slram_point(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char **mtdbuf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	slram_priv_t *priv = mtd->priv;
+
+	if (from + len > mtd->size)
+		return -EINVAL;
 
 	*mtdbuf = priv->start + from;
 	*retlen = len;
@@ -120,8 +124,14 @@ static void slram_unpoint(struct mtd_inf
 static int slram_read(struct mtd_info *mtd, loff_t from, size_t len,
 		size_t *retlen, u_char *buf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
-	
+	slram_priv_t *priv = mtd->priv;
+
+	if (from > mtd->size)
+		return -EINVAL;
+
+	if (from + len > mtd->size)
+		len = mtd->size - from;
+
 	memcpy(buf, priv->start + from, len);
 
 	*retlen = len;
@@ -131,7 +141,10 @@ static int slram_read(struct mtd_info *m
 static int slram_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, const u_char *buf)
 {
-	slram_priv_t *priv = (slram_priv_t *)mtd->priv;
+	slram_priv_t *priv = mtd->priv;
+
+	if (to + len > mtd->size)
+		return -EINVAL;
 
 	memcpy(priv->start + to, buf, len);
 
@@ -161,7 +174,7 @@ static int register_device(char *name, u
 	if ((*curmtd)->mtdinfo)	{
 		memset((char *)(*curmtd)->mtdinfo, 0, sizeof(struct mtd_info));
 		(*curmtd)->mtdinfo->priv =
-			(void *)kmalloc(sizeof(slram_priv_t), GFP_KERNEL);
+			kmalloc(sizeof(slram_priv_t), GFP_KERNEL);
 		
 		if (!(*curmtd)->mtdinfo->priv) {
 			kfree((*curmtd)->mtdinfo);
@@ -188,7 +201,7 @@ static int register_device(char *name, u
 	(*curmtd)->mtdinfo->name = name;
 	(*curmtd)->mtdinfo->size = length;
 	(*curmtd)->mtdinfo->flags = MTD_CLEAR_BITS | MTD_SET_BITS |
-					MTD_WRITEB_WRITEABLE | MTD_VOLATILE;
+					MTD_WRITEB_WRITEABLE | MTD_VOLATILE | MTD_CAP_RAM;
         (*curmtd)->mtdinfo->erase = slram_erase;
 	(*curmtd)->mtdinfo->point = slram_point;
 	(*curmtd)->mtdinfo->unpoint = slram_unpoint;
@@ -196,7 +209,7 @@ static int register_device(char *name, u
 	(*curmtd)->mtdinfo->write = slram_write;
 	(*curmtd)->mtdinfo->owner = THIS_MODULE;
 	(*curmtd)->mtdinfo->type = MTD_RAM;
-	(*curmtd)->mtdinfo->erasesize = 0x0;
+	(*curmtd)->mtdinfo->erasesize = SLRAM_BLK_SZ;
 
 	if (add_mtd_device((*curmtd)->mtdinfo))	{
 		E("slram: Failed to register new device\n");
@@ -261,7 +274,7 @@ static int parse_cmdline(char *devname, 
 	}
 	T("slram: devname=%s, devstart=0x%lx, devlength=0x%lx\n",
 			devname, devstart, devlength);
-	if ((devstart < 0) || (devlength < 0)) {
+	if ((devstart < 0) || (devlength < 0) || (devlength % SLRAM_BLK_SZ != 0)) {
 		E("slram: Illegal start / length parameter.\n");
 		return(-EINVAL);
 	}
Index: linux-2.6.10/drivers/mtd/ftl.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/ftl.c
+++ linux-2.6.10/drivers/mtd/ftl.c
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $
+ * $Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -80,7 +80,7 @@
 
 /* Parameters that can be set with 'insmod' */
 static int shuffle_freq = 50;
-MODULE_PARM(shuffle_freq, "i");
+module_param(shuffle_freq, int, 0);
 
 /*====================================================================*/
 
@@ -357,6 +357,7 @@ static int erase_xfer(partition_t *part,
     if (!erase) 
             return -ENOMEM;
 
+    erase->mtd = part->mbd.mtd;
     erase->callback = ftl_erase_callback;
     erase->addr = xfer->Offset;
     erase->len = 1 << part->header.EraseUnitSize;
@@ -1096,7 +1097,7 @@ struct mtd_blktrans_ops ftl_tr = {
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }
Index: linux-2.6.10/drivers/mtd/inftlcore.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/inftlcore.c
+++ linux-2.6.10/drivers/mtd/inftlcore.c
@@ -7,7 +7,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * Author: David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: inftlcore.c,v 1.18 2004/11/16 18:28:59 dwmw2 Exp $
+ * $Id: inftlcore.c,v 1.17 2004/08/09 13:56:48 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -893,7 +893,7 @@ extern char inftlmountrev[];
 
 static int __init init_inftl(void)
 {
-	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.18 $, "
+	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.17 $, "
 		"inftlmount.c %s\n", inftlmountrev);
 
 	return register_mtd_blktrans(&inftl_tr);
Index: linux-2.6.10/drivers/mtd/inftlmount.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/inftlmount.c
+++ linux-2.6.10/drivers/mtd/inftlmount.c
@@ -8,7 +8,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: inftlmount.c,v 1.16 2004/11/22 13:50:53 kalev Exp $
+ * $Id: inftlmount.c,v 1.15 2004/11/05 21:55:55 kalev Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,7 +41,7 @@
 #include <linux/mtd/inftl.h>
 #include <linux/mtd/compatmac.h>
 
-char inftlmountrev[]="$Revision: 1.16 $";
+char inftlmountrev[]="$Revision: 1.15 $";
 
 /*
  * find_boot_record: Find the INFTL Media Header and its Spare copy which
Index: linux-2.6.10/drivers/mtd/maps/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/Kconfig
+++ linux-2.6.10/drivers/mtd/maps/Kconfig
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id: Kconfig,v 1.38 2004/11/24 19:42:51 rpurdie Exp $
+# $Id: Kconfig,v 1.55 2005/07/02 01:53:24 tpoynor Exp $
 
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
@@ -60,6 +60,92 @@ config MTD_PHYSMAP_BANKWIDTH
 	  Ignore this option if you use run-time physmap configuration
 	  (i.e., run-time calling physmap_configure()).
 
+config MTD_MULTI_PHYSMAP
+	tristate "multiple CFI Flash devices in physical memory map"
+	depends on MTD_CFI
+	help
+	  Similar to MTD_PHYSMAP, just allows several seperate mappings.
+
+config MTD_MULTI_PHYSMAP_1_NAME
+	string "1st mapping name"
+	depends on MTD_MULTI_PHYSMAP
+	default ""
+
+config MTD_MULTI_PHYSMAP_1_START
+	hex "1st mapping start"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_1_LEN
+	hex "1st mapping length"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_1_WIDTH
+	int "1st mapping bus width - 0 disables mapping"
+	depends on MTD_MULTI_PHYSMAP
+	default "2"
+
+config MTD_MULTI_PHYSMAP_2_NAME
+	string "2nd mapping name"
+	depends on MTD_MULTI_PHYSMAP
+	default ""
+
+config MTD_MULTI_PHYSMAP_2_START
+	hex "2nd mapping start"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_2_LEN
+	hex "2nd mapping length"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_2_WIDTH
+	int "2nd mapping bus width - 0 disables mapping"
+	depends on MTD_MULTI_PHYSMAP
+	default "2"
+
+config MTD_MULTI_PHYSMAP_3_NAME
+	string "3rd mapping name"
+	depends on MTD_MULTI_PHYSMAP
+	default ""
+
+config MTD_MULTI_PHYSMAP_3_START
+	hex "3rd mapping start"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_3_LEN
+	hex "3rd mapping length"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_3_WIDTH
+	int "3rd mapping bus width - 0 disables mapping"
+	depends on MTD_MULTI_PHYSMAP
+	default "2"
+
+config MTD_MULTI_PHYSMAP_4_NAME
+	string "4th mapping name"
+	depends on MTD_MULTI_PHYSMAP
+	default ""
+
+config MTD_MULTI_PHYSMAP_4_START
+	hex "4th mapping start"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_4_LEN
+	hex "4th mapping length"
+	depends on MTD_MULTI_PHYSMAP
+	default "0x00000000"
+
+config MTD_MULTI_PHYSMAP_4_WIDTH
+	int "4th mapping bus width - 0 disables mapping"
+	depends on MTD_MULTI_PHYSMAP
+	default "2"
+
 config MTD_SUN_UFLASH
 	tristate "Sun Microsystems userflash support"
 	depends on (SPARC32 || SPARC64) && MTD_CFI
@@ -94,17 +180,17 @@ config MTD_NETSC520
 
 config MTD_TS5500
 	tristate "JEDEC Flash device mapped on Technologic Systems TS-5500"
-	depends on X86 && MTD_JEDECPROBE && MTD_PARTITIONS
+	depends on ELAN
+	select MTD_PARTITIONS
+	select MTD_JEDECPROBE
+	select MTD_CFI_AMDSTD
 	help
 	  This provides a driver for the on-board flash of the Technologic
-	  System's TS-5500 board. The flash is split into 3 partitions
+	  System's TS-5500 board. The 2MB flash is split into 3 partitions
 	  which are accessed as separate MTD devices.
 
-	  mtd0 and mtd2 are the two BIOS drives. Unfortunately the BIOS
-	  uses a proprietary flash translation layer from General Software,
-	  which is not supported (the drives cannot be mounted). You can
-	  create your own file system (jffs for example), but the BIOS
-	  won't be able to boot from it.
+	  mtd0 and mtd2 are the two BIOS drives, which use the resident
+	  flash disk (RFD) flash translation layer.
 
 	  mtd1 allows you to reprogram your BIOS. BE VERY CAREFUL.
 
@@ -167,7 +253,7 @@ config MTD_VMAX
 
 config MTD_SCx200_DOCFLASH
 	tristate "Flash device mapped with DOCCS on NatSemi SCx200"
-	depends on X86 && MTD_CFI && MTD_PARTITIONS
+	depends on SCx200 && MTD_CFI && MTD_PARTITIONS
 	help
 	  Enable support for a flash chip mapped using the DOCCS signal on a
 	  National Semiconductor SCx200 processor.
@@ -209,57 +295,23 @@ config MTD_TSUNAMI
 	help
 	  Support for the flash chip on Tsunami TIG bus.
 
+config MTD_LASAT
+	tristate "Flash chips on LASAT board"
+	depends on LASAT
+	help
+	  Support for the flash chips on the Lasat 100 and 200 boards.
+
 config MTD_NETtel
 	tristate "CFI flash device on SnapGear/SecureEdge"
 	depends on X86 && MTD_PARTITIONS && MTD_JEDECPROBE
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
-config MTD_PB1550
-	tristate "Flash devices on Alchemy PB1550 board"
-	depends on MIPS && MIPS_PB1550
-	help
-	  Flash memory access on Alchemy Pb1550 board
-
-config MTD_PB1550_BOOT
-	bool "PB1550 boot flash device"
-	depends on MTD_PB1550
-	help
-	  Use the first of the two 64MiB flash banks on Pb1550 board.
-	  You can say 'Y' to both this and 'MTD_PB1550_USER' below, to use
-	  both banks.
-
-config MTD_PB1550_USER
-	bool "PB1550 user flash device"
-	depends on MTD_PB1550
-	default y if MTD_PB1550_BOOT = n
-	help
-	  Use the second of the two 64MiB flash banks on Pb1550 board.
-	  You can say 'Y' to both this and 'MTD_PB1550_BOOT' above, to use
-	  both banks.
-
-config MTD_DB1550
-	tristate "Flash devices on Alchemy DB1550 board"
-	depends on MIPS && MIPS_DB1550
-	help
-	  Flash memory access on Alchemy Db1550 board
-
-config MTD_DB1550_BOOT
-	bool "DB1550 boot flash device"
-	depends on MTD_DB1550
-	help
-	  Use the first of the two 64MiB flash banks on Db1550 board.
-	  You can say 'Y' to both this and 'MTD_DB1550_USER' below, to use
-	  both banks.
-
-config MTD_DB1550_USER
-	bool "DB1550 user flash device"
-	depends on MTD_DB1550
-	default y if MTD_DB1550_BOOT = n
-	help
-	  Use the second of the two 64MiB flash banks on Db1550 board.
-	  You can say 'Y' to both this and 'MTD_DB1550_BOOT' above, to use
-	  both banks.
+config MTD_ALCHEMY
+	tristate '  AMD Alchemy Pb1xxx/Db1xxx/RDK MTD support' 
+	depends on MIPS && SOC_AU1X00
+	help
+	  Flash memory access on AMD Alchemy Pb/Db/RDK Reference Boards
 
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
@@ -333,83 +385,9 @@ config MTD_CFI_FLAGADM
 	tristate "CFI Flash device mapping on FlagaDM"
 	depends on PPC32 && 8xx && MTD_CFI
 	help
-	  Mapping for the Flaga digital module. If you don´t have one, ignore
+	  Mapping for the Flaga digital module. If you don't have one, ignore
 	  this setting.
 
-config MTD_PB1000
-	tristate "Pb1000 Boot Flash device"
-	depends on MIPS && MIPS_PB1000
-	help
-	  Flash memory access on Alchemy Pb1000
-
-config MTD_PB1100
-	tristate "Pb1100 Flash device"
-	depends on MIPS && MIPS_PB1100
-	help
-	  Flash memory access on Alchemy Pb1100
-
-config MTD_PB1500
-	tristate "Pb1500 Flash device"
-	depends on MIPS && MIPS_PB1500
-	help
-	  Flash memory access on Alchemy Pb1500
-
-config MTD_PB1500_BOOT
-	bool "Pb1100/Pb1500 Boot Flash device"
-	depends on MIPS && (MTD_PB1500 || MTD_PB1100)
-	help
-	  Use the first of the two 32MB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and the USER flash option, to use
-	  both banks.
-
-config MTD_PB1500_USER
-	bool "Pb1100/Pb1500 User Flash device (2nd 32MB bank)"
-	depends on MIPS && (MTD_PB1500 || MTD_PB1100)
-	help
-	  Use the second of the two 32MB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and the BOOT flash option, to use
-	  both banks.
-
-config MTD_DB1X00
-	tristate "Db1X00 Flash device"
-	depends on MIPS && (MIPS_DB1000 || MIPS_DB1100 || MIPS_DB1500)
-	help
-	  Flash memory access on Alchemy Db1X00 Boards
-
-config MTD_DB1X00_BOOT
-	bool "Db1X00 Boot Flash device"
-	depends on MIPS && MTD_DB1X00
-	help
-	  Use the first of the two 32MB flash banks on Db1X00 board.
-	  You can say 'Y' to both this and the USER flash option, to use
-	  both banks.
-
-config MTD_DB1X00_USER
-	bool "Db1X00 User Flash device (2nd 32MB bank)"
-	depends on MIPS && MTD_DB1X00
-	help
-	  Use the second of the two 32MB flash banks on Db1X00 boards.
-	  You can say 'Y' to both this and the BOOT flash option, to use
-	  both banks.
-
-config MTD_BOSPORUS
-	tristate "Bosporus Flash device"
-	depends on MIPS && MIPS_BOSPORUS
-	help
-	  Flash memory access on Alchemy Bosporus Board
-
-config MTD_XXS1500
-	tristate "MyCable XXS1500 Flash device"
-	depends on MIPS && MIPS_XXS1500
-	help
-	  Flash memory access on MyCable XXS1500 Board
-
-config MTD_MTX1
-	tristate "4-G Systems MTX-1 Flash device"
-	depends on MIPS && MIPS_MTX1
-	help
-	  Flash memory access on 4-G Systems MTX-1 Board
-
 config MTD_BEECH
 	tristate "CFI Flash device mapped on IBM 405LP Beech"
 	depends on MTD_CFI && PPC32 && 40x && BEECH
@@ -426,9 +404,17 @@ config MTD_ARCTIC
 	  Arctic board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
+config MTD_WALNUT
+	tristate "Flash device mapped on IBM 405GP Walnut"
+	depends on MTD_JEDECPROBE && PPC32 && 40x && WALNUT
+	help
+	  This enables access routines for the flash chips on the IBM 405GP
+	  Walnut board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
 config MTD_EBONY
 	tristate "Flash devices mapped on IBM 440GP Ebony"
-	depends on MTD_CFI && PPC32 && 44x && EBONY
+	depends on MTD_JEDECPROBE && PPC32 && 44x && EBONY
 	help
 	  This enables access routines for the flash chips on the IBM 440GP
 	  Ebony board. If you have one of these boards and would like to
@@ -454,7 +440,7 @@ config MTD_CSTM_MIPS_IXX
 	tristate "Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board"
 	depends on MIPS && MTD_CFI && MTD_JEDECPROBE && MTD_PARTITIONS
 	help
-	  This provides a mapping driver for the Integrated Tecnology
+	  This provides a mapping driver for the Integrated Technology
 	  Express, Inc (ITE) QED-4N-S01B eval board and the Globespan IVR
 	  Reference Board. It provides the necessary addressing, length,
 	  buswidth, vpp code and addition setup of the flash device for
@@ -502,12 +488,6 @@ config MTD_OCELOT
 	  NVRAM on the Momenco Ocelot board. If you have one of these boards
 	  and would like access to either of these, say 'Y'.
 
-config MTD_LASAT
-	tristate "LASAT flash device"
-	depends on LASAT && MTD_CFI
-	help
-	  Support for the flash chips on the Lasat 100 and 200 boards.
-
 config MTD_SOLUTIONENGINE
 	tristate "CFI Flash device mapped on Hitachi SolutionEngine"
 	depends on SUPERH && MTD_CFI && MTD_REDBOOT_PARTS
@@ -639,13 +619,12 @@ config MTD_MPC1211
 	  This enables access to the flash chips on the Interface MPC-1211(CTP/PCI/MPC-SH02).
 	  If you have such a board, say 'Y'.
 
-config MTD_OMAP_NORv2
-	tristate "TI OMAP Development board mappings"
+config MTD_OMAP_NOR
+	tristate "TI OMAP board mappings"
 	depends on MTD_CFI && ARCH_OMAP
-	select MTD_CONCAT if MACH_OMAP_INNOVATOR
 	help
-	  This enables access to the NOR flash chips on several TI OMAP
-	  development boards, or others using the same NOR chipselects.
+	  This enables access to the NOR flash chips on TI OMAP-based
+	  boards defining flash platform devices and flash platform data.
 	  These boards include the Innovator, H2, H3, OSK, Perseus2, and
 	  more.  If you have such a board, say 'Y'.
 
@@ -668,6 +647,16 @@ config MTD_PCMCIA
 	  cards are usually around 4-16MiB in size. This does not include
 	  Compact Flash cards which are treated as IDE devices.
 
+config MTD_PCMCIA_ANONYMOUS
+	bool "Use PCMCIA MTD drivers for anonymous PCMCIA cards"
+	depends on MTD_PCMCIA
+	default N
+	help
+	  If this option is enabled, PCMCIA cards which do not report
+	  anything about themselves are assumed to be MTD cards.
+
+	  If unsure, say N.
+
 config MTD_UCLINUX
 	tristate "Generic uClinux RAM/ROM filesystem support"
 	depends on MTD_PARTITIONS && !MMU
@@ -698,13 +687,14 @@ config MTD_DMV182
           Map driver for Dy-4 SVME/DMV-182 board.
 
 config MTD_BAST
-	tristate "Map driver for Simtec BAST (EB2410ITX)"
-	depends on ARCH_BAST
+	tristate "Map driver for Simtec BAST (EB2410ITX) or Thorcom VR1000"
+	depends on ARCH_BAST || MACH_VR1000
 	select MTD_PARTITIONS
 	select MTD_MAP_BANK_WIDTH_16
 	select MTD_JEDECPROBE
 	help
-	  Map driver for NOR flash on the Simtec BAST (EB2410ITX).
+	  Map driver for NOR flash on the Simtec BAST (EB2410ITX), or the
+	  Thorcom VR1000
 
 	  Note, this driver *cannot* over-ride the WP link on the
 	  board, or currently detect the state of the link.
@@ -720,5 +710,15 @@ config MTD_SHARP_SL
 	help
 	  This enables access to the flash chip on the Sharp SL Series of PDAs.
 
+config MTD_PLATRAM
+	tristate "Map driver for platform device RAM (mtd-ram)"
+	depends on MTD
+	select MTD_RAM
+	help
+	  Map driver for RAM areas described via the platform device
+	  system.
+
+	  This selection automatically selects the map_ram driver.
+
 endmenu
 
Index: linux-2.6.10/drivers/mtd/maps/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/Makefile
+++ linux-2.6.10/drivers/mtd/maps/Makefile
@@ -1,7 +1,7 @@
 #
 # linux/drivers/maps/Makefile
 #
-# $Id: Makefile.common,v 1.20 2004/11/24 19:42:51 rpurdie Exp $
+# $Id: Makefile.common,v 1.27 2005/03/07 23:15:48 joern Exp $
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
 obj-$(CONFIG_MTD)		+= map_funcs.o
@@ -28,6 +28,7 @@ obj-$(CONFIG_MTD_MBX860)	+= mbx860.o
 obj-$(CONFIG_MTD_CEIVA)		+= ceiva.o
 obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
 obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o 
+obj-$(CONFIG_MTD_MULTI_PHYSMAP)	+= mphysmap.o
 obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o
 obj-$(CONFIG_MTD_PCMCIA)	+= pcmciamtd.o
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
@@ -45,9 +46,8 @@ obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
+obj-$(CONFIG_MTD_ALCHEMY)       += alchemy-flash.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
-obj-$(CONFIG_MTD_PB1550)	+= pb1550-flash.o
-obj-$(CONFIG_MTD_DB1550)	+= db1550-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -60,6 +60,7 @@ obj-$(CONFIG_MTD_EBONY)		+= ebony.o
 obj-$(CONFIG_MTD_OCOTEA)	+= ocotea.o
 obj-$(CONFIG_MTD_BEECH)		+= beech-mtd.o
 obj-$(CONFIG_MTD_ARCTIC)	+= arctic-mtd.o
+obj-$(CONFIG_MTD_WALNUT)        += walnut.o
 obj-$(CONFIG_MTD_H720X)		+= h720x-flash.o
 obj-$(CONFIG_MTD_SBC8240)	+= sbc8240.o
 obj-$(CONFIG_MTD_NOR_TOTO)	+= omap-toto-flash.o
@@ -69,8 +70,5 @@ obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
-obj-$(CONFIG_MTD_OMAP_NORv2)	+= omap_nor.o
-obj-$(CONFIG_MTD_PB1000)        += pb1xxx-flash.o
-obj-$(CONFIG_MTD_PB1100)        += pb1xxx-flash.o
-obj-$(CONFIG_MTD_PB1500)        += pb1xxx-flash.o
-obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
+obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
+obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
Index: linux-2.6.10/drivers/mtd/maps/alchemy-flash.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/maps/alchemy-flash.c
@@ -0,0 +1,192 @@
+/*
+ * Flash memory access on AMD Alchemy evaluation boards
+ * 
+ * $Id: alchemy-flash.c,v 1.0 2004/11/04 13:24:14 ppopov Exp $
+ *
+ * (C) 2003, 2004 Pete Popov <ppopov@embeddedalley.com>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_PB1000
+#define BOARD_MAP_NAME "Pb1000 Flash"
+#define BOARD_FLASH_SIZE 0x00800000 /* 8MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1500
+#define BOARD_MAP_NAME "Pb1500 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1100
+#define BOARD_MAP_NAME "Pb1100 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1550
+#define BOARD_MAP_NAME "Pb1550 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1200
+#define BOARD_MAP_NAME "Pb1200 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1000
+#define BOARD_MAP_NAME "Db1000 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1500
+#define BOARD_MAP_NAME "Db1500 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1100
+#define BOARD_MAP_NAME "Db1100 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+#define BOARD_MAP_NAME "Db1550 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#define BOARD_MAP_NAME "Db1200 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_HYDROGEN3
+#define BOARD_MAP_NAME "Hydrogen3 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#define USE_LOCAL_ACCESSORS /* why? */
+#endif
+
+#ifdef CONFIG_MIPS_BOSPORUS
+#define BOARD_MAP_NAME "Bosporus Flash"
+#define BOARD_FLASH_SIZE 0x01000000 /* 16MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_MIRAGE
+#define BOARD_MAP_NAME "Mirage Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#define USE_LOCAL_ACCESSORS /* why? */
+#endif
+
+static struct map_info alchemy_map = {
+	.name =	BOARD_MAP_NAME,
+};
+
+static struct mtd_partition alchemy_partitions[] = {
+        {
+                .name = "User FS",
+                .size = BOARD_FLASH_SIZE - 0x00400000,
+                .offset = 0x0000000
+        },{
+                .name = "YAMON",
+                .size = 0x0100000,
+		.offset = MTDPART_OFS_APPEND,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "raw kernel",
+		.size = (0x300000 - 0x40000), /* last 256KB is yamon env */
+		.offset = MTDPART_OFS_APPEND,
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+
+int __init alchemy_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	unsigned long window_addr;
+	unsigned long window_size;
+	
+	/* Default flash buswidth */
+	alchemy_map.bankwidth = BOARD_FLASH_WIDTH;
+
+	window_addr = 0x20000000 - BOARD_FLASH_SIZE;
+	window_size = BOARD_FLASH_SIZE;
+#ifdef CONFIG_MIPS_MIRAGE_WHY
+	/* Boot ROM flash bank only; no user bank */
+	window_addr = 0x1C000000;
+	window_size = 0x04000000;
+	/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+	alchemy_partitions[0].size = 0x03C00000;
+#endif
+
+	/*
+	 * Static partition definition selection
+	 */
+	parts = alchemy_partitions;
+	nb_parts = NB_OF(alchemy_partitions);
+	alchemy_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE BOARD_MAP_NAME ": probing %d-bit flash bus\n", 
+			alchemy_map.bankwidth*8);
+	alchemy_map.virt = ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &alchemy_map);
+	if (!mymtd) {
+		iounmap(alchemy_map.virt);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit alchemy_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		iounmap(alchemy_map.virt);
+	}
+}
+
+module_init(alchemy_mtd_init);
+module_exit(alchemy_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Alley Solutions, Inc");
+MODULE_DESCRIPTION(BOARD_MAP_NAME " MTD driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/mtd/maps/amd76xrom.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/amd76xrom.c
+++ linux-2.6.10/drivers/mtd/maps/amd76xrom.c
@@ -2,7 +2,7 @@
  * amd76xrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id: amd76xrom.c,v 1.18 2004/11/16 18:29:02 dwmw2 Exp $
+ * $Id: amd76xrom.c,v 1.19 2004/11/28 09:40:39 dwmw2 Exp $
  */
 
 #include <linux/module.h>
@@ -314,7 +314,7 @@ static int __init init_amd76xrom(void)
 	}
 	return -ENXIO;
 #if 0
-	return pci_module_init(&amd76xrom_driver);
+	return pci_register_driver(&amd76xrom_driver);
 #endif
 }
 
Index: linux-2.6.10/drivers/mtd/maps/arctic-mtd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/arctic-mtd.c
+++ linux-2.6.10/drivers/mtd/maps/arctic-mtd.c
@@ -1,5 +1,5 @@
 /*
- * $Id: arctic-mtd.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: arctic-mtd.c,v 1.12 2004/09/16 23:27:12 gleixner Exp $
  * 
  * drivers/mtd/maps/arctic-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Arctic boards.
Index: linux-2.6.10/drivers/mtd/maps/autcpu12-nvram.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/autcpu12-nvram.c
+++ linux-2.6.10/drivers/mtd/maps/autcpu12-nvram.c
@@ -2,7 +2,7 @@
  * NV-RAM memory access on autcpu12 
  * (C) 2002 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: autcpu12-nvram.c,v 1.8 2004/11/04 13:24:14 gleixner Exp $ 
+ * $Id: autcpu12-nvram.c,v 1.7 2004/09/16 23:27:12 gleixner Exp $ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
Index: linux-2.6.10/drivers/mtd/maps/bast-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/bast-flash.c
+++ linux-2.6.10/drivers/mtd/maps/bast-flash.c
@@ -1,12 +1,13 @@
 /* linux/drivers/mtd/maps/bast_flash.c
  *
- * Copyright (c) 2004 Simtec Electronics
- * Ben Dooks <ben@simtec.co.uk>
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
  *
  * Simtec Bast (EB2410ITX) NOR MTD Mapping driver
  *
  * Changelog:
  *	20-Sep-2004  BJD  Initial version
+ *	17-Jan-2005  BJD  Add whole device if no partitions found
  *
  * $Id: bast-flash.c,v 1.1 2004/09/21 14:29:04 bjd Exp $
  *
@@ -46,9 +47,9 @@
 #include <asm/arch/bast-cpld.h>
 
 #ifdef CONFIG_MTD_BAST_MAXSIZE
-#define AREA_MAXSIZE (CONFIG_MTD_BAST_MAXSIZE * (1024*1024))
+#define AREA_MAXSIZE (CONFIG_MTD_BAST_MAXSIZE * SZ_1M)
 #else
-#define AREA_MAXSIZE (32*1024*1024)
+#define AREA_MAXSIZE (32 * SZ_1M)
 #endif
 
 #define PFX "bast-flash: "
@@ -189,6 +190,8 @@ static int bast_flash_probe(struct devic
 		err = add_mtd_partitions(info->mtd, info->partitions, err);
 		if (err) 
 			printk(KERN_ERR PFX "cannot add/parse partitions\n");
+	} else {
+		err = add_mtd_device(info->mtd);
 	}
 
 	if (err == 0)
Index: linux-2.6.10/drivers/mtd/maps/beech-mtd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/beech-mtd.c
+++ linux-2.6.10/drivers/mtd/maps/beech-mtd.c
@@ -1,5 +1,5 @@
 /*
- * $Id: beech-mtd.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: beech-mtd.c,v 1.9 2004/09/16 23:27:12 gleixner Exp $
  * 
  * drivers/mtd/maps/beech-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Beech boards.
Index: linux-2.6.10/drivers/mtd/maps/cdb89712.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/cdb89712.c
+++ linux-2.6.10/drivers/mtd/maps/cdb89712.c
@@ -1,7 +1,7 @@
 /*
  * Flash on Cirrus CDB89712
  *
- * $Id: cdb89712.c,v 1.10 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: cdb89712.c,v 1.9 2004/09/16 23:27:12 gleixner Exp $
  */
 
 #include <linux/module.h>
Index: linux-2.6.10/drivers/mtd/maps/ceiva.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ceiva.c
+++ linux-2.6.10/drivers/mtd/maps/ceiva.c
@@ -11,7 +11,7 @@
  *
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  *
- * $Id: ceiva.c,v 1.11 2004/09/16 23:27:12 gleixner Exp $
+ * $Id: ceiva.c,v 1.10 2004/07/12 21:59:43 dwmw2 Exp $
  */
 
 #include <linux/config.h>
Index: linux-2.6.10/drivers/mtd/maps/cfi_flagadm.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/cfi_flagadm.c
+++ linux-2.6.10/drivers/mtd/maps/cfi_flagadm.c
@@ -1,7 +1,7 @@
 /*
  *  Copyright © 2001 Flaga hf. Medical Devices, Kári Davíðsson <kd@flaga.is>
  *
- *  $Id: cfi_flagadm.c,v 1.14 2004/11/04 13:24:14 gleixner Exp $
+ *  $Id: cfi_flagadm.c,v 1.13 2004/09/16 23:27:12 gleixner Exp $
  *  
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
Index: linux-2.6.10/drivers/mtd/maps/dbox2-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/dbox2-flash.c
+++ linux-2.6.10/drivers/mtd/maps/dbox2-flash.c
@@ -1,5 +1,5 @@
 /*
- * $Id: dbox2-flash.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: dbox2-flash.c,v 1.12 2004/09/16 23:27:12 gleixner Exp $
  *
  * D-Box 2 flash driver
  */
Index: linux-2.6.10/drivers/mtd/maps/dc21285.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/dc21285.c
+++ linux-2.6.10/drivers/mtd/maps/dc21285.c
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  * 
- * $Id: dc21285.c,v 1.22 2004/11/01 13:39:21 rmk Exp $
+ * $Id: dc21285.c,v 1.21 2004/09/16 23:27:13 gleixner Exp $
  */
 #include <linux/config.h>
 #include <linux/module.h>
Index: linux-2.6.10/drivers/mtd/maps/dilnetpc.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/dilnetpc.c
+++ linux-2.6.10/drivers/mtd/maps/dilnetpc.c
@@ -14,7 +14,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id: dilnetpc.c,v 1.16 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: dilnetpc.c,v 1.17 2004/11/28 09:40:39 dwmw2 Exp $
  *
  * The DIL/Net PC is a tiny embedded PC board made by SSV Embedded Systems
  * featuring the AMD Elan SC410 processor. There are two variants of this
Index: linux-2.6.10/drivers/mtd/maps/dmv182.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/dmv182.c
+++ linux-2.6.10/drivers/mtd/maps/dmv182.c
@@ -4,7 +4,7 @@
  * 
  * Flash map driver for the Dy4 SVME182 board
  * 
- * $Id: dmv182.c,v 1.5 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: dmv182.c,v 1.4 2004/09/16 23:27:13 gleixner Exp $
  *
  * Copyright 2003-2004, TimeSys Corporation
  *
Index: linux-2.6.10/drivers/mtd/maps/ebony.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ebony.c
+++ linux-2.6.10/drivers/mtd/maps/ebony.c
@@ -1,5 +1,5 @@
 /*
- * $Id: ebony.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: ebony.c,v 1.14 2004/11/28 09:40:39 dwmw2 Exp $
  * 
  * Mapping for Ebony user flash
  *
@@ -103,7 +103,7 @@ int __init init_ebony(void)
 
 	simple_map_init(&ebony_small_map);
 
-	flash = do_map_probe("map_rom", &ebony_small_map);
+	flash = do_map_probe("jedec_probe", &ebony_small_map);
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_small_partitions,
@@ -124,7 +124,7 @@ int __init init_ebony(void)
 
 	simple_map_init(&ebony_large_map);
 
-	flash = do_map_probe("cfi_probe", &ebony_large_map);
+	flash = do_map_probe("jedec_probe", &ebony_large_map);
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_large_partitions,
Index: linux-2.6.10/drivers/mtd/maps/edb7312.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/edb7312.c
+++ linux-2.6.10/drivers/mtd/maps/edb7312.c
@@ -1,5 +1,5 @@
 /*
- * $Id: edb7312.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: edb7312.c,v 1.12 2004/09/16 23:27:13 gleixner Exp $
  *
  * Handle mapping of the NOR flash on Cogent EDB7312 boards
  *
Index: linux-2.6.10/drivers/mtd/maps/epxa10db-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/epxa10db-flash.c
+++ linux-2.6.10/drivers/mtd/maps/epxa10db-flash.c
@@ -5,7 +5,7 @@
  *  Copyright (C) 2001 Altera Corporation
  *  Copyright (C) 2001 Red Hat, Inc.
  *
- * $Id: epxa10db-flash.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $ 
+ * $Id: epxa10db-flash.c,v 1.12 2004/09/16 23:27:13 gleixner Exp $ 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
Index: linux-2.6.10/drivers/mtd/maps/fortunet.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/fortunet.c
+++ linux-2.6.10/drivers/mtd/maps/fortunet.c
@@ -1,6 +1,6 @@
 /* fortunet.c memory map
  *
- * $Id: fortunet.c,v 1.9 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: fortunet.c,v 1.8 2004/09/16 23:27:13 gleixner Exp $
  */
 
 #include <linux/module.h>
Index: linux-2.6.10/drivers/mtd/maps/h720x-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/h720x-flash.c
+++ linux-2.6.10/drivers/mtd/maps/h720x-flash.c
@@ -2,7 +2,7 @@
  * Flash memory access on Hynix GMS30C7201/HMS30C7202 based 
  * evaluation boards
  * 
- * $Id: h720x-flash.c,v 1.11 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: h720x-flash.c,v 1.10 2004/09/16 23:27:13 gleixner Exp $
  *
  * (C) 2002 Jungjun Kim <jungjun.kim@hynix.com>
  *     2003 Thomas Gleixner <tglx@linutronix.de>	
Index: linux-2.6.10/drivers/mtd/maps/ichxrom.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ichxrom.c
+++ linux-2.6.10/drivers/mtd/maps/ichxrom.c
@@ -2,7 +2,7 @@
  * ichxrom.c
  *
  * Normal mappings of chips in physical memory
- * $Id: ichxrom.c,v 1.15 2004/11/16 18:29:02 dwmw2 Exp $
+ * $Id: ichxrom.c,v 1.17 2005/03/18 14:04:35 gleixner Exp $
  */
 
 #include <linux/module.h>
@@ -338,9 +338,9 @@ static struct pci_device_id ichxrom_pci_
 	{ 0, },
 };
 
+#if 0
 MODULE_DEVICE_TABLE(pci, ichxrom_pci_tbl);
 
-#if 0
 static struct pci_driver ichxrom_driver = {
 	.name =		MOD_NAME,
 	.id_table =	ichxrom_pci_tbl,
@@ -366,7 +366,7 @@ static int __init init_ichxrom(void)
 	}
 	return -ENXIO;
 #if 0
-	return pci_module_init(&ichxrom_driver);
+	return pci_register_driver(&ichxrom_driver);
 #endif
 }
 
Index: linux-2.6.10/drivers/mtd/maps/impa7.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/impa7.c
+++ linux-2.6.10/drivers/mtd/maps/impa7.c
@@ -1,5 +1,5 @@
 /*
- * $Id: impa7.c,v 1.13 2004/11/04 13:24:14 gleixner Exp $
+ * $Id: impa7.c,v 1.12 2004/09/16 23:27:13 gleixner Exp $
  *
  * Handle mapping of the NOR flash on implementa A7 boards
  *
Index: linux-2.6.10/drivers/mtd/maps/integrator-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/integrator-flash.c
+++ linux-2.6.10/drivers/mtd/maps/integrator-flash.c
@@ -22,7 +22,7 @@
    This is access code for flashes using ARM's flash partitioning 
    standards.
 
-   $Id: integrator-flash.c,v 1.18 2004/11/01 13:26:15 rmk Exp $
+   $Id: integrator-flash.c,v 1.17 2004/09/16 23:27:13 gleixner Exp $
 
 ======================================================================*/
 
Index: linux-2.6.10/drivers/mtd/maps/iq80310.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/iq80310.c
+++ linux-2.6.10/drivers/mtd/maps/iq80310.c
@@ -1,5 +1,5 @@
 /*
- * $Id: iq80310.c,v 1.20 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: iq80310.c,v 1.19 2004/09/16 23:27:13 gleixner Exp $
  *
  * Mapping for the Intel XScale IQ80310 evaluation board
  *
Index: linux-2.6.10/drivers/mtd/maps/ixp2000.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ixp2000.c
+++ linux-2.6.10/drivers/mtd/maps/ixp2000.c
@@ -216,11 +216,6 @@ static int ixp2000_flash_probe(struct de
 		goto Error;
 	}
 
-	/*
-	 * Setup read mode for FLASH
-	 */
-	*IXP2000_SLOWPORT_FRM = 1;
-
 #if defined(__ARMEB__)
 	/*
 	 * Enable erratum 44 workaround for NPUs with broken slowport
Index: linux-2.6.10/drivers/mtd/maps/ixp4xx.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ixp4xx.c
+++ linux-2.6.10/drivers/mtd/maps/ixp4xx.c
@@ -1,5 +1,5 @@
 /*
- * $Id: ixp4xx.c,v 1.7 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: ixp4xx.c,v 1.6 2004/09/17 00:25:06 gleixner Exp $
  *
  * drivers/mtd/maps/ixp4xx.c
  *
Index: linux-2.6.10/drivers/mtd/maps/lasat.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/lasat.c
+++ linux-2.6.10/drivers/mtd/maps/lasat.c
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
  *
- * $Id: lasat.c,v 1.7 2004/07/12 21:59:44 dwmw2 Exp $
+ * $Id: lasat.c,v 1.8 2004/09/16 23:27:13 gleixner Exp $
  *
  */
 
@@ -50,7 +50,7 @@ static int __init init_lasat(void)
 	ENABLE_VPP((&lasat_map));
 
 	lasat_map.phys = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
-	lasat_map.virt = (unsigned long)ioremap_nocache(
+	lasat_map.virt = ioremap_nocache(
 		        lasat_map.phys, lasat_board_info.li_flash_size);
 	lasat_map.size = lasat_board_info.li_flash_size;
 
Index: linux-2.6.10/drivers/mtd/maps/lubbock-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/lubbock-flash.c
+++ linux-2.6.10/drivers/mtd/maps/lubbock-flash.c
@@ -1,5 +1,5 @@
 /*
- * $Id: lubbock-flash.c,v 1.19 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: lubbock-flash.c,v 1.18 2004/09/28 18:54:40 nico Exp $
  *
  * Map driver for the Lubbock developer platform.
  *
Index: linux-2.6.10/drivers/mtd/maps/map_funcs.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/map_funcs.c
+++ linux-2.6.10/drivers/mtd/maps/map_funcs.c
@@ -1,5 +1,5 @@
 /*
- * $Id: map_funcs.c,v 1.9 2004/07/13 22:33:15 dwmw2 Exp $
+ * $Id: map_funcs.c,v 1.8 2004/07/12 14:34:25 dwmw2 Exp $
  *
  * Out-of-line map I/O functions for simple maps when CONFIG_COMPLEX_MAPPINGS
  * is enabled.
Index: linux-2.6.10/drivers/mtd/maps/mbx860.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/mbx860.c
+++ linux-2.6.10/drivers/mtd/maps/mbx860.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mbx860.c,v 1.8 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: mbx860.c,v 1.7 2004/09/16 23:27:13 gleixner Exp $
  *
  * Handle mapping of the flash on MBX860 boards
  *
Index: linux-2.6.10/drivers/mtd/maps/mpc1211.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/mpc1211.c
+++ linux-2.6.10/drivers/mtd/maps/mpc1211.c
@@ -1,7 +1,7 @@
 /*
  * Flash on MPC-1211
  *
- * $Id: mpc1211.c,v 1.4 2004/09/16 23:27:13 gleixner Exp $
+ * $Id: mpc1211.c,v 1.3 2004/07/14 17:45:40 dwmw2 Exp $
  *
  * (C) 2002 Interface, Saito.K & Jeanne
  *
Index: linux-2.6.10/drivers/mtd/maps/mphysmap.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/maps/mphysmap.c
@@ -0,0 +1,282 @@
+/*
+ * $Id$
+ *
+ * Several mappings of NOR chips
+ *
+ * Copyright (c) 2001-2005	Jörn Engel <joern@wh.fh-wedelde>
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+
+
+#define NO_DEVICES 8
+struct map_info maps[NO_DEVICES] = {
+#if CONFIG_MTD_MULTI_PHYSMAP_1_WIDTH
+	{
+		.name		= CONFIG_MTD_MULTI_PHYSMAP_1_NAME,
+		.phys		= CONFIG_MTD_MULTI_PHYSMAP_1_START,
+		.size		= CONFIG_MTD_MULTI_PHYSMAP_1_LEN,
+		.bankwidth	= CONFIG_MTD_MULTI_PHYSMAP_1_WIDTH,
+	},
+#endif
+#if CONFIG_MTD_MULTI_PHYSMAP_2_WIDTH
+	{
+		.name		= CONFIG_MTD_MULTI_PHYSMAP_2_NAME,
+		.phys		= CONFIG_MTD_MULTI_PHYSMAP_2_START,
+		.size		= CONFIG_MTD_MULTI_PHYSMAP_2_LEN,
+		.bankwidth	= CONFIG_MTD_MULTI_PHYSMAP_2_WIDTH,
+	},
+#endif
+#if CONFIG_MTD_MULTI_PHYSMAP_3_WIDTH
+	{
+		.name		= CONFIG_MTD_MULTI_PHYSMAP_3_NAME,
+		.phys		= CONFIG_MTD_MULTI_PHYSMAP_3_START,
+		.size		= CONFIG_MTD_MULTI_PHYSMAP_3_LEN,
+		.bankwidth	= CONFIG_MTD_MULTI_PHYSMAP_3_WIDTH,
+	},
+#endif
+#if CONFIG_MTD_MULTI_PHYSMAP_4_WIDTH
+	{
+		.name		= CONFIG_MTD_MULTI_PHYSMAP_4_NAME,
+		.phys		= CONFIG_MTD_MULTI_PHYSMAP_4_START,
+		.size		= CONFIG_MTD_MULTI_PHYSMAP_4_LEN,
+		.bankwidth	= CONFIG_MTD_MULTI_PHYSMAP_4_WIDTH,
+	},
+#endif
+	{
+		.name = NULL,
+	},
+};
+DECLARE_MUTEX(map_mutex);
+
+
+static int map_one(struct map_info *map)
+{
+	struct mtd_info *mtd;
+
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt)
+		return -EIO;
+
+	simple_map_init(map);
+
+	mtd = do_map_probe("cfi_probe", map);
+	if (!mtd) {
+		iounmap(map->virt);
+		return -ENXIO;
+	}
+
+	map->map_priv_1 = (unsigned long)mtd;
+	mtd->owner = THIS_MODULE;
+	/* TODO: partitioning */
+	return add_mtd_device(mtd);
+}
+
+
+static void unmap_one(struct map_info *map)
+{
+	struct mtd_info *mtd = (struct mtd_info*)map->map_priv_1;
+
+	if (map->map_priv_2)
+		kfree(map->name);
+
+	if (!map->virt)
+		return;
+
+	BUG_ON(!mtd);
+	BUG_ON(map->map_priv_2 > 1);
+
+	del_mtd_device(mtd);
+	map_destroy(mtd);
+	iounmap(map->virt);
+
+	map->map_priv_1 = 0;
+	map->map_priv_2 = 0;
+	map->virt = NULL;
+}
+
+
+static struct map_info *next_free_map(void)
+{
+	int i;
+	for (i=0; i<NO_DEVICES; i++) {
+		struct map_info *map = &maps[i];
+		if (!map->virt)
+			return map;
+	}
+	return NULL;
+}
+
+
+static int add_one_map(const char *name, unsigned long start,
+		unsigned long len, int width)
+{
+	struct map_info *map = next_free_map();
+	if (!map)
+		return -ENOSPC;
+	
+	map->name = kmalloc(strlen(name)+1, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	strcpy(map->name, name);
+	map->phys = start;
+	map->size = len;
+	map->bankwidth = width;
+	map->map_priv_2 = 1; /* marker to free map->name */
+
+	return map_one(map);
+}
+
+
+static int parse_ulong(unsigned long *num, const char *token)
+{
+	char *endp;
+	unsigned long n;
+
+	n = ustrtoul(token, &endp, 0);
+	if (*endp)
+		return -EINVAL;
+
+	*num = n;
+	return 0;
+}
+
+
+static int parse_uint(unsigned int *num, const char *token)
+{
+	char *endp;
+	unsigned long n;
+
+	n = ustrtoul(token, &endp, 0);
+	if (*endp)
+		return -EINVAL;
+	if ((int)n != n)
+		return -EINVAL;
+
+	*num = n;
+	return 0;
+}
+
+
+static int parse_name(char **pname, const char *token, int limit)
+{
+	size_t len;
+	char *name;
+
+	len = strlen(token) + 1;
+	if (len > limit)
+		return -ENOSPC;
+
+	name = kmalloc(len, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	memcpy(name, token, len);
+
+	*pname = name;
+	return 0;
+}
+
+
+static inline void kill_final_newline(char *str)
+{
+	char *newline = strrchr(str, '\n');
+	if (newline && !newline[1])
+		*newline = 0;
+}
+
+
+#define parse_err(fmt, args...) do {	\
+	printk(KERN_ERR fmt "\n", ## args);	\
+	return 0;			\
+} while(0)
+
+/* mphysmap=name,start,len,width */
+static int mphysmap_setup(const char *val, struct kernel_param *kp)
+{
+	char buf[64+14+14+14], *str = buf;
+	char *token[4];
+	char *name;
+	unsigned long start;
+	unsigned long len;
+	unsigned int width;
+	int i, ret;
+
+	if (strnlen(val, sizeof(buf)) >= sizeof(buf))
+		parse_err("parameter too long");
+
+	strcpy(str, val);
+	kill_final_newline(str);
+
+	for (i=0; i<4; i++)
+		token[i] = strsep(&str, ",");
+
+	if (str)
+		parse_err("too many arguments");
+	if (!token[3])
+		parse_err("not enough arguments");
+
+	ret = parse_name(&name, token[0], 64);
+	if (ret == -ENOMEM)
+		parse_err("out of memory");
+	if (ret == -ENOSPC)
+		parse_err("name too long");
+	if (ret)
+		parse_err("illegal name: %d", ret);
+
+	ret = parse_ulong(&start, token[1]);
+	if (ret)
+		parse_err("illegal start address");
+
+	ret = parse_ulong(&len, token[2]);
+	if (ret)
+		parse_err("illegal length");
+
+	ret = parse_uint(&width, token[3]);
+	if (ret)
+		parse_err("illegal bus width");
+
+	down(&map_mutex);
+	ret = add_one_map(name, start, len, width);
+	up(&map_mutex);
+	if (ret == -ENOSPC)
+		parse_err("no free space for new map");
+	if (ret)
+		parse_err("error while mapping: %d", ret);
+
+	return 0;
+}
+
+
+static int __init mphysmap_init(void)
+{
+	int i;
+	down(&map_mutex);
+	for (i=0; i<NO_DEVICES; i++)
+		map_one(&maps[i]);
+	up(&map_mutex);
+	return 0;
+}
+
+
+static void __exit mphysmap_exit(void)
+{
+	int i;
+	down(&map_mutex);
+	for (i=0; i<NO_DEVICES; i++)
+		unmap_one(&maps[i]);
+	up(&map_mutex);
+}
+
+
+__module_param_call("", mphysmap, mphysmap_setup, NULL, NULL, 0600);
+
+module_init(mphysmap_init);
+module_exit(mphysmap_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jörn Engel <joern@wh.fh-wedelde>");
+MODULE_DESCRIPTION("Generic configurable extensible MTD map driver");
Index: linux-2.6.10/drivers/mtd/maps/nettel.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/nettel.c
+++ linux-2.6.10/drivers/mtd/maps/nettel.c
@@ -6,7 +6,7 @@
  *      (C) Copyright 2000-2001, Greg Ungerer (gerg@snapgear.com)
  *      (C) Copyright 2001-2002, SnapGear (www.snapgear.com)
  *
- *	$Id: nettel.c,v 1.8 2004/11/04 13:24:15 gleixner Exp $
+ *	$Id: nettel.c,v 1.9 2004/11/28 09:40:40 dwmw2 Exp $
  */
 
 /****************************************************************************/
@@ -332,8 +332,8 @@ int __init nettel_init(void)
 
 		/* Destroy useless AMD MTD mapping */
 		amd_mtd = NULL;
-		iounmap((void *) nettel_amd_map.virt);
-		nettel_amd_map.virt = (unsigned long) NULL;
+		iounmap(nettel_amd_map.virt);
+		nettel_amd_map.virt = NULL;
 #else
 		/* Only AMD flash supported */
 		return(-ENXIO);
@@ -357,8 +357,7 @@ int __init nettel_init(void)
 	/* Probe for the the size of the first Intel flash */
 	nettel_intel_map.size = maxsize;
 	nettel_intel_map.phys = intel0addr;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1\n");
 		return(-EIO);
@@ -366,8 +365,8 @@ int __init nettel_init(void)
 	simple_map_init(&nettel_intel_map);
 
 	intel_mtd = do_map_probe("cfi_probe", &nettel_intel_map);
-	if (! intel_mtd) {
-		iounmap((void *) nettel_intel_map.virt);
+	if (!intel_mtd) {
+		iounmap(nettel_intel_map.virt);
 		return(-ENXIO);
 	}
 
@@ -388,11 +387,10 @@ int __init nettel_init(void)
 	/* Delete the old map and probe again to do both chips */
 	map_destroy(intel_mtd);
 	intel_mtd = NULL;
-	iounmap((void *) nettel_intel_map.virt);
+	iounmap(nettel_intel_map.virt);
 
 	nettel_intel_map.size = maxsize;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1/2\n");
 		return(-EIO);
@@ -480,7 +478,7 @@ void __exit nettel_cleanup(void)
 		map_destroy(intel_mtd);
 	}
 	if (nettel_intel_map.virt) {
-		iounmap((void *)nettel_intel_map.virt);
+		iounmap(nettel_intel_map.virt);
 		nettel_intel_map.virt = 0;
 	}
 #endif
Index: linux-2.6.10/drivers/mtd/maps/ocelot.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ocelot.c
+++ linux-2.6.10/drivers/mtd/maps/ocelot.c
@@ -28,7 +28,7 @@ static struct mtd_info *nvram_mtd;
 
 static void ocelot_ram_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
 {
-        struct map_info *map = (struct map_info *)mtd->priv;
+        struct map_info *map = mtd->priv;
 	size_t done = 0;
 
 	/* If we use memcpy, it does word-wide writes. Even though we told the 
Index: linux-2.6.10/drivers/mtd/maps/omap-toto-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/omap-toto-flash.c
+++ linux-2.6.10/drivers/mtd/maps/omap-toto-flash.c
@@ -5,7 +5,7 @@
  *
  *  (C) 2002 MontVista Software, Inc.
  *
- * $Id: omap-toto-flash.c,v 1.3 2004/09/16 23:27:13 gleixner Exp $
+ * $Id: omap-toto-flash.c,v 1.2 2004/07/12 21:59:44 dwmw2 Exp $
  */
 
 #include <linux/config.h>
Index: linux-2.6.10/drivers/mtd/maps/omap_nor.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/omap_nor.c
+++ linux-2.6.10/drivers/mtd/maps/omap_nor.c
@@ -30,6 +30,7 @@
  * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -42,59 +43,19 @@
 #include <asm/io.h>
 #include <asm/hardware.h>
 #include <asm/mach-types.h>
+#include <asm/mach/flash.h>
 #include <asm/arch/tc.h>
 
-#define	MODULE_NAME	"omap_nor"
-
-
 #ifdef CONFIG_MTD_PARTITIONS
-
-/* only bootable devices have a default partitioning */
-static struct mtd_partition boot_partitions[] = {
-	/* bootloader (U-Boot, etc) in first sector */
-	{
-	      .name		= "bootloader",
-	      .offset		= 0,
-	      .size		= SZ_128K,
-	      .mask_flags	= MTD_WRITEABLE, /* force read-only */
-	},
-	/* bootloader params in the next sector */
-	{
-	      .name		= "params",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= SZ_128K,
-	      .mask_flags	= 0, 
-	},
-	/* kernel */
-	{
-	      .name		= "kernel",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= SZ_2M,
-	      .mask_flags	= 0
-	},
-#ifdef	CONFIG_MACH_OMAP_INNOVATOR
-	/* rest of flash1 is a file system */
-	{
-	      .name		= "rootfs",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= SZ_16M - SZ_2M - 2 * SZ_128K,
-	      .mask_flags	= 0
-	},
-#endif
-	/* file system */
-	{
-	      .name		= "filesystem",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= MTDPART_SIZ_FULL,
-	      .mask_flags	= 0
-	}
-};
-
 static const char *part_probes[] = { /* "RedBoot", */ "cmdlinepart", NULL };
-static struct mtd_partition *parts;
-
 #endif
 
+struct omapflash_info {
+	struct mtd_partition	*parts;
+	struct mtd_info		*mtd;
+	struct map_info		map;
+};
+
 static void omap_set_vpp(struct map_info *map, int enable)
 {
 	static int	count;
@@ -108,87 +69,110 @@ static void omap_set_vpp(struct map_info
 	}
 }
 
-static struct map_info omap_map = {
-	.bankwidth	= 2,
-	.set_vpp	= omap_set_vpp,
-};
-
-static struct mtd_info *mymtd;
-
-static int __init probe_nor(char *name, u32 phys, u32 size, int bootable)
+static int __devinit omapflash_probe(struct device *dev)
 {
-	int	tmp = -EBUSY;
-
-	if (!request_mem_region(phys, size, name))
-		return tmp;
+	int err;
+	struct omapflash_info *info;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct flash_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res = pdev->resource;
+	unsigned long size = res->end - res->start + 1;
+
+	info = kmalloc(sizeof(struct omapflash_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	memset(info, 0, sizeof(struct omapflash_info));
+
+	if (!request_mem_region(res->start, size, "flash")) {
+		err = -EBUSY;
+		goto out_free_info;
+	}
 
-	omap_map.name = name;
-	omap_map.phys = phys;
-	omap_map.size = size;
-	omap_map.virt = ioremap(phys, size);
-
-	simple_map_init(&omap_map);
-	mymtd = do_map_probe("cfi_probe", &omap_map);
-	if (!mymtd) {
-		release_mem_region(phys, size);
-		iounmap(omap_map.virt);
-		return -EIO;
+	info->map.virt		= ioremap(res->start, size);
+	if (!info->map.virt) {
+		err = -ENOMEM;
+		goto out_release_mem_region;
+	}
+	info->map.name		= pdev->dev.bus_id;
+	info->map.phys		= res->start;
+	info->map.size		= size;
+	info->map.bankwidth	= pdata->width;
+	info->map.set_vpp	= omap_set_vpp;
+
+	simple_map_init(&info->map);
+	info->mtd = do_map_probe(pdata->map_name, &info->map);
+	if (!info->mtd) {
+		err = -EIO;
+		goto out_iounmap;
 	}
-	mymtd->owner = THIS_MODULE;
+	info->mtd->owner = THIS_MODULE;
 
 #ifdef CONFIG_MTD_PARTITIONS
-	tmp = parse_mtd_partitions(mymtd, part_probes, &parts, 0);
-	if (tmp > 0)
-		add_mtd_partitions(mymtd, parts, tmp);
-	else if (tmp < 0 && bootable)
-		add_mtd_partitions(mymtd, boot_partitions, 
-				   ARRAY_SIZE(boot_partitions));
+	err = parse_mtd_partitions(info->mtd, part_probes, &info->parts, 0);
+	if (err > 0)
+		add_mtd_partitions(info->mtd, info->parts, err);
+	else if (err < 0 && pdata->parts)
+		add_mtd_partitions(info->mtd, pdata->parts, pdata->nr_parts);
 	else
 #endif
-		add_mtd_device(mymtd);
+		add_mtd_device(info->mtd);
+
+	dev_set_drvdata(&pdev->dev, info);
 
 	return 0;
+
+out_iounmap:
+	iounmap(info->map.virt);
+out_release_mem_region:
+	release_mem_region(res->start, size);
+out_free_info:
+	kfree(info);
+
+	return err;
 }
 
-static int __init init_omap_nor(void)
+static int __devexit omapflash_remove(struct device *dev)
 {
-	int ret = -ENODEV;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct omapflash_info *info = dev_get_drvdata(&pdev->dev);
 
-	/* external CS3 flash might be mapped to address 0 ... */
-	if (machine_is_omap_innovator())
-		ret = probe_nor(MODULE_NAME "_cs0", 0, SZ_32M, 1);
-	else
-		ret = probe_nor(MODULE_NAME "_cs3",
-				omap_cs3_phys(), OMAP_CS3_SIZE, 1);
+	dev_set_drvdata(&pdev->dev, NULL);
 
-	/* H2/H3 "NAND boot" puts NOR at CS2B, NAND at CS3 */
-	if (ret < 0 && (machine_is_omap_h2() || machine_is_omap_h3()))
-		ret = probe_nor(MODULE_NAME "_cs2b",
-				OMAP_CS2B_PHYS, OMAP_CS2B_SIZE, 0);
+	if (info) {
+		if (info->parts) {
+			del_mtd_partitions(info->mtd);
+			kfree(info->parts);
+		} else
+			del_mtd_device(info->mtd);
+		map_destroy(info->mtd);
+		release_mem_region(info->map.phys, info->map.size);
+		iounmap((void __iomem *) info->map.virt);
+		kfree(info);
+	}
 
-	return ret;
+	return 0;
 }
 
-static void __exit cleanup_omap_nor(void)
+static struct device_driver omapflash_driver = {
+	.name	= "omapflash",
+	.bus	= &platform_bus_type,
+	.probe	= omapflash_probe,
+	.remove	= __devexit_p(omapflash_remove),
+};
+
+static int __init omapflash_init(void)
 {
-#ifdef CONFIG_MTD_PARTITIONS
-	if (parts)
-		del_mtd_partitions(mymtd);
-	else
-#endif
-		del_mtd_device(mymtd);
-	map_destroy(mymtd);
-	release_mem_region(omap_map.phys, omap_map.size);
-	iounmap((void *) omap_map.virt);
+	return driver_register(&omapflash_driver);
+}
 
-#ifdef CONFIG_MTD_PARTITIONS
-	if (parts)
-		kfree(parts);
-#endif
+static void __exit omapflash_exit(void)
+{
+	driver_unregister(&omapflash_driver);
 }
 
-module_init(init_omap_nor);
-module_exit(cleanup_omap_nor);
+module_init(omapflash_init);
+module_exit(omapflash_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("MTD NOR map driver for TI OMAP boards");
Index: linux-2.6.10/drivers/mtd/maps/pci.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/pci.c
+++ linux-2.6.10/drivers/mtd/maps/pci.c
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- *  $Id: pci.c,v 1.8 2004/07/12 22:38:29 dwmw2 Exp $
+ *  $Id: pci.c,v 1.10 2005/03/18 14:04:35 gleixner Exp $
  * 
  * Generic PCI memory map driver.  We support the following boards:
  *  - Intel IQ80310 ATU.
@@ -205,9 +205,9 @@ intel_dc21285_init(struct pci_dev *dev, 
 		 * or simply enabling it?
 		 */
 		if (!(pci_resource_flags(dev, PCI_ROM_RESOURCE) &
-		     PCI_ROM_ADDRESS_ENABLE)) {
+				    IORESOURCE_ROM_ENABLE)) {
 		     	u32 val;
-			pci_resource_flags(dev, PCI_ROM_RESOURCE) |= PCI_ROM_ADDRESS_ENABLE;
+			pci_resource_flags(dev, PCI_ROM_RESOURCE) |= IORESOURCE_ROM_ENABLE;
 			pci_read_config_dword(dev, PCI_ROM_ADDRESS, &val);
 			val |= PCI_ROM_ADDRESS_ENABLE;
 			pci_write_config_dword(dev, PCI_ROM_ADDRESS, val);
@@ -241,7 +241,7 @@ intel_dc21285_exit(struct pci_dev *dev, 
 	/*
 	 * We need to undo the PCI BAR2/PCI ROM BAR address alteration.
 	 */
-	pci_resource_flags(dev, PCI_ROM_RESOURCE) &= ~PCI_ROM_ADDRESS_ENABLE;
+	pci_resource_flags(dev, PCI_ROM_RESOURCE) &= ~IORESOURCE_ROM_ENABLE;
 	pci_read_config_dword(dev, PCI_ROM_ADDRESS, &val);
 	val &= ~PCI_ROM_ADDRESS_ENABLE;
 	pci_write_config_dword(dev, PCI_ROM_ADDRESS, val);
@@ -370,7 +370,7 @@ static struct pci_driver mtd_pci_driver 
 
 static int __init mtd_pci_maps_init(void)
 {
-	return pci_module_init(&mtd_pci_driver);
+	return pci_register_driver(&mtd_pci_driver);
 }
 
 static void __exit mtd_pci_maps_exit(void)
Index: linux-2.6.10/drivers/mtd/maps/pcmciamtd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/pcmciamtd.c
+++ linux-2.6.10/drivers/mtd/maps/pcmciamtd.c
@@ -800,7 +800,6 @@ static dev_link_t *pcmciamtd_attach(void
 
 	/* Register with Card Services */
 	client_reg.dev_info = &dev_info;
-	client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
 	client_reg.EventMask =
 		CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
 		CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
@@ -819,6 +818,32 @@ static dev_link_t *pcmciamtd_attach(void
 	return link;
 }
 
+static struct pcmcia_device_id pcmciamtd_ids[] = {
+	PCMCIA_DEVICE_FUNC_ID(1),
+	PCMCIA_DEVICE_PROD_ID123("IO DATA", "PCS-2M", "2MB SRAM", 0x547e66dc, 0x1fed36cd, 0x36eadd21),
+	PCMCIA_DEVICE_PROD_ID12("IBM", "2MB SRAM", 0xb569a6e5, 0x36eadd21),
+	PCMCIA_DEVICE_PROD_ID12("IBM", "4MB FLASH", 0xb569a6e5, 0x8bc54d2a),
+	PCMCIA_DEVICE_PROD_ID12("IBM", "8MB FLASH", 0xb569a6e5, 0x6df1be3e),
+	PCMCIA_DEVICE_PROD_ID12("Intel", "S2E20SW", 0x816cc815, 0xd14c9dcf),
+	PCMCIA_DEVICE_PROD_ID12("Intel", "S2E8 SW", 0x816cc815, 0xa2d7dedb),
+	PCMCIA_DEVICE_PROD_ID12("intel", "SERIES2-02 ", 0x40ade711, 0x145cea5c),
+	PCMCIA_DEVICE_PROD_ID12("intel", "SERIES2-04 ", 0x40ade711, 0x42064dda),
+	PCMCIA_DEVICE_PROD_ID12("intel", "SERIES2-20 ", 0x40ade711, 0x25ee5cb0),
+	PCMCIA_DEVICE_PROD_ID12("intel", "VALUE SERIES 100 ", 0x40ade711, 0xdf8506d8),
+	PCMCIA_DEVICE_PROD_ID12("KINGMAX TECHNOLOGY INC.", "SRAM 256K Bytes", 0x54d0c69c, 0xad12c29c),
+	PCMCIA_DEVICE_PROD_ID12("Maxtor", "MAXFL MobileMax Flash Memory Card", 0xb68968c8, 0x2dfb47b0),
+	PCMCIA_DEVICE_PROD_ID12("SEIKO EPSON", "WWB101EN20", 0xf9876baf, 0xad0b207b),
+	PCMCIA_DEVICE_PROD_ID12("SEIKO EPSON", "WWB513EN20", 0xf9876baf, 0xe8d884ad),
+	PCMCIA_DEVICE_PROD_ID12("Starfish, Inc.", "REX-3000", 0x05ddca47, 0xe7d67bca),
+	PCMCIA_DEVICE_PROD_ID12("Starfish, Inc.", "REX-4100", 0x05ddca47, 0x7bc32944),
+	/* the following was commented out in pcmcia-cs-3.2.7 */
+	/* PCMCIA_DEVICE_PROD_ID12("RATOC Systems,Inc.", "SmartMedia ADAPTER PC Card", 0xf4a2fefe, 0x5885b2ae), */
+#ifdef CONFIG_MTD_PCMCIA_ANONYMOUS
+	{ .match_flags = PCMCIA_DEV_ID_MATCH_ANONYMOUS, },
+#endif
+	PCMCIA_DEVICE_NULL
+};
+MODULE_DEVICE_TABLE(pcmcia, pcmciamtd_ids);
 
 static struct pcmcia_driver pcmciamtd_driver = {
 	.drv		= {
@@ -826,7 +851,8 @@ static struct pcmcia_driver pcmciamtd_dr
 	},
 	.attach		= pcmciamtd_attach,
 	.detach		= pcmciamtd_detach,
-	.owner		= THIS_MODULE
+	.owner		= THIS_MODULE,
+	.id_table	= pcmciamtd_ids,
 };
 
 
@@ -854,35 +880,7 @@ static void __exit exit_pcmciamtd(void)
 {
 	DEBUG(1, DRIVER_DESC " unloading");
 	pcmcia_unregister_driver(&pcmciamtd_driver);
-
-	while(dev_list) {
-		dev_link_t *link = dev_list;
-
-		dev_list = link->next;
-		if (link) {
-			struct pcmciamtd_dev *dev = link->priv;
-			
- 			if(dev) {
-				if(link->state & DEV_PRESENT) {
-					if (!(link->state & DEV_STALE_LINK)) {
-						pcmciamtd_detach(link);
-					}
-					link->state &= ~DEV_PRESENT;
-					if(dev->mtd_info) {
-						del_mtd_device(dev->mtd_info);
-						info("mtd%d: Removed",
-						     dev->mtd_info->index);
-					}
-				}
-				if(dev->mtd_info) {
-					DEBUG(2, "Destroying map for mtd%d",
-					      dev->mtd_info->index);
-					map_destroy(dev->mtd_info);
-				}
-				kfree(dev);
-			}
-		}
-	}
+	BUG_ON(dev_list != NULL);
 }
 
 module_init(init_pcmciamtd);
Index: linux-2.6.10/drivers/mtd/maps/plat-ram.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/maps/plat-ram.c
@@ -0,0 +1,278 @@
+/* drivers/mtd/maps/plat-ram.c
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Generic platfrom device based RAM map
+ *
+ * $Id: plat-ram.c,v 1.2 2005/03/14 20:33:19 bjd Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/plat-ram.h>
+
+#include <asm/io.h>
+
+/* private structure for each mtd platform ram device created */
+
+struct platram_info {
+	struct device		*dev;
+	struct mtd_info		*mtd;
+	struct map_info		 map;
+	struct mtd_partition	*partitions;
+	struct resource		*area;
+	struct platdata_mtd_ram	*pdata;
+};
+
+/* to_platram_info()
+ *
+ * device private data to struct platram_info conversion
+*/
+
+static inline struct platram_info *to_platram_info(struct device *dev)
+{
+	return (struct platram_info *)dev_get_drvdata(dev);
+}
+
+/* platram_setrw
+ *
+ * call the platform device's set rw/ro control
+ *
+ * to = 0 => read-only
+ *    = 1 => read-write
+*/
+
+static inline void platram_setrw(struct platram_info *info, int to)
+{
+	if (info->pdata == NULL)
+		return;
+
+	if (info->pdata->set_rw != NULL)
+		(info->pdata->set_rw)(info->dev, to);
+}
+
+/* platram_remove
+ *
+ * called to remove the device from the driver's control
+*/
+
+static int platram_remove(struct device *dev)
+{
+	struct platram_info *info = to_platram_info(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	dev_dbg(dev, "removing device\n");
+
+	if (info == NULL) 
+		return 0;
+
+	if (info->mtd) {
+#ifdef CONFIG_MTD_PARTITIONS
+		if (info->partitions) {
+			del_mtd_partitions(info->mtd);
+			kfree(info->partitions);
+		}
+#endif
+		del_mtd_device(info->mtd);
+		map_destroy(info->mtd);
+	}
+
+	/* ensure ram is left read-only */
+
+	platram_setrw(info, PLATRAM_RO);
+
+	/* release resources */
+
+	if (info->area) {
+		release_resource(info->area);
+		kfree(info->area);
+	}
+
+	if (info->map.virt != NULL)
+		iounmap(info->map.virt);
+	
+	kfree(info);
+
+	return 0;
+}
+
+/* platram_probe
+ *
+ * called from device drive system when a device matching our
+ * driver is found.
+*/
+
+static int platram_probe(struct device *dev)
+{
+	struct platform_device *pd = to_platform_device(dev);
+	struct platdata_mtd_ram	*pdata;
+	struct platram_info *info;
+	struct resource *res;
+	int err = 0;
+
+	dev_dbg(dev, "probe entered\n");
+	
+	if (dev->platform_data == NULL) {
+		dev_err(dev, "no platform data supplied\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	pdata = dev->platform_data;
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(dev, "no memory for flash info\n");
+		err = -ENOMEM;
+		goto exit_error;
+	}
+
+	memset(info, 0, sizeof(*info));
+	dev_set_drvdata(dev, info);
+
+	info->dev = dev;
+	info->pdata = pdata;
+
+	/* get the resource for the memory mapping */
+
+	res = platform_get_resource(pd, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		dev_err(dev, "no memory resource specified\n");
+		err = -ENOENT;
+		goto exit_free;
+	}
+
+	dev_dbg(dev, "got platform resource %p (0x%lx)\n", res, res->start);
+
+	/* setup map parameters */
+
+	info->map.phys = res->start;
+	info->map.size = (res->end - res->start) + 1;
+	info->map.name = pdata->mapname != NULL ? pdata->mapname : pd->name;
+	info->map.bankwidth = pdata->bankwidth;
+
+	/* register our usage of the memory area */
+
+	info->area = request_mem_region(res->start, info->map.size, pd->name);
+	if (info->area == NULL) {
+		dev_err(dev, "failed to request memory region\n");
+		err = -EIO;
+		goto exit_free;
+	}
+
+	/* remap the memory area */
+
+	info->map.virt = ioremap(res->start, info->map.size);
+	dev_dbg(dev, "virt %p, %lu bytes\n", info->map.virt, info->map.size);
+
+	if (info->map.virt == NULL) {
+		dev_err(dev, "failed to ioremap() region\n");
+		err = -EIO;
+		goto exit_free;
+	}
+
+	simple_map_init(&info->map);
+
+	dev_dbg(dev, "initialised map, probing for mtd\n");
+
+	/* probe for the right mtd map driver */
+
+	info->mtd = do_map_probe("map_ram" , &info->map);
+	if (info->mtd == NULL) {
+		dev_err(dev, "failed to probe for map_ram\n");
+		err = -ENOMEM;
+		goto exit_free;
+	}
+
+	info->mtd->owner = THIS_MODULE;
+
+	platram_setrw(info, PLATRAM_RW);
+
+	/* check to see if there are any available partitions, or wether
+	 * to add this device whole */
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (pdata->nr_partitions > 0) {
+		const char **probes = { NULL };
+
+		if (pdata->probes)
+			probes = (const char **)pdata->probes;
+
+		err = parse_mtd_partitions(info->mtd, probes,
+					   &info->partitions, 0);
+		if (err > 0) {
+			err = add_mtd_partitions(info->mtd, info->partitions,
+						 err);
+		}
+	}
+#endif /* CONFIG_MTD_PARTITIONS */
+
+	if (add_mtd_device(info->mtd)) {
+		dev_err(dev, "add_mtd_device() failed\n");
+		err = -ENOMEM;
+	}
+	
+	dev_info(dev, "registered mtd device\n");
+	return err;
+
+ exit_free:
+	platram_remove(dev);
+ exit_error:
+	return err;
+}
+
+/* device driver info */
+
+static struct device_driver platram_driver = {
+	.name		= "mtd-ram",
+	.bus		= &platform_bus_type,
+	.probe		= platram_probe,
+	.remove		= platram_remove,
+};
+
+/* module init/exit */
+
+static int __init platram_init(void)
+{
+	printk("Generic platform RAM MTD, (c) 2004 Simtec Electronics\n");
+	return driver_register(&platram_driver);
+}
+
+static void __exit platram_exit(void)
+{
+	driver_unregister(&platram_driver);
+}
+
+module_init(platram_init);
+module_exit(platram_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("MTD platform RAM map driver");
Index: linux-2.6.10/drivers/mtd/maps/pnc2000.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/pnc2000.c
+++ linux-2.6.10/drivers/mtd/maps/pnc2000.c
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: pnc2000.c,v 1.17 2004/11/16 18:29:02 dwmw2 Exp $
+ * $Id: pnc2000.c,v 1.16 2004/09/16 23:27:13 gleixner Exp $
  */
 
 #include <linux/module.h>
Index: linux-2.6.10/drivers/mtd/maps/redwood.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/redwood.c
+++ linux-2.6.10/drivers/mtd/maps/redwood.c
@@ -1,5 +1,5 @@
 /*
- * $Id: redwood.c,v 1.10 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: redwood.c,v 1.9 2004/09/16 23:27:13 gleixner Exp $
  *
  * drivers/mtd/maps/redwood.c
  *
Index: linux-2.6.10/drivers/mtd/maps/rpxlite.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/rpxlite.c
+++ linux-2.6.10/drivers/mtd/maps/rpxlite.c
@@ -1,5 +1,5 @@
 /*
- * $Id: rpxlite.c,v 1.22 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: rpxlite.c,v 1.21 2004/09/16 23:27:13 gleixner Exp $
  *
  * Handle mapping of the flash on the RPX Lite and CLLF boards
  */
Index: linux-2.6.10/drivers/mtd/maps/sa1100-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sa1100-flash.c
+++ linux-2.6.10/drivers/mtd/maps/sa1100-flash.c
@@ -3,9 +3,8 @@
  * 
  * (C) 2000 Nicolas Pitre <nico@cam.org>
  * 
- * $Id: sa1100-flash.c,v 1.46 2004/11/01 13:12:24 rmk Exp $
+ * $Id: sa1100-flash.c,v 1.48 2005/03/18 02:01:48 gleixner Exp $
  */
-
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -14,177 +13,24 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/err.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/concat.h>
 
-#include <asm/hardware.h>
 #include <asm/mach-types.h>
 #include <asm/io.h>
 #include <asm/sizes.h>
+#include <asm/mach/flash.h>
 
-#include <asm/arch/h3600.h>
-
-#ifndef CONFIG_ARCH_SA1100
-#error This is for SA1100 architecture only
-#endif
-
-/*
- * This isnt complete yet, so...
- */
-#define CONFIG_MTD_SA1100_STATICMAP 1
-
-#ifdef CONFIG_MTD_SA1100_STATICMAP
-/*
- * Here are partition information for all known SA1100-based devices.
- * See include/linux/mtd/partitions.h for definition of the mtd_partition
- * structure.
- *
- * Please note:
- *  1. We no longer support static flash mappings via the machine io_desc
- *     structure.
- *  2. The flash size given should be the largest flash size that can
- *     be accommodated.
- *
- * The MTD layer will detect flash chip aliasing and reduce the size of
- * the map accordingly.
- *
- * Please keep these in alphabetical order, and formatted as per existing
- * entries.  Thanks.
- */
-
-#ifdef CONFIG_SA1100_ADSBITSY
-static struct mtd_partition adsbitsy_partitions[] = {
-	{
-		.name		= "bootROM",
-		.size		= 0x80000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_ASSABET
-/* Phase 4 Assabet has two 28F160B3 flash parts in bank 0: */
-static struct mtd_partition assabet4_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00020000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00020000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "jffs",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-
-/* Phase 5 Assabet has two 28F128J3A flash parts in bank 0: */
-static struct mtd_partition assabet5_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "jffs",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-
-#define assabet_partitions	assabet5_partitions
-#endif
-
-#ifdef CONFIG_SA1100_BADGE4
+#if 0
 /*
- * 1 x Intel 28F320C3 Advanced+ Boot Block Flash (32 Mi bit)
- *   Eight 4 KiW Parameter Bottom Blocks (64 KiB)
- *   Sixty-three 32 KiW Main Blocks (4032 Ki b)
- *
- * <or>
- *
- * 1 x Intel 28F640C3 Advanced+ Boot Block Flash (64 Mi bit)
- *   Eight 4 KiW Parameter Bottom Blocks (64 KiB)
- *   One-hundred-twenty-seven 32 KiW Main Blocks (8128 Ki b)
+ * This is here for documentation purposes only - until these people
+ * submit their machine types.  It will be gone January 2005.
  */
-static struct mtd_partition badge4_partitions[] = {
-	{
-		.name		= "BLOB boot loader",
-		.offset		= 0,
-		.size		= 0x0000A000
-	}, {
-		.name		= "params",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 0x00006000
-	}, {
-		.name		= "root",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL
-	}
-};
-#endif
-
-
-#ifdef CONFIG_SA1100_CERF
-#ifdef CONFIG_SA1100_CERF_FLASH_32MB
-#  define CERF_FLASH_SIZE	0x02000000
-#elif defined CONFIG_SA1100_CERF_FLASH_16MB
-#  define CERF_FLASH_SIZE	0x01000000
-#elif defined CONFIG_SA1100_CERF_FLASH_8MB
-#  define CERF_FLASH_SIZE	0x00800000
-#else
-#  error "Undefined flash size for CERF in sa1100-flash.c"
-#endif
-
-static struct mtd_partition cerf_partitions[] = {
-	{
-		.name		= "Bootloader",
-		.size		= 0x00020000,
-		.offset		= 0x00000000,
-	}, {
-		.name		= "Params",
-		.size		= 0x00040000,
-		.offset		= 0x00020000,
-	}, {
-		.name		= "Kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00060000,
-	}, {
-		.name		= "Filesystem",
-		.size		= CERF_FLASH_SIZE-0x00160000,
-		.offset		= 0x00160000,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_CONSUS
 static struct mtd_partition consus_partitions[] = {
 	{
 		.name		= "Consus boot firmware",
@@ -219,108 +65,7 @@ static struct mtd_partition consus_parti
 		 .mask_flags	= 0,
 	}
 };
-#endif
-
-#ifdef CONFIG_SA1100_FLEXANET
-/* Flexanet has two 28F128J3A flash parts in bank 0: */
-#define FLEXANET_FLASH_SIZE		0x02000000
-static struct mtd_partition flexanet_partitions[] = {
-	{
-		.name		= "bootloader",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "bootloader params",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "kernel",
-		.size		= 0x000C0000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "altkernel",
-		.size		= 0x000C0000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "root",
-		.size		= 0x00400000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free1",
-		.size		= 0x00300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free2",
-		.size		= 0x00300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "free3",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_FREEBIRD
-static struct mtd_partition freebird_partitions[] = {
-#ifdef CONFIG_SA1100_FREEBIRD_NEW
-	{
-		.name		= "firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "params",
-		.size		= 0x00040000,
-		.offset		= 0x000C0000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00200000,
-	}, {
-		.name		= "usr cramfs",
-		.size		= 0x00C00000,
-		.offset		= 0x00500000,
-	}, {
-		.name		= "local",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x01100000,
-	}
-#else
-	{
-		.size		= 0x00040000,
-		.offset		= 0,
-	}, {
-		.size		= 0x000c0000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0x00400000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-#endif
-};
-#endif
 
-#ifdef CONFIG_SA1100_FRODO
 /* Frodo has 2 x 16M 28F128J3A flash chips in bank 0: */
 static struct mtd_partition frodo_partitions[] =
 {
@@ -350,153 +95,7 @@ static struct mtd_partition frodo_partit
 		.offset		= MTDPART_OFS_APPEND
 	}
 };
-#endif
-
-#ifdef CONFIG_SA1100_GRAPHICSCLIENT
-static struct mtd_partition graphicsclient_partitions[] = {
-	{
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_GRAPHICSMASTER
-static struct mtd_partition graphicsmaster_partitions[] = {
-	{
-		.name		= "zImage",
-		.size		= 0x100000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	},
-	{
-		.name		= "ramdisk.gz",
-		.size		= 0x300000,
-		.offset		= MTDPART_OFS_APPEND,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	},
-	{
-		.name		= "User FS",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_H3XXX
-static struct mtd_partition h3xxx_partitions[] = {
-	{
-		.name		= "H3XXX boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-#ifdef CONFIG_MTD_2PARTS_IPAQ
-		.name		= "H3XXX root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00040000,
-#else
-		.name		= "H3XXX kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "H3XXX params",
-		.size		= 0x00040000,
-		.offset		= 0x000C0000,
-	}, {
-#ifdef CONFIG_JFFS2_FS
-		.name		= "H3XXX root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00100000,
-#else
-		.name		= "H3XXX initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "H3XXX root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00200000,
-	}, {
-		.name		= "H3XXX usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00500000,
-	}, {
-		.name		= "H3XXX usr local",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= 0x00d00000,
-#endif
-#endif
-	}
-};
-
-static void h3xxx_set_vpp(struct map_info *map, int vpp)
-{
-	assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, vpp);
-}
-#else
-#define h3xxx_set_vpp NULL
-#endif
-
-#ifdef CONFIG_SA1100_HACKKIT
-static struct mtd_partition hackkit_partitions[] = {
-	{
-		.name		= "BLOB",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "config",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00180000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "rootfs",
-		.size		= 0x700000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "data",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
-
-#ifdef CONFIG_SA1100_HUW_WEBPANEL
-static struct mtd_partition huw_webpanel_partitions[] = {
-	{
-		.name		= "Loader",
-		.size		= 0x00040000,
-		.offset		= 0,
-	}, {
-		.name		= "Sector 1",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
 
-#ifdef CONFIG_SA1100_JORNADA56X
 static struct mtd_partition jornada56x_partitions[] = {
 	{
 		.name		= "bootldr",
@@ -510,7 +109,7 @@ static struct mtd_partition jornada56x_p
 	}
 };
 
-static void jornada56x_set_vpp(struct map_info *map, int vpp)
+static void jornada56x_set_vpp(int vpp)
 {
 	if (vpp)
 		GPSR = GPIO_GPIO26;
@@ -518,870 +117,336 @@ static void jornada56x_set_vpp(struct ma
 		GPCR = GPIO_GPIO26;
 	GPDR |= GPIO_GPIO26;
 }
-#else
-#define jornada56x_set_vpp NULL
+
+/*
+ * Machine        Phys          Size    set_vpp
+ * Consus    : SA1100_CS0_PHYS SZ_32M
+ * Frodo     : SA1100_CS0_PHYS SZ_32M
+ * Jornada56x: SA1100_CS0_PHYS SZ_32M jornada56x_set_vpp
+ */
 #endif
 
-#ifdef CONFIG_SA1100_JORNADA720
-static struct mtd_partition jornada720_partitions[] = {
-	{
-		.name		= "JORNADA720 boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "JORNADA720 kernel",
-		.size		= 0x000c0000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "JORNADA720 params",
-		.size		= 0x00040000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "JORNADA720 initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00140000,
-	}, {
-		.name		= "JORNADA720 root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00240000,
-	}, {
-		.name		= "JORNADA720 usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00540000,
-	}, {
-		.name		= "JORNADA720 usr local",
-		.size		= 0,  /* will expand to the end of the flash */
-		.offset		= 0x00d00000,
-	}
+struct sa_subdev_info {
+	char name[16];
+	struct map_info map;
+	struct mtd_info *mtd;
+	struct flash_platform_data *data;
 };
 
-static void jornada720_set_vpp(struct map_info *map, int vpp)
-{
-	if (vpp)
-		PPSR |= 0x80;
-	else
-		PPSR &= ~0x80;
-	PPDR |= 0x80;
-}
-#else
-#define jornada720_set_vpp NULL
-#endif
-
-#ifdef CONFIG_SA1100_PANGOLIN
-static struct mtd_partition pangolin_partitions[] = {
-	{
-		.name		= "boot firmware",
-		.size		= 0x00080000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00080000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00280000,
-		.offset		= 0x00180000,
-	}, {
-		.name		= "initrd-test",
-		.size		= 0x03C00000,
-		.offset		= 0x00400000,
-	}
+struct sa_info {
+	struct mtd_partition	*parts;
+	struct mtd_info		*mtd;
+	int			num_subdev;
+	struct sa_subdev_info	subdev[0];
 };
-#endif
 
-#ifdef CONFIG_SA1100_PT_SYSTEM3
-/* erase size is 0x40000 == 256k partitions have to have this boundary */
-static struct mtd_partition system3_partitions[] = {
-	{
-		.name		= "BLOB",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "config",
-		.size		= 0x00040000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "root",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
+static void sa1100_set_vpp(struct map_info *map, int on)
+{
+	struct sa_subdev_info *subdev = container_of(map, struct sa_subdev_info, map);
+	subdev->data->set_vpp(on);
+}
 
-#ifdef CONFIG_SA1100_SHANNON
-static struct mtd_partition shannon_partitions[] = {
-	{
-		.name		= "BLOB boot loader",
-		.offset		= 0,
-		.size		= 0x20000
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 0xe0000
-	},
-	{ 
-		.name		= "initrd",
-		.offset		= MTDPART_OFS_APPEND,	
-		.size		= MTDPART_SIZ_FULL
-	}
-};
+static void sa1100_destroy_subdev(struct sa_subdev_info *subdev)
+{
+	if (subdev->mtd)
+		map_destroy(subdev->mtd);
+	if (subdev->map.virt)
+		iounmap(subdev->map.virt);
+	release_mem_region(subdev->map.phys, subdev->map.size);
+}
 
-#endif
+static int sa1100_probe_subdev(struct sa_subdev_info *subdev, struct resource *res)
+{
+	unsigned long phys;
+	unsigned int size;
+	int ret;
 
-#ifdef CONFIG_SA1100_SHERMAN
-static struct mtd_partition sherman_partitions[] = {
-	{
-		.size		= 0x50000,
-		.offset		= 0,
-	}, {
-		.size		= 0x70000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0x600000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.size		= 0xA0000,
-		.offset		= MTDPART_OFS_APPEND,
-	}
-};
-#endif
+	phys = res->start;
+	size = res->end - phys + 1;
 
-#ifdef CONFIG_SA1100_SIMPAD
-static struct mtd_partition simpad_partitions[] = {
-	{
-		.name		= "SIMpad boot firmware",
-		.size		= 0x00080000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "SIMpad kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-#ifdef CONFIG_ROOT_CRAMFS
-		.name		= "SIMpad root cramfs",
-		.size	     	=0x00D80000,
-		.offset		= MTDPART_OFS_APPEND
+	/*
+	 * Retrieve the bankwidth from the MSC registers.
+	 * We currently only implement CS0 and CS1 here.
+	 */
+	switch (phys) {
+	default:
+		printk(KERN_WARNING "SA1100 flash: unknown base address "
+		       "0x%08lx, assuming CS0\n", phys);
 
-	}, {
-		.name		= "SIMpad local jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND
-#else
-		.name		= "SIMpad root jffs2",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND
-#endif
-	}
-};
-#endif /* CONFIG_SA1100_SIMPAD */
+	case SA1100_CS0_PHYS:
+		subdev->map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;
+		break;
 
-#ifdef CONFIG_SA1100_STORK
-static struct mtd_partition stork_partitions[] = {
-	{
-		.name		= "STORK boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "STORK params",
-		.size		= 0x00040000,
-		.offset		= 0x00040000,
-	}, {
-		.name		= "STORK kernel",
-		.size		= 0x00100000,
-		.offset		= 0x00080000,
-	}, {
-#ifdef CONFIG_JFFS2_FS
-		.name		= "STORK root jffs2",
-		.offset		= 0x00180000,
-		.size		= MTDPART_SIZ_FULL,
-#else
-		.name		= "STORK initrd",
-		.size		= 0x00100000,
-		.offset		= 0x00180000,
-	}, {
-		.name		= "STORK root cramfs",
-		.size		= 0x00300000,
-		.offset		= 0x00280000,
-	}, {
-		.name		= "STORK usr cramfs",
-		.size		= 0x00800000,
-		.offset		= 0x00580000,
-	}, {
-		.name		= "STORK usr local",
-		.offset		= 0x00d80000,
-		.size		= MTDPART_SIZ_FULL,
-#endif
+	case SA1100_CS1_PHYS:
+		subdev->map.bankwidth = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;
+		break;
 	}
-};
-#endif
 
-#ifdef CONFIG_SA1100_TRIZEPS
-static struct mtd_partition trizeps_partitions[] = {
-	{
-		.name		= "Bootloader",
-		.size		= 0x00100000,
-		.offset		= 0,
-	}, {
-		.name		= "Kernel",
-		.size		= 0x00100000,
-		.offset		= MTDPART_OFS_APPEND,
-	}, {
-		.name		= "root",
-		.size		= MTDPART_SIZ_FULL,
-		.offset		= MTDPART_OFS_APPEND,
+	if (!request_mem_region(phys, size, subdev->name)) {
+		ret = -EBUSY;
+		goto out;
 	}
-};
-#endif
 
-#ifdef CONFIG_SA1100_YOPY
-static struct mtd_partition yopy_partitions[] = {
-	{
-		.name		= "boot firmware",
-		.size		= 0x00040000,
-		.offset		= 0x00000000,
-		.mask_flags	= MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name		= "kernel",
-		.size		= 0x00080000,
-		.offset		= 0x00080000,
-	}, {
-		.name		= "initrd",
-		.size		= 0x00300000,
-		.offset		= 0x00100000,
-	}, {
-		.name		= "root",
-		.size		= 0x01000000,
-		.offset		= 0x00400000,
+	if (subdev->data->set_vpp)
+		subdev->map.set_vpp = sa1100_set_vpp;
+
+	subdev->map.phys = phys;
+	subdev->map.size = size;
+	subdev->map.virt = ioremap(phys, size);
+	if (!subdev->map.virt) {
+		ret = -ENOMEM;
+		goto err;
 	}
-};
-#endif
 
-static int __init sa1100_static_partitions(struct mtd_partition **parts)
+	simple_map_init(&subdev->map);
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	subdev->mtd = do_map_probe(subdev->data->map_name, &subdev->map);
+	if (subdev->mtd == NULL) {
+		ret = -ENXIO;
+		goto err;
+	}
+	subdev->mtd->owner = THIS_MODULE;
+
+	printk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %dMiB, "
+		"%d-bit\n", phys, subdev->mtd->size >> 20,
+		subdev->map.bankwidth * 8);
+
+	return 0;
+
+ err:
+	sa1100_destroy_subdev(subdev);
+ out:
+	return ret;
+}
+
+static void sa1100_destroy(struct sa_info *info)
 {
-	int nb_parts = 0;
+	int i;
 
-#ifdef CONFIG_SA1100_ADSBITSY
-	if (machine_is_adsbitsy()) {
-		*parts       = adsbitsy_partitions;
-		nb_parts     = ARRAY_SIZE(adsbitsy_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_ASSABET
-	if (machine_is_assabet()) {
-		*parts       = assabet_partitions;
-		nb_parts     = ARRAY_SIZE(assabet_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_BADGE4
-	if (machine_is_badge4()) {
-		*parts       = badge4_partitions;
-		nb_parts     = ARRAY_SIZE(badge4_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_CERF
-	if (machine_is_cerf()) {
-		*parts       = cerf_partitions;
-		nb_parts     = ARRAY_SIZE(cerf_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_CONSUS
-	if (machine_is_consus()) {
-		*parts       = consus_partitions;
-		nb_parts     = ARRAY_SIZE(consus_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FLEXANET
-	if (machine_is_flexanet()) {
-		*parts       = flexanet_partitions;
-		nb_parts     = ARRAY_SIZE(flexanet_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FREEBIRD
-	if (machine_is_freebird()) {
-		*parts       = freebird_partitions;
-		nb_parts     = ARRAY_SIZE(freebird_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_FRODO
-	if (machine_is_frodo()) {
-		*parts       = frodo_partitions;
-		nb_parts     = ARRAY_SIZE(frodo_partitions);
-	}
-#endif	
-#ifdef CONFIG_SA1100_GRAPHICSCLIENT
-	if (machine_is_graphicsclient()) {
-		*parts       = graphicsclient_partitions;
-		nb_parts     = ARRAY_SIZE(graphicsclient_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_GRAPHICSMASTER
-	if (machine_is_graphicsmaster()) {
-		*parts       = graphicsmaster_partitions;
-		nb_parts     = ARRAY_SIZE(graphicsmaster_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_H3XXX
-	if (machine_is_h3xxx()) {
-		*parts       = h3xxx_partitions;
-		nb_parts     = ARRAY_SIZE(h3xxx_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_HACKKIT
-	if (machine_is_hackkit()) {
-		*parts = hackkit_partitions;
-		nb_parts = ARRAY_SIZE(hackkit_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_HUW_WEBPANEL
-	if (machine_is_huw_webpanel()) {
-		*parts       = huw_webpanel_partitions;
-		nb_parts     = ARRAY_SIZE(huw_webpanel_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_JORNADA56X
-	if (machine_is_jornada56x()) {
-		*parts       = jornada56x_partitions;
-		nb_parts     = ARRAY_SIZE(jornada56x_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_JORNADA720
-	if (machine_is_jornada720()) {
-		*parts       = jornada720_partitions;
-		nb_parts     = ARRAY_SIZE(jornada720_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_PANGOLIN
-	if (machine_is_pangolin()) {
-		*parts       = pangolin_partitions;
-		nb_parts     = ARRAY_SIZE(pangolin_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_PT_SYSTEM3
-	if (machine_is_pt_system3()) {
-		*parts       = system3_partitions;
-		nb_parts     = ARRAY_SIZE(system3_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SHANNON
-	if (machine_is_shannon()) {
-		*parts       = shannon_partitions;
-		nb_parts     = ARRAY_SIZE(shannon_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SHERMAN
-	if (machine_is_sherman()) {
-		*parts       = sherman_partitions;
-		nb_parts     = ARRAY_SIZE(sherman_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_SIMPAD
-	if (machine_is_simpad()) {
-		*parts       = simpad_partitions;
-		nb_parts     = ARRAY_SIZE(simpad_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_STORK
-	if (machine_is_stork()) {
-		*parts       = stork_partitions;
-		nb_parts     = ARRAY_SIZE(stork_partitions);
-	}
-#endif
-#ifdef CONFIG_SA1100_TRIZEPS
-	if (machine_is_trizeps()) {
-		*parts       = trizeps_partitions;
-		nb_parts     = ARRAY_SIZE(trizeps_partitions);
-	}
+	if (info->mtd) {
+		del_mtd_partitions(info->mtd);
+
+#ifdef CONFIG_MTD_CONCAT
+		if (info->mtd != info->subdev[0].mtd)
+			mtd_concat_destroy(info->mtd);
 #endif
-#ifdef CONFIG_SA1100_YOPY
-	if (machine_is_yopy()) {
-		*parts       = yopy_partitions;
-		nb_parts     = ARRAY_SIZE(yopy_partitions);
 	}
-#endif
 
-	return nb_parts;
+	if (info->parts)
+		kfree(info->parts);
+
+	for (i = info->num_subdev - 1; i >= 0; i--)
+		sa1100_destroy_subdev(&info->subdev[i]);
+	kfree(info);
 }
-#endif
 
-struct sa_info {
-	unsigned long base;
-	unsigned long size;
-	int width;
-	void (*set_vpp)(struct map_info *, int);
-	char name[16];
-	struct map_info *map;
-	struct mtd_info *mtd;
-};
+static struct sa_info *__init
+sa1100_setup_mtd(struct platform_device *pdev, struct flash_platform_data *flash)
+{
+	struct sa_info *info;
+	int nr, size, i, ret = 0;
 
-#define NR_SUBMTD 4
+	/*
+	 * Count number of devices.
+	 */
+	for (nr = 0; ; nr++)
+		if (!platform_get_resource(pdev, IORESOURCE_MEM, nr))
+			break;
 
-static struct sa_info info[NR_SUBMTD];
+	if (nr == 0) {
+		ret = -ENODEV;
+		goto out;
+	}
 
-static int __init sa1100_setup_mtd(struct sa_info *sa, int nr, struct mtd_info **rmtd)
-{
-	struct mtd_info *subdev[nr];
-	struct map_info *maps;
-	int i, found = 0, ret = 0;
+	size = sizeof(struct sa_info) + sizeof(struct sa_subdev_info) * nr;
 
 	/*
 	 * Allocate the map_info structs in one go.
 	 */
-	maps = kmalloc(sizeof(struct map_info) * nr, GFP_KERNEL);
-	if (!maps)
-		return -ENOMEM;
+	info = kmalloc(size, GFP_KERNEL);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
-	memset(maps, 0, sizeof(struct map_info) * nr);
+	memset(info, 0, size);
 
 	/*
 	 * Claim and then map the memory regions.
 	 */
 	for (i = 0; i < nr; i++) {
-		if (sa[i].base == (unsigned long)-1)
-			break;
-
-		sa[i].map = maps + i;
-		sa[i].map->name = sa[i].name;
-		sprintf(sa[i].name, "sa1100-%d", i);
-
-		if (!request_mem_region(sa[i].base, sa[i].size, sa[i].name)) {
-			i -= 1;
-			ret = -EBUSY;
-			break;
-		}
+		struct sa_subdev_info *subdev = &info->subdev[i];
+		struct resource *res;
 
-		sa[i].map->virt = ioremap(sa[i].base, sa[i].size);
-		if (!sa[i].map->virt) {
-			ret = -ENOMEM;
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res)
 			break;
-		}
-
-		sa[i].map->phys = sa[i].base;
-		sa[i].map->set_vpp = sa[i].set_vpp;
-		sa[i].map->bankwidth = sa[i].width;
-		sa[i].map->size = sa[i].size;
 
-		simple_map_init(sa[i].map);
+		subdev->map.name = subdev->name;
+		sprintf(subdev->name, "sa1100-%d", i);
+		subdev->data = flash;
 
-		/*
-		 * Now let's probe for the actual flash.  Do it here since
-		 * specific machine settings might have been set above.
-		 */
-		sa[i].mtd = do_map_probe("cfi_probe", sa[i].map);
-		if (sa[i].mtd == NULL) {
-			ret = -ENXIO;
+		ret = sa1100_probe_subdev(subdev, res);
+		if (ret)
 			break;
-		}
-		sa[i].mtd->owner = THIS_MODULE;
-		subdev[i] = sa[i].mtd;
-
-		printk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %dMiB, "
-			"%d-bit\n", sa[i].base, sa[i].mtd->size >> 20,
-			sa[i].width * 8);
-		found += 1;
 	}
 
-	/*
-	 * ENXIO is special.  It means we didn't find a chip when
-	 * we probed.  We need to tear down the mapping, free the
-	 * resource and mark it as such.
-	 */
-	if (ret == -ENXIO) {
-		iounmap(sa[i].map->virt);
-		sa[i].map->virt = NULL;
-		release_mem_region(sa[i].base, sa[i].size);
-	}
+	info->num_subdev = i;
 
 	/*
-	 * If we found one device, don't bother with concat support.
-	 * If we found multiple devices, use concat if we have it
-	 * available, otherwise fail.
+	 * ENXIO is special.  It means we didn't find a chip when we probed.
 	 */
-	if (ret == 0 || ret == -ENXIO) {
-		if (found == 1) {
-			*rmtd = subdev[0];
-			ret = 0;
-		} else if (found > 1) {
-			/*
-			 * We detected multiple devices.  Concatenate
-			 * them together.
-			 */
-#ifdef CONFIG_MTD_CONCAT
-			*rmtd = mtd_concat_create(subdev, found,
-						  "sa1100");
-			if (*rmtd == NULL)
-				ret = -ENXIO;
-#else
-			printk(KERN_ERR "SA1100 flash: multiple devices "
-			       "found but MTD concat support disabled.\n");
-			ret = -ENXIO;
-#endif
-		}
-	}
+	if (ret != 0 && !(ret == -ENXIO && info->num_subdev > 0))
+		goto err;
 
 	/*
-	 * If we failed, clean up.
+	 * If we found one device, don't bother with concat support.  If
+	 * we found multiple devices, use concat if we have it available,
+	 * otherwise fail.  Either way, it'll be called "sa1100".
 	 */
-	if (ret) {
-		do {
-			if (sa[i].mtd)
-				map_destroy(sa[i].mtd);
-			if (sa[i].map->virt)
-				iounmap(sa[i].map->virt);
-			release_mem_region(sa[i].base, sa[i].size);
-		} while (i-- > 0);
-
-		kfree(maps);
-	}
-
-	return ret;
-}
-
-static void __exit sa1100_destroy_mtd(struct sa_info *sa, struct mtd_info *mtd)
-{
-	int i;
-
-	del_mtd_partitions(mtd);
-
+	if (info->num_subdev == 1) {
+		strcpy(info->subdev[0].name, "sa1100");
+		info->mtd = info->subdev[0].mtd;
+		ret = 0;
+	} else if (info->num_subdev > 1) {
 #ifdef CONFIG_MTD_CONCAT
-	if (mtd != sa[0].mtd)
-		mtd_concat_destroy(mtd);
-#endif
-
-	for (i = NR_SUBMTD; i >= 0; i--) {
-		if (sa[i].mtd)
-			map_destroy(sa[i].mtd);
-		if (sa[i].map->virt)
-			iounmap(sa[i].map->virt);
-		release_mem_region(sa[i].base, sa[i].size);
-	}
-	kfree(sa[0].map);
-}
-
-/*
- * A Thought: can we automatically detect the flash?
- *  - Check to see if the region is busy (yes -> failure)
- *  - Is the MSC setup for flash (no -> failure)
- *  - Probe for flash
- */
-static void __init sa1100_probe_one_cs(unsigned int msc, unsigned long phys)
-{
-	struct map_info map;
-	struct mtd_info *mtd;
-
-	printk(KERN_INFO "* Probing 0x%08lx: MSC = 0x%04x %d bit ",
-		phys, msc & 0xffff, msc & MSC_RBW ? 16 : 32);
-
-	if (check_mem_region(phys, 0x08000000)) {
-		printk("busy\n");
-		return;
-	}
+		struct mtd_info *cdev[nr];
+		/*
+		 * We detected multiple devices.  Concatenate them together.
+		 */
+		for (i = 0; i < info->num_subdev; i++)
+			cdev[i] = info->subdev[i].mtd;
 
-	if ((msc & 3) == 1) {
-		printk("wrong type\n");
-		return;
+		info->mtd = mtd_concat_create(cdev, info->num_subdev,
+					      "sa1100");
+		if (info->mtd == NULL)
+			ret = -ENXIO;
+#else
+		printk(KERN_ERR "SA1100 flash: multiple devices "
+		       "found but MTD concat support disabled.\n");
+		ret = -ENXIO;
+#endif
 	}
 
-	memset(&map, 0, sizeof(struct map_info));
-
-	map.name = "Probe";
-	map.bankwidth = msc & MSC_RBW ? 2 : 4;
-	map.size = SZ_1M;
-	map.phys = phys;
-	map.virt = ioremap(phys, SZ_1M);
-	if (map.virt == NULL)
-		goto fail;
-
-	simple_map_init(&map);
-
-	/* Shame cfi_probe blurts out kernel messages... */
-	mtd = do_map_probe("cfi_probe", &map);
-	if (mtd)
-		map_destroy(mtd);
-	iounmap(map.virt);
-
-	if (!mtd)
-		goto fail;
-
-	printk("pass\n");
-	return;
+	if (ret == 0)
+		return info;
 
- fail:
-	printk("failed\n");
+ err:
+	sa1100_destroy(info);
+ out:
+	return ERR_PTR(ret);
 }
 
-static void __init sa1100_probe_flash(void)
-{
-	printk(KERN_INFO "-- SA11xx Flash probe.  Please report results.\n");
-	sa1100_probe_one_cs(MSC0, SA1100_CS0_PHYS);
-	sa1100_probe_one_cs(MSC0 >> 16, SA1100_CS1_PHYS);
-	sa1100_probe_one_cs(MSC1, SA1100_CS2_PHYS);
-	sa1100_probe_one_cs(MSC1 >> 16, SA1100_CS3_PHYS);
-	sa1100_probe_one_cs(MSC2, SA1100_CS4_PHYS);
-	sa1100_probe_one_cs(MSC2 >> 16, SA1100_CS5_PHYS);
-	printk(KERN_INFO "-- SA11xx Flash probe complete.\n");
-}
+static const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
 
-static int __init sa1100_locate_flash(void)
+static int __init sa1100_mtd_probe(struct device *dev)
 {
-	int i, nr = -ENODEV;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	struct mtd_partition *parts;
+	const char *part_type = NULL;
+	struct sa_info *info;
+	int err, nr_parts = 0;
 
-	sa1100_probe_flash();
+	if (!flash)
+		return -ENODEV;
 
-	if (machine_is_adsbitsy()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_assabet()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		info[1].base = SA1100_CS1_PHYS; /* neponset */
-		info[1].size = SZ_32M;
-		nr = 2;
-	}
-	if (machine_is_badge4()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		nr = 1;
-	}
-	if (machine_is_cerf()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_consus()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_flexanet()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_freebird()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_frodo()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_graphicsclient()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_graphicsmaster()) {
-		info[0].base = SA1100_CS1_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_h3xxx()) {
-		info[0].set_vpp = h3xxx_set_vpp;
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_huw_webpanel()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_itsy()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_jornada56x()) {
-		info[0].set_vpp = jornada56x_set_vpp;
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_jornada720()) {
-		info[0].set_vpp = jornada720_set_vpp;
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_nanoengine()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[1].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_pangolin()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		nr = 1;
-	}
-	if (machine_is_pfs168()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_pleb()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_4M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_4M;
-		nr = 2;
-	}
-	if (machine_is_pt_system3()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_shannon()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_4M;
-		nr = 1;
-	}
-	if (machine_is_sherman()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_simpad()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_16M;
-		nr = 2;
-	}
-	if (machine_is_stork()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_32M;
-		nr = 1;
-	}
-	if (machine_is_trizeps()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_16M;
-		nr = 1;
-	}
-	if (machine_is_victor()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_2M;
-		nr = 1;
-	}
-	if (machine_is_yopy()) {
-		info[0].base = SA1100_CS0_PHYS;
-		info[0].size = SZ_64M;
-		info[1].base = SA1100_CS1_PHYS;
-		info[1].size = SZ_64M;
-		nr = 2;
+	info = sa1100_setup_mtd(pdev, flash);
+	if (IS_ERR(info)) {
+		err = PTR_ERR(info);
+		goto out;
 	}
 
-	if (nr < 0)
-		return nr;
-
 	/*
-	 * Retrieve the bankwidth from the MSC registers.
-	 * We currently only implement CS0 and CS1 here.
+	 * Partition selection stuff.
 	 */
-	for (i = 0; i < nr; i++) {
-		switch (info[i].base) {
-		default:
-			printk(KERN_WARNING "SA1100 flash: unknown base address "
-				"0x%08lx, assuming CS0\n", info[i].base);
-		case SA1100_CS0_PHYS:
-			info[i].width = (MSC0 & MSC_RBW) ? 2 : 4;
-			break;
-
-		case SA1100_CS1_PHYS:
-			info[i].width = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;
-			break;
-		}
-	}
-
-	return nr;
-}
-
-static struct mtd_partition *parsed_parts;
-const char *part_probes[] = { "cmdlinepart", "RedBoot", NULL };
-
-static void __init sa1100_locate_partitions(struct mtd_info *mtd)
-{
-	const char *part_type = NULL;
-	int nr_parts = 0;
-
-	do {
-		/*
-		 * Partition selection stuff.
-		 */
 #ifdef CONFIG_MTD_PARTITIONS
-		nr_parts = parse_mtd_partitions(mtd, part_probes, &parsed_parts, 0);
-		if (nr_parts > 0) {
-			part_type = "dynamic";
-			break;
-		}
-#endif
-#ifdef CONFIG_MTD_SA1100_STATICMAP
-		nr_parts = sa1100_static_partitions(&parsed_parts);
-		if (nr_parts > 0) {
-			part_type = "static";
-			break;
-		}
+	nr_parts = parse_mtd_partitions(info->mtd, part_probes, &parts, 0);
+	if (nr_parts > 0) {
+		info->parts = parts;
+		part_type = "dynamic";
+	} else
 #endif
-	} while (0);
+	{
+		parts = flash->parts;
+		nr_parts = flash->nr_parts;
+		part_type = "static";
+	}
 
 	if (nr_parts == 0) {
 		printk(KERN_NOTICE "SA1100 flash: no partition info "
 			"available, registering whole flash\n");
-		add_mtd_device(mtd);
+		add_mtd_device(info->mtd);
 	} else {
 		printk(KERN_NOTICE "SA1100 flash: using %s partition "
 			"definition\n", part_type);
-		add_mtd_partitions(mtd, parsed_parts, nr_parts);
+		add_mtd_partitions(info->mtd, parts, nr_parts);
 	}
 
-	/* Always succeeds. */
+	dev_set_drvdata(dev, info);
+	err = 0;
+
+ out:
+	return err;
 }
 
-static void __exit sa1100_destroy_partitions(void)
+static int __exit sa1100_mtd_remove(struct device *dev)
 {
-	if (parsed_parts)
-		kfree(parsed_parts);
+	struct sa_info *info = dev_get_drvdata(dev);
+	dev_set_drvdata(dev, NULL);
+	sa1100_destroy(info);
+	return 0;
 }
 
-static struct mtd_info *mymtd;
-
-static int __init sa1100_mtd_init(void)
+#ifdef CONFIG_PM
+static int sa1100_mtd_suspend(struct device *dev, pm_message_t state, u32 level)
 {
-	int ret;
-	int nr;
+	struct sa_info *info = dev_get_drvdata(dev);
+	int ret = 0;
 
-	nr = sa1100_locate_flash();
-	if (nr < 0)
-		return nr;
-
-	ret = sa1100_setup_mtd(info, nr, &mymtd);
-	if (ret == 0)
-		sa1100_locate_partitions(mymtd);
+	if (info && level == SUSPEND_SAVE_STATE)
+		ret = info->mtd->suspend(info->mtd);
 
 	return ret;
 }
 
-static void __exit sa1100_mtd_cleanup(void)
+static int sa1100_mtd_resume(struct device *dev, u32 level)
+{
+	struct sa_info *info = dev_get_drvdata(dev);
+	if (info && level == RESUME_RESTORE_STATE)
+		info->mtd->resume(info->mtd);
+	return 0;
+}
+#else
+#define sa1100_mtd_suspend NULL
+#define sa1100_mtd_resume  NULL
+#endif
+
+static struct device_driver sa1100_mtd_driver = {
+	.name		= "flash",
+	.bus		= &platform_bus_type,
+	.probe		= sa1100_mtd_probe,
+	.remove		= __exit_p(sa1100_mtd_remove),
+	.suspend	= sa1100_mtd_suspend,
+	.resume		= sa1100_mtd_resume,
+};
+
+static int __init sa1100_mtd_init(void)
+{
+	return driver_register(&sa1100_mtd_driver);
+}
+
+static void __exit sa1100_mtd_exit(void)
 {
-	sa1100_destroy_mtd(info, mymtd);
-	sa1100_destroy_partitions();
+	driver_unregister(&sa1100_mtd_driver);
 }
 
 module_init(sa1100_mtd_init);
-module_exit(sa1100_mtd_cleanup);
+module_exit(sa1100_mtd_exit);
 
 MODULE_AUTHOR("Nicolas Pitre");
 MODULE_DESCRIPTION("SA1100 CFI map driver");
Index: linux-2.6.10/drivers/mtd/maps/sbc8240.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sbc8240.c
+++ linux-2.6.10/drivers/mtd/maps/sbc8240.c
@@ -5,7 +5,7 @@
  *
  * This code is GPLed
  *
- * $Id: sbc8240.c,v 1.4 2004/07/12 22:38:29 dwmw2 Exp $
+ * $Id: sbc8240.c,v 1.3 2004/07/12 21:59:45 dwmw2 Exp $
  *
  */
 
Index: linux-2.6.10/drivers/mtd/maps/sbc_gxx.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sbc_gxx.c
+++ linux-2.6.10/drivers/mtd/maps/sbc_gxx.c
@@ -17,7 +17,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 
-   $Id: sbc_gxx.c,v 1.32 2004/11/16 18:29:02 dwmw2 Exp $
+   $Id: sbc_gxx.c,v 1.33 2004/11/28 09:40:40 dwmw2 Exp $
 
 The SBC-MediaGX / SBC-GXx has up to 16 MiB of 
 Intel StrataFlash (28F320/28F640) in x8 mode.  
Index: linux-2.6.10/drivers/mtd/maps/sc520cdp.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sc520cdp.c
+++ linux-2.6.10/drivers/mtd/maps/sc520cdp.c
@@ -16,7 +16,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id: sc520cdp.c,v 1.18 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: sc520cdp.c,v 1.20 2004/12/11 15:41:19 dedekind Exp $
  *
  *
  * The SC520CDP is an evaluation board for the Elan SC520 processor available
Index: linux-2.6.10/drivers/mtd/maps/scb2_flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/scb2_flash.c
+++ linux-2.6.10/drivers/mtd/maps/scb2_flash.c
@@ -1,6 +1,6 @@
 /*
  * MTD map driver for BIOS Flash on Intel SCB2 boards
- * $Id: scb2_flash.c,v 1.10 2004/11/16 18:29:02 dwmw2 Exp $
+ * $Id: scb2_flash.c,v 1.11 2004/11/28 09:40:40 dwmw2 Exp $
  * Copyright (C) 2002 Sun Microsystems, Inc.
  * Tim Hockin <thockin@sun.com>
  *
@@ -238,7 +238,7 @@ static struct pci_driver scb2_flash_driv
 static int __init
 scb2_flash_init(void)
 {
-	return pci_module_init(&scb2_flash_driver);
+	return pci_register_driver(&scb2_flash_driver);
 }
 
 static void __exit
Index: linux-2.6.10/drivers/mtd/maps/scx200_docflash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/scx200_docflash.c
+++ linux-2.6.10/drivers/mtd/maps/scx200_docflash.c
@@ -2,7 +2,7 @@
 
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
 
-   $Id: scx200_docflash.c,v 1.9 2004/11/16 18:29:02 dwmw2 Exp $ 
+   $Id: scx200_docflash.c,v 1.10 2004/11/28 09:40:40 dwmw2 Exp $ 
 
    National Semiconductor SCx200 flash mapped with DOCCS
 */
@@ -26,23 +26,20 @@ MODULE_AUTHOR("Christer Weinigel <wingel
 MODULE_DESCRIPTION("NatSemi SCx200 DOCCS Flash Driver");
 MODULE_LICENSE("GPL");
 
-/* Set this to one if you want to partition the flash */
-#define PARTITION 1
+static int probe = 0;		/* Don't autoprobe */
+static unsigned size = 0x1000000; /* 16 MiB the whole ISA address space */
+static unsigned width = 8;	/* Default to 8 bits wide */
+static char *flashtype = "cfi_probe";
 
-MODULE_PARM(probe, "i");
+module_param(probe, int, 0);
 MODULE_PARM_DESC(probe, "Probe for a BIOS mapping");
-MODULE_PARM(size, "i");
+module_param(size, int, 0);
 MODULE_PARM_DESC(size, "Size of the flash mapping");
-MODULE_PARM(width, "i");
+module_param(width, int, 0);
 MODULE_PARM_DESC(width, "Data width of the flash mapping (8/16)");
-MODULE_PARM(flashtype, "s");
+module_param(flashtype, charp, 0);
 MODULE_PARM_DESC(flashtype, "Type of MTD probe to do");
 
-static int probe = 0;		/* Don't autoprobe */
-static unsigned size = 0x1000000; /* 16 MiB the whole ISA address space */
-static unsigned width = 8;	/* Default to 8 bits wide */
-static char *flashtype = "cfi_probe";
-
 static struct resource docmem = {
 	.flags = IORESOURCE_MEM,
 	.name  = "NatSemi SCx200 DOCCS Flash",
@@ -50,7 +47,7 @@ static struct resource docmem = {
 
 static struct mtd_info *mymtd;
 
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition partition_info[] = {
 	{ 
 		.name   = "DOCCS Boot kernel", 
@@ -95,17 +92,16 @@ static int __init init_scx200_docflash(v
 				      PCI_DEVICE_ID_NS_SCx200_BRIDGE,
 				      NULL)) == NULL)
 		return -ENODEV;
-	
-	if (!scx200_cb_probe(SCx200_CB_BASE)) {
-		printk(KERN_WARNING NAME ": no configuration block found\n");
+
+	/* check that we have found the configuration block */
+	if (!scx200_cb_present())
 		return -ENODEV;
-	}
 
 	if (probe) {
 		/* Try to use the present flash mapping if any */
 		pci_read_config_dword(bridge, SCx200_DOCCS_BASE, &base);
 		pci_read_config_dword(bridge, SCx200_DOCCS_CTRL, &ctrl);
-		pmr = inl(SCx200_CB_BASE + SCx200_PMR);
+		pmr = inl(scx200_cb_base + SCx200_PMR);
 
 		if (base == 0
 		    || (ctrl & 0x07000000) != 0x07000000
@@ -158,14 +154,14 @@ static int __init init_scx200_docflash(v
 		
 		pci_write_config_dword(bridge, SCx200_DOCCS_BASE, docmem.start);
 		pci_write_config_dword(bridge, SCx200_DOCCS_CTRL, ctrl);
-		pmr = inl(SCx200_CB_BASE + SCx200_PMR);
+		pmr = inl(scx200_cb_base + SCx200_PMR);
 		
 		if (width == 8) {
 			pmr &= ~(1<<6);
 		} else {
 			pmr |= (1<<6);
 		}
-		outl(pmr, SCx200_CB_BASE + SCx200_PMR);
+		outl(pmr, scx200_cb_base + SCx200_PMR);
 	}
 	
        	printk(KERN_INFO NAME ": DOCCS mapped at 0x%lx-0x%lx, width %d\n", 
@@ -200,7 +196,7 @@ static int __init init_scx200_docflash(v
 
 	mymtd->owner = THIS_MODULE;
 
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 	partition_info[3].offset = mymtd->size-partition_info[3].size;
 	partition_info[2].size = partition_info[3].offset-partition_info[2].offset;
 	add_mtd_partitions(mymtd, partition_info, NUM_PARTITIONS);
@@ -213,7 +209,7 @@ static int __init init_scx200_docflash(v
 static void __exit cleanup_scx200_docflash(void)
 {
 	if (mymtd) {
-#if PARTITION
+#ifdef CONFIG_MTD_PARTITIONS
 		del_mtd_partitions(mymtd);
 #else
 		del_mtd_device(mymtd);
Index: linux-2.6.10/drivers/mtd/maps/sharpsl-flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sharpsl-flash.c
+++ linux-2.6.10/drivers/mtd/maps/sharpsl-flash.c
@@ -4,7 +4,7 @@
  * Copyright (C) 2001 Lineo Japan, Inc.
  * Copyright (C) 2002  SHARP
  *
- * $Id: sharpsl-flash.c,v 1.2 2004/11/24 20:38:06 rpurdie Exp $
+ * $Id: sharpsl-flash.c,v 1.4 2005/03/21 05:50:04 gleixner Exp $
  *
  * based on rpxlite.c,v 1.15 2001/10/02 15:05:14 dwmw2 Exp
  *          Handle mapping of the flash on the RPX Lite and CLLF boards
@@ -24,13 +24,14 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <asm/io.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
 
 #define WINDOW_ADDR 0x00000000
-#define WINDOW_SIZE 0x01000000
+#define WINDOW_SIZE 0x00800000
 #define BANK_WIDTH 2
 
 static struct mtd_info *mymtd;
@@ -44,9 +45,7 @@ struct map_info sharpsl_map = {
 
 static struct mtd_partition sharpsl_partitions[1] = {
 	{
-		name:		"Filesystem",
-		size:		0x006d0000,
-		offset:		0x00120000
+		name:		"Boot PROM Filesystem",
 	}
 };
 
@@ -58,12 +57,16 @@ int __init init_sharpsl(void)
 	int nb_parts = 0;
 	char *part_type = "static";
 
-	printk(KERN_NOTICE "Sharp SL series flash device: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	printk(KERN_NOTICE "Sharp SL series flash device: %x at %x\n", 
+		WINDOW_SIZE, WINDOW_ADDR);
 	sharpsl_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
 	if (!sharpsl_map.virt) {
 		printk("Failed to ioremap\n");
 		return -EIO;
 	}
+
+	simple_map_init(&sharpsl_map);
+
 	mymtd = do_map_probe("map_rom", &sharpsl_map);
 	if (!mymtd) {
 		iounmap(sharpsl_map.virt);
@@ -72,6 +75,22 @@ int __init init_sharpsl(void)
 
 	mymtd->owner = THIS_MODULE;
 
+	if (machine_is_corgi() || machine_is_shepherd() || machine_is_husky() 
+		|| machine_is_poodle()) {
+		sharpsl_partitions[0].size=0x006d0000;
+		sharpsl_partitions[0].offset=0x00120000;
+	} else if (machine_is_tosa()) {
+		sharpsl_partitions[0].size=0x006a0000;
+		sharpsl_partitions[0].offset=0x00160000;
+	} else if (machine_is_spitz()) {
+		sharpsl_partitions[0].size=0x006b0000;
+		sharpsl_partitions[0].offset=0x00140000;
+	} else {
+		map_destroy(mymtd);
+		iounmap(sharpsl_map.virt);	
+		return -ENODEV;
+	}
+	
 	parts = sharpsl_partitions;
 	nb_parts = NB_OF(sharpsl_partitions);
 
Index: linux-2.6.10/drivers/mtd/maps/solutionengine.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/solutionengine.c
+++ linux-2.6.10/drivers/mtd/maps/solutionengine.c
@@ -1,5 +1,5 @@
 /*
- * $Id: solutionengine.c,v 1.14 2004/09/16 23:27:14 gleixner Exp $
+ * $Id: solutionengine.c,v 1.13 2004/07/12 21:59:45 dwmw2 Exp $
  *
  * Flash and EPROM on Hitachi Solution Engine and similar boards.
  *
Index: linux-2.6.10/drivers/mtd/maps/sun_uflash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/sun_uflash.c
+++ linux-2.6.10/drivers/mtd/maps/sun_uflash.c
@@ -109,7 +109,7 @@ int uflash_devinit(struct linux_ebus_dev
 	/* MTD registration */
 	pdev->mtd = do_map_probe("cfi_probe", &pdev->map);
 	if(0 == pdev->mtd) {
-		iounmap((void *)pdev->map.virt);
+		iounmap(pdev->map.virt);
 		kfree(pdev->name);
 		kfree(pdev);
 		return(-ENXIO);
@@ -163,8 +163,8 @@ static void __exit uflash_cleanup(void)
 			map_destroy(udev->mtd);
 		}
 		if(0 != udev->map.virt) {
-			iounmap((void*)udev->map.virt);
-			udev->map.virt = 0;
+			iounmap(udev->map.virt);
+			udev->map.virt = NULL;
 		}
 		if(0 != udev->name) {
 			kfree(udev->name);
Index: linux-2.6.10/drivers/mtd/maps/tqm8xxl.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/tqm8xxl.c
+++ linux-2.6.10/drivers/mtd/maps/tqm8xxl.c
@@ -2,7 +2,7 @@
  * Handle mapping of the flash memory access routines 
  * on TQM8xxL based devices.
  *
- * $Id: tqm8xxl.c,v 1.13 2004/10/20 22:21:53 dwmw2 Exp $
+ * $Id: tqm8xxl.c,v 1.11 2004/07/12 21:59:45 dwmw2 Exp $
  *
  * based on rpxlite.c
  *
Index: linux-2.6.10/drivers/mtd/maps/ts5500_flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/ts5500_flash.c
+++ linux-2.6.10/drivers/mtd/maps/ts5500_flash.c
@@ -19,26 +19,22 @@
  *
  * Note:
  * - In order for detection to work, jumper 3 must be set.
- * - Drive A and B use a proprietary FTL from General Software which isn't 
- *   supported as of yet so standard drives can't be mounted; you can create 
- *   your own (e.g. jffs) file system.
+ * - Drive A and B use the resident flash disk (RFD) flash translation layer. 
  * - If you have created your own jffs file system and the bios overwrites 
  *   it during boot, try disabling Drive A: and B: in the boot order.
  *
- * $Id: ts5500_flash.c,v 1.1 2004/09/20 15:33:26 sean Exp $
+ * $Id: ts5500_flash.c,v 1.3 2005/06/16 08:49:30 sean Exp $
  */
 
 #include <linux/config.h>
+#include <linux/init.h>
 #include <linux/module.h>
-#include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
-
-#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
-#endif
+#include <linux/types.h>
+
 
 #define WINDOW_ADDR	0x09400000
 #define WINDOW_SIZE	0x00200000
@@ -50,7 +46,6 @@ static struct map_info ts5500_map = {
 	.phys = WINDOW_ADDR
 };
 
-#ifdef CONFIG_MTD_PARTITIONS
 static struct mtd_partition ts5500_partitions[] = {
 	{
 		.name = "Drive A",
@@ -71,8 +66,6 @@ static struct mtd_partition ts5500_parti
 
 #define NUM_PARTITIONS (sizeof(ts5500_partitions)/sizeof(struct mtd_partition))
 
-#endif
-
 static struct mtd_info *mymtd;
 
 static int __init init_ts5500_map(void)
@@ -81,36 +74,32 @@ static int __init init_ts5500_map(void)
 
 	ts5500_map.virt = ioremap_nocache(ts5500_map.phys, ts5500_map.size);
 
-	if(!ts5500_map.virt) {
+	if (!ts5500_map.virt) {
 		printk(KERN_ERR "Failed to ioremap_nocache\n");
 		rc = -EIO;
-		goto err_out_ioremap;
+		goto err2;
 	}
 
 	simple_map_init(&ts5500_map);
 
 	mymtd = do_map_probe("jedec_probe", &ts5500_map);
-	if(!mymtd)
+	if (!mymtd)
 		mymtd = do_map_probe("map_rom", &ts5500_map);
 
-	if(!mymtd) {
+	if (!mymtd) {
 		rc = -ENXIO;
-		goto err_out_map;
+		goto err1;
 	}
 
 	mymtd->owner = THIS_MODULE;
-#ifdef CONFIG_MTD_PARTITIONS
 	add_mtd_partitions(mymtd, ts5500_partitions, NUM_PARTITIONS);
-#else	
-	add_mtd_device(mymtd);
-#endif
 
 	return 0;
 
-err_out_map:
+err1:
 	map_destroy(mymtd);
-err_out_ioremap:
 	iounmap(ts5500_map.virt);
+err2:
 
 	return rc;
 }
@@ -118,11 +107,7 @@ err_out_ioremap:
 static void __exit cleanup_ts5500_map(void)
 {
 	if (mymtd) {
-#ifdef CONFIG_MTD_PARTITIONS
 		del_mtd_partitions(mymtd);
-#else
-		del_mtd_device(mymtd);
-#endif
 		map_destroy(mymtd);
 	}
 
Index: linux-2.6.10/drivers/mtd/maps/tsunami_flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/tsunami_flash.c
+++ linux-2.6.10/drivers/mtd/maps/tsunami_flash.c
@@ -2,7 +2,7 @@
  * tsunami_flash.c
  *
  * flash chip on alpha ds10...
- * $Id: tsunami_flash.c,v 1.9 2004/07/14 09:52:55 dwmw2 Exp $
+ * $Id: tsunami_flash.c,v 1.8 2004/07/12 22:38:29 dwmw2 Exp $
  */
 #include <asm/io.h>
 #include <asm/core_tsunami.h>
Index: linux-2.6.10/drivers/mtd/maps/uclinux.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/uclinux.c
+++ linux-2.6.10/drivers/mtd/maps/uclinux.c
@@ -47,7 +47,7 @@ struct mtd_partition uclinux_romfs[] = {
 int uclinux_point(struct mtd_info *mtd, loff_t from, size_t len,
 	size_t *retlen, u_char **mtdbuf)
 {
-	struct map_info *map = (struct map_info *) mtd->priv;
+	struct map_info *map = mtd->priv;
 	*mtdbuf = (u_char *) (map->virt + ((int) from));
 	*retlen = len;
 	return(0);
@@ -81,7 +81,7 @@ int __init uclinux_mtd_init(void)
 	mtd = do_map_probe("map_ram", mapp);
 	if (!mtd) {
 		printk("uclinux[mtd]: failed to find a mapping?\n");
-		iounmap((void *) mapp->virt);
+		iounmap(mapp->virt);
 		return(-ENXIO);
 	}
 		
Index: linux-2.6.10/drivers/mtd/maps/walnut.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/maps/walnut.c
@@ -0,0 +1,122 @@
+/*
+ * $Id: $
+ * 
+ * Mapping for Walnut flash
+ * (used ebony.c as a "framework")
+ * 
+ * Heikki Lindholm <holindho@infradead.org>
+ * 
+ * 
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#include <asm/ibm4xx.h>
+#include <platforms/4xx/walnut.h>
+
+/* these should be in platforms/4xx/walnut.h ? */
+#define WALNUT_FLASH_ONBD_N(x)		(x & 0x02)
+#define WALNUT_FLASH_SRAM_SEL(x)	(x & 0x01)
+#define WALNUT_FLASH_LOW		0xFFF00000
+#define WALNUT_FLASH_HIGH		0xFFF80000
+#define WALNUT_FLASH_SIZE		0x80000
+
+static struct mtd_info *flash;
+
+static struct map_info walnut_map = {
+	.name =		"Walnut flash",
+	.size =		WALNUT_FLASH_SIZE,
+	.bankwidth =	1,
+};
+
+/* Actually, OpenBIOS is the last 128 KiB of the flash - better
+ * partitioning could be made */
+static struct mtd_partition walnut_partitions[] = {
+	{
+		.name =   "OpenBIOS",
+		.offset = 0x0,
+		.size =   WALNUT_FLASH_SIZE,
+		/*.mask_flags = MTD_WRITEABLE, */ /* force read-only */		
+	}
+};
+
+int __init init_walnut(void)
+{
+	u8 fpga_brds1;
+	void *fpga_brds1_adr;
+	void *fpga_status_adr;
+	unsigned long flash_base;
+
+	/* this should already be mapped (platform/4xx/walnut.c) */
+	fpga_status_adr = ioremap(WALNUT_FPGA_BASE, 8);
+	if (!fpga_status_adr)
+		return -ENOMEM;
+
+	fpga_brds1_adr = fpga_status_adr+5;
+	fpga_brds1 = readb(fpga_brds1_adr);
+	/* iounmap(fpga_status_adr); */
+
+	if (WALNUT_FLASH_ONBD_N(fpga_brds1)) {
+		printk("The on-board flash is disabled (U79 sw 5)!");
+		return -EIO;
+	}
+	if (WALNUT_FLASH_SRAM_SEL(fpga_brds1)) 
+		flash_base = WALNUT_FLASH_LOW;
+	else
+		flash_base = WALNUT_FLASH_HIGH;
+	
+	walnut_map.phys = flash_base;
+	walnut_map.virt =
+		(void __iomem *)ioremap(flash_base, walnut_map.size);
+
+	if (!walnut_map.virt) {
+		printk("Failed to ioremap flash.\n");
+		return -EIO;
+	}
+
+	simple_map_init(&walnut_map);
+
+	flash = do_map_probe("jedec_probe", &walnut_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, walnut_partitions,
+					ARRAY_SIZE(walnut_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_walnut(void)
+{
+	if (flash) {
+		del_mtd_partitions(flash);
+		map_destroy(flash);
+	}
+
+	if (walnut_map.virt) {
+		iounmap((void *)walnut_map.virt);
+		walnut_map.virt = 0;
+	}
+}
+
+module_init(init_walnut);
+module_exit(cleanup_walnut);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Heikki Lindholm <holindho@infradead.org>");
+MODULE_DESCRIPTION("MTD map and partitions for IBM 405GP Walnut boards");
Index: linux-2.6.10/drivers/mtd/maps/wr_sbc82xx_flash.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/wr_sbc82xx_flash.c
+++ linux-2.6.10/drivers/mtd/maps/wr_sbc82xx_flash.c
@@ -1,5 +1,5 @@
 /*
- * $Id: wr_sbc82xx_flash.c,v 1.7 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: wr_sbc82xx_flash.c,v 1.6 2004/09/16 23:27:14 gleixner Exp $
  *
  * Map for flash chips on Wind River PowerQUICC II SBC82xx board.
  *
Index: linux-2.6.10/drivers/mtd/mtd_blkdevs.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtd_blkdevs.c
+++ linux-2.6.10/drivers/mtd/mtd_blkdevs.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd_blkdevs.c,v 1.24 2004/11/16 18:28:59 dwmw2 Exp $
+ * $Id: mtd_blkdevs.c,v 1.23 2004/08/19 01:54:36 tpoynor Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
Index: linux-2.6.10/drivers/mtd/mtdblock.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdblock.c
+++ linux-2.6.10/drivers/mtd/mtdblock.c
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id: mtdblock.c,v 1.66 2004/11/25 13:52:52 joern Exp $
+ * $Id: mtdblock.c,v 1.65 2004/11/16 18:28:59 dwmw2 Exp $
  *
  * (C) 2000-2003 Nicolas Pitre <nico@cam.org>
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
Index: linux-2.6.10/drivers/mtd/mtdblock_ro.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdblock_ro.c
+++ linux-2.6.10/drivers/mtd/mtdblock_ro.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdblock_ro.c,v 1.19 2004/11/16 18:28:59 dwmw2 Exp $
+ * $Id: mtdblock_ro.c,v 1.18 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
Index: linux-2.6.10/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdchar.c
+++ linux-2.6.10/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.65 2004/09/23 23:45:47 gleixner Exp $
+ * $Id: mtdchar.c,v 1.72 2005/06/30 00:23:24 tpoynor Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -327,12 +327,12 @@ static int mtd_ioctl(struct inode *inode
 
 	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
 	if (cmd & IOC_IN) {
-		ret = verify_area(VERIFY_READ, argp, size);
-		if (ret) return ret;
+		if (!access_ok(VERIFY_READ, argp, size))
+			return -EFAULT;
 	}
 	if (cmd & IOC_OUT) {
-		ret = verify_area(VERIFY_WRITE, argp, size);
-		if (ret) return ret;
+		if (!access_ok(VERIFY_WRITE, argp, size))
+			return -EFAULT;
 	}
 	
 	switch (cmd) {
@@ -431,7 +431,8 @@ static int mtd_ioctl(struct inode *inode
 		if (!mtd->write_oob)
 			ret = -EOPNOTSUPP;
 		else
-			ret = verify_area(VERIFY_READ, buf.ptr, buf.length);
+			ret = access_ok(VERIFY_READ, buf.ptr,
+					buf.length) ? 0 : EFAULT;
 
 		if (ret)
 			return ret;
@@ -470,7 +471,8 @@ static int mtd_ioctl(struct inode *inode
 		if (!mtd->read_oob)
 			ret = -EOPNOTSUPP;
 		else
-			ret = verify_area(VERIFY_WRITE, buf.ptr, buf.length);
+			ret = access_ok(VERIFY_WRITE, buf.ptr,
+					buf.length) ? 0 : -EFAULT;
 
 		if (ret)
 			return ret;
@@ -662,7 +664,7 @@ static int __init init_mtdchar(void)
 	if (IS_ERR(mtd_class)) {
 		printk(KERN_ERR "Error creating mtd class.\n");
 		unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
-		return 1;
+		return PTR_ERR(mtd_class);
 	}
 
 #ifdef CONFIG_DEVFS_FS
Index: linux-2.6.10/drivers/mtd/mtdconcat.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdconcat.c
+++ linux-2.6.10/drivers/mtd/mtdconcat.c
@@ -7,7 +7,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdconcat.c,v 1.9 2004/06/30 15:17:41 dbrown Exp $
+ * $Id: mtdconcat.c,v 1.8 2003/06/30 11:01:26 dwmw2 Exp $
  */
 
 #include <linux/module.h>
Index: linux-2.6.10/drivers/mtd/mtdcore.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdcore.c
+++ linux-2.6.10/drivers/mtd/mtdcore.c
@@ -149,8 +149,8 @@ void register_mtd_user (struct mtd_notif
 }
 
 /**
- *	register_mtd_user - unregister a 'user' of MTD devices.
- *	@new: pointer to notifier info structure
+ *	unregister_mtd_user - unregister a 'user' of MTD devices.
+ *	@old: pointer to notifier info structure
  *
  *	Removes a callback function pair from the list of 'users' to be
  *	notified upon addition or removal of MTD devices. Causes the
Index: linux-2.6.10/drivers/mtd/mtdpart.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/mtdpart.c
+++ linux-2.6.10/drivers/mtd/mtdpart.c
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.51 2004/11/16 18:28:59 dwmw2 Exp $
+ * $Id: mtdpart.c,v 1.52 2005/01/12 22:34:33 gleixner Exp $
  *
  * 	02-21-2002	Thomas Gleixner <gleixner@autronix.de>
  *			added support for read_oob, write_oob
Index: linux-2.6.10/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/Kconfig
+++ linux-2.6.10/drivers/mtd/nand/Kconfig
@@ -1,5 +1,5 @@
 # drivers/mtd/nand/Kconfig
-# $Id: Kconfig,v 1.26 2005/01/05 12:42:24 dwmw2 Exp $
+# $Id: Kconfig,v 1.31 2005/06/20 12:03:21 bjd Exp $
 
 menu "NAND Flash Device Drivers"
 	depends on MTD!=n
@@ -61,6 +61,13 @@ config MTD_NAND_TOTO
 	help
 	  Support for NAND flash on Texas Instruments Toto platform.
 
+config MTD_NAND_OMAP_HW
+	bool "OMAP HW NAND Flash controller support"
+        depends on ARM && ARCH_OMAP16XX && MTD_NAND
+
+	help
+	  Driver for TI OMAP16xx hardware NAND flash controller.
+
 config MTD_NAND_IDS
 	tristate
 
@@ -101,10 +108,11 @@ config MTD_NAND_PPCHAMELEONEVB
 	  This enables the NAND flash driver on the PPChameleon EVB Board.
 
 config MTD_NAND_S3C2410
-	tristate "NAND Flash support for S3C2410 SoC"
+	tristate "NAND Flash support for S3C2410/S3C2440 SoC"
 	depends on ARCH_S3C2410 && MTD_NAND
 	help
-	  This enables the NAND flash controller on the S3C2410.
+	  This enables the NAND flash controller on the S3C2410 and S3C2440
+	  SoCs
 
 	  No board specfic support is done by this driver, each board
 	  must advertise a platform_device for the driver to attach. 
@@ -198,23 +206,93 @@ config MTD_NAND_DISKONCHIP_BBTWRITE
 	  load time (assuming you build diskonchip as a module) with the module
 	  parameter "inftl_bbt_write=1".
 	  
- config MTD_NAND_SHARPSL
+config MTD_NAND_SHARPSL
  	bool "Support for NAND Flash on Sharp SL Series (C7xx + others)"
  	depends on MTD_NAND	&& ARCH_PXA
  
- config MTD_NAND_NANDSIM
- 	bool "Support for NAND Flash Simulator"
- 	depends on MTD_NAND && MTD_PARTITIONS
-
+config MTD_NAND_NANDSIM
+	tristate "Support for NAND Flash Simulator"
+	depends on m && MTD_NAND && MTD_PARTITIONS
 	help
 	  The simulator may simulate verious NAND flash chips for the
 	  MTD nand layer.
 
-config MTD_NAND_OMAP_HW
-	bool "OMAP HW NAND Flash controller support"
-        depends on ARM && ARCH_OMAP && MTD_NAND
-
+config MTD_NAND_NANDSIM_FIRST_ID
+	hex "First ID byte"
+	range 0x00 0xff
+	default 0x98
+	depends on MTD_NAND_NANDSIM
+	help 
+     	  The fist byte returned by NAND Flash 'read ID' command (manufaturer ID).
+
+config MTD_NAND_NANDSIM_SECOND_ID
+	hex "Second ID byte"
+	range 0x00 0xff
+	default 0x39
+	depends on MTD_NAND_NANDSIM
+	help
+	  The second byte returned by NAND Flash 'read ID' command (chip ID).
+
+config MTD_NAND_NANDSIM_THIRD_ID
+	hex "Third ID byte"
+	range 0x00 0xff
+	default 0xff
+	depends on MTD_NAND_NANDSIM
+	help
+	  The third byte returned by NAND Flash 'read ID' command.
+
+config MTD_NAND_NANDSIM_FOURTH_ID
+	hex "Fourth ID byte"
+	range 0x00 0xff
+	default 0xff
+	depends on MTD_NAND_NANDSIM
+	help
+	  The fourth byte returned by NAND Flash 'read ID' command.
+
+config MTD_NAND_NANDSIM_DEBUG
+	bool "NAND Simulator debugging"
+	depends on MTD_NAND_NANDSIM
+	help
+	  Only helful for tracking problems.
+
+config MTD_NAND_NANDSIM_LOG
+        bool "NAND Simulator logging"
+	depends on MTD_NAND_NANDSIM
+	help
+	   Logs the track of NAND read/write/erase commands.
+
+config MTD_NAND_NANDSIM_DELAY
+	bool "Emulate NAND chip delays using busy-wait cycles"
+	default n
+	depends on MTD_NAND_NANDSIM
+
+config MTD_NAND_NANDSIM_ACCESS_DELAY
+	int "Access delay (microiseconds)"
+	default 25
+	depends on MTD_NAND_NANDSIM_DELAY
+
+config MTD_NAND_NANDSIM_PROGRAM_DELAY
+	int "Program delay (microseconds)"
+	default 200
+	depends on MTD_NAND_NANDSIM_DELAY
+
+config MTD_NAND_NANDSIM_ERASE_DELAY
+	int "Erase delay (milliseconds)"
+	default 2
+	depends on MTD_NAND_NANDSIM_DELAY
+
+config MTD_NAND_NANDSIM_OUTPUT_CYCLE
+	int "Word output (from flash) time (nanoseconds)"
+	default 40
+	depends on MTD_NAND_NANDSIM_DELAY
+	help
+	  For 16 bit devices word is 2 bytes, for 8 bit devices - 1 byte
+
+config MTD_NAND_NANDSIM_INPUT_CYCLE
+	int "Word input (to flash) time (nanoseconds)"
+	default 50
+	depends on MTD_NAND_NANDSIM_DELAY
 	help
-	  Driver for TI Omap 1710 hardware nand flash controller.
-
+	  For 16 bit devices word is 2 bytes, for 8 bit devices - 1 byte
+	
 endmenu
Index: linux-2.6.10/drivers/mtd/nand/au1550nd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/au1550nd.c
+++ linux-2.6.10/drivers/mtd/nand/au1550nd.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Embedded Edge, LLC
  *
- * $Id: au1550nd.c,v 1.11 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: au1550nd.c,v 1.10 2004/10/31 23:48:33 ppopov Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/autcpu12.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/autcpu12.c
+++ linux-2.6.10/drivers/mtd/nand/autcpu12.c
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/spia.c
  * 	 Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 
- * $Id: autcpu12.c,v 1.22 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: autcpu12.c,v 1.21 2004/09/16 23:27:14 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/diskonchip.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/diskonchip.c
+++ linux-2.6.10/drivers/mtd/nand/diskonchip.c
@@ -16,7 +16,7 @@
  *  
  * Interface to generic NAND code for M-Systems DiskOnChip devices
  *
- * $Id: diskonchip.c,v 1.42 2004/11/16 18:29:03 dwmw2 Exp $
+ * $Id: diskonchip.c,v 1.53 2005/04/07 13:39:13 dbrown Exp $
  */
 
 #include <linux/kernel.h>
@@ -24,6 +24,7 @@
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/rslib.h>
+#include <linux/moduleparam.h>
 #include <asm/io.h>
 
 #include <linux/mtd/mtd.h>
@@ -34,13 +35,13 @@
 #include <linux/mtd/inftl.h>
 
 /* Where to look for the devices? */
-#ifndef CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS
-#define CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS 0
+#ifndef CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0
 #endif
 
 static unsigned long __initdata doc_locations[] = {
 #if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
-#ifdef CONFIG_MTD_DISKONCHIP_PROBE_HIGH
+#ifdef CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH
 	0xfffc8000, 0xfffca000, 0xfffcc000, 0xfffce000, 
 	0xfffd0000, 0xfffd2000, 0xfffd4000, 0xfffd6000,
 	0xfffd8000, 0xfffda000, 0xfffdc000, 0xfffde000, 
@@ -80,11 +81,6 @@ struct doc_priv {
 	struct mtd_info *nextdoc;
 };
 
-/* Max number of eraseblocks to scan (from start of device) for the (I)NFTL
-   MediaHeader.  The spec says to just keep going, I think, but that's just
-   silly. */
-#define MAX_MEDIAHEADER_SCAN 8
-
 /* This is the syndrome computed by the HW ecc generator upon reading an empty
    page, one with all 0xff for data and stored ecc code. */
 static u_char empty_read_syndrome[6] = { 0x26, 0xff, 0x6d, 0x47, 0x73, 0x7a };
@@ -110,10 +106,11 @@ module_param(try_dword, int, 0);
 static int no_ecc_failures=0;
 module_param(no_ecc_failures, int, 0);
 
-#ifdef CONFIG_MTD_PARTITIONS
 static int no_autopart=0;
 module_param(no_autopart, int, 0);
-#endif
+
+static int show_firmware_partition=0;
+module_param(show_firmware_partition, int, 0);
 
 #ifdef MTD_NAND_DISKONCHIP_BBTWRITE
 static int inftl_bbt_write=1;
@@ -122,7 +119,7 @@ static int inftl_bbt_write=0;
 #endif
 module_param(inftl_bbt_write, int, 0);
 
-static unsigned long doc_config_location = CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS;
+static unsigned long doc_config_location = CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS;
 module_param(doc_config_location, ulong, 0);
 MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
@@ -308,7 +305,7 @@ static inline int DoC_WaitReady(struct d
 static void doc2000_write_byte(struct mtd_info *mtd, u_char datum)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	if(debug)printk("write_byte %02x\n", datum);
@@ -319,7 +316,7 @@ static void doc2000_write_byte(struct mt
 static u_char doc2000_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	u_char ret;
 
@@ -334,7 +331,7 @@ static void doc2000_writebuf(struct mtd_
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 	if (debug)printk("writebuf of %d bytes: ", len);
@@ -350,7 +347,7 @@ static void doc2000_readbuf(struct mtd_i
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
  	int i;
 
@@ -365,7 +362,7 @@ static void doc2000_readbuf_dword(struct
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
  	int i;
 
@@ -386,7 +383,7 @@ static int doc2000_verifybuf(struct mtd_
 			      const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -399,7 +396,7 @@ static int doc2000_verifybuf(struct mtd_
 static uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	uint16_t ret;
 
 	doc200x_select_chip(mtd, nr);
@@ -409,7 +406,12 @@ static uint16_t __init doc200x_ident_chi
 	doc200x_hwcontrol(mtd, NAND_CTL_SETALE);
 	this->write_byte(mtd, 0);
 	doc200x_hwcontrol(mtd, NAND_CTL_CLRALE);
-
+	
+	/* We cant' use dev_ready here, but at least we wait for the
+	 * command to complete 
+	 */
+	udelay(50);
+	
 	ret = this->read_byte(mtd) << 8;
 	ret |= this->read_byte(mtd);
 
@@ -428,6 +430,8 @@ static uint16_t __init doc200x_ident_chi
 		doc2000_write_byte(mtd, 0);
 		doc200x_hwcontrol(mtd, NAND_CTL_CLRALE);
 
+		udelay(50);
+
 		ident.dword = readl(docptr + DoC_2k_CDSN_IO);
 		if (((ident.byte[0] << 8) | ident.byte[1]) == ret) {
 			printk(KERN_INFO "DiskOnChip 2000 responds to DWORD access\n");
@@ -441,7 +445,7 @@ static uint16_t __init doc200x_ident_chi
 static void __init doc2000_count_chips(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	uint16_t mfrid;
 	int i;
 
@@ -462,7 +466,7 @@ static void __init doc2000_count_chips(s
 
 static int doc200x_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
 {
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	int status;
 	
@@ -477,7 +481,7 @@ static int doc200x_wait(struct mtd_info 
 static void doc2001_write_byte(struct mtd_info *mtd, u_char datum)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	WriteDOC(datum, docptr, CDSNSlowIO);
@@ -488,7 +492,7 @@ static void doc2001_write_byte(struct mt
 static u_char doc2001_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	//ReadDOC(docptr, CDSNSlowIO);
@@ -503,7 +507,7 @@ static void doc2001_writebuf(struct mtd_
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -517,7 +521,7 @@ static void doc2001_readbuf(struct mtd_i
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -535,7 +539,7 @@ static int doc2001_verifybuf(struct mtd_
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -555,7 +559,7 @@ static int doc2001_verifybuf(struct mtd_
 static u_char doc2001plus_read_byte(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	u_char ret;
 
@@ -570,7 +574,7 @@ static void doc2001plus_writebuf(struct 
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -587,7 +591,7 @@ static void doc2001plus_readbuf(struct m
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -617,7 +621,7 @@ static int doc2001plus_verifybuf(struct 
 			     const u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 
@@ -643,7 +647,7 @@ static int doc2001plus_verifybuf(struct 
 static void doc2001plus_select_chip(struct mtd_info *mtd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
@@ -669,7 +673,7 @@ static void doc2001plus_select_chip(stru
 static void doc200x_select_chip(struct mtd_info *mtd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int floor = 0;
 
@@ -696,7 +700,7 @@ static void doc200x_select_chip(struct m
 static void doc200x_hwcontrol(struct mtd_info *mtd, int cmd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	switch(cmd) {
@@ -734,7 +738,7 @@ static void doc200x_hwcontrol(struct mtd
 static void doc2001plus_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	/*
@@ -838,7 +842,7 @@ static void doc2001plus_command (struct 
 static int doc200x_dev_ready(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	if (DoC_is_MillenniumPlus(doc)) {
@@ -876,7 +880,7 @@ static int doc200x_block_bad(struct mtd_
 static void doc200x_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
@@ -895,7 +899,7 @@ static void doc200x_enable_hwecc(struct 
 static void doc2001plus_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 
 	/* Prime the ECC engine */
@@ -916,7 +920,7 @@ static int doc200x_calculate_ecc(struct 
 				 unsigned char *ecc_code)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	int i;
 	int emptymatch = 1;
@@ -974,7 +978,7 @@ static int doc200x_correct_data(struct m
 {
 	int i, ret = 0;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
         void __iomem *docptr = doc->virtadr;
 	volatile u_char dummy;
 	int emptymatch = 1;
@@ -1045,11 +1049,21 @@ static int doc200x_correct_data(struct m
 		
 //u_char mydatabuf[528];
 
+/* The strange out-of-order .oobfree list below is a (possibly unneeded)
+ * attempt to retain compatibility.  It used to read:
+ * 	.oobfree = { {8, 8} }
+ * Since that leaves two bytes unusable, it was changed.  But the following
+ * scheme might affect existing jffs2 installs by moving the cleanmarker:
+ * 	.oobfree = { {6, 10} }
+ * jffs2 seems to handle the above gracefully, but the current scheme seems
+ * safer.  The only problem with it is that any code that parses oobfree must
+ * be able to handle out-of-order segments.
+ */
 static struct nand_oobinfo doc200x_oobinfo = {
         .useecc = MTD_NANDECC_AUTOPLACE,
         .eccbytes = 6,
         .eccpos = {0, 1, 2, 3, 4, 5},
-        .oobfree = { {8, 8} }
+        .oobfree = { {8, 8}, {6, 2} }
 };
  
 /* Find the (I)NFTL Media Header, and optionally also the mirror media header.
@@ -1062,13 +1076,12 @@ static int __init find_media_headers(str
 				     const char *id, int findmirror)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
-	unsigned offs, end = (MAX_MEDIAHEADER_SCAN << this->phys_erase_shift);
+	struct doc_priv *doc = this->priv;
+	unsigned offs;
 	int ret;
 	size_t retlen;
 
-	end = min(end, mtd->size); // paranoia
-	for (offs = 0; offs < end; offs += mtd->erasesize) {
+	for (offs = 0; offs < mtd->size; offs += mtd->erasesize) {
 		ret = mtd->read(mtd, offs, mtd->oobblock, &retlen, buf);
 		if (retlen != mtd->oobblock) continue;
 		if (ret) {
@@ -1105,11 +1118,12 @@ static inline int __init nftl_partscan(s
 				struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	int ret = 0;
 	u_char *buf;
 	struct NFTLMediaHeader *mh;
 	const unsigned psize = 1 << this->page_shift;
+	int numparts = 0;
 	unsigned blocks, maxblocks;
 	int offs, numheaders;
 
@@ -1121,8 +1135,10 @@ static inline int __init nftl_partscan(s
 	if (!(numheaders=find_media_headers(mtd, buf, "ANAND", 1))) goto out;
 	mh = (struct NFTLMediaHeader *) buf;
 
-//#ifdef CONFIG_MTD_DEBUG_VERBOSE
-//	if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
+	mh->NumEraseUnits = le16_to_cpu(mh->NumEraseUnits);
+	mh->FirstPhysicalEUN = le16_to_cpu(mh->FirstPhysicalEUN);
+	mh->FormattedSize = le32_to_cpu(mh->FormattedSize);
+
 	printk(KERN_INFO "    DataOrgID        = %s\n"
 			 "    NumEraseUnits    = %d\n"
 			 "    FirstPhysicalEUN = %d\n"
@@ -1131,7 +1147,6 @@ static inline int __init nftl_partscan(s
 		mh->DataOrgID, mh->NumEraseUnits,
 		mh->FirstPhysicalEUN, mh->FormattedSize,
 		mh->UnitSizeFactor);
-//#endif
 
 	blocks = mtd->size >> this->phys_erase_shift;
 	maxblocks = min(32768U, mtd->erasesize - psize);
@@ -1174,23 +1189,28 @@ static inline int __init nftl_partscan(s
 	offs <<= this->page_shift;
 	offs += mtd->erasesize;
 
-	//parts[0].name = " DiskOnChip Boot / Media Header partition";
-	//parts[0].offset = 0;
-	//parts[0].size = offs;
-
-	parts[0].name = " DiskOnChip BDTL partition";
-	parts[0].offset = offs;
-	parts[0].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;
+	if (show_firmware_partition == 1) {
+		parts[0].name = " DiskOnChip Firmware / Media Header partition";
+		parts[0].offset = 0;
+		parts[0].size = offs;
+		numparts = 1;
+	}
+
+	parts[numparts].name = " DiskOnChip BDTL partition";
+	parts[numparts].offset = offs;
+	parts[numparts].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;
+
+	offs += parts[numparts].size;
+	numparts++;
 
-	offs += parts[0].size;
 	if (offs < mtd->size) {
-		parts[1].name = " DiskOnChip Remainder partition";
-		parts[1].offset = offs;
-		parts[1].size = mtd->size - offs;
-		ret = 2;
-		goto out;
+		parts[numparts].name = " DiskOnChip Remainder partition";
+		parts[numparts].offset = offs;
+		parts[numparts].size = mtd->size - offs;
+		numparts++;
 	}
-	ret = 1;
+
+	ret = numparts;
 out:
 	kfree(buf);
 	return ret;
@@ -1201,7 +1221,7 @@ static inline int __init inftl_partscan(
 				 struct mtd_partition *parts)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	int ret = 0;
 	u_char *buf;
 	struct INFTLMediaHeader *mh;
@@ -1232,8 +1252,6 @@ static inline int __init inftl_partscan(
 	mh->FormatFlags = le32_to_cpu(mh->FormatFlags);
 	mh->PercentUsed = le32_to_cpu(mh->PercentUsed);
  
-//#ifdef CONFIG_MTD_DEBUG_VERBOSE
-//	if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
 	printk(KERN_INFO "    bootRecordID          = %s\n"
 			 "    NoOfBootImageBlocks   = %d\n"
 			 "    NoOfBinaryPartitions  = %d\n"
@@ -1251,7 +1269,6 @@ static inline int __init inftl_partscan(
 		((unsigned char *) &mh->OsakVersion)[2] & 0xf,
 		((unsigned char *) &mh->OsakVersion)[3] & 0xf,
 		mh->PercentUsed);
-//#endif
 
 	vshift = this->phys_erase_shift + mh->BlockMultiplierBits;
 
@@ -1277,8 +1294,6 @@ static inline int __init inftl_partscan(
 		ip->spareUnits = le32_to_cpu(ip->spareUnits);
 		ip->Reserved0 = le32_to_cpu(ip->Reserved0);
 
-//#ifdef CONFIG_MTD_DEBUG_VERBOSE
-//		if (CONFIG_MTD_DEBUG_VERBOSE >= 2)
 		printk(KERN_INFO	"    PARTITION[%d] ->\n"
 			"        virtualUnits    = %d\n"
 			"        firstUnit       = %d\n"
@@ -1288,16 +1303,14 @@ static inline int __init inftl_partscan(
 			i, ip->virtualUnits, ip->firstUnit,
 			ip->lastUnit, ip->flags,
 			ip->spareUnits);
-//#endif
 
-/*
-		if ((i == 0) && (ip->firstUnit > 0)) {
+		if ((show_firmware_partition == 1) &&
+		    (i == 0) && (ip->firstUnit > 0)) {
 			parts[0].name = " DiskOnChip IPL / Media Header partition";
 			parts[0].offset = 0;
 			parts[0].size = mtd->erasesize * ip->firstUnit;
 			numparts = 1;
 		}
-*/
 
 		if (ip->flags & INFTL_BINARY)
 			parts[numparts].name = " DiskOnChip BDK partition";
@@ -1326,7 +1339,7 @@ static int __init nftl_scan_bbt(struct m
 {
 	int ret, numparts;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	struct mtd_partition parts[2];
 
 	memset((char *) parts, 0, sizeof(parts));
@@ -1365,7 +1378,7 @@ static int __init inftl_scan_bbt(struct 
 {
 	int ret, numparts;
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 	struct mtd_partition parts[5];
 
 	if (this->numchips > doc->chips_per_floor) {
@@ -1424,7 +1437,7 @@ static int __init inftl_scan_bbt(struct 
 static inline int __init doc2000_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = doc2000_write_byte;
 	this->read_byte = doc2000_read_byte;
@@ -1442,7 +1455,7 @@ static inline int __init doc2000_init(st
 static inline int __init doc2001_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = doc2001_write_byte;
 	this->read_byte = doc2001_read_byte;
@@ -1474,7 +1487,7 @@ static inline int __init doc2001_init(st
 static inline int __init doc2001plus_init(struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
-	struct doc_priv *doc = (void *)this->priv;
+	struct doc_priv *doc = this->priv;
 
 	this->write_byte = NULL;
 	this->read_byte = doc2001plus_read_byte;
@@ -1596,7 +1609,7 @@ static inline int __init doc_probe(unsig
 		unsigned char oldval;
 		unsigned char newval;
 		nand = mtd->priv;
-		doc = (void *)nand->priv;
+		doc = nand->priv;
 		/* Use the alias resolution register to determine if this is
 		   in fact the same DOC aliased to a new address.  If writes
 		   to one chip's alias resolution register change the value on
@@ -1645,10 +1658,10 @@ static inline int __init doc_probe(unsig
 	nand->bbt_td		= (struct nand_bbt_descr *) (doc + 1);
 	nand->bbt_md		= nand->bbt_td + 1;
 
-	mtd->priv		= (void *) nand;
+	mtd->priv		= nand;
 	mtd->owner		= THIS_MODULE;
 
-	nand->priv		= (void *) doc;
+	nand->priv		= doc;
 	nand->select_chip	= doc200x_select_chip;
 	nand->hwcontrol		= doc200x_hwcontrol;
 	nand->dev_ready		= doc200x_dev_ready;
@@ -1699,7 +1712,7 @@ notfound:
 	   actually a DiskOnChip.  */
 	WriteDOC(save_control, virtadr, DOCControl);
 fail:
-	iounmap((void *)virtadr);
+	iounmap(virtadr);
 	return ret;
 }
 
@@ -1711,11 +1724,11 @@ static void release_nanddoc(void)
 
 	for (mtd = doclist; mtd; mtd = nextmtd) {
 		nand = mtd->priv;
-		doc = (void *)nand->priv;
+		doc = nand->priv;
 
 		nextmtd = doc->nextdoc;
 		nand_release(mtd);
-		iounmap((void *)doc->virtadr);
+		iounmap(doc->virtadr);
 		kfree(mtd);
 	}
 }
Index: linux-2.6.10/drivers/mtd/nand/edb7312.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/edb7312.c
+++ linux-2.6.10/drivers/mtd/nand/edb7312.c
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/autcpu12.c
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: edb7312.c,v 1.11 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: edb7312.c,v 1.10 2004/10/05 13:50:20 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/h1910.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/h1910.c
+++ linux-2.6.10/drivers/mtd/nand/h1910.c
@@ -7,7 +7,7 @@
  *       Copyright (C) 2002 Marius Gröger (mag@sysgo.de)
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: h1910.c,v 1.5 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: h1910.c,v 1.4 2004/10/05 13:50:20 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/nand_base.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/nand_base.c
+++ linux-2.6.10/drivers/mtd/nand/nand_base.c
@@ -28,6 +28,24 @@
  *		among multiple independend devices. Suggestions and initial patch
  *		from Ben Dooks <ben-mtd@fluff.org>
  *
+ *  12-05-2004	dmarlin: add workaround for Renesas AG-AND chips "disturb" issue.
+ *		Basically, any block not rewritten may lose data when surrounding blocks
+ *		are rewritten many times.  JFFS2 ensures this doesn't happen for blocks 
+ *		it uses, but the Bad Block Table(s) may not be rewritten.  To ensure they
+ *		do not lose data, force them to be rewritten when some of the surrounding
+ *		blocks are erased.  Rather than tracking a specific nearby block (which 
+ *		could itself go bad), use a page address 'mask' to select several blocks 
+ *		in the same area, and rewrite the BBT when any of them are erased.
+ *
+ *  01-03-2005	dmarlin: added support for the device recovery command sequence for Renesas 
+ *		AG-AND chips.  If there was a sudden loss of power during an erase operation,
+ * 		a "device recovery" operation must be performed when power is restored
+ * 		to ensure correct operation.
+ *
+ *  01-20-2005	dmarlin: added support for optional hardware specific callback routine to 
+ *		perform extra error status checks on erase and write failures.  This required
+ *		adding a wrapper function for nand_read_ecc.
+ *
  * Credits:
  *	David Woodhouse for adding multichip support  
  *	
@@ -41,7 +59,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
+ * $Id: nand_base.c,v 1.145 2005/05/31 20:32:53 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -149,17 +167,21 @@ static void nand_release_device (struct 
 
 	/* De-select the NAND device */
 	this->select_chip(mtd, -1);
-	/* Do we have a hardware controller ? */
+
 	if (this->controller) {
+		/* Release the controller and the chip */
 		spin_lock(&this->controller->lock);
 		this->controller->active = NULL;
+		this->state = FL_READY;
+		wake_up(&this->controller->wq);
 		spin_unlock(&this->controller->lock);
+	} else {
+		/* Release the chip */
+		spin_lock(&this->chip_lock);
+		this->state = FL_READY;
+		wake_up(&this->wq);
+		spin_unlock(&this->chip_lock);
 	}
-	/* Release the chip */
-	spin_lock (&this->chip_lock);
-	this->state = FL_READY;
-	wake_up (&this->wq);
-	spin_unlock (&this->chip_lock);
 }
 
 /**
@@ -443,7 +465,8 @@ static int nand_default_block_markbad(st
 	
 	/* Get block number */
 	block = ((int) ofs) >> this->bbt_erase_shift;
-	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
 
 	/* Do we have a flash based bad block table ? */
 	if (this->options & NAND_USE_FLASH_BBT)
@@ -466,7 +489,7 @@ static int nand_check_wp (struct mtd_inf
 	struct nand_chip *this = mtd->priv;
 	/* Check the WP bit */
 	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
-	return (this->read_byte(mtd) & 0x80) ? 0 : 1; 
+	return (this->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1; 
 }
 
 /**
@@ -490,6 +513,22 @@ static int nand_block_checkbad (struct m
 	return nand_isbad_bbt (mtd, ofs, allowbbt);
 }
 
+/* 
+ * Wait for the ready pin, after a command
+ * The timeout is catched later.
+ */
+static void nand_wait_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long	timeo = jiffies + 2;
+
+	/* wait until command is processed or timeout occures */
+	do {
+		if (this->dev_ready(mtd))
+			return;
+	} while (time_before(jiffies, timeo));	
+}
+
 /**
  * nand_command - [DEFAULT] Send command to NAND device
  * @mtd:	MTD device structure
@@ -571,7 +610,7 @@ static void nand_command (struct mtd_inf
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
 		return;
 
 	/* This applies to read commands */	
@@ -585,12 +624,11 @@ static void nand_command (struct mtd_inf
 			return;
 		}	
 	}
-	
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+
+	nand_wait_ready(mtd);
 }
 
 /**
@@ -619,7 +657,7 @@ static void nand_command_lp (struct mtd_
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/* Write out the command to the device. */
-	this->write_byte(mtd, command);
+	this->write_byte(mtd, (command & 0xff));
 	/* End command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 
@@ -647,8 +685,8 @@ static void nand_command_lp (struct mtd_
 	
 	/* 
 	 * program and erase have their own busy handlers 
-	 * status and sequential in needs no delay
-	*/
+	 * status, sequential in, and deplete1 need no delay
+	 */
 	switch (command) {
 			
 	case NAND_CMD_CACHEDPROG:
@@ -657,8 +695,19 @@ static void nand_command_lp (struct mtd_
 	case NAND_CMD_ERASE2:
 	case NAND_CMD_SEQIN:
 	case NAND_CMD_STATUS:
+	case NAND_CMD_DEPLETE1:
 		return;
 
+	/* 
+	 * read error status commands require only a short delay
+	 */
+	case NAND_CMD_STATUS_ERROR:
+	case NAND_CMD_STATUS_ERROR0:
+	case NAND_CMD_STATUS_ERROR1:
+	case NAND_CMD_STATUS_ERROR2:
+	case NAND_CMD_STATUS_ERROR3:
+		udelay(this->chip_delay);
+		return;
 
 	case NAND_CMD_RESET:
 		if (this->dev_ready)	
@@ -667,7 +716,7 @@ static void nand_command_lp (struct mtd_
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & 0x40));
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
 		return;
 
 	case NAND_CMD_READ0:
@@ -690,12 +739,12 @@ static void nand_command_lp (struct mtd_
 			return;
 		}	
 	}
-	
+
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
+
+	nand_wait_ready(mtd);
 }
 
 /**
@@ -708,37 +757,34 @@ static void nand_command_lp (struct mtd_
  */
 static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
 {
-	struct nand_chip *active = this;
-
+	struct nand_chip *active;
+	spinlock_t *lock;
+	wait_queue_head_t *wq;
 	DECLARE_WAITQUEUE (wait, current);
 
-	/* 
-	 * Grab the lock and see if the device is available 
-	*/
+	lock = (this->controller) ? &this->controller->lock : &this->chip_lock;
+	wq = (this->controller) ? &this->controller->wq : &this->wq;
 retry:
+	active = this;
+	spin_lock(lock);
+
 	/* Hardware controller shared among independend devices */
 	if (this->controller) {
-		spin_lock (&this->controller->lock);
 		if (this->controller->active)
 			active = this->controller->active;
 		else
 			this->controller->active = this;
-		spin_unlock (&this->controller->lock);
 	}
-	
-	if (active == this) {
-		spin_lock (&this->chip_lock);
-		if (this->state == FL_READY) {
-			this->state = new_state;
-			spin_unlock (&this->chip_lock);
-			return;
-		}
-	}	
-	set_current_state (TASK_UNINTERRUPTIBLE);
-	add_wait_queue (&active->wq, &wait);
-	spin_unlock (&active->chip_lock);
-	schedule ();
-	remove_wait_queue (&active->wq, &wait);
+	if (active == this && this->state == FL_READY) {
+		this->state = new_state;
+		spin_unlock(lock);
+		return;
+	}
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(wq, &wait);
+	spin_unlock(lock);
+	schedule();
+	remove_wait_queue(wq, &wait);
 	goto retry;
 }
 
@@ -785,7 +831,7 @@ static int nand_wait(struct mtd_info *mt
 			if (this->read_byte(mtd) & NAND_STATUS_READY)
 				break;
 		}
-		yield ();
+		cond_resched();
 	}
 	status = (int) this->read_byte(mtd);
 	return status;
@@ -871,8 +917,14 @@ static int nand_write_page (struct mtd_i
 	if (!cached) {
 		/* call wait ready function */
 		status = this->waitfunc (mtd, this, FL_WRITING);
+
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_WRITING, status, page);
+		}
+
 		/* See if device thinks it succeeded */
-		if (status & 0x01) {
+		if (status & NAND_STATUS_FAIL) {
 			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
 			return -EIO;
 		}
@@ -975,7 +1027,7 @@ static int nand_verify_pages (struct mtd
 		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));	
+			nand_wait_ready(mtd);
 
 		/* All done, return happy */
 		if (!numpages)
@@ -997,23 +1049,24 @@ out:	 
 #endif
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_read_ecc
+ * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
  * @retlen:	pointer to variable to store the number of read bytes
  * @buf:	the databuffer to put data
  *
- * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
-*/
+ * This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
+ * and flags = 0xff
+ */
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
-	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
-}			   
+	return nand_do_read_ecc (mtd, from, len, retlen, buf, NULL, &mtd->oobinfo, 0xff);
+}
 
 
 /**
- * nand_read_ecc - [MTD Interface] Read data with ECC
+ * nand_read_ecc - [MTD Interface] MTD compability function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
@@ -1022,11 +1075,39 @@ static int nand_read (struct mtd_info *m
  * @oob_buf:	filesystem supplied oob data buffer
  * @oobsel:	oob selection structure
  *
- * NAND read with ECC
+ * This function simply calls nand_do_read_ecc with flags = 0xff
  */
 static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
+	/* use userspace supplied oobinfo, if zero */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+	return nand_do_read_ecc(mtd, from, len, retlen, buf, oob_buf, oobsel, 0xff);
+}
+
+
+/**
+ * nand_do_read_ecc - [MTD Interface] Read data with ECC
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ * @oob_buf:	filesystem supplied oob data buffer (can be NULL)
+ * @oobsel:	oob selection structure
+ * @flags:	flag to indicate if nand_get_device/nand_release_device should be preformed
+ *		and how many corrected error bits are acceptable:
+ *		  bits 0..7 - number of tolerable errors
+ *		  bit  8    - 0 == do not get/release chip, 1 == get/release chip
+ *
+ * NAND read with ECC
+ */
+int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			     size_t * retlen, u_char * buf, u_char * oob_buf, 
+			     struct nand_oobinfo *oobsel, int flags)
+{
+
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
@@ -1051,12 +1132,9 @@ static int nand_read_ecc (struct mtd_inf
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd ,FL_READING);
+	if (flags & NAND_GET_DEVICE)
+		nand_get_device (this, mtd, FL_READING);
 
-	/* use userspace supplied oobinfo, if zero */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-	
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 		oobsel = this->autooob;
@@ -1118,7 +1196,8 @@ static int nand_read_ecc (struct mtd_inf
 		}	
 
 		/* get oob area, if we have no oob buffer from fs-driver */
-		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE)
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
+			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
 			oob_data = &this->data_buf[end];
 
 		eccsteps = this->eccsteps;
@@ -1155,7 +1234,8 @@ static int nand_read_ecc (struct mtd_inf
 					/* We calc error correction directly, it checks the hw
 					 * generator for an error, reads back the syndrome and
 					 * does the error correction on the fly */
-					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
+					ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
+					if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
 						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " 
 							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
 						ecc_failed++;
@@ -1194,7 +1274,7 @@ static int nand_read_ecc (struct mtd_inf
 				p[i] = ecc_status;
 			}
 			
-			if (ecc_status == -1) {	
+			if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {	
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
 				ecc_failed++;
 			}
@@ -1206,14 +1286,14 @@ static int nand_read_ecc (struct mtd_inf
 			/* without autoplace. Legacy mode used by YAFFS1 */
 			switch(oobsel->useecc) {
 			case MTD_NANDECC_AUTOPLACE:
+			case MTD_NANDECC_AUTOPL_USR:
 				/* Walk through the autoplace chunks */
-				for (i = 0, j = 0; j < mtd->oobavail; i++) {
+				for (i = 0; oobsel->oobfree[i][1]; i++) {
 					int from = oobsel->oobfree[i][0];
 					int num = oobsel->oobfree[i][1];
 					memcpy(&oob_buf[oob], &oob_data[from], num);
-					j+= num;
+					oob += num;
 				}
-				oob += mtd->oobavail;
 				break;
 			case MTD_NANDECC_PLACE:
 				/* YAFFS1 legacy mode */
@@ -1239,7 +1319,7 @@ static int nand_read_ecc (struct mtd_inf
 		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));	
+			nand_wait_ready(mtd);
 			
 		if (read == len)
 			break;	
@@ -1264,7 +1344,8 @@ static int nand_read_ecc (struct mtd_inf
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+	if (flags & NAND_GET_DEVICE)
+		nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1337,7 +1418,7 @@ static int nand_read_oob (struct mtd_inf
 		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));	
+			nand_wait_ready(mtd);
 
 		/* Read more ? */
 		if (i < len) {
@@ -1417,7 +1498,7 @@ int nand_read_raw (struct mtd_info *mtd,
 		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			while (!this->dev_ready(mtd));	
+			nand_wait_ready(mtd);
 			
 		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
@@ -1567,6 +1648,8 @@ static int nand_write_ecc (struct mtd_in
 		oobsel = this->autooob;
 		autoplace = 1;
 	}	
+	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		autoplace = 1;
 
 	/* Setup variables and oob buffer */
 	totalpages = len >> this->page_shift;
@@ -1733,7 +1816,7 @@ static int nand_write_oob (struct mtd_in
 	status = this->waitfunc (mtd, this, FL_WRITING);
 
 	/* See if device thinks it succeeded */
-	if (status & 0x01) {
+	if (status & NAND_STATUS_FAIL) {
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
 		ret = -EIO;
 		goto out;
@@ -1841,6 +1924,8 @@ static int nand_writev_ecc (struct mtd_i
 		oobsel = this->autooob;
 		autoplace = 1;
 	}	
+	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		autoplace = 1;
 
 	/* Setup start page */
 	page = (int) (to >> this->page_shift);
@@ -1987,6 +2072,7 @@ static int nand_erase (struct mtd_info *
 	return nand_erase_nand (mtd, instr, 0);
 }
  
+#define BBT_PAGE_MASK	0xffffff3f
 /**
  * nand_erase_intern - [NAND Interface] erase block(s)
  * @mtd:	MTD device structure
@@ -1999,6 +2085,10 @@ int nand_erase_nand (struct mtd_info *mt
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *this = mtd->priv;
+	int rewrite_bbt[NAND_MAX_CHIPS]={0};	/* flags to indicate the page, if bbt needs to be rewritten. */
+	unsigned int bbt_masked_page;		/* bbt mask to compare to page being erased. */
+						/* It is used to see if the current page is in the same */
+						/*   256 block group and the same bank as the bbt. */
 
 	DEBUG (MTD_DEBUG_LEVEL3,
 	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
@@ -2044,6 +2134,13 @@ int nand_erase_nand (struct mtd_info *mt
 		goto erase_exit;
 	}
 
+	/* if BBT requires refresh, set the BBT page mask to see if the BBT should be rewritten */
+	if (this->options & BBT_AUTO_REFRESH) {
+		bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+	} else {
+		bbt_masked_page = 0xffffffff;	/* should not match anything */
+	}
+
 	/* Loop through the pages */
 	len = instr->len;
 
@@ -2066,13 +2163,26 @@ int nand_erase_nand (struct mtd_info *mt
 		
 		status = this->waitfunc (mtd, this, FL_ERASING);
 
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_ERASING, status, page);
+		}
+
 		/* See if block erase succeeded */
-		if (status & 0x01) {
+		if (status & NAND_STATUS_FAIL) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = (page << this->page_shift);
 			goto erase_exit;
 		}
+
+		/* if BBT requires refresh, set the BBT rewrite flag to the page being erased */
+		if (this->options & BBT_AUTO_REFRESH) {
+			if (((page & BBT_PAGE_MASK) == bbt_masked_page) && 
+			     (page != this->bbt_td->pages[chipnr])) {
+				rewrite_bbt[chipnr] = (page << this->page_shift);
+			}
+		}
 		
 		/* Increment page address and decrement length */
 		len -= (1 << this->phys_erase_shift);
@@ -2083,6 +2193,13 @@ int nand_erase_nand (struct mtd_info *mt
 			chipnr++;
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
+
+			/* if BBT requires refresh and BBT-PERCHIP, 
+			 *   set the BBT page mask to see if this BBT should be rewritten */
+			if ((this->options & BBT_AUTO_REFRESH) && (this->bbt_td->options & NAND_BBT_PERCHIP)) {
+				bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+			}
+
 		}
 	}
 	instr->state = MTD_ERASE_DONE;
@@ -2097,6 +2214,18 @@ erase_exit:
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
+	/* if BBT requires refresh and erase was successful, rewrite any selected bad block tables */
+	if ((this->options & BBT_AUTO_REFRESH) && (!ret)) {
+		for (chipnr = 0; chipnr < this->numchips; chipnr++) {
+			if (rewrite_bbt[chipnr]) {
+				/* update the BBT for chip */
+				DEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt (%d:0x%0x 0x%0x)\n", 
+					chipnr, rewrite_bbt[chipnr], this->bbt_td->pages[chipnr]);
+				nand_update_bbt (mtd, rewrite_bbt[chipnr]);
+			}
+		}
+	}
+
 	/* Return more or less happy */
 	return ret;
 }
@@ -2168,7 +2297,7 @@ static int nand_block_markbad (struct mt
  */
 int nand_scan (struct mtd_info *mtd, int maxchips)
 {
-	int i, j, nand_maf_id, nand_dev_id, busw;
+	int i, nand_maf_id, nand_dev_id, busw, maf_id;
 	struct nand_chip *this = mtd->priv;
 
 	/* Get buswidth to select the correct functions*/
@@ -2256,12 +2385,18 @@ int nand_scan (struct mtd_info *mtd, int
 			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
 		}
 
+		/* Try to identify manufacturer */
+		for (maf_id = 0; nand_manuf_ids[maf_id].id != 0x0; maf_id++) {
+			if (nand_manuf_ids[maf_id].id == nand_maf_id)
+				break;
+		}
+
 		/* Check, if buswidth is correct. Hardware drivers should set
 		 * this correct ! */
 		if (busw != (this->options & NAND_BUSWIDTH_16)) {
 			printk (KERN_INFO "NAND device: Manufacturer ID:"
 				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
-				nand_manuf_ids[i].name , mtd->name);
+				nand_manuf_ids[maf_id].name , mtd->name);
 			printk (KERN_WARNING 
 				"NAND bus width %d instead %d bit\n", 
 					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
@@ -2300,14 +2435,9 @@ int nand_scan (struct mtd_info *mtd, int
 		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
 			this->cmdfunc = nand_command_lp;
 				
-		/* Try to identify manufacturer */
-		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
-			if (nand_manuf_ids[j].id == nand_maf_id)
-				break;
-		}
 		printk (KERN_INFO "NAND device: Manufacturer ID:"
 			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
-			nand_manuf_ids[j].name , nand_flash_ids[i].name);
+			nand_manuf_ids[maf_id].name , nand_flash_ids[i].name);
 		break;
 	}
 
@@ -2388,12 +2518,9 @@ int nand_scan (struct mtd_info *mtd, int
 	
 	/* The number of bytes available for the filesystem to place fs dependend
 	 * oob data */
-	if (this->options & NAND_BUSWIDTH_16) {
-		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
-		if (this->autooob->eccbytes & 0x01)
-			mtd->oobavail--;
-	} else
-		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
+	mtd->oobavail = 0;
+	for (i = 0; this->autooob->oobfree[i][1]; i++)
+		mtd->oobavail += this->autooob->oobfree[i][1];
 
 	/* 
 	 * check ECC mode, default to software
@@ -2524,6 +2651,10 @@ int nand_scan (struct mtd_info *mtd, int
 	memcpy(&mtd->oobinfo, this->autooob, sizeof(mtd->oobinfo));
 
 	mtd->owner = THIS_MODULE;
+	
+	/* Check, if we should skip the bad block table scan */
+	if (this->options & NAND_SKIP_BBTSCAN)
+		return 0;
 
 	/* Build bad block table */
 	return this->scan_bbt (mtd);
@@ -2555,8 +2686,8 @@ void nand_release (struct mtd_info *mtd)
 		kfree (this->data_buf);
 }
 
-EXPORT_SYMBOL (nand_scan);
-EXPORT_SYMBOL (nand_release);
+EXPORT_SYMBOL_GPL (nand_scan);
+EXPORT_SYMBOL_GPL (nand_release);
 
 MODULE_LICENSE ("GPL");
 MODULE_AUTHOR ("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
Index: linux-2.6.10/drivers/mtd/nand/nand_bbt.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/nand_bbt.c
+++ linux-2.6.10/drivers/mtd/nand/nand_bbt.c
@@ -6,7 +6,7 @@
  *   
  *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: nand_bbt.c,v 1.28 2004/11/13 10:19:09 gleixner Exp $
+ * $Id: nand_bbt.c,v 1.32 2005/06/14 15:39:53 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -77,7 +77,7 @@
 */
 static int check_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
 {
-	int i, end;
+	int i, end = 0;
 	uint8_t *p = buf;
 
 	end = paglen + td->offs;
@@ -95,9 +95,9 @@ static int check_pattern (uint8_t *buf, 
 			return -1;
 	}
 
-	p += td->len;
-	end += td->len;
 	if (td->options & NAND_BBT_SCANEMPTY) {
+		p += td->len;
+		end += td->len;
 		for (i = end; i < len; i++) {
 			if (*p++ != 0xff)
 				return -1;
@@ -106,6 +106,32 @@ static int check_pattern (uint8_t *buf, 
 	return 0;
 }
 
+/** 
+ * check_short_pattern - [GENERIC] check if a pattern is in the buffer
+ * @buf:	the buffer to search
+ * @len:	the length of buffer to search
+ * @paglen:	the pagelength
+ * @td:		search pattern descriptor
+ *
+ * Check for a pattern at the given place. Used to search bad block
+ * tables and good / bad block identifiers. Same as check_pattern, but 
+ * no optional empty check and the pattern is expected to start
+ * at offset 0.
+ *
+*/
+static int check_short_pattern (uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
+{
+	int i;
+	uint8_t *p = buf;
+
+	/* Compare the pattern */
+	for (i = 0; i < td->len; i++) {
+		if (p[i] != td->pattern[i])
+			return -1;
+	}
+	return 0;
+}
+
 /**
  * read_bbt - [GENERIC] Read the bad block table starting from page
  * @mtd:	MTD device structure
@@ -252,7 +278,7 @@ static int read_abs_bbts (struct mtd_inf
  * Create a bad block table by scanning the device
  * for the given good/bad block identify pattern
  */
-static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
+static int create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
 {
 	struct nand_chip *this = mtd->priv;
 	int i, j, numblocks, len, scanlen;
@@ -270,9 +296,17 @@ static void create_bbt (struct mtd_info 
 		else	
 			len = 1;
 	}
-	scanlen	= mtd->oobblock + mtd->oobsize;
-	readlen = len * mtd->oobblock;
-	ooblen = len * mtd->oobsize;
+
+	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
+		/* We need only read few bytes from the OOB area */
+		scanlen = ooblen = 0;
+		readlen = bd->len;
+	} else {
+		/* Full page content should be read */
+		scanlen	= mtd->oobblock + mtd->oobsize;
+		readlen = len * mtd->oobblock;
+		ooblen = len * mtd->oobsize;
+	}
 
 	if (chip == -1) {
 		/* Note that numblocks is 2 * (real numblocks) here, see i+=2 below as it
@@ -284,7 +318,7 @@ static void create_bbt (struct mtd_info 
 		if (chip >= this->numchips) {
 			printk (KERN_WARNING "create_bbt(): chipnr (%d) > available chips (%d)\n",
 				chip + 1, this->numchips);
-			return;	
+			return -EINVAL;
 		}
 		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
 		startblock = chip * numblocks;
@@ -293,18 +327,41 @@ static void create_bbt (struct mtd_info 
 	}
 	
 	for (i = startblock; i < numblocks;) {
-		nand_read_raw (mtd, buf, from, readlen, ooblen);
+		int ret;
+		
+		if (bd->options & NAND_BBT_SCANEMPTY)
+			if ((ret = nand_read_raw (mtd, buf, from, readlen, ooblen)))
+				return ret;
+
 		for (j = 0; j < len; j++) {
-			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
-				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
-				printk (KERN_WARNING "Bad eraseblock %d at 0x%08x\n", 
-					i >> 1, (unsigned int) from);
-				break;
+			if (!(bd->options & NAND_BBT_SCANEMPTY)) {
+				size_t retlen;
+				
+				/* No need to read pages fully, just read required OOB bytes */
+				ret = mtd->read_oob(mtd, from + j * mtd->oobblock + bd->offs,
+							readlen, &retlen, &buf[0]);
+				if (ret)
+					return ret;
+
+				if (check_short_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
+					this->bbt[i >> 3] |= 0x03 << (i & 0x6);
+					printk (KERN_WARNING "Bad eraseblock %d at 0x%08x\n", 
+						i >> 1, (unsigned int) from);
+					break;
+				}
+			} else {
+				if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
+					this->bbt[i >> 3] |= 0x03 << (i & 0x6);
+					printk (KERN_WARNING "Bad eraseblock %d at 0x%08x\n", 
+						i >> 1, (unsigned int) from);
+					break;
+				}
 			}
 		}
 		i += 2;
 		from += (1 << this->bbt_erase_shift);
 	}
+	return 0;
 }
 
 /**
@@ -589,14 +646,12 @@ write:	
  * The function creates a memory based bbt by scanning the device 
  * for manufacturer / software marked good / bad blocks
 */
-static int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
+static inline int nand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
 	struct nand_chip *this = mtd->priv;
 
-	/* Ensure that we only scan for the pattern and nothing else */
-	bd->options = 0;
-	create_bbt (mtd, this->data_buf, bd, -1);
-	return 0;
+	bd->options &= ~NAND_BBT_SCANEMPTY;
+	return create_bbt (mtd, this->data_buf, bd, -1);
 }
 
 /**
@@ -808,8 +863,14 @@ int nand_scan_bbt (struct mtd_info *mtd,
 	/* If no primary table decriptor is given, scan the device
 	 * to build a memory based bad block table
 	 */
-	if (!td)
-		return nand_memory_bbt(mtd, bd);
+	if (!td) {
+		if ((res = nand_memory_bbt(mtd, bd))) {
+			printk (KERN_ERR "nand_bbt: Can't scan flash and build the RAM-based BBT\n");
+			kfree (this->bbt);
+			this->bbt = NULL;
+		}
+		return res;
+	}
 
 	/* Allocate a temporary buffer for one eraseblock incl. oob */
 	len = (1 << this->bbt_erase_shift);
@@ -904,14 +965,11 @@ out:	
 }
 
 /* Define some generic bad / good block scan pattern which are used 
- * while scanning a device for factory marked good / bad blocks
- * 
- * The memory based patterns just 
- */
+ * while scanning a device for factory marked good / bad blocks. */
 static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
 
 static struct nand_bbt_descr smallpage_memorybased = {
-	.options = 0,
+	.options = NAND_BBT_SCAN2NDPAGE,
 	.offs = 5,
 	.len = 1,
 	.pattern = scan_ff_pattern
@@ -1042,7 +1100,7 @@ int nand_isbad_bbt (struct mtd_info *mtd
 	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
 
 	DEBUG (MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n", 
-		(unsigned int)offs, res, block >> 1);
+		(unsigned int)offs, block >> 1, res);
 
 	switch ((int)res) {
 	case 0x00:	return 0;
Index: linux-2.6.10/drivers/mtd/nand/nand_ecc.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/nand_ecc.c
+++ linux-2.6.10/drivers/mtd/nand/nand_ecc.c
@@ -7,7 +7,7 @@
  * Copyright (C) 2000-2004 Steven J. Hill (sjhill@realitydiluted.com)
  *                         Toshiba America Electronics Components, Inc.
  *
- * $Id: nand_ecc.c,v 1.14 2004/06/16 15:34:37 gleixner Exp $
+ * $Id: nand_ecc.c,v 1.13 2004/05/28 10:58:19 gleixner Exp $
  *
  * This file is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
Index: linux-2.6.10/drivers/mtd/nand/nand_ids.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/nand_ids.c
+++ linux-2.6.10/drivers/mtd/nand/nand_ids.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
   *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
+ * $Id: nand_ids.c,v 1.13 2005/05/27 08:31:34 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -56,17 +56,24 @@ struct nand_flash_dev nand_flash_ids[] =
 	{"NAND 64MiB 3,3V 16-bit", 	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
 	
 	{"NAND 128MiB 1,8V 8-bit", 	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 8-bit", 	0x39, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 3,3V 8-bit", 	0x79, 512, 128, 0x4000, 0},
 	{"NAND 128MiB 1,8V 16-bit", 	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1,8V 16-bit", 	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
 	{"NAND 128MiB 3,3V 16-bit", 	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit", 	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
 	
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
-	
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
 	*/
+	/*512 Megabit */
+	{"NAND 64MiB 1,8V 8-bit", 	0xA2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 3,3V 8-bit", 	0xF2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 1,8V 16-bit", 	0xB2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	{"NAND 64MiB 3,3V 16-bit", 	0xC2, 0,  64, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
+	
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit", 	0xA1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
 	{"NAND 128MiB 3,3V 8-bit", 	0xF1, 0, 128, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
@@ -103,7 +110,7 @@ struct nand_flash_dev nand_flash_ids[] =
 	 * Anyway JFFS2 would increase the eraseblock size so we chose a combined one which can be erased in one go
 	 * There are more speed improvements for reads and writes possible, but not implemented now 
 	 */
-	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000, NAND_IS_AND | NAND_NO_AUTOINCR | NAND_4PAGE_ARRAY},
+	{"AND 128MiB 3,3V 8-bit",	0x01, 2048, 128, 0x4000, NAND_IS_AND | NAND_NO_AUTOINCR | NAND_4PAGE_ARRAY | BBT_AUTO_REFRESH},
 
 	{NULL,}
 };
@@ -118,6 +125,7 @@ struct nand_manufacturers nand_manuf_ids
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+        {NAND_MFR_HYNIX, "Hynix"},
 	{0x0, "Unknown"}
 };
 
Index: linux-2.6.10/drivers/mtd/nand/nandsim.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/nandsim.c
+++ linux-2.6.10/drivers/mtd/nand/nandsim.c
@@ -22,7 +22,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
- * $Id: nandsim.c,v 1.3 2004/11/26 13:00:24 dedekind Exp $
+ * $Id: nandsim.c,v 1.10 2005/05/23 10:12:10 dedekind Exp $
  */
 
 #include <linux/config.h>
@@ -38,63 +38,76 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/delay.h>
+
 #ifdef CONFIG_NS_ABS_POS
 #include <asm/io.h>
 #endif
 
+#define CONFIG_NANDSIM_FIRST_ID_BYTE        CONFIG_MTD_NAND_NANDSIM_FIRST_ID
+#define CONFIG_NANDSIM_SECOND_ID_BYTE       CONFIG_MTD_NAND_NANDSIM_SECOND_ID
+#define CONFIG_NANDSIM_THIRD_ID_BYTE        CONFIG_MTD_NAND_NANDSIM_THIRD_ID
+#define CONFIG_NANDSIM_FOURTH_ID_BYTE       CONFIG_MTD_NAND_NANDSIM_FOURTH_ID
 
-/* Default simulator parameters values */
-#if !defined(CONFIG_NANDSIM_FIRST_ID_BYTE)  || \
-    !defined(CONFIG_NANDSIM_SECOND_ID_BYTE) || \
-    !defined(CONFIG_NANDSIM_THIRD_ID_BYTE)  || \
-    !defined(CONFIG_NANDSIM_FOURTH_ID_BYTE)
-#define CONFIG_NANDSIM_FIRST_ID_BYTE  0x98
-#define CONFIG_NANDSIM_SECOND_ID_BYTE 0x36
-#define CONFIG_NANDSIM_THIRD_ID_BYTE  0xFF /* No byte */
-#define CONFIG_NANDSIM_FOURTH_ID_BYTE 0xFF /* No byte */
+#ifndef CONFIG_MTD_NAND_NANDSIM_ACCESS_DELAY
+#  define CONFIG_MTD_NAND_NANDSIM_ACCESS_DELAY   25
 #endif
 
-#ifndef CONFIG_NANDSIM_ACCESS_DELAY
-#define CONFIG_NANDSIM_ACCESS_DELAY 25
-#endif
-#ifndef CONFIG_NANDSIM_PROGRAMM_DELAY
-#define CONFIG_NANDSIM_PROGRAMM_DELAY 200
+#ifndef CONFIG_MTD_NAND_NANDSIM_PROGRAM_DELAY
+#  define CONFIG_MTD_NAND_NANDSIM_PROGRAM_DELAY  200
 #endif
-#ifndef CONFIG_NANDSIM_ERASE_DELAY
-#define CONFIG_NANDSIM_ERASE_DELAY 2
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_ERASE_DELAY
+#  define CONFIG_MTD_NAND_NANDSIM_ERASE_DELAY    2
 #endif
-#ifndef CONFIG_NANDSIM_OUTPUT_CYCLE
-#define CONFIG_NANDSIM_OUTPUT_CYCLE 40
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_OUTPUT_CYCLE
+#  define CONFIG_MTD_NAND_NANDSIM_OUTPUT_CYCLE   40
 #endif
-#ifndef CONFIG_NANDSIM_INPUT_CYCLE
-#define CONFIG_NANDSIM_INPUT_CYCLE  50
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_INPUT_CYCLE
+#  define CONFIG_MTD_NAND_NANDSIM_INPUT_CYCLE    50
 #endif
-#ifndef CONFIG_NANDSIM_BUS_WIDTH
-#define CONFIG_NANDSIM_BUS_WIDTH  8
+
+#ifdef CONFIG_MTD_NAND_NANDSIM_16BIT_BUS
+#  define CONFIG_NANDSIM_BUS_WIDTH      16
+#else
+#  define CONFIG_NANDSIM_BUS_WIDTH      8
 #endif
-#ifndef CONFIG_NANDSIM_DO_DELAYS
-#define CONFIG_NANDSIM_DO_DELAYS  0
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_DELAY
+#  define CONFIG_MTD_NAND_NANDSIM_DELAY 0
+#else
+#  undef CONFIG_MTD_NAND_NANDSIM_DELAY
+#  define CONFIG_MTD_NAND_NANDSIM_DELAY 1
 #endif
-#ifndef CONFIG_NANDSIM_LOG
-#define CONFIG_NANDSIM_LOG        0
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_LOG
+#  define CONFIG_MTD_NAND_NANDSIM_LOG   0
+#else
+#  undef CONFIG_MTD_NAND_NANDSIM_LOG
+#  define CONFIG_MTD_NAND_NANDSIM_LOG   1
 #endif
-#ifndef CONFIG_NANDSIM_DBG
-#define CONFIG_NANDSIM_DBG        0
+
+#ifndef CONFIG_MTD_NAND_NANDSIM_DEBUG
+#  define CONFIG_MTD_NAND_NANDSIM_DEBUG 0
+#else
+#  undef CONFIG_MTD_NAND_NANDSIM_DEBUG
+#  define CONFIG_MTD_NAND_NANDSIM_DEBUG 1
 #endif
 
 static uint first_id_byte  = CONFIG_NANDSIM_FIRST_ID_BYTE;
 static uint second_id_byte = CONFIG_NANDSIM_SECOND_ID_BYTE;
 static uint third_id_byte  = CONFIG_NANDSIM_THIRD_ID_BYTE;
 static uint fourth_id_byte = CONFIG_NANDSIM_FOURTH_ID_BYTE;
-static uint access_delay   = CONFIG_NANDSIM_ACCESS_DELAY;
-static uint programm_delay = CONFIG_NANDSIM_PROGRAMM_DELAY;
-static uint erase_delay    = CONFIG_NANDSIM_ERASE_DELAY;
-static uint output_cycle   = CONFIG_NANDSIM_OUTPUT_CYCLE;
-static uint input_cycle    = CONFIG_NANDSIM_INPUT_CYCLE;
+static uint access_delay   = CONFIG_MTD_NAND_NANDSIM_ACCESS_DELAY;
+static uint programm_delay = CONFIG_MTD_NAND_NANDSIM_PROGRAM_DELAY;
+static uint erase_delay    = CONFIG_MTD_NAND_NANDSIM_ERASE_DELAY;
+static uint output_cycle   = CONFIG_MTD_NAND_NANDSIM_OUTPUT_CYCLE;
+static uint input_cycle    = CONFIG_MTD_NAND_NANDSIM_INPUT_CYCLE;
 static uint bus_width      = CONFIG_NANDSIM_BUS_WIDTH;
-static uint do_delays      = CONFIG_NANDSIM_DO_DELAYS;
-static uint log            = CONFIG_NANDSIM_LOG;
-static uint dbg            = CONFIG_NANDSIM_DBG;
+static uint do_delays      = CONFIG_MTD_NAND_NANDSIM_DELAY;
+static uint log            = CONFIG_MTD_NAND_NANDSIM_LOG;
+static uint dbg            = CONFIG_MTD_NAND_NANDSIM_DEBUG;
 
 module_param(first_id_byte,  uint, 0400);
 module_param(second_id_byte, uint, 0400);
@@ -117,19 +130,13 @@ MODULE_PARM_DESC(fourth_id_byte, "The fo
 MODULE_PARM_DESC(access_delay,   "Initial page access delay (microiseconds)");
 MODULE_PARM_DESC(programm_delay, "Page programm delay (microseconds");
 MODULE_PARM_DESC(erase_delay,    "Sector erase delay (milliseconds)");
-MODULE_PARM_DESC(output_cycle,   "Word output (from flash) time (nanodeconds)");
-MODULE_PARM_DESC(input_cycle,    "Word input (to flash) time (nanodeconds)");
+MODULE_PARM_DESC(output_cycle,   "Word output (from flash) time (nanoseconds)");
+MODULE_PARM_DESC(input_cycle,    "Word input (to flash) time (nanoseconds)");
 MODULE_PARM_DESC(bus_width,      "Chip's bus width (8- or 16-bit)");
 MODULE_PARM_DESC(do_delays,      "Simulate NAND delays using busy-waits if not zero");
 MODULE_PARM_DESC(log,            "Perform logging if not zero");
 MODULE_PARM_DESC(dbg,            "Output debug information if not zero");
 
-/* 
- * There is no macro for 0x30 command which is used in "large page"
- * devices in standard mtd header, define it here. 
- */
-#define NAND_CMD_READ2LP 0x30
-
 /* The largest possible page size */
 #define NS_LARGEST_PAGE_SIZE	2048
 	
@@ -138,13 +145,13 @@ MODULE_PARM_DESC(dbg,            "Output
 
 /* Simulator's output macros (logging, debugging, warning, error) */
 #define NS_LOG(args...) \
-	do { if (log) printk(KERN_INFO NS_OUTPUT_PREFIX " log: " args); } while(0)
+	do { if (log) printk(KERN_DEBUG NS_OUTPUT_PREFIX " log: " args); } while(0)
 #define NS_DBG(args...) \
-	do { if (dbg) printk(KERN_INFO NS_OUTPUT_PREFIX " debug: " args); } while(0)
+	do { if (dbg) printk(KERN_DEBUG NS_OUTPUT_PREFIX " debug: " args); } while(0)
 #define NS_WARN(args...) \
-	do { printk(KERN_INFO NS_OUTPUT_PREFIX " warnig: " args); } while(0)
+	do { printk(KERN_WARNING NS_OUTPUT_PREFIX " warnig: " args); } while(0)
 #define NS_ERR(args...) \
-	do { printk(KERN_INFO NS_OUTPUT_PREFIX " errorr: " args); } while(0)
+	do { printk(KERN_ERR NS_OUTPUT_PREFIX " errorr: " args); } while(0)
 
 /* Busy-wait delay macros (microseconds, milliseconds) */
 #define NS_UDELAY(us) \
@@ -171,7 +178,7 @@ MODULE_PARM_DESC(dbg,            "Output
 /* After a command is input, the simulator goes to one of the following states */
 #define STATE_CMD_READ0        0x00000001 /* read data from the beginning of page */
 #define STATE_CMD_READ1        0x00000002 /* read data from the second half of page */
-#define STATE_CMD_READ2LP      0x00000003 /* read data second command (large page devices) */
+#define STATE_CMD_READSTART    0x00000003 /* read data second command (large page devices) */
 #define STATE_CMD_PAGEPROG     0x00000004 /* start page programm */
 #define STATE_CMD_READOOB      0x00000005 /* read OOB area */
 #define STATE_CMD_ERASE1       0x00000006 /* sector erase first command */
@@ -343,7 +350,7 @@ static struct nandsim_operations {
 	/* Read ID */
 	{OPT_ANY, {STATE_CMD_READID, STATE_ADDR_ZERO, STATE_DATAOUT_ID, STATE_READY}},
 	/* Large page devices read page */
-	{OPT_LARGEPAGE, {STATE_CMD_READ0, STATE_ADDR_PAGE, STATE_CMD_READ2LP | ACTION_CPY,
+	{OPT_LARGEPAGE, {STATE_CMD_READ0, STATE_ADDR_PAGE, STATE_CMD_READSTART | ACTION_CPY,
 			       STATE_DATAOUT, STATE_READY}}
 };
 
@@ -412,7 +419,7 @@ init_nandsim(struct mtd_info *mtd)
 		}
 	} else {
 		if (ns->geom.totsz <= (128 << 20)) {
-			ns->geom.pgaddrbytes  = 5;
+			ns->geom.pgaddrbytes  = 4;
 			ns->geom.secaddrbytes = 2;
 		} else {
 			ns->geom.pgaddrbytes  = 5;
@@ -522,8 +529,8 @@ get_state_name(uint32_t state)
 			return "STATE_CMD_PAGEPROG";
 		case STATE_CMD_READOOB:
 			return "STATE_CMD_READOOB";
-		case STATE_CMD_READ2LP:
-			return "STATE_CMD_READ2LP";
+		case STATE_CMD_READSTART:
+			return "STATE_CMD_READSTART";
 		case STATE_CMD_ERASE1:
 			return "STATE_CMD_ERASE1";
 		case STATE_CMD_STATUS:
@@ -575,7 +582,7 @@ check_command(int cmd)
 	switch (cmd) {
 		
 	case NAND_CMD_READ0:
-	case NAND_CMD_READ2LP:
+	case NAND_CMD_READSTART:
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_READOOB:
 	case NAND_CMD_ERASE1:
@@ -606,8 +613,8 @@ get_state_by_command(unsigned command)
 			return STATE_CMD_READ1;
 		case NAND_CMD_PAGEPROG:
 			return STATE_CMD_PAGEPROG;
-		case NAND_CMD_READ2LP:
-			return STATE_CMD_READ2LP;
+		case NAND_CMD_READSTART:
+			return STATE_CMD_READSTART;
 		case NAND_CMD_READOOB:
 			return STATE_CMD_READOOB;
 		case NAND_CMD_ERASE1:
@@ -1490,33 +1497,6 @@ ns_nand_verify_buf(struct mtd_info *mtd,
 }
 
 /*
- * Having only NAND chip IDs we call nand_scan which detects NAND flash
- * parameters and then calls scan_bbt in order to scan/find/build the
- * NAND flash bad block table. But since at that moment the NAND flash
- * image isn't allocated in the simulator, errors arise. To avoid this
- * we redefine the scan_bbt callback and initialize the nandsim structure
- * before the flash media scanning.
- */
-int ns_scan_bbt(struct mtd_info *mtd)
-{ 
-	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
-	struct nandsim   *ns   = (struct nandsim *)(chip->priv);
-	int retval;
-
-	if (!NS_IS_INITIALIZED(ns))
-		if ((retval = init_nandsim(mtd)) != 0) {
-			NS_ERR("scan_bbt: can't initialize the nandsim structure\n");
-			return retval;
-		}
-	if ((retval = nand_default_bbt(mtd)) != 0) {
-		free_nandsim(ns);
-		return retval;
-	}
-
-	return 0;
-}
-
-/*
  * Module initialization function
  */
 int __init ns_init_module(void)
@@ -1550,7 +1530,6 @@ int __init ns_init_module(void)
 	chip->hwcontrol  = ns_hwcontrol;
 	chip->read_byte  = ns_nand_read_byte;
 	chip->dev_ready  = ns_device_ready;
-	chip->scan_bbt   = ns_scan_bbt;
 	chip->write_byte = ns_nand_write_byte;
 	chip->write_buf  = ns_nand_write_buf;
 	chip->read_buf   = ns_nand_read_buf;
@@ -1558,6 +1537,7 @@ int __init ns_init_module(void)
 	chip->write_word = ns_nand_write_word;
 	chip->read_word  = ns_nand_read_word;
 	chip->eccmode    = NAND_ECC_SOFT;
+	chip->options   |= NAND_SKIP_BBTSCAN;
 
 	/* 
 	 * Perform minimum nandsim structure initialization to handle
@@ -1586,6 +1566,16 @@ int __init ns_init_module(void)
 		goto error;
 	}
 
+	if ((retval = init_nandsim(nsmtd)) != 0) {
+		NS_ERR("scan_bbt: can't initialize the nandsim structure\n");
+		goto error;
+	}
+	
+	if ((retval = nand_default_bbt(nsmtd)) != 0) {
+		free_nandsim(nand);
+		goto error;
+	}
+
 	/* Register NAND as one big partition */
 	add_mtd_partitions(nsmtd, &nand->part, 1);
 
Index: linux-2.6.10/drivers/mtd/nand/ppchameleonevb.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/ppchameleonevb.c
+++ linux-2.6.10/drivers/mtd/nand/ppchameleonevb.c
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/edb7312.c
  *
  *
- * $Id: ppchameleonevb.c,v 1.6 2004/11/05 16:07:16 kalev Exp $
+ * $Id: ppchameleonevb.c,v 1.5 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/rtc_from4.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/rtc_from4.c
+++ linux-2.6.10/drivers/mtd/nand/rtc_from4.c
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/nand/spia.c
  *       Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  *
- * $Id: rtc_from4.c,v 1.7 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: rtc_from4.c,v 1.8 2005/01/17 19:44:36 dmarlin Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -83,13 +83,18 @@ static struct mtd_info *rtc_from4_mtd = 
 #define RTC_FROM4_RS_ECC_CHK		(RTC_FROM4_NAND_ADDR_FPGA | 0x00000070)
 #define RTC_FROM4_RS_ECC_CHK_ERROR	(1 << 7)
 
+#define ERR_STAT_ECC_AVAILABLE		0x20
+
 /* Undefine for software ECC */
 #define RTC_FROM4_HWECC	1
 
+/* Define as 1 for no virtual erase blocks (in JFFS2) */
+#define RTC_FROM4_NO_VIRTBLOCKS	0
+
 /*
  * Module stuff
  */
-static void __iomem *rtc_from4_fio_base = P2SEGADDR(RTC_FROM4_FIO_BASE);
+static void __iomem *rtc_from4_fio_base = (void *)P2SEGADDR(RTC_FROM4_FIO_BASE);
 
 const static struct mtd_partition partition_info[] = {
         {
@@ -267,7 +272,6 @@ static void rtc_from4_nand_select_chip(s
 }
 
 
-
 /*
  * rtc_from4_nand_device_ready - hardware specific ready/busy check
  * @mtd:	MTD device structure
@@ -286,6 +290,40 @@ static int rtc_from4_nand_device_ready(s
 
 }
 
+
+/*
+ * deplete - code to perform device recovery in case there was a power loss
+ * @mtd:	MTD device structure
+ * @chip:	Chip to select (0 == slot 3, 1 == slot 4)
+ *
+ * If there was a sudden loss of power during an erase operation, a 
+ * "device recovery" operation must be performed when power is restored
+ * to ensure correct operation.  This routine performs the required steps
+ * for the requested chip.
+ *
+ * See page 86 of the data sheet for details.
+ *
+ */
+static void deplete(struct mtd_info *mtd, int chip)
+{
+        struct nand_chip *this = mtd->priv;
+
+        /* wait until device is ready */
+        while (!this->dev_ready(mtd));
+
+	this->select_chip(mtd, chip);
+                                                                                                                                              
+	/* Send the commands for device recovery, phase 1 */
+	this->cmdfunc (mtd, NAND_CMD_DEPLETE1, 0x0000, 0x0000);
+	this->cmdfunc (mtd, NAND_CMD_DEPLETE2, -1, -1);
+
+	/* Send the commands for device recovery, phase 2 */
+	this->cmdfunc (mtd, NAND_CMD_DEPLETE1, 0x0000, 0x0004);
+	this->cmdfunc (mtd, NAND_CMD_DEPLETE2, -1, -1);
+
+}
+
+
 #ifdef RTC_FROM4_HWECC
 /*
  * rtc_from4_enable_hwecc - hardware specific hardware ECC enable function
@@ -329,6 +367,7 @@ static void rtc_from4_enable_hwecc(struc
 
 }
 
+
 /*
  * rtc_from4_calculate_ecc - hardware specific code to read ECC code
  * @mtd:	MTD device structure
@@ -356,6 +395,7 @@ static void rtc_from4_calculate_ecc(stru
 	ecc_code[7] |= 0x0f;	/* set the last four bits (not used) */
 }
 
+
 /*
  * rtc_from4_correct_data - hardware specific code to correct data using ECC code
  * @mtd:	MTD device structure
@@ -365,16 +405,14 @@ static void rtc_from4_calculate_ecc(stru
  *
  * The FPGA tells us fast, if there's an error or not. If no, we go back happy
  * else we read the ecc results from the fpga and call the rs library to decode
- * and hopefully correct the error
+ * and hopefully correct the error.
  *
- * For now I use the code, which we read from the FLASH to use the RS lib,
- * as the syndrom conversion has a unresolved issue.
  */
 static int rtc_from4_correct_data(struct mtd_info *mtd, const u_char *buf, u_char *ecc1, u_char *ecc2)
 {
 	int i, j, res;
 	unsigned short status; 
-	uint16_t par[6], syn[6], tmp;
+	uint16_t par[6], syn[6];
 	uint8_t ecc[8];
         volatile unsigned short *rs_ecc;
 
@@ -416,15 +454,86 @@ static int rtc_from4_correct_data(struct
 	}
 
 	/* Let the library code do its magic.*/
-	res = decode_rs8(rs_decoder, buf, par, 512, syn, 0, NULL, 0xff, NULL);
+	res = decode_rs8(rs_decoder, (uint8_t *)buf, par, 512, syn, 0, NULL, 0xff, NULL);
 	if (res > 0) {
 		DEBUG (MTD_DEBUG_LEVEL0, "rtc_from4_correct_data: " 
 			"ECC corrected %d errors on read\n", res);
 	}
 	return res;
 }
+
+
+/**
+ * rtc_from4_errstat - perform additional error status checks
+ * @mtd:	MTD device structure
+ * @this:	NAND chip structure
+ * @state:	state or the operation
+ * @status:	status code returned from read status
+ * @page:	startpage inside the chip, must be called with (page & this->pagemask)
+ * 
+ * Perform additional error status checks on erase and write failures 
+ * to determine if errors are correctable.  For this device, correctable 
+ * 1-bit errors on erase and write are considered acceptable.
+ *
+ * note: see pages 34..37 of data sheet for details.
+ *
+ */
+static int rtc_from4_errstat(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page)
+{
+	int	er_stat=0;
+	int	rtn, retlen;
+	size_t	len;
+	uint8_t *buf;
+	int	i;
+
+	this->cmdfunc (mtd, NAND_CMD_STATUS_CLEAR, -1, -1);
+
+        if (state == FL_ERASING) {
+		for (i=0; i<4; i++) {
+			if (status & 1<<(i+1)) {
+				this->cmdfunc (mtd, (NAND_CMD_STATUS_ERROR + i + 1), -1, -1);
+				rtn = this->read_byte(mtd);
+				this->cmdfunc (mtd, NAND_CMD_STATUS_RESET, -1, -1);
+				if (!(rtn & ERR_STAT_ECC_AVAILABLE)) {
+					er_stat |= 1<<(i+1);	/* err_ecc_not_avail */
+				}
+			}
+		}
+	} else if (state == FL_WRITING) {
+		/* single bank write logic */
+		this->cmdfunc (mtd, NAND_CMD_STATUS_ERROR, -1, -1);
+		rtn = this->read_byte(mtd);
+		this->cmdfunc (mtd, NAND_CMD_STATUS_RESET, -1, -1);
+		if (!(rtn & ERR_STAT_ECC_AVAILABLE)) {
+			er_stat |= 1<<1;	/* err_ecc_not_avail */
+		} else {
+			len = mtd->oobblock;
+			buf = kmalloc (len, GFP_KERNEL);
+			if (!buf) {
+				printk (KERN_ERR "rtc_from4_errstat: Out of memory!\n");
+				er_stat = 1;			/* if we can't check, assume failed */
+			} else {
+				/* recovery read */
+				/* page read */
+				rtn = nand_do_read_ecc (mtd, page, len, &retlen, buf, NULL, this->autooob, 1);
+				if (rtn) {	/* if read failed or > 1-bit error corrected */
+					er_stat |= 1<<1;	/* ECC read failed */
+				}
+				kfree(buf);
+			}
+		}
+	}
+
+	rtn = status;
+	if (er_stat == 0) {				/* if ECC is available   */
+		rtn = (status & ~NAND_STATUS_FAIL);	/*   clear the error bit */
+	}
+
+	return rtn;
+}
 #endif
 
+
 /*
  * Main initialization routine
  */
@@ -432,6 +541,7 @@ int __init rtc_from4_init (void)
 {
 	struct nand_chip *this;
 	unsigned short bcr1, bcr2, wcr2;
+	int i;
 
 	/* Allocate memory for MTD device structure and private data */
 	rtc_from4_mtd = kmalloc(sizeof(struct mtd_info) + sizeof (struct nand_chip),
@@ -483,6 +593,8 @@ int __init rtc_from4_init (void)
 
         this->eccmode = NAND_ECC_HW8_512;
 	this->options |= NAND_HWECC_SYNDROME;
+	/* return the status of extra status and ECC checks */
+	this->errstat = rtc_from4_errstat;
 	/* set the nand_oobinfo to support FPGA H/W error detection */
 	this->autooob = &rtc_from4_nand_oobinfo;
 	this->enable_hwecc = rtc_from4_enable_hwecc;
@@ -504,6 +616,18 @@ int __init rtc_from4_init (void)
 		return -ENXIO;
 	}
 
+	/* Perform 'device recovery' for each chip in case there was a power loss. */
+	for (i=0; i < this->numchips; i++) {
+		deplete(rtc_from4_mtd, i);
+	}
+
+#if RTC_FROM4_NO_VIRTBLOCKS
+	/* use a smaller erase block to minimize wasted space when a block is bad */
+	/* note: this uses eight times as much RAM as using the default and makes */
+	/*       mounts take four times as long. */
+	rtc_from4_mtd->flags |= MTD_NO_VIRTBLOCKS;
+#endif
+
 	/* Register the partitions */
 	add_mtd_partitions(rtc_from4_mtd, partition_info, NUM_PARTITIONS);
 
Index: linux-2.6.10/drivers/mtd/nand/s3c2410.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/s3c2410.c
+++ linux-2.6.10/drivers/mtd/nand/s3c2410.c
@@ -1,17 +1,24 @@
 /* linux/drivers/mtd/nand/s3c2410.c
  *
- * Copyright (c) 2004 Simtec Electronics
- * Ben Dooks <ben@simtec.co.uk>
+ * Copyright (c) 2004,2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
  *
- * Samsung S3C2410 NAND driver
+ * Samsung S3C2410/S3C240 NAND driver
  *
  * Changelog:
  *	21-Sep-2004  BJD  Initial version
  *	23-Sep-2004  BJD  Mulitple device support
  *	28-Sep-2004  BJD  Fixed ECC placement for Hardware mode
  *	12-Oct-2004  BJD  Fixed errors in use of platform data
+ *	18-Feb-2005  BJD  Fix sparse errors
+ *	14-Mar-2005  BJD  Applied tglx's code reduction patch
+ *	02-May-2005  BJD  Fixed s3c2440 support
+ *	02-May-2005  BJD  Reduced hwcontrol decode
+ *	20-Jun-2005  BJD  Updated s3c2440 support, fixed timing bug
+ *	08-Jul-2005  BJD  Fix OOPS when no platform data supplied
  *
- * $Id: s3c2410.c,v 1.6 2004/11/24 12:25:48 bjd Exp $
+ * $Id: s3c2410.c,v 1.13 2005/06/20 11:48:21 bjd Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -69,10 +76,10 @@ static int hardware_ecc = 0;
  */
 
 static struct nand_oobinfo nand_hw_eccoob = {
-	.useecc = MTD_NANDECC_AUTOPLACE,
-	.eccbytes = 3,
-	.eccpos = {0, 1, 2 },
-	.oobfree = { {8, 8} }
+	.useecc		= MTD_NANDECC_AUTOPLACE,
+	.eccbytes	= 3,
+	.eccpos		= {0, 1, 2 },
+	.oobfree	= { {8, 8} }
 };
 
 /* controller and mtd information */
@@ -99,8 +106,10 @@ struct s3c2410_nand_info {
 	struct device			*device;
 	struct resource			*area;
 	struct clk			*clk;
-	void				*regs;
+	void __iomem			*regs;
 	int				mtd_count;
+
+	unsigned char			is_s3c2440;
 };
 
 /* conversion functions */
@@ -117,12 +126,12 @@ static struct s3c2410_nand_info *s3c2410
 
 static struct s3c2410_nand_info *to_nand_info(struct device *dev)
 {
-	return (struct s3c2410_nand_info *)dev_get_drvdata(dev);
+	return dev_get_drvdata(dev);
 }
 
 static struct s3c2410_platform_nand *to_nand_plat(struct device *dev)
 {
-	return (struct s3c2410_platform_nand *)dev->platform_data;
+	return dev->platform_data;
 }
 
 /* timing calculations */
@@ -165,12 +174,12 @@ static int s3c2410_nand_inithw(struct s3
 	/* calculate the timing information for the controller */
 
 	if (plat != NULL) {
-		tacls = s3c2410_nand_calc_rate(plat->tacls, clkrate, 8);
+		tacls  = s3c2410_nand_calc_rate(plat->tacls, clkrate, 4);
 		twrph0 = s3c2410_nand_calc_rate(plat->twrph0, clkrate, 8);
 		twrph1 = s3c2410_nand_calc_rate(plat->twrph1, clkrate, 8);
 	} else {
 		/* default timings */
-		tacls = 8;
+		tacls = 4;
 		twrph0 = 8;
 		twrph1 = 8;
 	}
@@ -185,10 +194,16 @@ static int s3c2410_nand_inithw(struct s3
 	       to_ns(twrph0, clkrate),
 	       to_ns(twrph1, clkrate));
 
-	cfg  = S3C2410_NFCONF_EN;
-	cfg |= S3C2410_NFCONF_TACLS(tacls-1);
-	cfg |= S3C2410_NFCONF_TWRPH0(twrph0-1);
-	cfg |= S3C2410_NFCONF_TWRPH1(twrph1-1);
+	if (!info->is_s3c2440) {
+		cfg  = S3C2410_NFCONF_EN;
+		cfg |= S3C2410_NFCONF_TACLS(tacls-1);
+		cfg |= S3C2410_NFCONF_TWRPH0(twrph0-1);
+		cfg |= S3C2410_NFCONF_TWRPH1(twrph1-1);
+	} else {
+		cfg   = S3C2440_NFCONF_TACLS(tacls-1);
+		cfg  |= S3C2440_NFCONF_TWRPH0(twrph0-1);
+		cfg  |= S3C2440_NFCONF_TWRPH1(twrph1-1);
+	}
 
 	pr_debug(PFX "NF_CONF is 0x%lx\n", cfg);
 
@@ -203,17 +218,22 @@ static void s3c2410_nand_select_chip(str
 	struct s3c2410_nand_info *info;
 	struct s3c2410_nand_mtd *nmtd; 
 	struct nand_chip *this = mtd->priv;
+	void __iomem *reg;
 	unsigned long cur;
+	unsigned long bit;
 
-	nmtd = (struct s3c2410_nand_mtd *)this->priv;
+	nmtd = this->priv;
 	info = nmtd->info;
 
-	cur = readl(info->regs + S3C2410_NFCONF);
+	bit = (info->is_s3c2440) ? S3C2440_NFCONT_nFCE : S3C2410_NFCONF_nFCE;
+	reg = info->regs+((info->is_s3c2440) ? S3C2440_NFCONT:S3C2410_NFCONF);
+
+	cur = readl(reg);
 
 	if (chip == -1) {
-		cur |= S3C2410_NFCONF_nFCE;
+		cur |= bit;
 	} else {
-		if (chip > nmtd->set->nr_chips) {
+		if (nmtd->set != NULL && chip > nmtd->set->nr_chips) {
 			printk(KERN_ERR PFX "chip %d out of range\n", chip);
 			return;
 		}
@@ -223,143 +243,76 @@ static void s3c2410_nand_select_chip(str
 				(info->platform->select_chip)(nmtd->set, chip);
 		}
 
-		cur &= ~S3C2410_NFCONF_nFCE;
+		cur &= ~bit;
 	}
 
-	writel(cur, info->regs + S3C2410_NFCONF);
+	writel(cur, reg);
 }
 
-/* command and control functions */
+/* command and control functions 
+ *
+ * Note, these all use tglx's method of changing the IO_ADDR_W field
+ * to make the code simpler, and use the nand layer's code to issue the
+ * command and address sequences via the proper IO ports.
+ *
+*/
 
 static void s3c2410_nand_hwcontrol(struct mtd_info *mtd, int cmd)
 {
 	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
-	unsigned long cur;
+	struct nand_chip *chip = mtd->priv;
 
 	switch (cmd) {
 	case NAND_CTL_SETNCE:
-		cur = readl(info->regs + S3C2410_NFCONF);
-		cur &= ~S3C2410_NFCONF_nFCE;
-		writel(cur, info->regs + S3C2410_NFCONF);
-		break;
-
 	case NAND_CTL_CLRNCE:
-		cur = readl(info->regs + S3C2410_NFCONF);
-		cur |= S3C2410_NFCONF_nFCE;
-		writel(cur, info->regs + S3C2410_NFCONF);
+		printk(KERN_ERR "%s: called for NCE\n", __FUNCTION__);
 		break;
 
-		/* we don't need to implement these */
 	case NAND_CTL_SETCLE:
-	case NAND_CTL_CLRCLE:
+		chip->IO_ADDR_W = info->regs + S3C2410_NFCMD;
+		break;
+
 	case NAND_CTL_SETALE:
-	case NAND_CTL_CLRALE:
-		pr_debug(PFX "s3c2410_nand_hwcontrol(%d) unusedn", cmd);
+		chip->IO_ADDR_W = info->regs + S3C2410_NFADDR;
+		break;
+
+		/* NAND_CTL_CLRCLE: */
+		/* NAND_CTL_CLRALE: */
+	default:
+		chip->IO_ADDR_W = info->regs + S3C2410_NFDATA;
 		break;
 	}
 }
 
-/* s3c2410_nand_command
- *
- * This function implements sending commands and the relevant address
- * information to the chip, via the hardware controller. Since the
- * S3C2410 generates the correct ALE/CLE signaling automatically, we
- * do not need to use hwcontrol.
-*/
+/* command and control functions */
 
-static void s3c2410_nand_command (struct mtd_info *mtd, unsigned command,
-				  int column, int page_addr)
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
 {
-	register struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
-	register struct nand_chip *this = mtd->priv;
-
-	/*
-	 * Write out the command to the device.
-	 */
-	if (command == NAND_CMD_SEQIN) {
-		int readcmd;
-
-		if (column >= mtd->oobblock) {
-			/* OOB area */
-			column -= mtd->oobblock;
-			readcmd = NAND_CMD_READOOB;
-		} else if (column < 256) {
-			/* First 256 bytes --> READ0 */
-			readcmd = NAND_CMD_READ0;
-		} else {
-			column -= 256;
-			readcmd = NAND_CMD_READ1;
-		}
-		
-		writeb(readcmd, info->regs + S3C2410_NFCMD);
-	}
-	writeb(command, info->regs + S3C2410_NFCMD);
-
-	/* Set ALE and clear CLE to start address cycle */
-
-	if (column != -1 || page_addr != -1) {
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	struct nand_chip *chip = mtd->priv;
 
-		/* Serially input address */
-		if (column != -1) {
-			/* Adjust columns for 16 bit buswidth */
-			if (this->options & NAND_BUSWIDTH_16)
-				column >>= 1;
-			writeb(column, info->regs + S3C2410_NFADDR);
-		}
-		if (page_addr != -1) {
-			writeb((unsigned char) (page_addr), info->regs + S3C2410_NFADDR);
-			writeb((unsigned char) (page_addr >> 8), info->regs + S3C2410_NFADDR);
-			/* One more address cycle for higher density devices */
-			if (this->chipsize & 0x0c000000) 
-				writeb((unsigned char) ((page_addr >> 16) & 0x0f),
-				       info->regs + S3C2410_NFADDR);
-		}
-		/* Latch in address */
-	}
-	
-	/* 
-	 * program and erase have their own busy handlers 
-	 * status and sequential in needs no delay
-	*/
-	switch (command) {
-			
-	case NAND_CMD_PAGEPROG:
-	case NAND_CMD_ERASE1:
-	case NAND_CMD_ERASE2:
-	case NAND_CMD_SEQIN:
-	case NAND_CMD_STATUS:
-		return;
-
-	case NAND_CMD_RESET:
-		if (this->dev_ready)	
-			break;
+	switch (cmd) {
+	case NAND_CTL_SETNCE:
+	case NAND_CTL_CLRNCE:
+		printk(KERN_ERR "%s: called for NCE\n", __FUNCTION__);
+		break;
 
-		udelay(this->chip_delay);
-		writeb(NAND_CMD_STATUS, info->regs + S3C2410_NFCMD);
+	case NAND_CTL_SETCLE:
+		chip->IO_ADDR_W = info->regs + S3C2440_NFCMD;
+		break;
 
-		while ( !(this->read_byte(mtd) & 0x40));
-		return;
+	case NAND_CTL_SETALE:
+		chip->IO_ADDR_W = info->regs + S3C2440_NFADDR;
+		break;
 
-	/* This applies to read commands */	
+		/* NAND_CTL_CLRCLE: */
+		/* NAND_CTL_CLRALE: */
 	default:
-		/* 
-		 * If we don't have access to the busy pin, we apply the given
-		 * command delay
-		*/
-		if (!this->dev_ready) {
-			udelay (this->chip_delay);
-			return;
-		}	
+		chip->IO_ADDR_W = info->regs + S3C2440_NFDATA;
+		break;
 	}
-	
-	/* Apply this short delay always to ensure that we do wait tWB in
-	 * any case on any machine. */
-	ndelay (100);
-	/* wait until command is processed */
-	while (!this->dev_ready(mtd));
 }
 
-
 /* s3c2410_nand_devready()
  *
  * returns 0 if the nand is busy, 1 if it is ready
@@ -369,9 +322,12 @@ static int s3c2410_nand_devready(struct 
 {
 	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
 	
+	if (info->is_s3c2440)
+		return readb(info->regs + S3C2440_NFSTAT) & S3C2440_NFSTAT_READY;
 	return readb(info->regs + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY;
 }
 
+
 /* ECC handling functions */
 
 static int s3c2410_nand_correct_data(struct mtd_info *mtd, u_char *dat,
@@ -394,6 +350,12 @@ static int s3c2410_nand_correct_data(str
 	return -1;
 }
 
+/* ECC functions
+ *
+ * These allow the s3c2410 and s3c2440 to use the controller's ECC
+ * generator block to ECC the data as it passes through]
+*/
+
 static void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
@@ -404,6 +366,15 @@ static void s3c2410_nand_enable_hwecc(st
 	writel(ctrl, info->regs + S3C2410_NFCONF);
 }
 
+static void s3c2440_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ctrl;
+
+	ctrl = readl(info->regs + S3C2440_NFCONT);
+	writel(ctrl | S3C2440_NFCONT_INITECC, info->regs + S3C2440_NFCONT);
+}
+
 static int s3c2410_nand_calculate_ecc(struct mtd_info *mtd,
 				      const u_char *dat, u_char *ecc_code)
 {
@@ -420,18 +391,37 @@ static int s3c2410_nand_calculate_ecc(st
 }
 
 
-/* over-ride the standard functions for a little more speed? */
+static int s3c2440_nand_calculate_ecc(struct mtd_info *mtd,
+				      const u_char *dat, u_char *ecc_code)
+{
+	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	unsigned long ecc = readl(info->regs + S3C2440_NFMECC0);
+
+	ecc_code[0] = ecc;
+	ecc_code[1] = ecc >> 8;
+	ecc_code[2] = ecc >> 16;
+
+	pr_debug("calculate_ecc: returning ecc %02x,%02x,%02x\n",
+		 ecc_code[0], ecc_code[1], ecc_code[2]);
+
+	return 0;
+}
+
+
+/* over-ride the standard functions for a little more speed. We can
+ * use read/write block to move the data buffers to/from the controller
+*/
 
 static void s3c2410_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 {
-	struct nand_chip *this = (struct nand_chip *)mtd->priv;
+	struct nand_chip *this = mtd->priv;
 	readsb(this->IO_ADDR_R, buf, len);
 }
 
 static void s3c2410_nand_write_buf(struct mtd_info *mtd,
 				   const u_char *buf, int len)
 {
-	struct nand_chip *this = (struct nand_chip *)mtd->priv;
+	struct nand_chip *this = mtd->priv;
 	writesb(this->IO_ADDR_W, buf, len);
 }
 
@@ -523,11 +513,10 @@ static void s3c2410_nand_init_chip(struc
 {
 	struct nand_chip *chip = &nmtd->chip;
 
-	chip->IO_ADDR_R	   = (char *)info->regs + S3C2410_NFDATA;
-	chip->IO_ADDR_W    = (char *)info->regs + S3C2410_NFDATA;
+	chip->IO_ADDR_R	   = info->regs + S3C2410_NFDATA;
+	chip->IO_ADDR_W    = info->regs + S3C2410_NFDATA;
 	chip->hwcontrol    = s3c2410_nand_hwcontrol;
 	chip->dev_ready    = s3c2410_nand_devready;
-	chip->cmdfunc      = s3c2410_nand_command;
 	chip->write_buf    = s3c2410_nand_write_buf;
 	chip->read_buf     = s3c2410_nand_read_buf;
 	chip->select_chip  = s3c2410_nand_select_chip;
@@ -536,6 +525,12 @@ static void s3c2410_nand_init_chip(struc
 	chip->options	   = 0;
 	chip->controller   = &info->controller;
 
+	if (info->is_s3c2440) {
+		chip->IO_ADDR_R	 = info->regs + S3C2440_NFDATA;
+		chip->IO_ADDR_W  = info->regs + S3C2440_NFDATA;
+		chip->hwcontrol  = s3c2440_nand_hwcontrol;
+	}
+
 	nmtd->info	   = info;
 	nmtd->mtd.priv	   = chip;
 	nmtd->set	   = set;
@@ -546,6 +541,11 @@ static void s3c2410_nand_init_chip(struc
 		chip->calculate_ecc = s3c2410_nand_calculate_ecc;
 		chip->eccmode	    = NAND_ECC_HW3_512;
 		chip->autooob       = &nand_hw_eccoob;
+
+		if (info->is_s3c2440) {
+			chip->enable_hwecc  = s3c2440_nand_enable_hwecc;
+			chip->calculate_ecc = s3c2440_nand_calculate_ecc;
+		}
 	} else {
 		chip->eccmode	    = NAND_ECC_SOFT;
 	}
@@ -559,7 +559,7 @@ static void s3c2410_nand_init_chip(struc
  * nand layer to look for devices
 */
 
-static int s3c2410_nand_probe(struct device *dev)
+static int s3c24xx_nand_probe(struct device *dev, int is_s3c2440)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct s3c2410_platform_nand *plat = to_nand_plat(dev);
@@ -585,6 +585,7 @@ static int s3c2410_nand_probe(struct dev
 	dev_set_drvdata(dev, info);
 
 	spin_lock_init(&info->controller.lock);
+	init_waitqueue_head(&info->controller.wq);
 
 	/* get the clock source and enable it */
 
@@ -600,7 +601,8 @@ static int s3c2410_nand_probe(struct dev
 
 	/* allocate and map the resource */
 
-	res = pdev->resource;  /* assume that the flash has one resource */
+	/* currently we assume we have the one resource */
+	res  = pdev->resource;
 	size = res->end - res->start + 1;
 
 	info->area = request_mem_region(res->start, size, pdev->name);
@@ -611,9 +613,10 @@ static int s3c2410_nand_probe(struct dev
 		goto exit_error;
 	}
 
-	info->device = dev;
-	info->platform = plat;
-	info->regs = ioremap(res->start, size);
+	info->device     = dev;
+	info->platform   = plat;
+	info->regs       = ioremap(res->start, size);
+	info->is_s3c2440 = is_s3c2440;
 
 	if (info->regs == NULL) {
 		printk(KERN_ERR PFX "cannot reserve register region\n");
@@ -678,6 +681,18 @@ static int s3c2410_nand_probe(struct dev
 	return err;
 }
 
+/* driver device registration */
+
+static int s3c2410_nand_probe(struct device *dev)
+{
+	return s3c24xx_nand_probe(dev, 0);
+}
+
+static int s3c2440_nand_probe(struct device *dev)
+{
+	return s3c24xx_nand_probe(dev, 1);
+}
+
 static struct device_driver s3c2410_nand_driver = {
 	.name		= "s3c2410-nand",
 	.bus		= &platform_bus_type,
@@ -685,14 +700,24 @@ static struct device_driver s3c2410_nand
 	.remove		= s3c2410_nand_remove,
 };
 
+static struct device_driver s3c2440_nand_driver = {
+	.name		= "s3c2440-nand",
+	.bus		= &platform_bus_type,
+	.probe		= s3c2440_nand_probe,
+	.remove		= s3c2410_nand_remove,
+};
+
 static int __init s3c2410_nand_init(void)
 {
-	printk("S3C2410 NAND Driver, (c) 2004 Simtec Electronics\n");
+	printk("S3C24XX NAND Driver, (c) 2004 Simtec Electronics\n");
+
+	driver_register(&s3c2440_nand_driver);
 	return driver_register(&s3c2410_nand_driver);
 }
 
 static void __exit s3c2410_nand_exit(void)
 {
+	driver_unregister(&s3c2440_nand_driver);
 	driver_unregister(&s3c2410_nand_driver);
 }
 
@@ -701,4 +726,4 @@ module_exit(s3c2410_nand_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
-MODULE_DESCRIPTION("S3C2410 MTD NAND driver");
+MODULE_DESCRIPTION("S3C24XX MTD NAND driver");
Index: linux-2.6.10/drivers/mtd/nand/sharpsl.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/sharpsl.c
+++ linux-2.6.10/drivers/mtd/nand/sharpsl.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Richard Purdie
  *
- *  $Id: sharpsl.c,v 1.2 2004/11/24 20:38:07 rpurdie Exp $
+ *  $Id: sharpsl.c,v 1.3 2005/01/03 14:53:50 rpurdie Exp $
  *
  *  Based on Sharp's NAND driver sharp_sl.c
  *
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 
 static void __iomem *sharpsl_io_base;
 static int sharpsl_phys_base = 0x0C000000;
@@ -56,43 +57,22 @@ static struct mtd_info *sharpsl_mtd = NU
  */
 #define DEFAULT_NUM_PARTITIONS 3
 
-#if defined CONFIG_MACH_POODLE
-#define SHARPSL_ROOTFS_SIZE 22
-#define SHARPSL_FLASH_SIZE 64
-#elif defined CONFIG_MACH_CORGI 
-#define SHARPSL_ROOTFS_SIZE 25
-#define SHARPSL_FLASH_SIZE 32
-#elif defined CONFIG_MACH_SHEPHERD
-#define SHARPSL_ROOTFS_SIZE 25
-#define SHARPSL_FLASH_SIZE 64
-#elif defined CONFIG_MACH_HUSKY
-#define SHARPSL_ROOTFS_SIZE 53
-#define SHARPSL_FLASH_SIZE 128
-#elif defined CONFIG_MACH_TOSA
-#define SHARPSL_ROOTFS_SIZE 28
-#define SHARPSL_FLASH_SIZE 64
-#else
-#define SHARPSL_ROOTFS_SIZE 30
-#define SHARPSL_FLASH_SIZE 64
-#endif
-
 static int nr_partitions;
 static struct mtd_partition sharpsl_nand_default_partition_info[] = {
 	{
-	.name = "NAND flash partition 0",
+	.name = "System Area",
 	.offset = 0,
 	.size = 7 * 1024 * 1024,
 	},
-	
 	{
-	.name = "NAND flash partition 1",
+	.name = "Root Filesystem",
 	.offset = 7 * 1024 * 1024,
-	.size = SHARPSL_ROOTFS_SIZE * 1024 * 1024,
+	.size = 30 * 1024 * 1024,
 	},
 	{
-	.name = "NAND flash partition 2",
-	.offset = (SHARPSL_ROOTFS_SIZE+7) * 1024 * 1024,
-	.size = (SHARPSL_FLASH_SIZE - SHARPSL_ROOTFS_SIZE - 7) * 1024 * 1024,
+	.name = "Home Filesystem",
+	.offset = MTDPART_OFS_APPEND ,
+	.size = MTDPART_SIZ_FULL ,
 	},
 };
 
@@ -235,12 +215,19 @@ sharpsl_nand_init(void)
 	if (nr_partitions <= 0) {
 		nr_partitions = DEFAULT_NUM_PARTITIONS;
 		sharpsl_partition_info = sharpsl_nand_default_partition_info;
+		if (machine_is_poodle()) {
+			sharpsl_partition_info[1].size=30 * 1024 * 1024;
+		} else if (machine_is_corgi() || machine_is_shepherd()) {
+			sharpsl_partition_info[1].size=25 * 1024 * 1024;
+		} else if (machine_is_husky()) {
+			sharpsl_partition_info[1].size=53 * 1024 * 1024;
+		} 		
 	}
 
-#ifdef CONFIG_MACH_HUSKY
-	/* Need to use small eraseblock size for backward compatibility */
-	sharpsl_mtd->flags |= MTD_NO_VIRTBLOCKS;
-#endif
+	if (machine_is_husky()) {
+		/* Need to use small eraseblock size for backward compatibility */
+		sharpsl_mtd->flags |= MTD_NO_VIRTBLOCKS;
+	}
 
 	add_mtd_partitions(sharpsl_mtd, sharpsl_partition_info, nr_partitions);
 
Index: linux-2.6.10/drivers/mtd/nand/spia.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/spia.c
+++ linux-2.6.10/drivers/mtd/nand/spia.c
@@ -8,7 +8,7 @@
  *			to controllines	(due to change in nand.c)
  *			page_cache added
  *
- * $Id: spia.c,v 1.24 2004/11/04 12:53:10 gleixner Exp $
+ * $Id: spia.c,v 1.23 2004/10/05 13:50:20 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/drivers/mtd/nand/toto.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/toto.c
+++ linux-2.6.10/drivers/mtd/nand/toto.c
@@ -15,7 +15,7 @@
  *   This is a device driver for the NAND flash device found on the
  *   TI fido board. It supports 32MiB and 64MiB cards
  *
- * $Id: toto.c,v 1.4 2004/10/05 13:50:20 gleixner Exp $
+ * $Id: toto.c,v 1.3 2004/09/16 23:27:15 gleixner Exp $
  */
 
 #include <linux/slab.h>
Index: linux-2.6.10/drivers/mtd/nand/tx4925ndfmc.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/tx4925ndfmc.c
+++ linux-2.6.10/drivers/mtd/nand/tx4925ndfmc.c
@@ -11,7 +11,7 @@
  * Derived from drivers/mtd/autcpu12.c
  *       Copyright (c) 2001 Thomas Gleixner (gleixner@autronix.de)
  *
- * $Id: tx4925ndfmc.c,v 1.5 2004/10/05 13:50:20 gleixner Exp $
+ * $Id: tx4925ndfmc.c,v 1.4 2004/09/16 23:27:15 gleixner Exp $
  *
  * Copyright (C) 2001 Toshiba Corporation 
  * 
Index: linux-2.6.10/drivers/mtd/nand/tx4938ndfmc.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/tx4938ndfmc.c
+++ linux-2.6.10/drivers/mtd/nand/tx4938ndfmc.c
@@ -10,7 +10,7 @@
  *
  * Based on spia.c by Steven J. Hill
  *
- * $Id: tx4938ndfmc.c,v 1.4 2004/10/05 13:50:20 gleixner Exp $
+ * $Id: tx4938ndfmc.c,v 1.3 2004/09/16 23:27:15 gleixner Exp $
  *
  * Copyright (C) 2000-2001 Toshiba Corporation 
  *
Index: linux-2.6.10/drivers/mtd/nftlcore.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nftlcore.c
+++ linux-2.6.10/drivers/mtd/nftlcore.c
@@ -1,7 +1,7 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id: nftlcore.c,v 1.97 2004/11/16 18:28:59 dwmw2 Exp $ */
+/* $Id: nftlcore.c,v 1.96 2004/06/28 13:52:55 dbrown Exp $ */
 
 /*
   The contents of this file are distributed under the GNU General
@@ -749,7 +749,7 @@ extern char nftlmountrev[];
 
 static int __init init_nftl(void)
 {
-	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.97 $, nftlmount.c %s\n", nftlmountrev);
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.96 $, nftlmount.c %s\n", nftlmountrev);
 
 	return register_mtd_blktrans(&nftl_tr);
 }
Index: linux-2.6.10/drivers/mtd/nftlmount.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nftlmount.c
+++ linux-2.6.10/drivers/mtd/nftlmount.c
@@ -4,7 +4,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: nftlmount.c,v 1.40 2004/11/22 14:38:29 kalev Exp $
+ * $Id: nftlmount.c,v 1.39 2004/11/05 22:51:41 kalev Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,7 +31,7 @@
 
 #define SECTORSIZE 512
 
-char nftlmountrev[]="$Revision: 1.40 $";
+char nftlmountrev[]="$Revision: 1.39 $";
 
 /* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the
  *	various device information of the NFTL partition and Bad Unit Table. Update
Index: linux-2.6.10/drivers/mtd/redboot.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/redboot.c
+++ linux-2.6.10/drivers/mtd/redboot.c
@@ -1,5 +1,5 @@
 /*
- * $Id: redboot.c,v 1.17 2004/11/22 11:33:56 ijc Exp $
+ * $Id: redboot.c,v 1.16 2004/11/22 11:32:13 ijc Exp $
  *
  * Parse RedBoot-style Flash Image System (FIS) tables and
  * produce a Linux partition array to match.
Index: linux-2.6.10/drivers/mtd/rfd_ftl.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/rfd_ftl.c
@@ -0,0 +1,809 @@
+/*
+ * rfd_ftl.c -- resident flash disk (flash translation layer)
+ *
+ * Copyright (C) 2005  Sean Young <sean@mess.org>
+ *
+ * $Id: rfd_ftl.c,v 1.2 2005/06/23 14:50:11 sean Exp $
+ *
+ * This type of flash translation layer (FTL) is used by the Embedded BIOS
+ * by General Software. It is known as the Resident Flash Disk (RFD), see:
+ *
+ *	http://www.gensw.com/pages/prod/bios/rfd.htm
+ *
+ * based on ftl.c
+ */
+
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/mtd/blktrans.h>
+#include <linux/mtd/mtd.h>
+#include <linux/vmalloc.h>
+
+#include <asm/types.h>
+
+static int block_size = 0;
+module_param(block_size, int, 0);
+MODULE_PARM_DESC(block_size, "Block size to use by RFD, defaults to erase unit size");
+
+#define PREFIX "rfd_ftl: "
+
+/* Major device # for FTL device */
+
+/* A request for this major has been sent to device@lanana.org */
+#ifndef RFD_FTL_MAJOR
+#define RFD_FTL_MAJOR		95
+#endif
+
+/* Maximum number of partitions in an FTL region */
+#define PART_BITS		4
+
+/* An erase unit should start with this value */
+#define RFD_MAGIC		0x9193
+
+/* the second value is 0xffff or 0xffc8; function unknown */
+
+/* the third value is always 0xffff, ignored */
+
+/* next is an array of mapping for each corresponding sector */
+#define HEADER_MAP_OFFSET	3
+#define SECTOR_DELETED		0x0000
+#define SECTOR_ZERO		0xfffe
+#define SECTOR_FREE		0xffff
+
+#define SECTOR_SIZE		512
+
+struct block {
+	enum {
+		BLOCK_OK,
+		BLOCK_ERASING,
+		BLOCK_ERASED,
+		BLOCK_FAILED
+	} state;
+	int free_sectors;
+	int used_sectors;
+	int erases;
+	u_long offset;
+};
+
+struct partition {
+	struct mtd_blktrans_dev mbd;
+
+	u_int block_size;		/* size of erase unit */
+	u_int total_blocks;		/* number of erase units */
+	u_int header_sectors_per_block;	/* header sectors in erase unit */
+	u_int data_sectors_per_block;	/* data sectors in erase unit */
+	u_int sector_count;		/* sectors in translated disk */
+	u_int header_size;		/* bytes in header sector */
+	int reserved_block;		/* block next up for reclaim */
+	int current_block;		/* block to write to */
+	u16 *header_cache;		/* cached header */
+
+	int is_reclaiming;
+	u_long *sector_map;
+	struct block *blocks;
+};
+
+static int rfd_ftl_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf);
+
+static int build_block_map(struct partition *part, int block_no)
+{
+	struct block *block = &part->blocks[block_no];
+	int i;
+	
+	block->offset = part->block_size * block_no;
+
+	if (le16_to_cpu(part->header_cache[0]) != RFD_MAGIC) {
+		block->state = BLOCK_ERASED; /* assumption */
+		block->free_sectors = part->data_sectors_per_block;
+		part->reserved_block = block_no;
+		return 1;
+	}
+
+	block->state = BLOCK_OK;
+
+	for (i=0; i<part->data_sectors_per_block; i++) {
+		u16 entry;
+		
+		entry = le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i]);
+
+		if (entry == SECTOR_DELETED)
+			continue;
+	
+		if (entry == SECTOR_FREE) {
+			block->free_sectors++;
+			continue;
+		}
+
+		if (entry == SECTOR_ZERO)
+			entry = 0;
+	
+		if (entry >= part->sector_count) {
+			printk(KERN_NOTICE PREFIX 
+				"'%s': unit #%d: entry %d corrupt, "
+				"sector %d out of range\n",
+				part->mbd.mtd->name, block_no, i, entry);
+			continue;
+		}
+
+		if (part->sector_map[entry] != -1) {
+			printk(KERN_NOTICE PREFIX 
+				"'%s': more than one entry for sector %d\n",
+				part->mbd.mtd->name, entry);
+			continue;
+		}
+
+		part->sector_map[entry] = block->offset + 
+			(i + part->header_sectors_per_block) * SECTOR_SIZE;
+
+		block->used_sectors++;
+	}
+
+	if (block->free_sectors == part->data_sectors_per_block)
+		part->reserved_block = block_no;
+
+	return 0;
+}
+
+static int scan_header(struct partition *part)
+{
+	int sectors_per_block;
+	int i, rc = -ENOMEM;
+	int blocks_found;
+	size_t retlen;
+
+	sectors_per_block = part->block_size / SECTOR_SIZE;
+	part->total_blocks = part->mbd.mtd->size / part->block_size;
+
+	if (part->total_blocks < 2)
+		return -ENOENT;
+
+	/* each erase block has three bytes header, followed by the map */
+	part->header_sectors_per_block = 
+		((HEADER_MAP_OFFSET + sectors_per_block) * 
+		 sizeof(u16) + SECTOR_SIZE - 1) / SECTOR_SIZE;
+	part->data_sectors_per_block = sectors_per_block - 
+				part->header_sectors_per_block;
+
+	part->header_size = (HEADER_MAP_OFFSET + 
+				part->data_sectors_per_block) * sizeof(u16);
+	part->sector_count = part->data_sectors_per_block * 
+				(part->total_blocks - 1);
+	part->current_block = -1;
+	part->reserved_block = -1;
+	part->is_reclaiming = 0;
+
+	part->header_cache = kmalloc(part->header_size, GFP_KERNEL);
+	if (!part->header_cache)
+		goto err;
+
+	part->blocks = kcalloc(part->total_blocks, sizeof(struct block), 
+			GFP_KERNEL);
+	if (!part->blocks)
+		goto err;
+
+	part->sector_map = vmalloc(part->sector_count * sizeof(u_long));
+	if (!part->sector_map) {
+		printk(KERN_ERR PREFIX "'%s': unable to allocate memory for "
+			"sector map", part->mbd.mtd->name);
+		goto err;
+	}
+
+	for (i=0; i<part->sector_count; i++) 
+		part->sector_map[i] = -1;
+
+	for (i=0, blocks_found= 0; i<part->total_blocks; i++) {
+		rc = part->mbd.mtd->read(part->mbd.mtd, 
+				i * part->block_size, part->header_size,
+				&retlen, (u_char*)part->header_cache);
+
+		if (!rc && retlen != part->header_size)
+			rc = -EIO;
+
+		if (rc) 
+			goto err;
+
+		if (!build_block_map(part, i))
+			blocks_found++;
+	}
+
+	if (blocks_found == 0) {
+		printk(KERN_NOTICE PREFIX "no RFD magic found in '%s'.\n",
+				part->mbd.mtd->name);
+		rc = -ENOENT;
+		goto err;
+	}
+	
+	return 0;
+
+err:
+	vfree(part->sector_map);
+	kfree(part->header_cache);
+	kfree(part->blocks);
+
+	return rc;
+}
+
+static int rfd_ftl_readsect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)
+{
+	struct partition *part= (struct partition*)dev;
+	u_long addr;
+	size_t retlen;
+	int rc;
+	
+	if (sector >= part->sector_count)
+		return -EIO;
+
+	addr = part->sector_map[sector];
+	if (addr != -1) {
+		rc = part->mbd.mtd->read(part->mbd.mtd, addr, SECTOR_SIZE,
+						&retlen, (u_char*)buf);
+		if (!rc && retlen != SECTOR_SIZE)
+			rc = -EIO;
+
+		if (rc) {
+			printk(KERN_WARNING PREFIX "error reading '%s' at "
+				"0x%lx\n", part->mbd.mtd->name, addr);
+			return rc;
+		}
+	} else
+		memset(buf, 0, SECTOR_SIZE);
+	
+	return 0;
+} 
+
+static void erase_callback(struct erase_info *erase)
+{
+	struct partition *part;
+	int i;
+
+	part = (struct partition*)erase->priv;
+
+	i = erase->addr / part->block_size;
+	if (i >= part->total_blocks || part->blocks[i].offset != erase->addr) {
+		printk(KERN_ERR PREFIX "internal error: erase callback "
+				"for unknown offset %x on '%s'\n", 
+				erase->addr, part->mbd.mtd->name);
+		return;
+	}
+
+	if (erase->state == MTD_ERASE_DONE) {
+		part->blocks[i].state = BLOCK_ERASED;
+		part->blocks[i].free_sectors = part->data_sectors_per_block;
+		part->blocks[i].used_sectors = 0;
+		part->blocks[i].erases++;
+	} else {
+		printk(KERN_WARNING PREFIX "erase failed at 0x%x on '%s', "
+				"state %d\n", erase->addr, 
+				part->mbd.mtd->name, erase->state);
+
+		part->blocks[i].state = BLOCK_FAILED;
+		part->blocks[i].free_sectors = 0;
+		part->blocks[i].used_sectors = 0;
+	}
+
+	kfree(erase);
+}
+
+static int erase_block(struct partition *part, int block)
+{
+	struct erase_info *erase;
+	int rc = -ENOMEM;
+
+	erase = kmalloc(sizeof(struct erase_info), GFP_KERNEL);
+	if (!erase)
+		goto err;
+
+	erase->mtd = part->mbd.mtd;
+	erase->callback = erase_callback;
+	erase->addr = part->blocks[block].offset;
+	erase->len = part->block_size;
+	erase->priv = (u_long)part;
+
+	part->blocks[block].state = BLOCK_ERASING;
+	part->blocks[block].free_sectors = 0;
+
+	rc = part->mbd.mtd->erase(part->mbd.mtd, erase);
+
+	if (rc) {
+		printk(KERN_WARNING PREFIX "erase of region %x,%x on '%s' "
+				"failed\n", erase->addr, erase->len,
+				part->mbd.mtd->name);
+		kfree(erase);
+	}
+
+err:
+	return rc;
+}
+
+static int move_block_contents(struct partition *part, int block_no, u_long *old_sector)
+{
+	void *sector_data;
+	u16 *map;
+	size_t retlen;
+	int i, rc = -ENOMEM;
+
+	part->is_reclaiming = 1;
+
+	sector_data = kmalloc(SECTOR_SIZE, GFP_KERNEL);
+	if (!sector_data)
+		goto err3;
+
+	map = kmalloc(part->header_size, GFP_KERNEL);
+	if (!map)
+		goto err2;
+	
+	rc = part->mbd.mtd->read(part->mbd.mtd, 
+		part->blocks[block_no].offset, part->header_size, 
+		&retlen, (u_char*)map);
+	
+	if (!rc && retlen != part->header_size)
+		rc = -EIO;
+
+	if (rc) {
+		printk(KERN_NOTICE PREFIX "error reading '%s' at "
+			"0x%lx\n", part->mbd.mtd->name, 
+			part->blocks[block_no].offset);
+
+		goto err;
+	}
+
+	for (i=0; i<part->data_sectors_per_block; i++) {
+		u16 entry = le16_to_cpu(map[HEADER_MAP_OFFSET + i]);
+		u_long addr;
+
+
+		if (entry == SECTOR_FREE || entry == SECTOR_DELETED)
+			continue;
+
+		if (entry == SECTOR_ZERO) 
+			entry = 0;
+
+		/* already warned about and ignored in build_block_map() */
+		if (entry >= part->sector_count) 
+			continue;
+
+		addr = part->blocks[block_no].offset +
+			(i + part->header_sectors_per_block) * SECTOR_SIZE;
+
+		if (*old_sector == addr) {
+			*old_sector = -1;
+			if (!part->blocks[block_no].used_sectors--) {
+				rc = erase_block(part, block_no);
+				break;
+			}
+			continue;
+		}
+		rc = part->mbd.mtd->read(part->mbd.mtd, addr,
+			SECTOR_SIZE, &retlen, sector_data);
+	
+		if (!rc && retlen != SECTOR_SIZE)
+			rc = -EIO;
+
+		if (rc) {
+			printk(KERN_NOTICE PREFIX "'%s': Unable to "
+				"read sector for relocation\n",
+				part->mbd.mtd->name);
+
+			goto err;
+		}
+		
+		rc = rfd_ftl_writesect((struct mtd_blktrans_dev*)part,
+				entry, sector_data);
+		
+		if (rc) 
+			goto err;
+	}
+
+err:
+	kfree(map);
+err2:
+	kfree(sector_data);
+err3:
+	part->is_reclaiming = 0;
+
+	return rc;
+}
+
+static int reclaim_block (struct partition *part, u_long *old_sector) 
+{
+	int block, best_block, score, old_sector_block;
+	int rc;
+	
+	/* we have a race if sync doesn't exist */
+	if (part->mbd.mtd->sync)
+		part->mbd.mtd->sync(part->mbd.mtd);
+
+	score = 0x7fffffff; /* MAX_INT */
+	best_block = -1;
+	if (*old_sector != -1)
+		old_sector_block = *old_sector / part->block_size;
+	else
+		old_sector_block = -1;
+
+	for (block=0; block<part->total_blocks; block++) {
+		int this_score;
+
+		if (block == part->reserved_block)
+			continue;
+
+		/*
+		 * Postpone reclaiming if there is a free sector as
+		 * more removed sectors is more efficient (have to move
+		 * less).
+		 */
+		if (part->blocks[block].free_sectors) 
+			return 0;
+
+		this_score = part->blocks[block].used_sectors;
+
+		if (block == old_sector_block) 
+			this_score--;
+		else {
+			/* no point in moving a full block */
+			if (part->blocks[block].used_sectors == 
+					part->data_sectors_per_block)
+				continue;
+		}
+
+		this_score += part->blocks[block].erases;
+
+		if (this_score < score) {
+			best_block = block;
+			score = this_score;
+		}
+	}
+
+	if (best_block == -1)
+		return -ENOSPC;
+
+	part->current_block = -1;
+	part->reserved_block = best_block;
+
+	pr_debug("reclaim_block: reclaiming block #%d with %d used "
+		 "%d free sectors\n", best_block,
+		 part->blocks[best_block].used_sectors,
+		 part->blocks[best_block].free_sectors);
+
+	if (part->blocks[best_block].used_sectors)
+		rc = move_block_contents(part, best_block, old_sector);
+	else
+		rc = erase_block(part, best_block);
+
+	return rc;
+}
+
+static int find_free_block (struct partition *part)
+{
+	int block, stop;
+
+	block = part->current_block == -1 ?
+			jiffies % part->total_blocks : part->current_block;
+	stop = block;
+
+	do {
+		if (part->blocks[block].free_sectors && 
+				block != part->reserved_block)
+			return block;
+
+		if (++block >= part->total_blocks)
+			block = 0;
+
+	} while (block != stop);
+
+	return -1;
+}
+
+static int find_writeable_block (struct partition *part, u_long *old_sector)
+{
+	int rc, block;
+	size_t retlen;
+
+	block = find_free_block(part);
+
+	if (block == -1) {
+		if (!part->is_reclaiming) {
+			rc = reclaim_block(part, old_sector);
+			if (rc)
+				goto err;
+
+			block = find_free_block(part);
+		}
+
+		if (block == -1) {
+			rc = -ENOSPC;
+			goto err;
+		}
+	}
+
+	if (part->blocks[block].state == BLOCK_ERASED) {
+		u16 magic = cpu_to_le16(RFD_MAGIC);
+
+		rc = part->mbd.mtd->write(part->mbd.mtd, 
+			part->blocks[block].offset, sizeof(magic), &retlen, 
+			(u_char*)&magic);
+		
+		if (!rc && retlen != sizeof(magic))
+			rc = -EIO;
+
+		if (rc) {
+			printk(KERN_NOTICE PREFIX "'%s': unable to write RFD "
+					"header at 0x%lx\n",
+					part->mbd.mtd->name, 
+					part->blocks[block].offset);
+			goto err;
+		}
+		part->blocks[block].state = BLOCK_OK;
+	}
+
+	rc = part->mbd.mtd->read(part->mbd.mtd, 
+		part->blocks[block].offset, part->header_size,
+				&retlen, (u_char*)part->header_cache);
+
+	if (!rc && retlen != part->header_size)
+		rc = -EIO;
+
+	if (rc) {
+		printk(KERN_NOTICE PREFIX "'%s': unable to read header at "
+				"0x%lx\n", part->mbd.mtd->name, 
+				part->blocks[block].offset);
+		goto err;
+	}
+
+	part->current_block = block;
+
+err:
+	return rc;
+}	
+
+static int mark_sector_removed(struct partition *part, u_long old_addr)
+{
+	int block, offset, rc;
+	u_long addr;
+	size_t retlen;
+	u16 del = cpu_to_le16(SECTOR_DELETED);
+
+	block = old_addr / part->block_size;
+	offset = (old_addr % part->block_size) / SECTOR_SIZE - 
+		part->header_sectors_per_block;
+
+	addr = part->blocks[block].offset +
+			(HEADER_MAP_OFFSET + offset) * sizeof(u16);
+	rc = part->mbd.mtd->write(part->mbd.mtd, addr,
+		sizeof(del), &retlen, (u_char*)&del);
+
+	if (!rc && retlen != sizeof(del))
+		rc = -EIO;
+
+	if (rc) {
+		printk(KERN_WARNING PREFIX "error writing '%s' at "
+			"0x%lx\n", part->mbd.mtd->name, addr);
+		if (rc) 
+			goto err;
+	}
+	if (block == part->current_block)
+		part->header_cache[offset + HEADER_MAP_OFFSET] = del;
+
+	part->blocks[block].used_sectors--;
+
+	if (!part->blocks[block].used_sectors &&
+	    !part->blocks[block].free_sectors)
+		rc = erase_block(part, block);
+
+err:
+	return rc;
+}
+
+static int do_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf, ulong *old_addr)
+{
+	struct partition *part= (struct partition*)dev;
+	u_long addr;
+	int i;
+	int rc;
+	size_t retlen;
+	u16 entry;
+
+	if (part->current_block == -1 ||
+		!part->blocks[part->current_block].free_sectors) {
+
+		rc = find_writeable_block(part, old_addr);
+		if (rc) 
+			goto err;
+	}
+
+	for (i=0; i<part->data_sectors_per_block; i++) {
+		if (le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i]) 
+				== SECTOR_FREE)
+			break;
+	}
+	BUG_ON(part->data_sectors_per_block == i);
+
+	addr = (i + part->header_sectors_per_block) * SECTOR_SIZE + 
+		part->blocks[part->current_block].offset;
+	rc = part->mbd.mtd->write(part->mbd.mtd, 
+		addr, SECTOR_SIZE, &retlen, (u_char*)buf);
+
+	if (!rc && retlen != SECTOR_SIZE)
+		rc = -EIO;
+
+	if (rc) {
+		printk(KERN_WARNING PREFIX "error writing '%s' at 0x%lx\n",
+				part->mbd.mtd->name, addr);
+		if (rc) 
+			goto err;
+	}
+
+	part->sector_map[sector] = addr;
+
+	entry = cpu_to_le16(sector == 0 ? SECTOR_ZERO : sector);
+
+	part->header_cache[i + HEADER_MAP_OFFSET] = entry;
+
+	addr = part->blocks[part->current_block].offset +
+			(HEADER_MAP_OFFSET + i) * sizeof(u16);
+	rc = part->mbd.mtd->write(part->mbd.mtd, addr,
+			sizeof(entry), &retlen, (u_char*)&entry);
+
+	if (!rc && retlen != sizeof(entry))
+		rc = -EIO;
+
+	if (rc) {
+		printk(KERN_WARNING PREFIX "error writing '%s' at 0x%lx\n",
+				part->mbd.mtd->name, addr);
+		if (rc) 
+			goto err;
+	}
+	part->blocks[part->current_block].used_sectors++;
+	part->blocks[part->current_block].free_sectors--;
+
+err:
+	return rc;
+}
+
+static int rfd_ftl_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)
+{
+	struct partition *part= (struct partition*)dev;
+	u_long old_addr;
+	int i;
+	int rc = 0;
+
+	pr_debug("rfd_ftl_writesect(sector=0x%lx)\n", sector);
+
+	if (part->reserved_block == -1) {
+		rc = -EACCES;
+		goto err;
+	}
+
+	if (sector >= part->sector_count) {
+		rc = -EIO;
+		goto err;
+	}
+
+	old_addr = part->sector_map[sector];
+
+	for (i=0; i<SECTOR_SIZE; i++) {
+		if (!buf[i])
+			continue;
+
+		rc = do_writesect(dev, sector, buf, &old_addr);
+		if (rc)
+			goto err;
+		break;
+	}
+
+	if (i == SECTOR_SIZE) 
+		part->sector_map[sector] = -1;
+
+	if (old_addr != -1)
+		rc = mark_sector_removed(part, old_addr);
+
+err:
+	return rc;
+}
+
+static int rfd_ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)
+{
+	struct partition *part = (struct partition*)dev;
+
+	geo->heads = 1;
+	geo->sectors = part->data_sectors_per_block;
+	geo->cylinders = part->total_blocks - 1;
+
+	return 0;
+}
+
+static void rfd_ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
+{
+	struct partition *part;
+
+	if(mtd->type != MTD_NORFLASH)
+		return;
+
+	part = kcalloc(1, sizeof(struct partition), GFP_KERNEL);
+	if (!part)
+		return;
+
+	part->mbd.mtd = mtd;
+
+	if (block_size)
+		part->block_size = block_size;
+	else {
+		if (!mtd->erasesize) {
+			printk(KERN_NOTICE PREFIX "please provide block_size");
+			return;
+		}
+		else
+			part->block_size = mtd->erasesize;
+	}
+
+	if (scan_header(part) == 0) {
+		part->mbd.size = part->sector_count;
+		part->mbd.blksize = SECTOR_SIZE;
+		part->mbd.tr = tr;
+		part->mbd.devnum = -1;
+		if (!(mtd->flags & MTD_WRITEABLE))
+			part->mbd.readonly = 1;
+		else if (part->reserved_block == -1) {
+			printk(KERN_NOTICE PREFIX "'%s': no empty erase unit "
+				"found, setting read-only\n",
+				part->mbd.mtd->name);
+	
+			part->mbd.readonly = 1;
+		}
+
+		printk(KERN_INFO PREFIX "name: '%s' type: %d flags %x\n",
+				mtd->name, mtd->type, mtd->flags);
+
+		if (!add_mtd_blktrans_dev((void*)part))
+			return;
+	} 
+
+	kfree(part);
+}
+
+static void rfd_ftl_remove_dev(struct mtd_blktrans_dev *dev)
+{
+	struct partition *part = (struct partition*)dev;
+	int i;
+
+	for (i=0; i<part->total_blocks; i++) {
+		pr_debug("rfd_ftl_remove_dev:'%s': erase unit #%02d: %d erases\n",
+			part->mbd.mtd->name, i, part->blocks[i].erases);
+	}
+
+	del_mtd_blktrans_dev(dev);
+	vfree(part->sector_map);
+	kfree(part->header_cache);
+	kfree(part->blocks);
+	kfree(part);
+}
+
+struct mtd_blktrans_ops rfd_ftl_tr = {
+	.name		= "rfd",
+	.major		= RFD_FTL_MAJOR,
+	.part_bits	= PART_BITS,
+	.readsect	= rfd_ftl_readsect,
+	.writesect	= rfd_ftl_writesect, 
+	.getgeo		= rfd_ftl_getgeo,
+	.add_mtd	= rfd_ftl_add_mtd,
+	.remove_dev	= rfd_ftl_remove_dev,
+	.owner		= THIS_MODULE,
+};
+
+static int __init init_rfd_ftl(void)
+{
+	return register_mtd_blktrans(&rfd_ftl_tr);
+}
+
+static void __exit cleanup_rfd_ftl(void)
+{
+	deregister_mtd_blktrans(&rfd_ftl_tr);
+}
+
+module_init(init_rfd_ftl);
+module_exit(cleanup_rfd_ftl);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sean Young <sean@mess.org>");
+MODULE_DESCRIPTION("Support code for RFD Flash Translation Layer, "
+		"used by General Software's Embedded BIOS");
+
Index: linux-2.6.10/drivers/mtd/ssfdc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/ssfdc.c
@@ -0,0 +1,1132 @@
+/*
+ *  drivers/mtd/ssfdc.c
+ *
+ *  Copyright (C) 2003 Simon Haynes (simon@baydel.con)
+ *                     Baydel Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * version 2.1 as published by the Free Software Foundation.
+ *
+ * This module provides a translation layer, via mtd, for smart
+ * media card access. It essentially enables the possibility 
+ * of using cards on a hardware which does not have a hardware translation
+ * layer and interchanging them with hardware that does ie: PC card readers
+ *
+ * I had to write this module for a specific task and in a short timeframe
+ * for this reason I have imposed some restricions to make the job easier.
+ *
+ * To build an compile the driver I added the following lines
+ * to mtd/Config.in
+ *
+ *  dep_tristate '  SSFDC support' CONFIG_SSFDC $CONFIG_MTD
+ *
+ * to /mtd/Makefile
+ *
+ * obj-$(CONFIG_SSFDC)             += ssfdc.o
+ *
+ * and compiled the kernel via the usual methods.
+ *
+ * I am sure that there are many problems I don't know about but here are
+ * some that I know of
+ *
+ * Currently the driver uses MAJOR number 44 which I think is FTL or NFTL
+ * I did this because I wanted a static number and I didn't know
+ * how to go about getting a new one. This needs addressing
+ * The dev nodes required are like standard. I only use minor 0
+ * (/dev/ssfdca), and minor 1 (/dev/ssfdca1).
+ * You should be able to run fdisk on /dev/ssfdca and the first partition
+ * is /dev/ssfdca1. There is no working code in the module for changing the
+ * SMC and rebuilding the maps so the card should not be changed once the
+ * module is loaded. At present I only look for 1 partition. But this is a
+ * small commented hack.
+ *
+ * There is no support cards which do not have a 512 byte page size with 16
+ * bytes of oob and an erase size of 16K.
+ * There are no checks for this at present. In addition the MTD reported size
+ * must be 16M or a multiple.
+ *
+ * Code to handle multiple partitions or multiple cards is incomplete
+ * Need to allocate data buffer and oob buffer on a per partition basis.
+ * As I am only concerned with one partition I will do this if I ever need to.
+ * The cached physical address variable also needs this attention.
+ *
+ * Recently I have started to work on media changes. Some of this is specific
+ * to my hardware and you will see references to pt_ssfdc_smc and smc_status.
+ * This code is incomplete and does not work. I have commented it for the moment
+ * but it should give an indication of what I think is required. Maybe there is
+ * something it mtd that can help
+ *
+ * 17th August 2004 MHB
+ *
+ * Following updating CVS I noticed some single bit data corruption. I believe
+ * that this was down to the fact that I was using mtd->read instead of mtd->read_ecc
+ * and that mtd->read was applying it's own error corretion from the wrong ecc bytes
+ * I have now corrected this.
+ *
+ * During this time I noticed that while in allocate new I only seem to look for blocks
+ * in 1 zone. So this limits the partition size to 16MB with all the other SMC size
+ * restrictions
+
+
+*/
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/blktrans.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/ioctl.h>
+#include <linux/hdreg.h>
+#include <linux/list.h>
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
+
+#if (LINUX_VERSION_CODE >= 0x20100)
+#include <linux/vmalloc.h>
+#endif
+#if (LINUX_VERSION_CODE >= 0x20303)
+#include <linux/blkpg.h>
+#endif
+
+#include <asm/semaphore.h>
+
+#define SSFDC_FORMAT 1
+
+#define PDEBUG(fmt, args...)
+
+#define BLK_INC_USE_COUNT MOD_INC_USE_COUNT
+#define BLK_DEC_USE_COUNT MOD_DEC_USE_COUNT
+
+#if (LINUX_VERSION_CODE < 0x20320)
+#define BLK_DEFAULT_QUEUE(n)    blk_dev[n].request_fn
+#define blk_init_queue(q, req)  q = (req)
+#define blk_cleanup_queue(q)    q = NULL
+#define request_arg_t           void
+#else
+#define request_arg_t           request_queue_t *q
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+#define SSFDC_MAJOR	44
+
+#define MAJOR_NR		SSFDC_MAJOR
+#define DEVICE_NAME		"ssfdc"
+#define DEVICE_REQUEST		do_ssfdc_request
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+
+#include <linux/blk.h>
+
+#include "/home/simon/ebony/dbwhatu/dbwhatu/smccontrol.h"
+
+
+
+#define ZONE_SIZE 		(16 * 1024 * 1024)
+#define SMC_BLOCK_SIZE 		(16 * 1024)
+#define SECTOR_SIZE 		512
+#define SECTORS_PER_ZONE  	(ZONE_SIZE / SECTOR_SIZE)
+#define BLOCKS_PER_ZONE	    	(ZONE_SIZE / SMC_BLOCK_SIZE)
+#define SECTORS_PER_BLOCK	(SMC_BLOCK_SIZE / SECTOR_SIZE)
+#define OOB_SIZE		16
+
+
+#define MAX_DEVICES 	4
+#define MAX_PARTITIONS 	8
+#define PARTITION_BITS 	3
+#define MAX_ZONES 	8
+
+
+int ssfdc_major = SSFDC_MAJOR;
+unsigned int ssfdc_cached = 0xFFFFFFFF;
+static unsigned char ssfdc_scratch[16384];
+static unsigned char ssfdc_buffer[16];
+static unsigned char ssfdc_ffoob_buf[OOB_SIZE * SECTORS_PER_BLOCK];
+static unsigned char ssfdc_oob_buf[OOB_SIZE * SECTORS_PER_BLOCK];
+
+
+static struct nand_oobinfo ssfdc_ffoob_info = {
+	.useecc = 0,
+};
+
+
+typedef struct minor_t {
+	atomic_t open;
+	int cached;
+	unsigned char * pt_data;
+	unsigned char * pt_oob;
+} minor_t;
+
+
+
+typedef struct partition_t {
+	int type;
+    	struct mtd_info	*mtd;
+    	int count;
+	unsigned int *zone;
+	unsigned int zoneCount;
+	minor_t minor[MAX_PARTITIONS];
+	unsigned int last_written[MAX_ZONES];
+} partition_t;
+
+partition_t SMCParts[MAX_DEVICES];
+
+
+static unsigned char ssfdc_ecc[] = {14, 13, 15, 9, 8, 10};
+
+static struct hd_struct ssfdc_hd[MAX_DEVICES * MAX_PARTITIONS];
+static int ssfdc_sizes[MAX_DEVICES * MAX_PARTITIONS];
+static int ssfdc_blocksizes[MAX_DEVICES * MAX_PARTITIONS];
+smc_control * pt_ssfdc_smc;
+
+
+static struct gendisk ssfdc_gendisk = {
+    major:		SSFDC_MAJOR,
+    major_name:		"ssfdc",
+    minor_shift:	PARTITION_BITS,
+    max_p:		MAX_PARTITIONS,
+    part:		ssfdc_hd,
+    sizes:		ssfdc_sizes,
+};
+
+
+static int	ssfdc_ioctl(struct inode *inode, struct file *file, u_int cmd, u_long arg);
+static int 	ssfdc_open(struct inode *inode, struct file *file);
+static int 	ssfdc_close(struct inode *inode, struct file *file);
+static int 	ssfdc_write(partition_t *part, caddr_t buffer, u_long sector, u_long nblocks);
+static int 	ssfdc_read(partition_t *part, caddr_t buffer, u_long sector, u_long nblocks);
+static int 	ssfdc_physical(partition_t * pt_smcpart, int zone, int block);
+static int 	ssfdc_erase(partition_t *pt_smcpart, unsigned int offset);
+static int 	ssfdc_read_partitions(partition_t * pt_smcpart);
+static void 	ssfdc_notify_add(struct mtd_info *mtd);
+static void 	ssfdc_notify_remove(struct mtd_info *mtd);
+static void 	ssfdc_tables(partition_t * pt_smcpart);
+static int 	ssfdc_sector_blank(partition_t * pt_smcpart, int sc);
+static int  	ssfdc_allocate_new(partition_t * pt_smcpart, int zone);
+int 		ssfdc_parity(int number);
+static void 	ssfdc_erase_callback(struct erase_info *erase);
+
+
+
+static DECLARE_WAIT_QUEUE_HEAD(ssfdc_wq);
+
+
+static struct mtd_notifier ssfdc_notifier = {
+	add:		ssfdc_notify_add,
+	remove:		ssfdc_notify_remove,
+};
+
+
+
+static struct block_device_operations ssfdc_fops = {
+    open:	ssfdc_open,
+    release:	ssfdc_close,
+    ioctl:	ssfdc_ioctl,
+};
+                                               
+static struct semaphore ssfdc_semaphore;
+
+static void ssfdc_notify_add(struct mtd_info *mtd) {
+
+
+
+	
+	if(mtd->index >= 1) return;   // Hack to limit SSFDC to 1 partition
+
+	if( ((mtd->size % ZONE_SIZE) != 0) && (mtd->size < (ZONE_SIZE * MAX_ZONES)) ){
+		PDEBUG("ssfdc_notify_add : mtd partition %d is not modulus 16M, not SSFDC\n", mtd->index);	
+	}
+	else {
+		memset((void *)&SMCParts[mtd->index].type, 0, sizeof(partition_t));	
+		SMCParts[mtd->index].mtd = mtd;
+		SMCParts[mtd->index].count = mtd->index;
+		SMCParts[mtd->index].type = 1;
+		SMCParts[mtd->index].zoneCount = mtd->size / ZONE_SIZE;
+		SMCParts[mtd->index].zone = kmalloc(SMCParts[mtd->index].zoneCount * 8192, GFP_KERNEL);
+		
+
+		if(!SMCParts[mtd->index].zone) {
+			printk(KERN_NOTICE "ssfdc_notify_add : mtd partition %d, failed to allocate mapping table\n", mtd->index);
+			SMCParts[mtd->index].type = 0;
+		}
+		else {
+			memset((void *)SMCParts[mtd->index].zone, 0xFF, SMCParts[mtd->index].zoneCount * 8192);
+		}
+	
+		ssfdc_read_partitions((partition_t *)&SMCParts[mtd->index].type);
+	}
+	return;
+
+}
+static int ssfdc_read_partitions(partition_t * pt_smcpart) {
+
+	int whole, i, j, size;
+
+//=printk("ssfdc_read_partitions : start\n");
+
+	for(i=0; i<MAX_PARTITIONS; i++)
+	   	if ((atomic_read(&pt_smcpart->minor[i].open) > 1)) {
+//=printk("ssfdc_read_partitions : part %d busy\n", i);
+
+    		return -EBUSY;
+   		}
+
+
+//=printk("ssfdc_read_partitions : tables start\n");
+	ssfdc_tables(pt_smcpart);
+//=printk("ssfdc_read_partitions : tables end\n");
+
+   	whole = pt_smcpart->count << PARTITION_BITS;         		
+
+
+   	j = MAX_PARTITIONS - 1;
+   	while (j-- > 0) {
+		if (ssfdc_hd[whole+j].nr_sects > 0) {
+    			kdev_t rdev = MKDEV(SSFDC_MAJOR, whole+j);
+    			invalidate_device(rdev, 1);
+		}
+		ssfdc_hd[whole+j].start_sect = 0;
+		ssfdc_hd[whole+j].nr_sects = 0;
+   	}
+
+
+	size = (((pt_smcpart->mtd->size / 16384) * 1000) / 1024) * 32;
+	size /= (0x8 * 0x20);
+	size = size * (0x8 * 0x20);
+
+//=printk("ssfdc_read_partitions : register start\n");
+
+    register_disk(&ssfdc_gendisk, whole >> PARTITION_BITS, MAX_PARTITIONS,
+		  &ssfdc_fops, size);
+
+//=printk("ssfdc_read_partitions : register end\n");
+
+
+    	return 0;
+}
+
+
+static void ssfdc_notify_remove(struct mtd_info *mtd) {
+int i, j, whole;
+
+	i=mtd->index;
+	whole = i << PARTITION_BITS;
+   	if(SMCParts[i].mtd == mtd) {
+       		if(SMCParts[i].zone)kfree(SMCParts[i].zone);
+		memset((void *)&SMCParts[i].type, 0, sizeof(partition_t));
+    		for (j = 0; j < MAX_PARTITIONS; j++) {
+			if (ssfdc_hd[whole+j].nr_sects > 0) {
+		   		ssfdc_hd[whole+j].start_sect = 0;
+	   			ssfdc_hd[whole+j].nr_sects=0;
+			}
+    		}
+		return;
+	}
+	return;
+}
+
+
+
+static int ssfdc_ioctl(struct inode *inode, struct file *file,
+		u_int cmd, u_long arg) {
+
+    int minor = MINOR(inode->i_rdev);
+    int ret = -EINVAL;
+    partition_t * pt_smcpart = (partition_t *)&SMCParts[(minor & ~(MAX_PARTITIONS -1)) >> PARTITION_BITS].type;
+    struct hd_geometry geo;
+    int size;
+/*
+	unsigned char smc_status;
+
+  	smc_status = in_8((void *)&pt_ssfdc_smc->smc_status);
+  	if(!(smc_status & SMC_PRESENT)) {
+		printk("ssfdc : media not present\n");
+		ret = 1;
+		goto ssfdc_ioctl_error;
+	}
+
+  	if(smc_status & SMC_CHANGED) {
+   		out_8((void *)&pt_ssfdc_smc->smc_status, smc_status);
+		if(minor & ((1<< PARTITION_BITS) - 1)) return -ENOTTY;
+			ssfdc_read_partitions(pt_smcpart);
+		printk("ssfdc : media change\n");
+  	}
+*/
+	switch(cmd) {
+
+	    case HDIO_GETGEO:
+		   	memset(&geo, 0, sizeof(geo));
+			size = (((pt_smcpart->mtd->size / 16384) * 1000) / 1024) * 32;
+			size /= (0x8 * 0x20);
+			geo.heads = 0x8;
+			geo.sectors = 0x20;
+			geo.cylinders = size;
+			geo.start = ssfdc_hd[minor].start_sect;
+//			printk(KERN_WARNING "ssfdc : HDIO_GETGEO heads %d, sectors %d, cylinders %d, start %lu\n",
+//				geo.heads, geo.sectors, geo.cylinders, geo.start);
+			copy_to_user((void *)arg, &geo, sizeof(geo));
+			ret = 0;
+		break;
+
+	    case BLKGETSIZE64:
+   	 	case BLKGETSIZE:
+			size = (((pt_smcpart->mtd->size / 16384) * 1000) / 1024) * 32;
+			//=printk(KERN_WARNING "ssfdc : BLKGETSIZE %d, minor %d\n", size, minor);
+			ret = copy_to_user((unsigned long *)arg, &size, sizeof(size));
+		break;
+		case BLKSSZGET:
+			size = 512;
+			ret = copy_to_user((unsigned long *)arg, &size, sizeof(size));
+		break;
+		break;
+
+    	case BLKRRPART:
+				if(minor & ((1<< PARTITION_BITS) - 1)) return -ENOTTY;
+				ssfdc_read_partitions(pt_smcpart);
+				ret=0;
+		break;
+   		case BLKFLSBUF:
+			printk(KERN_WARNING "ssfdc : block ioctl 0x%x\n", cmd);
+		break;
+
+   		default:
+			printk(KERN_WARNING "ssfdc: unknown ioctl 0x%x\n", cmd);
+    }
+
+//ssfdc_ioctl_error:
+    return(ret);
+
+}
+static int ssfdc_open(struct inode *inode, struct file *file)
+{
+    int minor = MINOR(inode->i_rdev);
+    partition_t *pt_smcpart;
+	int index;
+
+    if (minor >= MAX_MTD_DEVICES)
+	return -ENODEV;
+
+    index = (minor & ~(MAX_PARTITIONS -1)) >> PARTITION_BITS;
+
+
+    if(SMCParts[index].type != SSFDC_FORMAT)
+	return -ENXIO;
+
+	pt_smcpart = &SMCParts[index];
+
+
+	if(!pt_smcpart->zone)
+	return -ENXIO;
+ 
+
+    BLK_INC_USE_COUNT;
+
+    if (!get_mtd_device(pt_smcpart->mtd, -1)) {
+	    BLK_DEC_USE_COUNT;
+	    return -ENXIO;
+    }
+
+    if ((file->f_mode & 2) && !(pt_smcpart->mtd->flags & MTD_CLEAR_BITS) ) {
+	    put_mtd_device(pt_smcpart->mtd);
+	    BLK_DEC_USE_COUNT;
+            return -EROFS;
+    }
+
+
+    atomic_inc(&pt_smcpart->minor[minor & ~(MAX_PARTITIONS -1)].open);
+
+	PDEBUG("ssfdc_open : device %d\n", minor);
+
+	return(0);
+}
+
+static void ssfdc_tables(partition_t * pt_smcpart) {
+
+	int * logical, * physical;
+	int offset = 0;
+	int zone, block;
+	int i, retlen;
+	int block_address, parity;
+	int h, l;
+
+	for(zone=0; zone<pt_smcpart->zoneCount; zone++) {	
+		logical  =  pt_smcpart->zone + (2048 * zone);
+		memset((void *)logical, 0xFF, 1024 * sizeof(int));
+		physical =  pt_smcpart->zone + (2048 * zone) + 1024;
+		memset((void *)physical, 0xFF, 1024 * sizeof(int));
+
+		for(block=0; block < 1024; block++) {
+			offset = (zone * ZONE_SIZE) + (block * SMC_BLOCK_SIZE);
+	    		pt_smcpart->mtd->read_oob(pt_smcpart->mtd, offset, sizeof(ssfdc_buffer), &retlen, ssfdc_buffer);
+			if(retlen != sizeof(ssfdc_buffer)) {
+				printk(KERN_WARNING "ssfdc_tables : failed to read OOB\n");
+				pt_smcpart->type = 0;
+				return;
+			}
+
+			l = (ssfdc_buffer[7] & 0xFF);
+			h = (ssfdc_buffer[6] & 0xFF);
+            		block_address = l + (h << 8L);
+
+			if((block_address & ~0x7FF) != 0x1000) {
+					continue;
+			}
+
+			parity = block_address & 0x01;
+			
+			block_address &= 0x7FF;
+			block_address >>= 1;
+
+
+			if(ssfdc_parity(block_address) != parity) {
+ 				printk(KERN_WARNING "ssfdc_tables : parity error offset 0x%x, block 0x%x, parity 0x%x\nOOB : "
+						, offset, block_address, parity);
+			    	for(i=0; i<16; i++) {
+                 			printk("0x%02x ", (unsigned char)ssfdc_buffer[i]);
+			    	}
+				printk("\n");
+				pt_smcpart->type = 0;
+				return;          		
+			}
+
+
+            		/* Ok we have a valid block number so insert it */
+            		*(logical + block_address) = (offset/SMC_BLOCK_SIZE);
+			PDEBUG("ssfdc_tables : logical 0x%x + 0x%x = 0x%x\n", 
+					(unsigned int)logical, block_address, (offset/SMC_BLOCK_SIZE));
+			*(physical + block) = block_address;
+			PDEBUG("ssfdc_tables : physical 0x%x + 0x%x = 0x%x\n", (unsigned int)physical, block, block_address);
+			
+
+    		}
+    	}
+    	return;
+}
+int ssfdc_parity(int number) {
+ 	int i;
+	int parity = 1; // the 0x1000 bit
+
+	for(i=0; i<10; i++) {
+      		parity += ((number >> i) & 1);
+	}
+	PDEBUG("ssfdc_parity : number 0x%x, parity 0x%x\n", number, parity);
+	return(parity % 2);
+}
+static int ssfdc_physical(partition_t * pt_smcpart, int zone, int block) {
+
+	unsigned int * logical;
+
+	logical = pt_smcpart->zone + (zone * 2048);
+
+	logical += block;
+
+	if(*logical == 0xFFFFFFFF) {
+		PDEBUG("ssfdc_physical : physical for zone %d, block %d invalid\n", zone, block);
+		return(-1);
+	}
+
+	PDEBUG("ssfdc_physical : physical for zone %d, block %d, 0x%x\n", zone, block, (*logical * SMC_BLOCK_SIZE));
+	return(*logical * SMC_BLOCK_SIZE);
+}
+
+static int ssfdc_close(struct inode *inode, struct file *file)
+{                       
+    int minor = MINOR(inode->i_rdev);
+    partition_t *pt_smcpart;
+	int index = (minor & ~(MAX_PARTITIONS -1)) >> PARTITION_BITS;
+
+    if (minor >= MAX_MTD_DEVICES)
+	return -ENODEV;
+
+    if(SMCParts[index].type != SSFDC_FORMAT)
+	return -ENXIO;
+
+    pt_smcpart = &SMCParts[index];
+    atomic_dec(&pt_smcpart->minor[minor & ~(MAX_PARTITIONS -1)].open);
+    put_mtd_device(pt_smcpart->mtd);
+    BLK_DEC_USE_COUNT;
+
+    return(0);
+} 
+
+
+static void do_ssfdc_request(request_arg_t)
+{
+    int ret, minor;
+    partition_t *pt_smcpart;
+	int index;
+    do {
+
+	INIT_REQUEST;
+
+
+
+	minor = MINOR(CURRENT->rq_dev);
+	index = (minor & ~(MAX_PARTITIONS -1)) >> PARTITION_BITS;
+
+	pt_smcpart = &SMCParts[index];
+	if (pt_smcpart->type == SSFDC_FORMAT) {
+ 		ret = 0;
+		switch (CURRENT->cmd) {
+			case READ:
+	  			ret = ssfdc_read(pt_smcpart, CURRENT->buffer,
+					CURRENT->sector + ssfdc_hd[minor].start_sect,
+					CURRENT->current_nr_sectors);
+		    break;
+
+		  	case WRITE:
+		    	ret = ssfdc_write(pt_smcpart, CURRENT->buffer,
+				    CURRENT->sector	+ ssfdc_hd[minor].start_sect,
+				    CURRENT->current_nr_sectors);
+		    break;
+
+		  default:
+		    panic("do_ssfdc_request : unknown block command!\n");
+		  }
+	
+	} else {
+	  ret = 1;
+	  PDEBUG("not ssfdc partition type\n");
+	}
+
+	if (!ret) {
+	  CURRENT->sector += CURRENT->current_nr_sectors;
+	}
+
+	end_request((ret == 0) ? 1 : 0);
+    } while (1);
+}
+
+static int ssfdc_write(partition_t *pt_smcpart, caddr_t buffer,
+		     u_long sector, u_long nblocks)
+{
+	int zone, block, offset;
+	int sectors_written = 0;
+    	int physical;
+	int * pt_logical;
+	int * pt_physical;
+	int new = -1;
+	int size;
+	int retlen;
+	int i;
+	int sc;
+	int ptr_done = 0;
+	unsigned char * ptr = (unsigned char *)buffer;
+	unsigned char ecc_code[6], ecc_calc[6];
+	int do_erase;
+//	unsigned char smc_status;
+
+
+
+	offset = (sector % SECTORS_PER_ZONE) % SECTORS_PER_BLOCK ;
+
+    	PDEBUG("write device %d, sector %d, count %d\n",
+			pt_smcpart->count, sector, nblocks);
+/*
+  	smc_status = in_8((void *)&pt_ssfdc_smc->smc_status);
+	if(!(smc_status & SMC_PRESENT)) {
+		printk("ssfdc : media not present\n");
+		return -ENXIO;
+	}
+
+    if(smc_status & SMC_CHANGED) {
+   		out_8((void *)&pt_ssfdc_smc->smc_status, smc_status);
+		ssfdc_read_partitions(pt_smcpart);
+		printk("ssfdc : media change\n");
+	}
+*/
+	while(sectors_written < nblocks) {
+
+		new = -1;
+		do_erase = FALSE;
+    
+		zone = (sector + sectors_written) / SECTORS_PER_ZONE;
+		block = ((sector + sectors_written) % SECTORS_PER_ZONE) / SECTORS_PER_BLOCK ;
+		offset = ((sector + sectors_written) % SECTORS_PER_ZONE) % SECTORS_PER_BLOCK ;
+
+		pt_logical = pt_smcpart->zone + (zone * 2048);
+		pt_physical = pt_smcpart->zone + (zone * 2048) + 1024;
+
+		size = ((SECTORS_PER_BLOCK - offset) < (nblocks - sectors_written)) ?
+				(SECTORS_PER_BLOCK - offset) : (nblocks - sectors_written);
+		size *= SECTOR_SIZE;
+
+		PDEBUG("write device %d, sector %d, count %d, zone %d, block %d, offset %d, done %d, size %d, address 0x%x\n",
+				pt_smcpart->count, sector, nblocks, zone, block, offset, sectors_written, size, (unsigned int)ptr);
+
+		physical = ssfdc_physical(pt_smcpart, zone, block);
+
+
+		if(physical >= 0) {
+			if(ssfdc_cached != physical) {
+	   			pt_smcpart->mtd->read_ecc(pt_smcpart->mtd, physical, SMC_BLOCK_SIZE, &retlen, ssfdc_scratch,
+					 ssfdc_oob_buf, &ssfdc_ffoob_info);
+				if(retlen != SMC_BLOCK_SIZE) {
+					printk(KERN_WARNING "ssfdc_write : failed to read physical\n");
+					return -ENXIO;
+				}
+
+				for(sc=0; sc<SECTORS_PER_BLOCK; sc++) {
+	   				pt_smcpart->mtd->read_oob(pt_smcpart->mtd, physical + (sc * SECTOR_SIZE), sizeof(ssfdc_buffer), &retlen, ssfdc_buffer);
+					if(retlen != sizeof(ssfdc_buffer)) {
+						printk(KERN_WARNING "ssfdc_write : failed to read physical oob\n");
+						return -ENXIO;
+					}
+
+					nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_calc[0]);
+					nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_calc[3]);
+					for(i=0; i<6; i++) ecc_code[i] = ssfdc_buffer[ssfdc_ecc[i]];
+					nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_code[0], &ecc_calc[0]);
+					nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_code[3], &ecc_calc[3]);
+				}
+
+			}
+			
+			for(sc=0; sc<SECTORS_PER_BLOCK; sc++) {
+				if(offset > sc) {
+					PDEBUG("offset %d, sector %d\n", offset, sc);
+					continue;
+				}
+   				pt_smcpart->mtd->read_oob(pt_smcpart->mtd, physical + (sc * SECTOR_SIZE), sizeof(ssfdc_buffer), &retlen, ssfdc_buffer);
+				if(retlen != sizeof(ssfdc_buffer)) {
+					printk(KERN_WARNING "ssfdc_write : failed to read physical oob\n");
+					return -ENXIO;
+				}
+
+				nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_calc[0]);
+				nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_calc[3]);
+				for(i=0; i<6; i++) ecc_code[i] = ssfdc_buffer[ssfdc_ecc[i]];
+				nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_code[0], &ecc_calc[0]);
+				nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_code[3], &ecc_calc[3]);
+				
+				/* find out if the block is being used */
+
+
+				if(ssfdc_sector_blank(pt_smcpart, sc)) {
+					PDEBUG("ssfdc_write : zone %d, block %d, sector %d, lbn %d, blank, physical 0x%x\n",
+						zone, block, sc, sector, physical);
+					memcpy(&ssfdc_scratch[(sc * SECTOR_SIZE)], ptr+ptr_done, SECTOR_SIZE);
+					nand_calculate_ecc (pt_smcpart->mtd, (ptr + ptr_done), &ecc_calc[0]);
+					nand_calculate_ecc (pt_smcpart->mtd, (ptr + ptr_done + 256), &ecc_calc[3]);
+					for(i=0; i<6; i++) ssfdc_buffer[ssfdc_ecc[i]] = ecc_calc[i];
+					i = (block << 1) | 0x1000;
+					i |= ssfdc_parity(block);
+       				        ssfdc_buffer[7] = ssfdc_buffer[12] = i & 0xFF;
+                    			ssfdc_buffer[6] = ssfdc_buffer[11] = (i & 0xFF00) >> 0x08;
+
+                    pt_smcpart->mtd->write_ecc(pt_smcpart->mtd, physical + (sc * SECTOR_SIZE), SECTOR_SIZE, &retlen,
+								ptr + ptr_done, ssfdc_buffer, &ssfdc_ffoob_info);
+					if(retlen != SECTOR_SIZE) {
+						printk(KERN_WARNING "ssfdc_write : failed to write physical 0x%x, sector 0x%x, blank, retlen %d\n"
+								, physical, sc, retlen);
+						return -ENXIO;
+					}
+
+                    ptr_done += SECTOR_SIZE;
+					if(ptr_done >= size) break;
+				}
+				else {
+					new = ssfdc_allocate_new(pt_smcpart, zone);
+					/* erase the old block */
+		            *(pt_physical + ((physical % ZONE_SIZE) / SMC_BLOCK_SIZE)) = 0xFFFFFFFF;
+
+					PDEBUG("ssfdc_write : physical 0x%x + 0x%x = 0x%x\n",
+						(unsigned int)pt_physical, ((physical % ZONE_SIZE) / SMC_BLOCK_SIZE), 0xFFFFFFFF);
+					do_erase = TRUE;
+					PDEBUG("ssfdc_write : zone %d, block %d, sector %d, lbn %d, written, physical 0x%x, new 0x%x\n",
+						zone, block, sc, sector, physical, new);
+					break;
+				}
+			}
+		}
+		else {
+			ssfdc_cached = 0xFFFFFFFF;
+			memset(ssfdc_scratch, 0xFF, sizeof(ssfdc_scratch));
+			new = ssfdc_allocate_new(pt_smcpart, zone);
+			PDEBUG("ssfdc_write : zone %d, block %d, lbn %d, physical 0x%x, unallocated, new 0x%x\n",
+				zone, block, sector, physical, new);
+		}
+
+
+
+		if(new != -1) {
+
+
+			memcpy(&ssfdc_scratch[(offset * SECTOR_SIZE)], ptr, size);
+			PDEBUG("ssfdc_write : new 0x%x, offset 0x%x, size 0x%x, block 0x%x\n", new, offset, size, block);
+       		for(sc=0; sc<SECTORS_PER_BLOCK; sc++) {
+				memset(ssfdc_buffer, 0xFF, OOB_SIZE);
+				nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_calc[0]);
+				nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_calc[3]);
+				for(i=0; i<6; i++) ssfdc_buffer[ssfdc_ecc[i]] = ecc_calc[i];
+				i = (block << 1) | 0x1000;
+				i |= ssfdc_parity(block);
+                		ssfdc_buffer[7] = ssfdc_buffer[12] = i & 0xFF;
+                		ssfdc_buffer[6] = ssfdc_buffer[11] = (i & 0xFF00) >> 0x08;
+                memcpy(&ssfdc_oob_buf[sc * OOB_SIZE], ssfdc_buffer, OOB_SIZE);
+			}
+
+
+	   		pt_smcpart->mtd->write_ecc(pt_smcpart->mtd, new, SMC_BLOCK_SIZE, &retlen, ssfdc_scratch,
+                        ssfdc_oob_buf, &ssfdc_ffoob_info);
+			if(retlen != SMC_BLOCK_SIZE) {
+				printk(KERN_WARNING "ssfdc_write : failed to write block, physical 0x%x, returned 0x%x\n", new, retlen);
+				return -ENXIO;
+			}
+			/* change the mapping table to reflect the new block placement */
+
+			*(pt_logical + block) = (new % ZONE_SIZE) / SMC_BLOCK_SIZE;
+			PDEBUG("ssfdc_write : logical 0x%x + 0x%x = 0x%x\n",
+						(unsigned int)pt_logical, block, (new % ZONE_SIZE) / SMC_BLOCK_SIZE);
+
+            		*(pt_physical + ((new % ZONE_SIZE) / SMC_BLOCK_SIZE)) = block;
+			PDEBUG("ssfdc_write : physical 0x%x + 0x%x = 0x%x\n",
+				(unsigned int)pt_physical, ((new % ZONE_SIZE) / SMC_BLOCK_SIZE), block);
+
+
+			ssfdc_cached = new;
+   	    }
+
+
+		ptr += size;
+		ptr_done = 0;
+		sectors_written += (size / SECTOR_SIZE);
+		if(do_erase) ssfdc_erase(pt_smcpart, physical);
+
+	}
+
+
+
+
+	return(0);
+}
+static int ssfdc_sector_blank(partition_t * pt_smcpart, int sc) {
+int b;
+
+	for(b=0; b<SECTOR_SIZE; b++) {
+		if(ssfdc_scratch[b + (sc * SECTOR_SIZE)] != 0xFF) return(0);
+	}
+	for(b=0; b<OOB_SIZE; b++) {
+		if((b==6) || (b==7) || (b==11) || (b==12)) continue;   // Block address fields
+		if(ssfdc_buffer[b] != 0xFF) return(0);
+	}
+    return(1);
+}
+static int ssfdc_allocate_new(partition_t * pt_smcpart, int zone) {
+
+	int new = pt_smcpart->last_written[zone] + 1;
+	int * pt_physical;
+	int physical;
+    	int block;
+	int retlen;
+	unsigned char oob[16];
+	
+
+	if(new >= BLOCKS_PER_ZONE) new = 0;
+
+
+	while (new != pt_smcpart->last_written[zone]) {
+       	block = new % BLOCKS_PER_ZONE;
+		pt_physical = pt_smcpart->zone + (zone * 2048) + 1024 + block;
+		physical = (zone * ZONE_SIZE) + (block * SMC_BLOCK_SIZE);
+
+	  	PDEBUG("ssfdc_allocate_new : zone %d, block %d, address 0x%08x, data 0x%08x\n",
+			zone, block, (unsigned int)pt_physical, *pt_physical);
+     		if(*pt_physical == 0xFFFFFFFF) {
+			PDEBUG("ssfdc_allocate_new : physical 0x%x = 0x%x\n", (unsigned int)pt_physical, *pt_physical);
+			memset(oob, 0, OOB_SIZE);
+			pt_smcpart->mtd->read_oob(pt_smcpart->mtd, physical, OOB_SIZE, &retlen, oob);
+			if((oob[5] == 0xFF) && (retlen == OOB_SIZE)) {   // If not a bad block
+				pt_smcpart->last_written[zone] = new;
+				return((new * SMC_BLOCK_SIZE) + (zone * ZONE_SIZE));
+			}
+			else {
+             			PDEBUG("ssfdc_allocate_new : new 0x%x, physical 0x%x, block status 0x%x, oob length 0x%x\n", new, physical, oob[5], retlen);
+			}
+		}
+		new++;
+		if(new >= BLOCKS_PER_ZONE) new = 0;
+	}
+
+   	panic("ssfdc_allocate_new : cant find free block\n");
+
+}
+	
+
+
+static int ssfdc_read(partition_t *pt_smcpart, caddr_t buffer,
+		    u_long sector, u_long nblocks)
+{
+	int zone, block, offset;
+	int sectors_read = 0;
+    int physical;
+	int size;
+	int retlen;
+	int i;
+	int sc;
+	unsigned char * ptr = (unsigned char *)buffer;
+	unsigned char ecc_code[6], ecc_calc[6];
+/*
+    unsigned char smc_status;
+
+  	smc_status = in_8((void *)&pt_ssfdc_smc->smc_status);
+	if(!(smc_status & SMC_PRESENT)) {
+		printk("ssfdc : media not present\n");
+		return -ENXIO;
+	}
+
+
+
+    if(smc_status & SMC_CHANGED) {
+   		out_8((void *)&pt_ssfdc_smc->smc_status, smc_status);
+		ssfdc_read_partitions(pt_smcpart);
+		printk("ssfdc : media change\n");
+	}
+*/
+	while(sectors_read < nblocks) {
+
+		zone = (sector + sectors_read) / SECTORS_PER_ZONE;
+		block = ((sector + sectors_read) % SECTORS_PER_ZONE) / SECTORS_PER_BLOCK ;
+		offset = ((sector + sectors_read) % SECTORS_PER_ZONE) % SECTORS_PER_BLOCK ;
+
+
+		if(offset) {
+			size = ((SECTORS_PER_BLOCK - offset) < (nblocks - sectors_read)) ?
+					(SECTORS_PER_BLOCK - offset) : (nblocks - sectors_read);
+		}
+		else {
+			size = (SECTORS_PER_BLOCK < (nblocks - sectors_read)) ? SECTORS_PER_BLOCK : nblocks - sectors_read;
+		}
+		size *= SECTOR_SIZE;
+
+	    PDEBUG("ssfdc_read :  device %d, sector %d, count %d, zone %d, block %d, offset %d, done %d, size %d, address 0x%x\n",
+			pt_smcpart->count, sector, nblocks, zone, block, offset, sectors_read, size, (unsigned int)ptr);
+
+			
+		physical = ssfdc_physical(pt_smcpart, zone, block);
+		if(physical >=  0) {
+			if(ssfdc_cached != physical) {
+           		pt_smcpart->mtd->read_ecc(pt_smcpart->mtd, physical, SMC_BLOCK_SIZE, &retlen, ssfdc_scratch,
+													 ssfdc_oob_buf, &ssfdc_ffoob_info);
+				if(retlen != SMC_BLOCK_SIZE) {
+					printk(KERN_WARNING "ssfdc_read : failed to read physical\n");
+					return -ENXIO;
+				}
+				for(sc=0; sc<SECTORS_PER_BLOCK; sc++) {
+	    			pt_smcpart->mtd->read_oob(pt_smcpart->mtd, physical + (sc * SECTOR_SIZE), sizeof(ssfdc_buffer), &retlen, ssfdc_buffer);
+					if(retlen != sizeof(ssfdc_buffer)) {
+						printk(KERN_WARNING "ssfdc_read : failed to read physical oob\n");
+						return -ENXIO;
+					}
+					nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_calc[0]);
+					nand_calculate_ecc (pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_calc[3]);
+					for(i=0; i<3; i++) ecc_code[i] = ssfdc_buffer[ssfdc_ecc[i]];
+					for(i=3; i<6; i++) ecc_code[i] = ssfdc_buffer[ssfdc_ecc[i]];
+					nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[sc * SECTOR_SIZE], &ecc_code[0], &ecc_calc[0]);
+					nand_correct_data(pt_smcpart->mtd, &ssfdc_scratch[(sc * SECTOR_SIZE) + 256], &ecc_code[3], &ecc_calc[3]);
+				}
+
+				/* Get the ecc bytes and check that they are ok */
+
+
+			}
+			ssfdc_cached = physical;
+			
+			
+		}
+		else {
+			memset(ssfdc_scratch, 0xFF, sizeof(ssfdc_scratch));
+			ssfdc_cached = 0xFFFFFFFF;
+		}
+			
+
+		memcpy(ptr, &ssfdc_scratch[(offset * SECTOR_SIZE)], size);
+		ptr += size;
+		sectors_read += (size / SECTOR_SIZE);	
+	}
+
+
+	                                                    
+	return(0);
+}
+
+static void ssfdc_erase_callback(struct erase_info *erase) {
+
+	PDEBUG("ssfdc_erase_callback : wake erase\n");
+    	up(&ssfdc_semaphore);
+	PDEBUG("ssfdc_erase_callback : woken erase\n");
+}
+
+static int ssfdc_erase(partition_t *pt_smcpart, unsigned int offset)
+{
+	int ret = 0;
+    	struct erase_info *erase;
+	unsigned char * junk;
+	unsigned char * oob;
+	int retlen;
+	int b, sc;
+
+
+	PDEBUG("ssfdc_erase : offset 0x%08x\n", offset);
+
+	erase=kmalloc(sizeof(struct erase_info), GFP_KERNEL);
+    	junk=kmalloc(pt_smcpart->mtd->erasesize + 16, GFP_KERNEL);
+    	oob = junk + pt_smcpart->mtd->erasesize;
+
+    	if (!erase)
+        	 return -ENOMEM;
+    	if (!junk)
+        	 return -ENOMEM;
+
+    	erase->addr = offset;
+    	erase->len = pt_smcpart->mtd->erasesize;
+	erase->callback = ssfdc_erase_callback;
+    	ret = pt_smcpart->mtd->erase(pt_smcpart->mtd, erase);
+	if(ret) {
+     		printk(KERN_WARNING "ssfdc_erase : failed status 0x%x\n", ret);
+		goto end;
+
+	}
+
+	down(&ssfdc_semaphore);
+
+	pt_smcpart->mtd->read_ecc(pt_smcpart->mtd, offset, SMC_BLOCK_SIZE, &retlen, junk,
+							 ssfdc_oob_buf, &ssfdc_ffoob_info);
+	if(retlen != SMC_BLOCK_SIZE) {
+           	printk(KERN_WARNING "ssfdc_erase : offset 0x%x, read returned length %d\n", offset, retlen);
+		goto end;
+	}
+
+
+	for(sc=0; sc < SECTORS_PER_BLOCK; sc++) {
+		for(b=0; b<SECTOR_SIZE; b++) {
+			if(*(junk + (b + (sc * SECTOR_SIZE))) != 0xFF) {
+             			printk(KERN_WARNING "ssfdc_erase : offset 0x%x, sector 0x%x, byte 0x%x, data 0x%02x, expected 0xff\n"
+						, offset, sc, b, *(junk + (b + (sc * SECTOR_SIZE))));
+				goto end;
+			}
+		}
+		pt_smcpart->mtd->read_oob(pt_smcpart->mtd, offset + (sc * SECTOR_SIZE), OOB_SIZE, &retlen, oob);
+		if(retlen != OOB_SIZE) {
+           		printk(KERN_WARNING "ssfdc_erase : offset 0x%x, read oob returned length %d\n", offset, retlen);
+			goto end;
+		}
+		for(b=0; b<OOB_SIZE; b++) {
+			if(*(oob+b) != 0xFF) {
+             			printk(KERN_WARNING "ssfdc_erase : offset 0x%x, byte 0x%x, oob got 0x%02x, expected 0xff\n", 
+						offset, b, *(oob+b));
+				goto end;
+			}
+		}
+	}
+
+end:
+	
+    kfree(erase);
+	kfree(junk);
+
+    return ret;
+} /* erase_xfer */
+
+
+
+
+
+int init_ssfdc(void)
+{
+	int result, i;
+
+//	unsigned char smc_status;
+//	#define B01159_FIO_PBASE 0x0000000148000000  /* Physical Base address of SMC control chip  */
+
+	printk(KERN_INFO "SSFDC block device translation layer V1.0\n");
+/*
+	pt_ssfdc_smc = ioremap64(B01159_FIO_PBASE, 1024);
+	if(!pt_ssfdc_smc){
+     	printk("ssfdc : failed to map SMC control device\n");
+        return(-EFAULT);
+	}
+	
+  	smc_status = in_8((void *)&pt_ssfdc_smc->smc_status);
+*/	
+    memset(ssfdc_ffoob_buf, 0xFF, sizeof(ssfdc_ffoob_buf));
+    
+	for (i = 0; i < MAX_DEVICES*MAX_PARTITIONS; i++) {
+		ssfdc_hd[i].nr_sects = 0;
+		ssfdc_hd[i].start_sect = 0;
+		ssfdc_blocksizes[i] = 4096;
+    	}
+   	blksize_size[SSFDC_MAJOR] = ssfdc_blocksizes;
+   	ssfdc_gendisk.major = SSFDC_MAJOR;
+
+
+	memset(ssfdc_scratch, 0xFF, sizeof(ssfdc_scratch));
+
+	result = register_blkdev(ssfdc_major, "ssfdc", &ssfdc_fops);
+	if(result != 0) {
+		printk(KERN_WARNING "ssfdc : failed to get a major number\n");
+		return(result);
+	}
+//	if(ssfdc_major == 0) ssfdc_major = result;
+	
+    	blk_init_queue(BLK_DEFAULT_QUEUE(ssfdc_major), &do_ssfdc_request);
+
+    	add_gendisk(&ssfdc_gendisk);
+
+
+
+    	register_mtd_user(&ssfdc_notifier);
+
+
+	init_MUTEX_LOCKED(&ssfdc_semaphore);
+
+
+
+    	return 0;
+}
+
+static void __exit cleanup_ssfdc(void)
+{
+	int i;
+
+	for(i=0; i<MAX_DEVICES; i++) {
+       		if(SMCParts[i].zone)kfree(SMCParts[i].zone);
+	}
+
+
+    	unregister_mtd_user(&ssfdc_notifier);
+    	unregister_blkdev(ssfdc_major, "ssfdc");
+    	blk_cleanup_queue(BLK_DEFAULT_QUEUE(ssfdc_major));
+
+
+
+    	blksize_size[SSFDC_MAJOR] = NULL;
+    	del_gendisk(&ssfdc_gendisk);
+
+}
+
+module_init(init_ssfdc);
+module_exit(cleanup_ssfdc);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Simon Haynes <simon@baydel.com>");
+MODULE_DESCRIPTION("SSFDC translation layer support for MTD");
+
+
+
+
Index: linux-2.6.10/include/linux/mtd/blktrans.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/blktrans.h
+++ linux-2.6.10/include/linux/mtd/blktrans.h
@@ -1,5 +1,5 @@
 /*
- * $Id: blktrans.h,v 1.5 2003/06/23 12:00:08 dwmw2 Exp $
+ * $Id: blktrans.h,v 1.4 2003/05/21 01:01:32 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
Index: linux-2.6.10/include/linux/mtd/cfi.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/cfi.h
+++ linux-2.6.10/include/linux/mtd/cfi.h
@@ -1,7 +1,7 @@
 
 /* Common Flash Interface structures 
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id: cfi.h,v 1.50 2004/11/20 12:46:51 dwmw2 Exp $
+ * $Id: cfi.h,v 1.52 2005/02/08 17:11:15 nico Exp $
  */
 
 #ifndef __MTD_CFI_H__
@@ -315,6 +315,69 @@ static inline map_word cfi_build_cmd(u_l
 }
 #define CMD(x)  cfi_build_cmd((x), map, cfi)
 
+
+static inline unsigned char cfi_merge_status(map_word val, struct map_info *map, 
+					   struct cfi_private *cfi)
+{
+	int wordwidth, words_per_bus, chip_mode, chips_per_word;
+	unsigned long onestat, res = 0;
+	int i;
+
+	/* We do it this way to give the compiler a fighting chance 
+	   of optimising away all the crap for 'bankwidth' larger than
+	   an unsigned long, in the common case where that support is
+	   disabled */
+	if (map_bankwidth_is_large(map)) {
+		wordwidth = sizeof(unsigned long);
+		words_per_bus = (map_bankwidth(map)) / wordwidth; // i.e. normally 1
+	} else {
+		wordwidth = map_bankwidth(map);
+		words_per_bus = 1;
+	}
+	
+	chip_mode = map_bankwidth(map) / cfi_interleave(cfi);
+	chips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);
+
+	onestat = val.x[0];
+	/* Or all status words together */
+	for (i=1; i < words_per_bus; i++) {
+		onestat |= val.x[i];
+	}
+
+	res = onestat;
+	switch(chips_per_word) {
+	default: BUG();
+#if BITS_PER_LONG >= 64
+	case 8:
+		res |= (onestat >> (chip_mode * 32));
+#endif
+	case 4:
+		res |= (onestat >> (chip_mode * 16));
+	case 2:
+		res |= (onestat >> (chip_mode * 8));
+	case 1:
+		;
+	}
+
+	/* Last, determine what the bit-pattern should be for a single
+	   device, according to chip mode and endianness... */
+	switch (chip_mode) {
+	case 1:
+		break;
+	case 2:
+		res = cfi16_to_cpu(res);
+		break;
+	case 4:
+		res = cfi32_to_cpu(res);
+		break;
+	default: BUG();
+	}
+	return res;
+}
+
+#define MERGESTATUS(x) cfi_merge_status((x), map, cfi)
+
+
 /*
  * Sends a CFI command to a bank of flash for the given geometry.
  *
Index: linux-2.6.10/include/linux/mtd/cfi_endian.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/cfi_endian.h
+++ linux-2.6.10/include/linux/mtd/cfi_endian.h
@@ -1,5 +1,5 @@
 /*
- * $Id: cfi_endian.h,v 1.11 2002/01/30 23:20:48 awozniak Exp $
+ * $Id: cfi_endian.h,v 1.10 2001/06/18 11:00:46 abz Exp $
  *
  */
 
Index: linux-2.6.10/include/linux/mtd/compatmac.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/compatmac.h
+++ linux-2.6.10/include/linux/mtd/compatmac.h
@@ -1,10 +1,249 @@
+/*
+ * $Id: compatmac.h,v 1.78 2005/07/05 14:14:18 gleixner Exp $
+ *
+ * Extensions and omissions from the normal 'linux/compatmac.h'
+ * files. hopefully this will end up empty as the 'real' one 
+ * becomes fully-featured.
+ */
 
 #ifndef __LINUX_MTD_COMPATMAC_H__
 #define __LINUX_MTD_COMPATMAC_H__
 
-/* Nothing to see here. We write 2.5-compatible code and this
-   file makes it all OK in older kernels, but it's empty in _current_
-   kernels. Include guard just to make GCC ignore it in future inclusions
-   anyway... */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+#error "This kernel is too old: not supported by this file"
+#endif
+
+	/* O(1) scheduler stuff. */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,5) && !defined(__rh_config_h__)
+#include <linux/sched.h>
+static inline void __recalc_sigpending(void)
+{
+	recalc_sigpending(current);
+}
+#undef recalc_sigpending
+#define recalc_sigpending() __recalc_sigpending ()
+
+#define set_user_nice(tsk, n) do { (tsk)->nice = n; } while(0)
+#endif
+
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20)
+
+#ifndef yield
+#define yield() do { set_current_state(TASK_RUNNING); schedule(); } while(0)
+#endif
+
+#ifndef minor
+#define major(d) (MAJOR(to_kdev_t(d)))
+#define minor(d) (MINOR(to_kdev_t(d)))
+#endif
+
+#ifndef mk_kdev
+#define mk_kdev(ma,mi) MKDEV(ma,mi)
+#define kdev_t_to_nr(x)	(x)
+#endif
+
+#define need_resched() (current->need_resched)
+#define cond_resched() do { if need_resched() { yield(); } } while(0)
+
+#endif /* < 2.4.20 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,73)
+#define iminor(i) minor((i)->i_rdev)
+#define imajor(i) major((i)->i_rdev)
+#define old_encode_dev(d) ( (major(d)<<8) | minor(d) )
+#define old_decode_dev(rdev)  (kdev_t_to_nr(mk_kdev((rdev)>>8, (rdev)&0xff)))
+#define old_valid_dev(d) (1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,61)
+
+#include <linux/sched.h>
+
+#ifdef __rh_config_h__
+#define sigmask_lock sighand->siglock
+#define sig sighand
+#endif
+
+static inline void __daemonize_modvers(void)
+{
+	daemonize();
+
+	spin_lock_irq(&current->sigmask_lock);
+	sigfillset(&current->blocked);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sigmask_lock);
+}
+#undef daemonize
+#define daemonize(fmt, ...) do {						\
+	snprintf(current->comm, sizeof(current->comm), fmt ,##__VA_ARGS__);	\
+	__daemonize_modvers();							\
+	} while(0)
+
+static inline int dequeue_signal_lock(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
+{
+	unsigned long flags;
+	unsigned long ret;
+
+	spin_lock_irqsave(&current->sigmask_lock, flags);
+	ret = dequeue_signal(mask, info);
+	spin_unlock_irqrestore(&current->sigmask_lock, flags);
+
+	return ret;
+}
+
+static inline int allow_signal(int sig)
+{
+	if (sig < 1 || sig > _NSIG)
+		return -EINVAL;
+
+        spin_lock_irq(&current->sigmask_lock);
+	sigdelset(&current->blocked, sig);
+	recalc_sigpending();
+	/* Make sure the kernel neither eats it now converts to SIGKILL */
+	current->sig->action[sig-1].sa.sa_handler = (void *)2;
+	spin_unlock_irq(&current->sigmask_lock);
+	return 0;
+}
+static inline int disallow_signal(int sig)
+{
+	if (sig < 1 || sig > _NSIG)
+		return -EINVAL;
+
+	spin_lock_irq(&current->sigmask_lock);
+	sigaddset(&current->blocked, sig);
+	recalc_sigpending();
+
+	current->sig->action[sig-1].sa.sa_handler = SIG_DFL;
+	spin_unlock_irq(&current->sigmask_lock);
+	return 0;
+}
+
+#define PF_FREEZE 0
+#define refrigerator(x) do { ; } while(0)
+#endif
+
+	/* Module bits */
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+#define try_module_get(m) try_inc_mod_count(m)
+#define __module_get(m) do { if (!try_inc_mod_count(m)) BUG(); } while(0)
+#define module_put(m) do { if (m) __MOD_DEC_USE_COUNT((struct module *)(m)); } while(0)
+#define set_module_owner(x) do { x->owner = THIS_MODULE; } while(0)
+#endif
+
+
+	/* Random filesystem stuff, only for JFFS2 really */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,5)
+#define parent_ino(d) ((d)->d_parent->d_inode->i_ino)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,12)
+#define PageUptodate(x) Page_Uptodate(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,48)
+#define get_seconds() CURRENT_TIME
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,53)
+#define generic_file_readonly_mmap generic_file_mmap
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,70)
+
+#include <linux/kmod.h>
+#include <linux/string.h>
+
+static inline char *strlcpy(char *dest, const char *src, int len)
+{
+	dest[len-1] = 0;
+	return strncpy(dest, src, len-1);
+}
+
+static inline int do_old_request_module(const char *mod)
+{
+	return request_module(mod);
+}
+#undef request_module
+#define request_module(fmt, ...) \
+ ({ char modname[32]; snprintf(modname, 31, fmt ,##__VA_ARGS__); do_old_request_module(modname); })
+
+#endif /* 2.5.70 */
+
+#ifndef container_of
+#define container_of(ptr, type, member) ({		     \
+	const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+#define kvec iovec
+#define __user 
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,28)
+#define msleep(x) \
+	set_current_state(TASK_UNINTERRUPTIBLE); \
+	schedule_timeout((x)*(HZ/1000));
+#endif
+
+#ifndef __iomem
+#define __iomem
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+#define CURRENT_TIME_SEC ((struct timespec) { xtime.tv_sec, 0 })
+#include <linux/sched.h>
+#include <linux/suspend.h>
+static inline int try_to_freeze(unsigned long refrigerator_flags)
+{
+	if (unlikely(current->flags & PF_FREEZE)) {
+	        refrigerator(refrigerator_flags);
+	        return 1;
+	} else
+	        return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+#define try_to_freeze() try_to_freeze(0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+typedef struct class_simple class;
+#define class_device_create(cs, dev, device, fmt, ...) class_simple_device_add((struct class_simple *)cs, dev, device, fmt, __VA_ARGS__)
+#define class_device_destroy(cs, dev) class_simple_device_remove(dev)
+#define class_create(owner, name) (struct class *)class_simple_create(owner, name)
+#define class_destroy(cs) class_simple_destroy((struct class_simple *)cs)
+#endif
+
+#ifndef list_for_each_entry_safe
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop counter.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+#endif
+
+#ifndef DEFINE_SPINLOCK
+#define DEFINE_SPINLOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+#ifndef DEFINE_RWLOCK
+#define DEFINE_RWLOCK(x) rwlock_t x = RW_LOCK_UNLOCKED
+#endif
 
 #endif /* __LINUX_MTD_COMPATMAC_H__ */
Index: linux-2.6.10/include/linux/mtd/concat.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/concat.h
+++ linux-2.6.10/include/linux/mtd/concat.h
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: concat.h,v 1.1 2002/03/08 16:34:36 rkaiser Exp $
+ * $Id$
  */
 
 #ifndef MTD_CONCAT_H
Index: linux-2.6.10/include/linux/mtd/doc2000.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/doc2000.h
+++ linux-2.6.10/include/linux/mtd/doc2000.h
@@ -89,8 +89,8 @@
 #define WriteDOC_(d, adr, reg)  do{ *(volatile __u16 *)(((unsigned long)adr)+((reg)<<1)) = (__u16)d; wmb();} while(0)
 #define DOC_IOREMAP_LEN 0x4000
 #else
-#define ReadDOC_(adr, reg)      readb((void __iomem *)(((unsigned long)adr) + (reg)))
-#define WriteDOC_(d, adr, reg)  writeb(d, (void __iomem *)(((unsigned long)adr) + (reg)))
+#define ReadDOC_(adr, reg)      readb((void __iomem *)(adr) + (reg))
+#define WriteDOC_(d, adr, reg)  writeb(d, (void __iomem *)(adr) + (reg))
 #define DOC_IOREMAP_LEN 0x2000
 
 #endif
Index: linux-2.6.10/include/linux/mtd/flashchip.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/flashchip.h
+++ linux-2.6.10/include/linux/mtd/flashchip.h
@@ -6,7 +6,7 @@
  *
  * (C) 2000 Red Hat. GPLd.
  *
- * $Id: flashchip.h,v 1.15 2004/11/05 22:41:06 nico Exp $
+ * $Id: flashchip.h,v 1.16 2005/02/08 17:11:15 nico Exp $
  *
  */
 
@@ -63,8 +63,8 @@ struct flchip {
 	flstate_t state;
 	flstate_t oldstate;
 
-	int write_suspended:1;
-	int erase_suspended:1;
+	unsigned int write_suspended:1;
+	unsigned int erase_suspended:1;
 	unsigned long in_progress_block_addr;
 
 	spinlock_t *mutex;
Index: linux-2.6.10/include/linux/mtd/ftl.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/ftl.h
+++ linux-2.6.10/include/linux/mtd/ftl.h
@@ -1,5 +1,5 @@
 /*
- * $Id: ftl.h,v 1.6 2003/01/24 13:20:04 dwmw2 Exp $
+ * $Id: ftl.h,v 1.5 2001/06/02 20:35:51 dwmw2 Exp $
  * 
  * Derived from (and probably identical to):
  * ftl.h 1.7 1999/10/25 20:23:17
Index: linux-2.6.10/include/linux/mtd/iflash.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/iflash.h
+++ linux-2.6.10/include/linux/mtd/iflash.h
@@ -1,4 +1,4 @@
-/* $Id: iflash.h,v 1.2 2000/11/13 18:01:54 dwmw2 Exp $ */
+/* $Id$ */
 
 #ifndef __MTD_IFLASH_H__
 #define __MTD_IFLASH_H__
Index: linux-2.6.10/include/linux/mtd/inftl.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/inftl.h
+++ linux-2.6.10/include/linux/mtd/inftl.h
@@ -20,7 +20,7 @@
 #include <mtd/inftl-user.h>
 
 #ifndef INFTL_MAJOR
-#define INFTL_MAJOR 94
+#define INFTL_MAJOR 96
 #endif
 #define INFTL_PARTN_BITS 4
 
Index: linux-2.6.10/include/linux/mtd/jedec.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/jedec.h
+++ linux-2.6.10/include/linux/mtd/jedec.h
@@ -7,7 +7,7 @@
  *
  * See the AMD flash databook for information on how to operate the interface.
  *
- * $Id: jedec.h,v 1.3 2003/05/21 11:51:01 dwmw2 Exp $
+ * $Id: jedec.h,v 1.2 2001/11/06 14:37:36 dwmw2 Exp $
  */
 
 #ifndef __LINUX_MTD_JEDEC_H__
Index: linux-2.6.10/include/linux/mtd/map.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/map.h
+++ linux-2.6.10/include/linux/mtd/map.h
@@ -1,6 +1,6 @@
 
 /* Overhauled routines for dealing with different mmap regions of flash */
-/* $Id: map.h,v 1.46 2005/01/05 17:09:44 dwmw2 Exp $ */
+/* $Id: map.h,v 1.51 2005/05/25 10:15:29 gleixner Exp $ */
 
 #ifndef __LINUX_MTD_MAP_H__
 #define __LINUX_MTD_MAP_H__
@@ -340,13 +340,23 @@ static inline map_word map_word_load_par
 	return orig;
 }
 
+#if BITS_PER_LONG < 64
+#define MAP_FF_LIMIT 4
+#else
+#define MAP_FF_LIMIT 8
+#endif
+
 static inline map_word map_word_ff(struct map_info *map)
 {
 	map_word r;
 	int i;
-
-	for (i=0; i<map_words(map); i++) {
-		r.x[i] = ~0UL;
+	
+	if (map_bankwidth(map) < MAP_FF_LIMIT) {
+		int bw = 8 * map_bankwidth(map);
+		r.x[0] = (1 << bw) - 1;
+	} else {
+		for (i=0; i<map_words(map); i++)
+			r.x[i] = ~0UL;
 	}
 	return r;
 }
@@ -418,7 +428,7 @@ extern void simple_map_init(struct map_i
 
 
 #define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))
-#define map_is_linear(map) (1)
+#define map_is_linear(map) ({ (void)(map); 1; })
 
 #endif /* !CONFIG_MTD_COMPLEX_MAPPINGS */
 
Index: linux-2.6.10/include/linux/mtd/mtd.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/mtd.h
+++ linux-2.6.10/include/linux/mtd/mtd.h
@@ -1,5 +1,5 @@
 /* 
- * $Id: mtd.h,v 1.56 2004/08/09 18:46:04 dmarlin Exp $
+ * $Id: mtd.h,v 1.58 2005/04/01 01:59:54 nico Exp $
  *
  * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
  *
@@ -71,7 +71,6 @@ struct mtd_info {
 
 	u_int32_t oobblock;  // Size of OOB blocks (e.g. 512)
 	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
-	u_int32_t oobavail;  // Number of bytes in OOB area available for fs 
 	u_int32_t ecctype;
 	u_int32_t eccsize;
 	
@@ -82,6 +81,7 @@ struct mtd_info {
 
 	// oobinfo is a nand_oobinfo structure, which can be set by iotcl (MEMSETOOBINFO)
 	struct nand_oobinfo oobinfo;
+	u_int32_t oobavail;  // Number of bytes in OOB area available for fs 
 
 	/* Data for variable erase regions. If numeraseregions is zero,
 	 * it means that the whole device has erasesize as given above. 
Index: linux-2.6.10/include/linux/mtd/nand.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/nand.h
+++ linux-2.6.10/include/linux/mtd/nand.h
@@ -5,7 +5,7 @@
  *                     Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ * $Id: nand.h,v 1.72 2005/05/27 08:31:33 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -48,6 +48,10 @@
  *  02-08-2004 tglx 	added option field to nand structure for chip anomalities
  *  05-25-2004 tglx 	added bad block table support, ST-MICRO manufacturer id
  *			update of nand_chip structure description
+ *  01-17-2005 dmarlin	added extended commands for AG-AND device and added option 
+ * 			for BBT_AUTO_REFRESH.
+ *  01-20-2005 dmarlin	added optional pointer to hardware specific callback for 
+ *			extra error status checks.
  */
 #ifndef __LINUX_MTD_NAND_H
 #define __LINUX_MTD_NAND_H
@@ -115,6 +119,25 @@ extern int nand_read_raw (struct mtd_inf
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_CACHEDPROG	0x15
 
+/* Extended commands for AG-AND device */
+/* 
+ * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but 
+ *       there is no way to distinguish that from NAND_CMD_READ0
+ *       until the remaining sequence of commands has been completed
+ *       so add a high order bit and mask it off in the command.
+ */
+#define NAND_CMD_DEPLETE1	0x100
+#define NAND_CMD_DEPLETE2	0x38
+#define NAND_CMD_STATUS_MULTI	0x71
+#define NAND_CMD_STATUS_ERROR	0x72
+/* multi-bank error status (banks 0-3) */
+#define NAND_CMD_STATUS_ERROR0	0x73
+#define NAND_CMD_STATUS_ERROR1	0x74
+#define NAND_CMD_STATUS_ERROR2	0x75
+#define NAND_CMD_STATUS_ERROR3	0x76
+#define NAND_CMD_STATUS_RESET	0x7f
+#define NAND_CMD_STATUS_CLEAR	0xff
+
 /* Status bits */
 #define NAND_STATUS_FAIL	0x01
 #define NAND_STATUS_FAIL_N1	0x02
@@ -143,7 +166,7 @@ extern int nand_read_raw (struct mtd_inf
 
 /*
  * Constants for Hardware ECC
-*/
+ */
 /* Reset Hardware ECC for read */
 #define NAND_ECC_READ		0
 /* Reset Hardware ECC for write */
@@ -151,6 +174,10 @@ extern int nand_read_raw (struct mtd_inf
 /* Enable Hardware ECC before syndrom is read back from flash */
 #define NAND_ECC_READSYN	2
 
+/* Bit mask for flags passed to do_nand_read_ecc */
+#define NAND_GET_DEVICE		0x80
+
+
 /* Option constants for bizarre disfunctionality and real
 *  features
 */
@@ -170,6 +197,10 @@ extern int nand_read_raw (struct mtd_inf
 /* Chip has a array of 4 pages which can be read without
  * additional ready /busy waits */
 #define NAND_4PAGE_ARRAY	0x00000040 
+/* Chip requires that BBT is periodically rewritten to prevent
+ * bits from adjacent blocks from 'leaking' in altering data.
+ * This happens with the Renesas AG-AND chips, possibly others.  */
+#define BBT_AUTO_REFRESH	0x00000080
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -192,7 +223,8 @@ extern int nand_read_raw (struct mtd_inf
  * This can only work if we have the ecc bytes directly behind the 
  * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
 #define NAND_HWECC_SYNDROME	0x00020000
-
+/* This option skips the bbt scan during initialization. */
+#define NAND_SKIP_BBTSCAN	0x00040000
 
 /* Options set by nand scan */
 /* Nand scan has allocated oob_buf */
@@ -221,10 +253,13 @@ struct nand_chip;
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independend devices
  * @lock:               protection lock  
  * @active:		the mtd device which holds the controller currently
+ * @wq:			wait queue to sleep on if a NAND operation is in progress
+ *                      used instead of the per chip wait queue when a hw controller is available
  */
 struct nand_hw_control {
 	spinlock_t	 lock;
 	struct nand_chip *active;
+	wait_queue_head_t wq;
 };
 
 /**
@@ -283,6 +318,8 @@ struct nand_hw_control {
  * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial bad block scan 
  * @controller:		[OPTIONAL] a pointer to a hardware controller structure which is shared among multiple independend devices
  * @priv:		[OPTIONAL] pointer to private chip date
+ * @errstat:		[OPTIONAL] hardware specific function to perform additional error status checks 
+ *			(determine if errors are correctable)
  */
  
 struct nand_chip {
@@ -338,6 +375,7 @@ struct nand_chip {
 	struct nand_bbt_descr	*badblock_pattern;
 	struct nand_hw_control  *controller;
 	void		*priv;
+	int		(*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int status, int page);
 };
 
 /*
@@ -349,6 +387,7 @@ struct nand_chip {
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX          0xad
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
@@ -459,6 +498,9 @@ extern int nand_update_bbt (struct mtd_i
 extern int nand_default_bbt (struct mtd_info *mtd);
 extern int nand_isbad_bbt (struct mtd_info *mtd, loff_t offs, int allowbbt);
 extern int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt);
+extern int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+                             size_t * retlen, u_char * buf, u_char * oob_buf,
+                             struct nand_oobinfo *oobsel, int flags);
 
 /*
 * Constants for oob configuration
Index: linux-2.6.10/include/linux/mtd/nand_ecc.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/nand_ecc.h
+++ linux-2.6.10/include/linux/mtd/nand_ecc.h
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  *
- * $Id: nand_ecc.h,v 1.4 2004/06/17 02:35:02 dbrown Exp $
+ * $Id: nand_ecc.h,v 1.3 2003/07/01 23:31:15 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
Index: linux-2.6.10/include/linux/mtd/nftl.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/nftl.h
+++ linux-2.6.10/include/linux/mtd/nftl.h
@@ -1,5 +1,5 @@
 /*
- * $Id: nftl.h,v 1.16 2004/06/30 14:49:00 dbrown Exp $
+ * $Id: nftl.h,v 1.15 2004/05/05 15:25:23 dwmw2 Exp $
  *
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
  */
Index: linux-2.6.10/include/linux/mtd/partitions.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/partitions.h
+++ linux-2.6.10/include/linux/mtd/partitions.h
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: partitions.h,v 1.16 2004/11/16 18:34:40 dwmw2 Exp $
+ * $Id: partitions.h,v 1.15 2003/07/09 11:15:43 dwmw2 Exp $
  */
 
 #ifndef MTD_PARTITIONS_H
Index: linux-2.6.10/include/linux/mtd/physmap.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/physmap.h
+++ linux-2.6.10/include/linux/mtd/physmap.h
@@ -2,7 +2,7 @@
  * For boards with physically mapped flash and using 
  * drivers/mtd/maps/physmap.c mapping driver.
  *
- * $Id: physmap.h,v 1.3 2004/07/21 00:16:15 jwboyer Exp $
+ * $Id: physmap.h,v 1.2 2004/07/14 17:48:46 dwmw2 Exp $
  *
  * Copyright (C) 2003 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
Index: linux-2.6.10/include/linux/mtd/plat-ram.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/mtd/plat-ram.h
@@ -0,0 +1,35 @@
+/* linux/include/mtd/plat-ram.h
+ *
+ * (c) 2004 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Generic platform device based RAM map
+ *
+ * $Id: $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __LINUX_MTD_PLATRAM_H
+#define __LINUX_MTD_PLATRAM_H __FILE__
+
+#define PLATRAM_RO (0)
+#define PLATRAM_RW (1)
+
+struct platdata_mtd_ram {
+	char			*mapname;
+	char		       **probes;
+	struct mtd_partition	*partitions;
+	int			 nr_partitions;
+	int			 bankwidth;
+
+	/* control callbacks */
+
+	void	(*set_rw)(struct device *dev, int to);
+};
+
+#endif /* __LINUX_MTD_PLATRAM_H */
Index: linux-2.6.10/include/linux/mtd/pmc551.h
===================================================================
--- linux-2.6.10.orig/include/linux/mtd/pmc551.h
+++ linux-2.6.10/include/linux/mtd/pmc551.h
@@ -1,5 +1,5 @@
 /*
- * $Id: pmc551.h,v 1.5 2003/01/24 16:49:53 dwmw2 Exp $
+ * $Id: pmc551.h,v 1.4 2001/06/12 16:19:38 major Exp $
  *
  * PMC551 PCI Mezzanine Ram Device
  *
@@ -17,7 +17,7 @@
 
 #include <linux/mtd/mtd.h>
 
-#define PMC551_VERSION "$Id: pmc551.h,v 1.5 2003/01/24 16:49:53 dwmw2 Exp $\n"\
+#define PMC551_VERSION "$Id: pmc551.h,v 1.4 2001/06/12 16:19:38 major Exp $\n"\
        "Ramix PMC551 PCI Mezzanine Ram Driver. (C) 1999,2000 Nortel Networks.\n"
 
 /*
Index: linux-2.6.10/include/mtd/inftl-user.h
===================================================================
--- linux-2.6.10.orig/include/mtd/inftl-user.h
+++ linux-2.6.10/include/mtd/inftl-user.h
@@ -1,5 +1,5 @@
 /*
- * $Id: inftl-user.h,v 1.1 2004/05/05 15:17:00 dwmw2 Exp $
+ * $Id: nftl-user.h,v 1.1 2004/05/05 14:44:57 dwmw2 Exp $
  *
  * Parts of INFTL headers shared with userspace 
  *
Index: linux-2.6.10/include/mtd/jffs2-user.h
===================================================================
--- linux-2.6.10.orig/include/mtd/jffs2-user.h
+++ linux-2.6.10/include/mtd/jffs2-user.h
@@ -1,5 +1,5 @@
 /*
- * $Id: jffs2-user.h,v 1.1 2004/05/05 11:57:54 dwmw2 Exp $
+ * $Id$
  *
  * JFFS2 definitions for use in user space only
  */
Index: linux-2.6.10/include/mtd/mtd-abi.h
===================================================================
--- linux-2.6.10.orig/include/mtd/mtd-abi.h
+++ linux-2.6.10/include/mtd/mtd-abi.h
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd-abi.h,v 1.7 2004/11/23 15:37:32 gleixner Exp $
+ * $Id: mtd-abi.h,v 1.10 2005/02/09 09:17:42 pavlov Exp $
  *
  * Portions of MTD ABI definition which are shared by kernel and user space 
  */
@@ -29,6 +29,7 @@ struct mtd_oob_buf {
 #define MTD_NORFLASH		3
 #define MTD_NANDFLASH		4
 #define MTD_PEROM		5
+#define MTD_DATAFLASH		6
 #define MTD_OTHER		14
 #define MTD_UNKNOWN		15
 
@@ -60,6 +61,7 @@ struct mtd_oob_buf {
 #define MTD_NANDECC_PLACE	1	// Use the given placement in the structure (YAFFS1 legacy mode)
 #define MTD_NANDECC_AUTOPLACE	2	// Use the default placement scheme
 #define MTD_NANDECC_PLACEONLY	3	// Use the given placement in the structure (Do not store ecc result on read)
+#define MTD_NANDECC_AUTOPL_USR 	4	// Use the given autoplacement scheme rather than using the default
 
 /* OTP mode selection */
 #define MTD_OTP_OFF		0
@@ -106,7 +108,7 @@ struct otp_info {
 #define OTPSELECT		_IOR('M', 13, int)
 #define OTPGETREGIONCOUNT	_IOW('M', 14, int)
 #define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
-#define OTPLOCK                 _IOR('M', 16, struct otp_info)
+#define OTPLOCK		_IOR('M', 16, struct otp_info)
 
 struct nand_oobinfo {
 	uint32_t useecc;
Index: linux-2.6.10/include/mtd/mtd-user.h
===================================================================
--- linux-2.6.10.orig/include/mtd/mtd-user.h
+++ linux-2.6.10/include/mtd/mtd-user.h
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd-user.h,v 1.2 2004/05/05 14:44:57 dwmw2 Exp $
+ * $Id: mtd-user.h,v 1.1 2004/05/05 11:57:54 dwmw2 Exp $
  *
  * MTD ABI header for use by user space only.
  */
Index: linux-2.6.10/include/mtd/nftl-user.h
===================================================================
--- linux-2.6.10.orig/include/mtd/nftl-user.h
+++ linux-2.6.10/include/mtd/nftl-user.h
@@ -1,5 +1,5 @@
 /*
- * $Id: nftl-user.h,v 1.1 2004/05/05 14:44:57 dwmw2 Exp $
+ * $Id$
  *
  * Parts of NFTL headers shared with userspace 
  *
Index: linux-2.6.10/mvl_patches/pro-0043.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0043.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(43);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

