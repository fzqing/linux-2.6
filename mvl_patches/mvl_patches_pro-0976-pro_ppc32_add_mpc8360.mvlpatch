#! /usr/bin/env bash
# Patch: -pro_ppc32_add_mpc8360
# Date: Fri Nov  3 21:35:24 2006
# Source: Freescale Semiconductor.
# MR: 20018
# Type: Enhancement
# Disposition: merged from Freescale
# Signed-off-by: Randy Vinson <rvinson@mvista.com>
# Description:
# This patch adds support for the Freescale 8360EPB development platform. A large
# part of the code was provided by Freescale, but additional work was done by
# MontaVista to get PCI and restart/reboots working along with cleanups and bug
# fixes in the UCC Ethernet driver (ucc_geth.c). The bug fixes have been sent to
# Andy Fleming at Freescale.
# 

PATCHNUM=976
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Freescale Semiconductor.
MR: 20018
Type: Enhancement
Disposition: merged from Freescale
Signed-off-by: Randy Vinson <rvinson@mvista.com>
Description:
This patch adds support for the Freescale 8360EPB development platform. A large
part of the code was provided by Freescale, but additional work was done by
MontaVista to get PCI and restart/reboots working along with cleanups and bug
fixes in the UCC Ethernet driver (ucc_geth.c). The bug fixes have been sent to
Andy Fleming at Freescale.

Index: linux-2.6.10/arch/ppc/configs/mpc8360epb_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/configs/mpc8360epb_defconfig
@@ -0,0 +1,988 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.10_mvl401
+# Wed Sep 13 11:28:59 2006
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ASM_SEMAPHORES=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SEMMNI=128
+CONFIG_SYSVIPC_SEMMSL=250
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_LTT_MAX_HANDLES=128
+# CONFIG_BOOT_FLIGHT_RECORDER is not set
+CONFIG_LOCKLESS=y
+CONFIG_BOOT_FLIGHT_BUFFERS=4
+CONFIG_BOOT_FLIGHT_SIZE=524288
+CONFIG_FLIGHT_PROC_BUFFERS=8
+CONFIG_FLIGHT_PROC_SIZE=8192
+CONFIG_NEWEV=y
+CONFIG_CSTM=y
+# CONFIG_CREATE_DEV_CONSOLE is not set
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Processor
+#
+CONFIG_6xx=y
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E200 is not set
+# CONFIG_E500 is not set
+CONFIG_PPC_FPU=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_PPC_GEN550=y
+CONFIG_PPC_STD_MMU=y
+
+#
+# Platform options
+#
+# CONFIG_PPC_MULTIPLATFORM is not set
+# CONFIG_APUS is not set
+# CONFIG_KATANA is not set
+# CONFIG_WILLOW is not set
+# CONFIG_TAIGA is not set
+# CONFIG_CPCI690 is not set
+# CONFIG_PCORE is not set
+# CONFIG_POWERPMC250 is not set
+# CONFIG_CHESTNUT is not set
+# CONFIG_SPRUCE is not set
+# CONFIG_EV64260 is not set
+# CONFIG_LOPEC is not set
+# CONFIG_MCPN765 is not set
+# CONFIG_MVME5100 is not set
+# CONFIG_PPLUS is not set
+# CONFIG_PRPMC275 is not set
+# CONFIG_PRPMC750 is not set
+# CONFIG_PRPMC800 is not set
+# CONFIG_SANDPOINT is not set
+# CONFIG_ADIR is not set
+# CONFIG_K2 is not set
+# CONFIG_PAL4 is not set
+# CONFIG_GEMINI is not set
+# CONFIG_EST8260 is not set
+# CONFIG_SBC82xx is not set
+# CONFIG_SBS8260 is not set
+# CONFIG_RPX8260 is not set
+# CONFIG_TQM8260 is not set
+# CONFIG_ADS8272 is not set
+# CONFIG_PQ2FADS is not set
+# CONFIG_LITE5200 is not set
+# CONFIG_MPC834x_SYS is not set
+CONFIG_MPC8360E_PB=y
+# CONFIG_MPC8641_HPCN is not set
+CONFIG_MPC8360=y
+CONFIG_83xx=y
+CONFIG_QE=y
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT_DESKTOP=y
+# CONFIG_PREEMPT_RT is not set
+CONFIG_PREEMPT=y
+# CONFIG_PREEMPT_SOFTIRQS is not set
+# CONFIG_PREEMPT_HARDIRQS is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_SPINLOCK_BKL is not set
+CONFIG_PREEMPT_BKL=y
+# CONFIG_HIGHMEM is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_GENERIC_ISA_DMA=y
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x8000000
+CONFIG_MTD_PHYSMAP_LEN=0x4000000
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_MULTI_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_RAMTD is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_USE_POLICY_FWD=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_ADVANCED_ROUTER is not set
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP6_NF_CONNTRACK is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+
+#
+# Broadcom network devices
+#
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_GIANFAR is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_TSLIBDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_BLOCKER is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_SGI is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_OMAP is not set
+
+#
+# Hardware Sensors Chip support
+#
+CONFIG_I2C_SENSOR=y
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+CONFIG_SENSORS_DS1374=y
+# CONFIG_SENSORS_DS1338 is not set
+# CONFIG_SENSORS_RV5C387A is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_M41T00 is not set
+# CONFIG_SENSORS_MAX6900 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# Enable Host or Gadget support to see Inventra options
+#
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Synchronous Serial Interfaces (SSI)
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=m
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_CRAMFS_LINEAR is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+# CONFIG_YAFFS1_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+CONFIG_NLS_ISO8859_8=y
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# QE Options
+#
+CONFIG_UCC1=y
+# CONFIG_UCC1_SLOW is not set
+CONFIG_UCC1_FAST=y
+
+#
+# UCC1 Protocols options
+#
+CONFIG_UCC1_GETH=y
+CONFIG_UCC2=y
+# CONFIG_UCC2_SLOW is not set
+CONFIG_UCC2_FAST=y
+
+#
+# UCC2 Protocols options
+#
+CONFIG_UCC2_GETH=y
+# CONFIG_UCC3 is not set
+# CONFIG_UCC4 is not set
+# CONFIG_UCC5 is not set
+# CONFIG_UCC6 is not set
+# CONFIG_UCC7 is not set
+# CONFIG_UCC8 is not set
+CONFIG_UCC=y
+CONFIG_UCC_FAST=y
+CONFIG_UCC_GETH=y
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Fast Real-Time Domain
+#
+# CONFIG_FRD is not set
+
+#
+# Fast Real-Time Domain Advanced Options
+#
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# MontaVista System tools
+#
+# CONFIG_ILATENCY is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_WAKEUP_TIMING is not set
+# CONFIG_CRITICAL_PREEMPT_TIMING is not set
+# CONFIG_CRITICAL_IRQSOFF_TIMING is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
Index: linux-2.6.10/arch/ppc/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/ppc/Kconfig
+++ linux-2.6.10/arch/ppc/Kconfig
@@ -739,6 +739,11 @@ config MPC8641_HPCN
 	help
 	  This option enables Freescale's MPC8641-HPCN platform.
 
+config MPC8360E_PB
+	bool "Freescale MPC8360E-PB"
+	help
+	  This option enables support for the MPC 8360E PB evaluation board.
+
 endchoice
 
 source arch/ppc/platforms/83xx/Kconfig
@@ -780,13 +785,19 @@ config 8272
 	  The MPC8272 CPM has a different internal dpram setup than other CPM2
 	  devices
 
-config 83xx
+config MPC834x
 	bool
-	default y if MPC834x_SYS
+	depends on MPC834x_SYS
+	default y
 
-config MPC834x
+config MPC8360
 	bool
-	default y if MPC834x_SYS
+	depends on MPC8360E_PB
+	default y
+
+config 83xx
+	bool
+	default y if MPC834x || MPC8360
 
 config CPM1
  	bool
@@ -808,6 +819,16 @@ config CPM2
 	  you wish to build a kernel for a machine with a CPM2 coprocessor
 	  on it (826x, 827x, 8560).
 
+config QE
+	bool
+	depends on MPC8360
+	default y
+	help
+	  The QE (QUICC Engine) is a coprocessor on embedded CPUs made
+	  by Freescale.  Selecting this option means that you wish to
+	  build a kernel for a machine with a QE coprocessor on it
+	  (E.g. 8360).
+
 config PPC_CHRP
 	bool
 	depends on PPC_MULTIPLATFORM
@@ -1223,7 +1244,7 @@ config PCI_DOMAINS
 	default PCI
 
 config MPC83xx_PCI2
-	bool "  Supprt for 2nd PCI host controller"
+	bool "  Support for 2nd PCI host controller"
 	depends on PCI && MPC834x
 	default y if MPC834x_SYS
 
@@ -1399,6 +1420,7 @@ source "arch/ppc/8xx_io/Kconfig"
 
 source "arch/ppc/8260_io/Kconfig"
 
+source "arch/ppc/qe_io/Kconfig"
 
 menu "IBM 40x options"
 	depends on 40x
Index: linux-2.6.10/arch/ppc/lib/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/lib/Makefile
+++ linux-2.6.10/arch/ppc/lib/Makefile
@@ -7,3 +7,4 @@ obj-y			:= checksum.o string.o strcase.o
 obj-$(CONFIG_SMP)	+= locks.o
 obj-$(CONFIG_8xx)	+= rheap.o
 obj-$(CONFIG_CPM2)	+= rheap.o
+obj-$(CONFIG_QE)	+= rheap.o
Index: linux-2.6.10/arch/ppc/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/Makefile
+++ linux-2.6.10/arch/ppc/Makefile
@@ -65,6 +65,7 @@ core-$(CONFIG_APUS)		+= arch/ppc/amiga/
 drivers-$(CONFIG_8xx)		+= arch/ppc/8xx_io/
 drivers-$(CONFIG_4xx)		+= arch/ppc/4xx_io/
 drivers-$(CONFIG_CPM2)		+= arch/ppc/8260_io/
+drivers-$(CONFIG_QE)            += arch/ppc/qe_io/
 
 drivers-$(CONFIG_OPROFILE)	+= arch/ppc/oprofile/
 
Index: linux-2.6.10/arch/ppc/platforms/83xx/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/83xx/Makefile
+++ linux-2.6.10/arch/ppc/platforms/83xx/Makefile
@@ -2,3 +2,4 @@
 # Makefile for the PowerPC 83xx linux kernel.
 #
 obj-$(CONFIG_MPC834x_SYS)	+= mpc834x_sys.o
+obj-$(CONFIG_MPC8360E_PB)	+= mpc8360e_pb.o
Index: linux-2.6.10/arch/ppc/platforms/83xx/mpc8360e_pb.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/83xx/mpc8360e_pb.c
@@ -0,0 +1,634 @@
+/*
+ * arch/ppc/platforms/83xx/mpc8360e_pb.c
+ *
+ * MPC8360E PB board specific routines
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/serial.h>
+#include <linux/tty.h>		/* for linux/serial_core.h */
+#include <linux/serial_core.h>
+#include <linux/mtd/physmap.h>
+#include <linux/initrd.h>
+#include <linux/module.h>
+#include <linux/fsl_devices.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/atomic.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/prom.h>
+#include <asm/ipic.h>
+#ifdef CONFIG_QE
+#include <asm/qe_ic.h>
+#endif				/* CONFIG_QE */
+#include <asm/bootinfo.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpc83xx.h>
+#include <asm/irq.h>
+#include <asm/kgdb.h>
+#include <asm/ppc_sys.h>
+#include <mm/mmu_decl.h>
+
+#include <syslib/ppc83xx_setup.h>
+
+#ifdef CONFIG_QE
+extern void qe_reset(void);
+#endif				/* CONFIG_QE */
+
+#ifndef CONFIG_PCI
+unsigned long isa_io_base = 0;
+unsigned long isa_mem_base = 0;
+#endif
+
+extern unsigned long total_memory;	/* in mm/init */
+extern void gen550_progress(char *, unsigned short);
+extern void gen550_init(int, struct uart_port *);
+
+unsigned char __res[sizeof(bd_t)];
+
+#define NUM_OF_PINS     32
+#define NUM_OF_PAR_IOS  7
+
+typedef struct par_io {
+	struct {
+		u32 cpodr;	/* Open drain register */
+		u32 cpdata;	/* Data register */
+		u32 cpdir1;	/* Direction register */
+		u32 cpdir2;	/* Direction register */
+		u32 cppar1;	/* Pin assignment register */
+		u32 cppar2;	/* Pin assignment register */
+	} io_regs[NUM_OF_PAR_IOS];
+} par_io_t;
+
+typedef struct qe_par_io {
+	u8 res[0xc];
+	u32 cepier;		/* QE ports interrupt event register */
+	u32 cepimr;		/* QE ports mask event register */
+	u32 cepicr;		/* QE ports control event register */
+} qe_par_io_t;
+
+static int qe_irq_ports[NUM_OF_PAR_IOS][NUM_OF_PINS] = {
+	/* 0-7 *//* 8-15 *//* 16 - 23 *//* 24 - 31 */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 1, 1, 0},
+	{0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 1, 1, 0, 0, 0, 0},
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 1, 1, 1, 0, 0},
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
+	 0, 0, 1, 1, 0, 0, 0, 0},
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 1, 1, 1, 1, 0, 0, 0, 1},
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0},
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 1}
+};
+
+static u8 get_irq_num(u8 port, u8 pin)
+{
+	int i, j;
+	u8 num = 0;
+
+	for (j = 0; j <= port; j++)
+		for (i = 0; i < pin; i++)
+			if (qe_irq_ports[j][i])
+				num++;
+	return num;
+}
+
+static par_io_t *par_io = NULL;
+static qe_par_io_t *qe_par_io = NULL;
+
+int par_io_config_pin(u8 port,
+		      u8 pin,
+		      int dir, int open_drain, int assignment, int has_irq)
+{
+	u32 pinMask1bit, pinMask2bits, newMask2bits, tmp_val;
+
+	if (!par_io) {
+		par_io =
+		    (par_io_t *) ioremap(immrbar + 0x1400, sizeof(par_io_t));
+		qe_par_io =
+		    (qe_par_io_t *) ioremap(immrbar + 0xC00,
+					    sizeof(qe_par_io_t));
+
+		/* clear event bits in the event register of the QE ports */
+		out_be32(&qe_par_io->cepier, 0xFFFFFFFF);
+	}
+
+	/* calculate pin location for single and 2 bits  information */
+	pinMask1bit = (u32) (1 << (NUM_OF_PINS - (pin + 1)));
+
+	/* Set open drain, if required */
+	tmp_val = in_be32(&par_io->io_regs[port].cpodr);
+	if (open_drain)
+		out_be32(&par_io->io_regs[port].cpodr, pinMask1bit | tmp_val);
+	else
+		out_be32(&par_io->io_regs[port].cpodr, ~pinMask1bit & tmp_val);
+
+	/* define direction */
+	tmp_val = (pin > (NUM_OF_PINS / 2) - 1) ?
+	    in_be32(&par_io->io_regs[port].cpdir2) :
+	    in_be32(&par_io->io_regs[port].cpdir1);
+
+	/* get all bits mask for 2 bit per port */
+	pinMask2bits =
+	    (u32) (0x3 << (NUM_OF_PINS - (pin % (NUM_OF_PINS / 2) + 1) * 2));
+
+	/* Get the final mask we need for the right definition */
+	newMask2bits =
+	    (u32) (dir << (NUM_OF_PINS - (pin % (NUM_OF_PINS / 2) + 1) * 2));
+
+	/* clear and set 2 bits mask */
+	if (pin > (NUM_OF_PINS / 2) - 1) {
+		out_be32(&par_io->io_regs[port].cpdir2,
+			 ~pinMask2bits & tmp_val);
+		out_be32(&par_io->io_regs[port].cpdir2, newMask2bits | tmp_val);
+	} else {
+		out_be32(&par_io->io_regs[port].cpdir1,
+			 ~pinMask2bits & tmp_val);
+		out_be32(&par_io->io_regs[port].cpdir1, newMask2bits | tmp_val);
+	}
+	/* define pin assignment */
+	tmp_val = (pin > (NUM_OF_PINS / 2) - 1) ?
+	    in_be32(&par_io->io_regs[port].cppar2) :
+	    in_be32(&par_io->io_regs[port].cppar1);
+
+	newMask2bits =
+	    (u32) (assignment <<
+		   (NUM_OF_PINS - (pin % (NUM_OF_PINS / 2) + 1) * 2));
+	/* clear and set 2 bits mask */
+	if (pin > (NUM_OF_PINS / 2) - 1) {
+		out_be32(&par_io->io_regs[port].cppar2,
+			 ~pinMask2bits & tmp_val);
+		out_be32(&par_io->io_regs[port].cppar2, newMask2bits | tmp_val);
+	} else {
+		out_be32(&par_io->io_regs[port].cppar1,
+			 ~pinMask2bits & tmp_val);
+		out_be32(&par_io->io_regs[port].cppar1, newMask2bits | tmp_val);
+	}
+
+	/* If this pin should not generate interrupt clear event mask bit */
+	if (has_irq) {
+		int i, j, k = 0;
+		int irq = get_irq_num(port, pin);
+		u32 mask = 0;
+
+		for (j = 0; j < NUM_OF_PAR_IOS; j++)
+			for (i = 0; i < NUM_OF_PINS; i++) {
+				if (qe_irq_ports[j][i]) {
+					if (k == irq) {
+						mask = 0x80000000 >> k;
+						break;
+					}
+					k++;
+				}
+			}
+
+		if (!mask)
+			return -EINVAL;
+
+		tmp_val = in_be32(&qe_par_io->cepimr);
+		out_be32(&qe_par_io->cepimr, ~mask & tmp_val);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(par_io_config_pin);
+
+#ifdef CONFIG_PCI
+int mpc83xx_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *       A      B      C      D
+	     */
+	{
+		{PIRQA, PIRQB, PIRQC, PIRQD},	/* idsel 0x11 */
+		{PIRQC, PIRQD, PIRQA, PIRQB},	/* idsel 0x12 */
+		{PIRQD, PIRQA, PIRQB, PIRQC}	/* idsel 0x13 */
+	};
+
+	const long min_idsel = 0x11, max_idsel = 0x13, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+}
+
+int mpc83xx_exclude_device(u_char bus, u_char devfn)
+{
+	return PCIBIOS_SUCCESSFUL;
+}
+#endif				/* CONFIG_PCI */
+
+/* ************************************************************************
+ *
+ * Setup the architecture
+ *
+ */
+static void __init mpc8360e_pb_setup_arch(void)
+{
+	bd_t *binfo = (bd_t *) __res;
+	unsigned int freq;
+	struct ucc_geth_platform_data *pdata;
+	u8 *bcsr_regs;
+	u32 tmp_val, *tmp_reg;
+
+	/* get the core frequency */
+	freq = binfo->bi_intfreq;
+
+	/* Set loops_per_jiffy to a half-way reasonable value,
+	   for use until calibrate_delay gets called. */
+	loops_per_jiffy = freq / HZ;
+
+#ifdef CONFIG_PCI
+	/* setup PCI host bridges */
+	mpc83xx_setup_hose();
+#endif
+#ifdef CONFIG_SERIAL_8250
+	mpc83xx_early_serial_map();
+#endif
+
+#ifdef CONFIG_QE
+	qe_reset();
+
+	/* setup the board related information for the enet controllers */
+	pdata =
+	    (struct ucc_geth_platform_data *)ppc_sys_get_pdata(MPC83xx_QE_UCC1);
+	pdata->rx_clock = QE_CLK_NONE;
+	pdata->tx_clock = QE_CLK9;
+	pdata->board_flags = FSL_UGETH_BRD_HAS_PHY_INTR;
+	pdata->phy_id = 0;
+	pdata->phy_interface = ENET_1000_GMII;
+	pdata->phy_interrupt = MPC83xx_IRQ_EXT1;
+	/* fixup phy address */
+	pdata->phy_reg_addr += QE_MAP_ADDR;
+	memcpy(pdata->mac_addr, binfo->bi_enetaddr, 6);
+
+	par_io_config_pin(0, 3, 1, 0, 1, 0);	/* TxD0 */
+	par_io_config_pin(0, 4, 1, 0, 1, 0);	/* TxD1 */
+	par_io_config_pin(0, 5, 1, 0, 1, 0);	/* TxD2 */
+	par_io_config_pin(0, 6, 1, 0, 1, 0);	/* TxD3 */
+	par_io_config_pin(1, 6, 1, 0, 3, 0);	/* TxD4 */
+	par_io_config_pin(1, 7, 1, 0, 1, 0);	/* TxD5 */
+	par_io_config_pin(1, 9, 1, 0, 2, 0);	/* TxD6 */
+	par_io_config_pin(1, 10, 1, 0, 2, 0);	/* TxD7 */
+	par_io_config_pin(0, 9, 2, 0, 1, 0);	/* RxD0 */
+	par_io_config_pin(0, 10, 2, 0, 1, 0);	/* RxD1 */
+	par_io_config_pin(0, 11, 2, 0, 1, 0);	/* RxD2 */
+	par_io_config_pin(0, 12, 2, 0, 1, 0);	/* RxD3 */
+	par_io_config_pin(0, 13, 2, 0, 1, 0);	/* RxD4 */
+	par_io_config_pin(1, 1, 2, 0, 2, 0);	/* RxD5 */
+	par_io_config_pin(1, 0, 2, 0, 2, 0);	/* RxD6 */
+	par_io_config_pin(1, 4, 2, 0, 2, 0);	/* RxD7 */
+	par_io_config_pin(0, 7, 1, 0, 1, 0);	/* TX_EN */
+	par_io_config_pin(0, 8, 1, 0, 1, 0);	/* TX_ER */
+	par_io_config_pin(0, 15, 2, 0, 1, 0);	/* RX_DV */
+	par_io_config_pin(0, 16, 2, 0, 1, 0);	/* RX_ER */
+	par_io_config_pin(0, 0, 2, 0, 1, 0);	/* RX_CLK */
+	par_io_config_pin(2, 9, 1, 0, 3, 0);	/* GTX_CLK - CLK10 */
+	par_io_config_pin(2, 8, 2, 0, 1, 0);	/* GTX125 - CLK9 */
+
+	/* setup the board related information for the enet controllers */
+	pdata =
+	    (struct ucc_geth_platform_data *)ppc_sys_get_pdata(MPC83xx_QE_UCC2);
+	pdata->rx_clock = QE_CLK_NONE;
+	pdata->tx_clock = QE_CLK4;
+	pdata->board_flags = FSL_UGETH_BRD_HAS_PHY_INTR;
+	pdata->phy_id = 1;
+	pdata->phy_interface = ENET_1000_GMII;
+	pdata->phy_interrupt = MPC83xx_IRQ_EXT2;
+	/* fixup phy address */
+	pdata->phy_reg_addr += QE_MAP_ADDR;
+	memcpy(pdata->mac_addr, binfo->bi_enet1addr, 6);
+
+	par_io_config_pin(0, 17, 1, 0, 1, 0);	/* TxD0 */
+	par_io_config_pin(0, 18, 1, 0, 1, 0);	/* TxD1 */
+	par_io_config_pin(0, 19, 1, 0, 1, 0);	/* TxD2 */
+	par_io_config_pin(0, 20, 1, 0, 1, 0);	/* TxD3 */
+	par_io_config_pin(1, 2, 1, 0, 1, 0);	/* TxD4 */
+	par_io_config_pin(1, 3, 1, 0, 2, 0);	/* TxD5 */
+	par_io_config_pin(1, 5, 1, 0, 3, 0);	/* TxD6 */
+	par_io_config_pin(1, 8, 1, 0, 3, 0);	/* TxD7 */
+	par_io_config_pin(0, 23, 2, 0, 1, 0);	/* RxD0 */
+	par_io_config_pin(0, 24, 2, 0, 1, 0);	/* RxD1 */
+	par_io_config_pin(0, 25, 2, 0, 1, 0);	/* RxD2 */
+	par_io_config_pin(0, 26, 2, 0, 1, 0);	/* RxD3 */
+	par_io_config_pin(0, 27, 2, 0, 1, 0);	/* RxD4 */
+	par_io_config_pin(1, 12, 2, 0, 2, 0);	/* RxD5 */
+	par_io_config_pin(1, 13, 2, 0, 3, 0);	/* RxD6 */
+	par_io_config_pin(1, 11, 2, 0, 2, 0);	/* RxD7 */
+	par_io_config_pin(0, 21, 1, 0, 1, 0);	/* TX_EN */
+	par_io_config_pin(0, 22, 1, 0, 1, 0);	/* TX_ER */
+	par_io_config_pin(0, 29, 2, 0, 1, 0);	/* RX_DV */
+	par_io_config_pin(0, 30, 2, 0, 1, 0);	/* RX_ER */
+	par_io_config_pin(0, 31, 2, 0, 1, 0);	/* RX_CLK */
+	par_io_config_pin(2, 2, 1, 0, 2, 0);	/* GTX_CLK - CLK10 */
+	par_io_config_pin(2, 3, 2, 0, 1, 0);	/* GTX125 - CLK4 */
+
+	par_io_config_pin(0, 1, 3, 0, 2, 0);	/* MDIO */
+	par_io_config_pin(0, 2, 1, 0, 1, 0);	/* MDC */
+
+	/* Reset the Ethernet PHY */
+	bcsr_regs = (u8 *) BCSR_VIRT_ADDR;
+	bcsr_regs[9] &= ~0x20;
+	udelay(1000);
+	bcsr_regs[9] |= 0x20;
+	/* There's a bug in initial chip rev(s) in the RGMII ac timing.   */
+	/* The following compensates by writing to the reserved           */
+	/* QE Port Output Hold Registers (CPOH1?).                       */
+	tmp_reg = (u32 *) ioremap(immrbar + 0x14A8, 0x4);
+	tmp_val = in_be32(tmp_reg);
+	out_be32(tmp_reg, tmp_val | 0x00003000);
+
+#endif				/* CONFIG_QE */
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+#ifdef  CONFIG_ROOT_NFS
+		ROOT_DEV = Root_NFS;
+#else
+		ROOT_DEV = Root_HDA1;
+#endif
+}
+
+#if defined(CONFIG_MTD_PHYSMAP) && defined(CONFIG_MTD_PARTITIONS)
+
+/*
+ * The firmware doesn't seem to provide the correct FLASH values,
+ * hence these defines. They will most likely need to be updated for
+ * later boards.
+ */
+#define MPC8360EPB_FLASH_ADDR	0xfe000000
+#define MPC8360EPB_FLASH_SIZE	0x01000000
+#define MPC8360EPB_HRCW_SIZE	0x00020000
+#define MPC8360EPB_RAMDISK_SIZE	0x00400000
+#define MPC8360EPB_KRNL_SIZE	0x00200000
+#define MPC8360EPB_UBOOT_SIZE	0x00100000
+#define MPC8360EPB_FS_SIZE	(MPC8360EPB_FLASH_SIZE - \
+				 MPC8360EPB_HRCW_SIZE - \
+				 MPC8360EPB_KRNL_SIZE - \
+				 MPC8360EPB_RAMDISK_SIZE - \
+				 MPC8360EPB_UBOOT_SIZE)
+
+static struct mtd_partition ptbl[] = {
+	{
+	 .name = "Reset Configuration Word",
+	 .size = MPC8360EPB_HRCW_SIZE,
+	 .offset = 0,
+	 .mask_flags = MTD_WRITEABLE,
+	 },
+	{
+	 .name = "User FS",
+	 .size = MPC8360EPB_FS_SIZE,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0,
+	 },
+	{
+	 .name = "RAMDISK",
+	 .size = MPC8360EPB_RAMDISK_SIZE,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0,
+	 },
+	{
+	 .name = "Kernel",
+	 .size = MPC8360EPB_KRNL_SIZE,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0,
+	 },
+	{
+	 .name = "ROM Monitor",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE,
+	 }
+};
+
+static int __init mpc8360_setup_mtd(void)
+{
+
+	physmap_configure(MPC8360EPB_FLASH_ADDR, MPC8360EPB_FLASH_SIZE, 2,
+			  NULL);
+
+	physmap_set_partitions(ptbl, sizeof(ptbl) / sizeof(ptbl[0]));
+	return 0;
+}
+
+arch_initcall(mpc8360_setup_mtd);
+#endif
+
+static void __init mpc8360e_pb_map_io(void)
+{
+	/* we steal the lowest ioremap addr for virt space */
+	io_block_mapping(VIRT_IMMRBAR, immrbar, MPC83xx_IMMRBAR_SIZE, _PAGE_IO);
+	io_block_mapping(BCSR_VIRT_ADDR, BCSR_PHYS_ADDR, BCSR_SIZE, _PAGE_IO);
+}
+
+int mpc8360e_pb_show_cpuinfo(struct seq_file *m)
+{
+	uint pvid, svid, phid1;
+	bd_t *binfo = (bd_t *) __res;
+	unsigned int freq;
+
+	/* get the core frequency */
+	freq = binfo->bi_intfreq;
+
+	pvid = mfspr(PVR);
+	svid = mfspr(SVR);
+
+	seq_printf(m, "chip\t\t: MPC%s\n", cur_ppc_sys_spec->ppc_sys_name);
+	seq_printf(m, "Vendor\t\t: Freescale Inc.\n");
+	seq_printf(m, "Machine\t\t: mpc%s sys\n",
+		   cur_ppc_sys_spec->ppc_sys_name);
+	seq_printf(m, "core clock\t: %d MHz\n" "bus  clock\t: %d MHz\n",
+		   (int)(binfo->bi_intfreq / 1000000),
+		   (int)(binfo->bi_busfreq / 1000000));
+	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
+	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
+
+	/* Display cpu Pll setting */
+	phid1 = mfspr(HID1);
+	seq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));
+
+	/* Display the amount of memory */
+	seq_printf(m, "Memory\t\t: %d MB\n",
+		   (int)(binfo->bi_memsize / (1024 * 1024)));
+
+	return 0;
+}
+
+void __init mpc8360e_pb_init_IRQ(void)
+{
+	bd_t *binfo = (bd_t *) __res;
+
+	u8 senses[8] = {
+		0,		/* EXT 0 */
+		IRQ_SENSE_LEVEL,	/* EXT 1 */
+		IRQ_SENSE_LEVEL,	/* EXT 2 */
+		0,		/* EXT 3 */
+		IRQ_SENSE_LEVEL,	/* EXT 4 */
+		IRQ_SENSE_LEVEL,	/* EXT 5 */
+		IRQ_SENSE_LEVEL,	/* EXT 6 */
+		IRQ_SENSE_LEVEL,	/* EXT 7 */
+	};
+
+	ipic_init(binfo->bi_immr_base + 0x00700, 0, MPC83xx_IPIC_IRQ_OFFSET,
+		  senses, 8);
+
+	/* Initialize the default interrupt mapping priorities,
+	 * in case the boot rom changed something on us.
+	 */
+	ipic_set_default_priority();
+
+#ifdef CONFIG_QE
+	qe_ic_init(QE_MAP_ADDR + 0x00000080,
+		   (QE_IC_LOW_SIGNAL | QE_IC_HIGH_SIGNAL), QE_IRQ_OFFSET);
+#endif				/* CONFIG_QE */
+}
+
+#if defined(CONFIG_I2C_MPC) && defined(CONFIG_SENSORS_DS1374)
+extern ulong ds1374_get_rtc_time(void);
+extern int ds1374_set_rtc_time(ulong);
+
+static int __init mpc834x_rtc_hookup(void)
+{
+	struct timespec tv;
+
+	ppc_md.get_rtc_time = ds1374_get_rtc_time;
+	ppc_md.set_rtc_time = ds1374_set_rtc_time;
+
+	tv.tv_nsec = 0;
+	tv.tv_sec = (ppc_md.get_rtc_time) ();
+	do_settimeofday(&tv);
+
+	return 0;
+}
+
+late_initcall(mpc834x_rtc_hookup);
+#endif
+static __inline__ void mpc8360e_pb_set_bat(void)
+{
+	/* we steal the lowest ioremap addr for virt space */
+	mb();
+	mtspr(DBAT1U, VIRT_IMMRBAR | 0x3e);
+	mtspr(DBAT1L, immrbar | 0x2a);
+	mb();
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	bd_t *binfo = (bd_t *) __res;
+
+	/* parse_bootinfo must always be called first */
+	parse_bootinfo(find_bootinfo());
+
+	/*
+	 * If we were passed in a board information, copy it into the
+	 * residual data area.
+	 */
+	if (r3) {
+		memcpy((void *)__res, (void *)(r3 + KERNELBASE), sizeof(bd_t));
+	}
+#if defined(CONFIG_BLK_DEV_INITRD)
+	/*
+	 * If the init RAM disk has been configured in, and there's a valid
+	 * starting address for it, set it up.
+	 */
+	if (r4) {
+		initrd_start = r4 + KERNELBASE;
+		initrd_end = r5 + KERNELBASE;
+	}
+#endif				/* CONFIG_BLK_DEV_INITRD */
+
+	/* Copy the kernel command line arguments to a safe place. */
+	if (r6) {
+		*(char *)(r7 + KERNELBASE) = 0;
+		strcpy(cmd_line, (char *)(r6 + KERNELBASE));
+	}
+
+	immrbar = binfo->bi_immr_base;
+
+	mpc8360e_pb_set_bat();
+
+#if defined(CONFIG_SERIAL_8250) && defined(CONFIG_SERIAL_TEXT_DEBUG)
+	{
+		struct uart_port p;
+
+		memset(&p, 0, sizeof(p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (unsigned char __iomem *)VIRT_IMMRBAR + 0x4500;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(0, &p);
+
+		memset(&p, 0, sizeof(p));
+		p.iotype = SERIAL_IO_MEM;
+		p.membase = (unsigned char __iomem *)VIRT_IMMRBAR + 0x4600;
+		p.uartclk = binfo->bi_busfreq;
+
+		gen550_init(1, &p);
+	}
+#endif
+
+	identify_ppc_sys_by_id(mfspr(SVR));
+
+	/* setup the PowerPC module struct */
+	ppc_md.setup_arch = mpc8360e_pb_setup_arch;
+	ppc_md.show_cpuinfo = mpc8360e_pb_show_cpuinfo;
+
+	ppc_md.init_IRQ = mpc8360e_pb_init_IRQ;
+	ppc_md.get_irq = ipic_get_irq;
+
+	ppc_md.restart = mpc83xx_restart;
+	ppc_md.power_off = mpc83xx_power_off;
+	ppc_md.halt = mpc83xx_halt;
+
+	ppc_md.find_end_of_memory = mpc83xx_find_end_of_memory;
+	ppc_md.setup_io_mappings = mpc8360e_pb_map_io;
+
+	ppc_md.time_init = mpc83xx_time_init;
+	ppc_md.set_rtc_time = NULL;
+	ppc_md.get_rtc_time = NULL;
+	ppc_md.calibrate_decr = mpc83xx_calibrate_decr;
+
+#if defined(CONFIG_SERIAL_8250) && defined(CONFIG_SERIAL_TEXT_DEBUG)
+	ppc_md.progress = gen550_progress;
+#endif				/* CONFIG_SERIAL_8250 && CONFIG_SERIAL_TEXT_DEBUG */
+
+	if (ppc_md.progress)
+		ppc_md.progress("mpc8360e_pb_init(): exit", 0);
+
+	return;
+}
Index: linux-2.6.10/arch/ppc/platforms/83xx/mpc8360e_pb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/83xx/mpc8360e_pb.h
@@ -0,0 +1,39 @@
+/*
+ * arch/ppc/platforms/83xx/mpc8360e_pb.h
+ *
+ * MPC8360E PB common board definitions
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __MPC8360E_PB_H__
+#define __MPC8360E_PB_H__
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <syslib/ppc83xx_setup.h>
+#include <asm/ppcboot.h>
+
+#define VIRT_IMMRBAR		((uint)0xfe000000)
+
+#define BCSR_PHYS_ADDR		((uint)0xf8000000)
+#define BCSR_VIRT_ADDR		((uint)0xfe200000)
+#define BCSR_SIZE			((uint)(128 * 1024))
+
+#define QE_MAP_ADDR			((uint)immrbar + 0x100000)
+
+#define PIRQA	MPC83xx_IRQ_EXT4
+#define PIRQB	MPC83xx_IRQ_EXT5
+#define PIRQC	MPC83xx_IRQ_EXT6
+#define PIRQD	MPC83xx_IRQ_EXT7
+
+#endif				/* __MPC8360E_PB_H__ */
Index: linux-2.6.10/arch/ppc/qe_io/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/Kconfig
@@ -0,0 +1,9 @@
+#
+# QE Communication options
+#
+
+menu "QE Options"
+	depends on QE
+
+	source arch/ppc/qe_io/ucc/Kconfig
+endmenu
Index: linux-2.6.10/arch/ppc/qe_io/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the linux ppc-specific parts of QE
+#
+obj-$(CONFIG_QE)	+= qe_common.o
+
+obj-$(CONFIG_UCC)	+= ucc/
Index: linux-2.6.10/arch/ppc/qe_io/qe_common.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/qe_common.c
@@ -0,0 +1,333 @@
+/*
+ * arch/ppc/qe_io/qe_common.c
+ *
+ * General Purpose functions for the global management of the
+ * QUICC Engine (QE).
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/bootmem.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+#include <asm/rheap.h>
+
+#define QE_MAP_SIZE    (0x100000)	/* 1MB */
+
+/* QE snum state
+*/
+typedef enum qe_snum_state {
+	QE_SNUM_STATE_USED,	/* used */
+	QE_SNUM_STATE_FREE	/* free */
+} qe_snum_state_e;
+
+/* QE snum
+*/
+typedef struct qe_snum {
+	u8 num;			/* snum  */
+	qe_snum_state_e state;	/* state */
+} qe_snum_t;
+
+/* We allocate this here because it is used almost exclusively for
+ * the communication processor devices.
+ */
+EXPORT_SYMBOL(qe_immr);
+qe_map_t *qe_immr;
+static qe_snum_t snums[QE_NUM_OF_SNUM];	/* Dynamically allocated SNUMs  */
+
+static void qe_snums_init(void);
+static void qe_muram_init(void);
+static int qe_sdma_init(void);
+
+void qe_reset(void)
+{
+	qe_immr = (qe_map_t *) ioremap(QE_MAP_ADDR, QE_MAP_SIZE);
+
+	qe_snums_init();
+
+	qe_issue_cmd(QE_RESET, QE_CR_SUBBLOCK_INVALID,
+		     (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+
+	/* Reclaim the MURAM memory for our use. */
+	qe_muram_init();
+
+	if (qe_sdma_init())
+		panic("sdma init failed!");
+}
+
+EXPORT_SYMBOL(qe_issue_cmd);
+int qe_issue_cmd(uint cmd, uint device, u8 mcn_protocol, u32 cmd_input)
+{
+	unsigned long flags;
+	u32 cecr;
+	u8 mcn_shift = 0, dev_shift = 0;
+
+	local_irq_save(flags);
+	if (cmd == QE_RESET) {
+		out_be32(&qe_immr->cp.cecr, (u32) (cmd | QE_CR_FLG));
+	} else {
+		if (cmd == QE_ASSIGN_PAGE) {
+			/* Here device is the SNUM, not sub-block */
+			dev_shift = QE_CR_SNUM_SHIFT;
+		} else if (cmd == QE_ASSIGN_RISC) {
+			/* Here device is the SNUM, and mcnProtocol is e_QeCmdRiscAssignment value */
+			dev_shift = QE_CR_SNUM_SHIFT;
+			mcn_shift = QE_CR_MCN_RISC_ASSIGN_SHIFT;
+		} else {
+			if (device == QE_CR_SUBBLOCK_USB)
+				mcn_shift = QE_CR_MCN_USB_SHIFT;
+			else
+				mcn_shift = QE_CR_MCN_NORMAL_SHIFT;
+		}
+
+		out_be32(&qe_immr->cp.cecdr,
+			 immrbar_virt_to_phys((void *)cmd_input));
+		out_be32(&qe_immr->cp.cecr,
+			 (cmd | QE_CR_FLG | ((u32) device << dev_shift) | (u32)
+			  mcn_protocol << mcn_shift));
+	}
+
+	/* wait for the QE_CR_FLG to clear */
+	do {
+		cecr = in_be32(&qe_immr->cp.cecr);
+	} while (cecr & QE_CR_FLG);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* Set a baud rate generator. This needs lots of work. There are
+ * 16 BRGs, which can be connected to the QE channels or output
+ * as clocks. The BRGs are in two different block of internal
+ * memory mapped space.
+ * The baud rate clock is the system clock divided by something.
+ * It was set up long ago during the initial boot phase and is
+ * is given to us.
+ * Baud rate clocks are zero-based in the driver code (as that maps
+ * to port numbers). Documentation uses 1-based numbering.
+ */
+#define BRG_CLK    (((bd_t *)__res)->bi_brgfreq)
+
+/* This function is used by UARTS, or anything else that uses a 16x
+ * oversampled clock.
+ */
+void qe_setbrg(uint brg, uint rate)
+{
+	volatile uint *bp;
+	u32 divisor;
+	int div16 = 0;
+
+	bp = (uint *) & qe_immr->brg.brgc1;
+	bp += brg;
+
+	divisor = (BRG_CLK / rate);
+	if (divisor > QE_BRGC_DIVISOR_MAX + 1) {
+		div16 = 1;
+		divisor /= 16;
+	}
+
+	*bp = ((divisor - 1) << QE_BRGC_DIVISOR_SHIFT) | QE_BRGC_ENABLE;
+	if (div16)
+		*bp |= QE_BRGC_DIV16;
+}
+
+static void qe_snums_init(void)
+{
+	int i;
+
+	/* Initialize the SNUMs array. */
+	for (i = 0; i < QE_NUM_OF_SNUM; i++)
+		snums[i].state = QE_SNUM_STATE_FREE;
+
+	/* Initialize SNUMs (thread serial numbers) according to QE spec chapter 4, SNUM table */
+	i = 0;
+	snums[i++].num = 0x04;
+	snums[i++].num = 0x05;
+	snums[i++].num = 0x0C;
+	snums[i++].num = 0x0D;
+	snums[i++].num = 0x14;
+	snums[i++].num = 0x15;
+	snums[i++].num = 0x1C;
+	snums[i++].num = 0x1D;
+	snums[i++].num = 0x24;
+	snums[i++].num = 0x25;
+	snums[i++].num = 0x2C;
+	snums[i++].num = 0x2D;
+	snums[i++].num = 0x34;
+	snums[i++].num = 0x35;
+	snums[i++].num = 0x88;
+	snums[i++].num = 0x89;
+	snums[i++].num = 0x98;
+	snums[i++].num = 0x99;
+	snums[i++].num = 0xA8;
+	snums[i++].num = 0xA9;
+	snums[i++].num = 0xB8;
+	snums[i++].num = 0xB9;
+	snums[i++].num = 0xC8;
+	snums[i++].num = 0xC9;
+	snums[i++].num = 0xD8;
+	snums[i++].num = 0xD9;
+	snums[i++].num = 0xE8;
+	snums[i++].num = 0xE9;
+}
+
+int qe_get_snum(void)
+{
+	unsigned long flags;
+	int snum = -EBUSY;
+	int i;
+
+	local_irq_save(flags);
+	for (i = 0; i < QE_NUM_OF_SNUM; i++) {
+		if (snums[i].state == QE_SNUM_STATE_FREE) {
+			snums[i].state = QE_SNUM_STATE_USED;
+			snum = snums[i].num;
+			break;
+		}
+	}
+	local_irq_restore(flags);
+
+	return snum;
+}
+
+EXPORT_SYMBOL(qe_get_snum);
+
+void qe_put_snum(u8 snum)
+{
+	int i;
+
+	for (i = 0; i < QE_NUM_OF_SNUM; i++) {
+		if (snums[i].num == snum) {
+			snums[i].state = QE_SNUM_STATE_FREE;
+			break;
+		}
+	}
+}
+
+EXPORT_SYMBOL(qe_put_snum);
+
+static int qe_sdma_init(void)
+{
+	sdma_t *sdma = &qe_immr->sdma;
+	uint sdma_buf_offset;
+
+	if (!sdma)
+		return -ENODEV;
+
+	/* allocate 2 internal temporary buffers (512 bytes size each) for the SDMA */
+	sdma_buf_offset = qe_muram_alloc(512 * 2, 64);
+	if (IS_MURAM_ERR(sdma_buf_offset))
+		return -ENOMEM;
+
+	out_be32(&sdma->sdebcr, sdma_buf_offset & QE_SDEBCR_BA_MASK);
+	out_be32(&sdma->sdmr, (QE_SDMR_GLB_1_MSK | (0x1 >> QE_SDMR_CEN_SHIFT)));
+
+	return 0;
+}
+
+/*
+ * muram_alloc / muram_free bits.
+ */
+static spinlock_t qe_muram_lock;
+/* 16 blocks should be enough to satisfy all requests
+ * until the memory subsystem goes up... */
+static rh_block_t qe_boot_muram_rh_block[16];
+static rh_info_t qe_muram_info;
+
+static void qe_muram_init(void)
+{
+	spin_lock_init(&qe_muram_lock);
+
+	/* initialize the info header */
+	rh_init(&qe_muram_info, 1,
+		sizeof(qe_boot_muram_rh_block) /
+		sizeof(qe_boot_muram_rh_block[0]), qe_boot_muram_rh_block);
+
+	/* Attach the usable muram area */
+	/* XXX: This is actually crap. QE_DATAONLY_BASE and
+	 * QE_DATAONLY_SIZE is only a subset of the available muram. It
+	 * varies with the processor and the microcode patches activated.
+	 * But the following should be at least safe.
+	 */
+	rh_attach_region(&qe_muram_info,
+			 (void *)QE_MURAM_DATAONLY_BASE,
+			 QE_MURAM_DATAONLY_SIZE);
+}
+
+/* This function returns an index into the MURAM area.
+ */
+uint qe_muram_alloc(uint size, uint align)
+{
+	void *start;
+	unsigned long flags;
+
+	spin_lock_irqsave(&qe_muram_lock, flags);
+	start = rh_alloc_align(&qe_muram_info, size, align, "QE");
+	spin_unlock_irqrestore(&qe_muram_lock, flags);
+
+	return (uint) start;
+}
+
+EXPORT_SYMBOL(qe_muram_alloc);
+
+int qe_muram_free(uint offset)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&qe_muram_lock, flags);
+	ret = rh_free(&qe_muram_info, (void *)offset);
+	spin_unlock_irqrestore(&qe_muram_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(qe_muram_free);
+
+/* not sure if this is ever needed */
+uint qe_muram_alloc_fixed(uint offset, uint size)
+{
+	void *start;
+	unsigned long flags;
+
+	spin_lock_irqsave(&qe_muram_lock, flags);
+	start =
+	    rh_alloc_fixed(&qe_muram_info, (void *)offset, size, "commproc");
+	spin_unlock_irqrestore(&qe_muram_lock, flags);
+
+	return (uint) start;
+}
+
+EXPORT_SYMBOL(qe_muram_alloc_fixed);
+
+void qe_muram_dump(void)
+{
+	rh_dump(&qe_muram_info);
+}
+
+EXPORT_SYMBOL(qe_muram_dump);
+
+void *qe_muram_addr(uint offset)
+{
+	return (void *)&qe_immr->muram[offset];
+}
+
+EXPORT_SYMBOL(qe_muram_addr);
Index: linux-2.6.10/arch/ppc/qe_io/ucc/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/Kconfig
@@ -0,0 +1,311 @@
+#
+# QE UCC options
+#
+
+config UCC1
+	bool "Enable QE UCC1"
+
+choice
+	prompt "UCC1 speed selection"
+	depends on UCC1
+	default UCC1_SLOW
+
+	config UCC1_SLOW
+		bool "UCC1 is slow"
+	config UCC1_FAST
+		bool "UCC1 is fast"
+endchoice
+
+menu "UCC1 Protocols options"
+	depends on UCC1
+
+	choice
+		prompt "UCC1 Slow Protocols selection"
+		depends on UCC1_SLOW
+		default UCC1_UART
+
+		config UCC1_UART
+			bool "UCC1 is UART"
+	endchoice
+
+	choice
+		prompt "UCC1 Fast Protocols selection"
+		depends on UCC1_FAST
+		default UCC1_GETH
+
+		config UCC1_GETH
+			bool "UCC1 is GETH"
+	endchoice
+endmenu
+
+config UCC2
+	bool "Enable QE UCC2"
+
+choice
+	prompt "UCC2 speed selection"
+	depends on UCC2
+	default UCC2_SLOW
+
+	config UCC2_SLOW
+		bool "UCC2 is slow"
+	config UCC2_FAST
+		bool "UCC2 is fast"
+endchoice
+
+menu "UCC2 Protocols options"
+	depends on UCC2
+
+	choice
+		prompt "UCC2 Slow Protocols selection"
+		depends on UCC2_SLOW
+		default UCC2_UART
+
+		config UCC2_UART
+			bool "UCC2 is UART"
+	endchoice
+
+	choice
+		prompt "UCC2 Fast Protocols selection"
+		depends on UCC2_FAST
+		default UCC2_GETH
+
+		config UCC2_GETH
+			bool "UCC2 is GETH"
+	endchoice
+endmenu
+
+config UCC3
+	bool "Enable QE UCC3"
+
+choice
+	prompt "UCC3 speed selection"
+	depends on UCC3
+	default UCC3_SLOW
+
+	config UCC3_SLOW
+		bool "UCC3 is slow"
+	config UCC3_FAST
+		bool "UCC3 is fast"
+endchoice
+
+menu "UCC3 Protocols options"
+	depends on UCC3
+
+	choice
+		prompt "UCC3 Slow Protocols selection"
+		depends on UCC3_SLOW
+		default UCC3_UART
+
+		config UCC3_UART
+			bool "UCC3 is UART"
+        endchoice
+
+	choice
+		prompt "UCC3 Fast Protocols selection"
+		depends on UCC3_FAST
+		default UCC3_GETH
+
+		config UCC3_GETH
+			bool "UCC3 is GETH"
+	endchoice
+endmenu
+
+config UCC4
+	bool "Enable QE UCC4"
+
+choice
+	prompt "UCC4 speed selection"
+	depends on UCC4
+	default UCC4_SLOW
+
+	config UCC4_SLOW
+		bool "UCC4 is slow"
+	config UCC4_FAST
+		bool "UCC4 is fast"
+endchoice
+
+menu "UCC4 Protocols options"
+	depends on UCC4
+
+	choice
+		prompt "UCC4 Slow Protocols selection"
+		depends on UCC4_SLOW
+		default UCC4_UART
+
+		config UCC4_UART
+			bool "UCC4 is UART"
+	endchoice
+
+	choice
+		prompt "UCC4 Fast Protocols selection"
+		depends on UCC4_FAST
+		default UCC4_GETH
+
+		config UCC4_GETH
+			bool "UCC4 is GETH"
+	endchoice
+endmenu
+
+config UCC5
+	bool "Enable QE UCC5"
+
+choice
+	prompt "UCC5 speed selection"
+	depends on UCC5
+	default UCC5_SLOW
+
+	config UCC5_SLOW
+		bool "UCC5 is slow"
+	config UCC5_FAST
+		bool "UCC5 is fast"
+endchoice
+
+menu "UCC5 Protocols options"
+	depends on UCC5
+
+	choice
+		prompt "UCC5 Slow Protocols selection"
+		depends on UCC5_SLOW
+		default UCC5_UART
+
+		config UCC5_UART
+			bool "UCC5 is UART"
+	endchoice
+
+	choice
+		prompt "UCC5 Fast Protocols selection"
+		depends on UCC5_FAST
+		default UCC5_GETH
+
+		config UCC5_GETH
+			bool "UCC5 is GETH"
+	endchoice
+endmenu
+
+config UCC6
+	bool "Enable QE UCC6"
+
+choice
+	prompt "UCC6 speed selection"
+	depends on UCC6
+	default UCC6_SLOW
+
+	config UCC6_SLOW
+		bool "UCC6 is slow"
+	config UCC6_FAST
+		bool "UCC6 is fast"
+endchoice
+
+menu "UCC6 Protocols options"
+	depends on UCC6
+
+	choice
+		prompt "UCC6 Slow Protocols selection"
+		depends on UCC6_SLOW
+		default UCC6_UART
+
+		config UCC6_UART
+			bool "UCC6 is UART"
+	endchoice
+
+	choice
+		prompt "UCC6 Fast Protocols selection"
+		depends on UCC6_FAST
+		default UCC6_GETH
+
+		config UCC6_GETH
+			bool "UCC6 is GETH"
+	endchoice
+endmenu
+
+config UCC7
+	bool "Enable QE UCC7"
+
+choice
+	prompt "UCC7 speed selection"
+	depends on UCC7
+	default UCC7_SLOW
+
+	config UCC7_SLOW
+		bool "UCC7 is slow"
+	config UCC7_FAST
+		bool "UCC7 is fast"
+endchoice
+
+menu "UCC7 Protocols options"
+	depends on UCC7
+
+	choice
+		prompt "UCC7 Slow Protocols selection"
+		depends on UCC7_SLOW
+		default UCC7_UART
+
+		config UCC7_UART
+			bool "UCC7 is UART"
+	endchoice
+
+	choice
+		prompt "UCC7 Fast Protocols selection"
+		depends on UCC7_FAST
+		default UCC7_GETH
+
+		config UCC7_GETH
+			bool "UCC7 is GETH"
+	endchoice
+endmenu
+
+config UCC8
+	bool "Enable QE UCC8"
+
+choice
+	prompt "UCC8 speed selection"
+	depends on UCC8
+	default UCC8_SLOW
+
+	config UCC8_SLOW
+		bool "UCC8 is slow"
+	config UCC8_FAST
+		bool "UCC8 is fast"
+endchoice
+
+menu "UCC8 Protocols options"
+	depends on UCC8
+
+	choice
+		prompt "UCC8 Slow Protocols selection"
+		depends on UCC8_SLOW
+		default UCC8_UART
+
+		config UCC8_UART
+			bool "UCC8 is UART"
+	endchoice
+
+	choice
+		prompt "UCC8 Fast Protocols selection"
+		depends on UCC8_FAST
+		default UCC8_GETH
+
+		config UCC8_GETH
+			bool "UCC8 is GETH"
+	endchoice
+endmenu
+
+config UCC
+	depends on UCC1 || UCC2 || UCC3 || UCC4 || UCC5 || UCC6 || UCC7 || UCC8
+	default y
+	bool
+
+config UCC_SLOW
+	depends on UCC1_SLOW || UCC2_SLOW || UCC3_SLOW || UCC4_SLOW || UCC5_SLOW || UCC6_SLOW || UCC7_SLOW || UCC8_SLOW
+	default y
+	bool
+
+config UCC_FAST
+	depends on UCC1_FAST || UCC2_FAST || UCC3_FAST || UCC4_FAST || UCC5_FAST || UCC6_FAST || UCC7_FAST || UCC8_FAST
+	default y
+	bool
+
+config UCC_GETH
+	depends on UCC1_GETH || UCC2_GETH || UCC3_GETH || UCC4_GETH || UCC5_GETH || UCC6_GETH || UCC7_GETH || UCC8_GETH
+	default y
+	bool
Index: linux-2.6.10/arch/ppc/qe_io/ucc/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux ppc-specific parts of QE UCC
+#
+obj-$(CONFIG_UCC)	+= ucc.o
+obj-$(CONFIG_UCC_SLOW)	+= ucc_slow.o
+obj-$(CONFIG_UCC_FAST)	+= ucc_fast.o ucc_slow.o
+obj-$(CONFIG_UCC_GETH)	+= ucc_geth.o ucc_geth_phy.o
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc.c
@@ -0,0 +1,322 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc.c
+ *
+ * QE UCC API Set - UCC specific routines implementations.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+
+int ucc_set_qe_mux_mii_mng(unsigned int ucc_num)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	out_be32(&qe_immr->qmx.cmxgcr,
+		 ((in_be32(&qe_immr->qmx.cmxgcr) &
+		   ~QE_CMXGCR_MII_ENET_MNG) |
+		  (ucc_num << QE_CMXGCR_MII_ENET_MNG_SHIFT)));
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+int ucc_set_type(unsigned int ucc_num, struct ucc_common *regs,
+		 enum ucc_speed_type speed)
+{
+	u8 guemr = 0;
+
+	/* check if the UCC number is in range. */
+	if (ucc_num > UCC_MAX_NUM)
+		return -EINVAL;
+
+	guemr = regs->guemr;
+	guemr &= ~(UCC_GUEMR_MODE_MASK_RX | UCC_GUEMR_MODE_MASK_TX);
+	switch (speed) {
+	case UCC_SPEED_TYPE_SLOW:
+		guemr |= (UCC_GUEMR_MODE_SLOW_RX | UCC_GUEMR_MODE_SLOW_TX);
+		break;
+	case UCC_SPEED_TYPE_FAST:
+		guemr |= (UCC_GUEMR_MODE_FAST_RX | UCC_GUEMR_MODE_FAST_TX);
+		break;
+	default:
+		return -EINVAL;
+	}
+	regs->guemr = guemr;
+
+	return 0;
+}
+
+int ucc_init_guemr(struct ucc_common *regs)
+{
+	u8 guemr = 0;
+
+	if (!regs)
+		return -EINVAL;
+
+	/* Set bit 3 (which is reserved in the GUEMR register) to 1 */
+	guemr = UCC_GUEMR_SET_RESERVED3;
+
+	regs->guemr = guemr;
+
+	return 0;
+}
+
+static void get_cmxucr_reg(unsigned int ucc_num, u8 * reg_num, u8 * shift)
+{
+	struct reg_shift {
+		u32 reg;
+		u32 shift;
+	};
+
+	static struct reg_shift rs[] = {
+		{0, 16},
+		{2, 16},
+		{0, 0},
+		{2, 0},
+		{1, 16},
+		{3, 16},
+		{1, 0},
+		{3, 0}
+	};
+
+	*reg_num = rs[ucc_num].reg;
+	*shift = rs[ucc_num].shift;
+}
+
+int ucc_mux_set_grant_tsa_bkpt(unsigned int ucc_num, int set, u32 mask)
+{
+	volatile u32 *p_cmxucr;
+	u8 reg_num;
+	u8 shift;
+
+	/* check if the UCC number is in range. */
+	if (ucc_num > UCC_MAX_NUM)
+		return -EINVAL;
+
+	get_cmxucr_reg(ucc_num, &reg_num, &shift);
+
+	p_cmxucr = &qe_immr->qmx.cmxucrx[reg_num];
+
+	if (set)
+		out_be32(p_cmxucr, in_be32(p_cmxucr) | (mask << shift));
+	else
+		out_be32(p_cmxucr, in_be32(p_cmxucr) & ~(mask << shift));
+
+	return 0;
+}
+
+int ucc_set_qe_mux_rxtx(unsigned int ucc_num, qe_clock_e clock, comm_dir_e mode)
+{
+	volatile u32 *p_cmxucr;
+	u8 reg_num;
+	u8 shift;
+	u32 clockBits;
+	u32 clockMask;
+	int source = -1;
+
+	/* check if the UCC number is in range. */
+	if (ucc_num > UCC_MAX_NUM)
+		return -EINVAL;
+
+	if (!((mode == COMM_DIR_RX) || (mode == COMM_DIR_TX))) {
+		printk(KERN_ERR
+		       "ucc_set_qe_mux_rxtx: bad comm mode type passed.");
+		return -EINVAL;
+	}
+
+	get_cmxucr_reg(ucc_num, &reg_num, &shift);
+
+	p_cmxucr = &qe_immr->qmx.cmxucrx[reg_num];
+
+	switch (reg_num) {
+	case (0):
+		switch (clock) {
+		case (QE_BRG1):
+			source = 1;
+			break;
+		case (QE_BRG2):
+			source = 2;
+			break;
+		case (QE_BRG7):
+			source = 3;
+			break;
+		case (QE_BRG8):
+			source = 4;
+			break;
+		case (QE_CLK9):
+			source = 5;
+			break;
+		case (QE_CLK10):
+			source = 6;
+			break;
+		case (QE_CLK11):
+			source = 7;
+			break;
+		case (QE_CLK12):
+			source = 8;
+			break;
+		case (QE_CLK15):
+			source = 9;
+			break;
+		case (QE_CLK16):
+			source = 10;
+			break;
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	case (1):
+		switch (clock) {
+		case (QE_BRG5):
+			source = 1;
+			break;
+		case (QE_BRG6):
+			source = 2;
+			break;
+		case (QE_BRG7):
+			source = 3;
+			break;
+		case (QE_BRG8):
+			source = 4;
+			break;
+		case (QE_CLK13):
+			source = 5;
+			break;
+		case (QE_CLK14):
+			source = 6;
+			break;
+		case (QE_CLK19):
+			source = 7;
+			break;
+		case (QE_CLK20):
+			source = 8;
+			break;
+		case (QE_CLK15):
+			source = 9;
+			break;
+		case (QE_CLK16):
+			source = 10;
+			break;
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	case (2):
+		switch (clock) {
+		case (QE_BRG9):
+			source = 1;
+			break;
+		case (QE_BRG10):
+			source = 2;
+			break;
+		case (QE_BRG15):
+			source = 3;
+			break;
+		case (QE_BRG16):
+			source = 4;
+			break;
+		case (QE_CLK3):
+			source = 5;
+			break;
+		case (QE_CLK4):
+			source = 6;
+			break;
+		case (QE_CLK17):
+			source = 7;
+			break;
+		case (QE_CLK18):
+			source = 8;
+			break;
+		case (QE_CLK7):
+			source = 9;
+			break;
+		case (QE_CLK8):
+			source = 10;
+			break;
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	case (3):
+		switch (clock) {
+		case (QE_BRG13):
+			source = 1;
+			break;
+		case (QE_BRG14):
+			source = 2;
+			break;
+		case (QE_BRG15):
+			source = 3;
+			break;
+		case (QE_BRG16):
+			source = 4;
+			break;
+		case (QE_CLK5):
+			source = 5;
+			break;
+		case (QE_CLK6):
+			source = 6;
+			break;
+		case (QE_CLK21):
+			source = 7;
+			break;
+		case (QE_CLK22):
+			source = 8;
+			break;
+		case (QE_CLK7):
+			source = 9;
+			break;
+		case (QE_CLK8):
+			source = 10;
+			break;
+		default:
+			source = -1;
+			break;
+		}
+		break;
+	default:
+		source = -1;
+		break;
+	}
+
+	if (source == -1) {
+		printk(KERN_ERR
+		       "ucc_set_qe_mux_rxtx: Bad combination of clock and UCC.");
+		return -ENOENT;
+	}
+
+	clockBits = (u32) source;
+	clockMask = QE_CMXUCR_TX_CLK_SRC_MASK;
+	if (mode == COMM_DIR_RX) {
+		clockBits <<= 4;	/* Rx field is 4 bits to left of Tx field */
+		clockMask <<= 4;	/* Rx field is 4 bits to left of Tx field */
+	}
+	clockBits <<= shift;
+	clockMask <<= shift;
+
+	out_be32(p_cmxucr, (in_be32(p_cmxucr) & ~clockMask) | clockBits);
+
+	return 0;
+}
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_fast.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_fast.c
@@ -0,0 +1,405 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_fast.c
+ *
+ * QE UCC Fast API Set - UCC Fast specific routines implementations.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+#include "ucc_fast.h"
+
+#define uccf_printk(level, format, arg...)  \
+        printk(level format "\n", ## arg)
+
+#define uccf_dbg(format, arg...)            \
+        uccf_printk(KERN_DEBUG , format , ## arg)
+#define uccf_err(format, arg...)            \
+        uccf_printk(KERN_ERR , format , ## arg)
+#define uccf_info(format, arg...)           \
+        uccf_printk(KERN_INFO , format , ## arg)
+#define uccf_warn(format, arg...)           \
+        uccf_printk(KERN_WARNING , format , ## arg)
+
+#ifdef UCCF_VERBOSE_DEBUG
+#define uccf_vdbg uccf_dbg
+#else
+#define uccf_vdbg(fmt, args...) do { } while (0)
+#endif				/* UCCF_VERBOSE_DEBUG */
+
+void ucc_fast_dump_regs(ucc_fast_private_t * uccf)
+{
+	uccf_info("UCC%d Fast registers:", uccf->uf_info->ucc_num);
+	uccf_info("Base address: 0x%08x", (u32) uccf->uf_regs);
+
+	uccf_info("gumr  : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->gumr, in_be32(&uccf->uf_regs->gumr));
+	uccf_info("upsmr : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->upsmr, in_be32(&uccf->uf_regs->upsmr));
+	uccf_info("utodr : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->utodr, in_be16(&uccf->uf_regs->utodr));
+	uccf_info("udsr  : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->udsr, in_be16(&uccf->uf_regs->udsr));
+	uccf_info("ucce  : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->ucce, in_be32(&uccf->uf_regs->ucce));
+	uccf_info("uccm  : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->uccm, in_be32(&uccf->uf_regs->uccm));
+	uccf_info("uccs  : addr - 0x%08x, val - 0x%02x",
+		  (u32) & uccf->uf_regs->uccs, uccf->uf_regs->uccs);
+	uccf_info("urfb  : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->urfb, in_be32(&uccf->uf_regs->urfb));
+	uccf_info("urfs  : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->urfs, in_be16(&uccf->uf_regs->urfs));
+	uccf_info("urfet : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->urfet, in_be16(&uccf->uf_regs->urfet));
+	uccf_info("urfset: addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->urfset,
+		  in_be16(&uccf->uf_regs->urfset));
+	uccf_info("utfb  : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->utfb, in_be32(&uccf->uf_regs->utfb));
+	uccf_info("utfs  : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->utfs, in_be16(&uccf->uf_regs->utfs));
+	uccf_info("utfet : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->utfet, in_be16(&uccf->uf_regs->utfet));
+	uccf_info("utftt : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->utftt, in_be16(&uccf->uf_regs->utftt));
+	uccf_info("utpt  : addr - 0x%08x, val - 0x%04x",
+		  (u32) & uccf->uf_regs->utpt, in_be16(&uccf->uf_regs->utpt));
+	uccf_info("urtry : addr - 0x%08x, val - 0x%08x",
+		  (u32) & uccf->uf_regs->urtry, in_be32(&uccf->uf_regs->urtry));
+	uccf_info("guemr : addr - 0x%08x, val - 0x%02x",
+		  (u32) & uccf->uf_regs->guemr, uccf->uf_regs->guemr);
+}
+
+u32 ucc_fast_get_qe_cr_subblock(int uccf_num)
+{
+	switch (uccf_num) {
+	case (0):
+		return (QE_CR_SUBBLOCK_UCCFAST1);
+	case (1):
+		return (QE_CR_SUBBLOCK_UCCFAST2);
+	case (2):
+		return (QE_CR_SUBBLOCK_UCCFAST3);
+	case (3):
+		return (QE_CR_SUBBLOCK_UCCFAST4);
+	case (4):
+		return (QE_CR_SUBBLOCK_UCCFAST5);
+	case (5):
+		return (QE_CR_SUBBLOCK_UCCFAST6);
+	case (6):
+		return (QE_CR_SUBBLOCK_UCCFAST7);
+	case (7):
+		return (QE_CR_SUBBLOCK_UCCFAST8);
+	default:
+		return QE_CR_SUBBLOCK_INVALID;
+	}
+}
+
+void ucc_fast_transmit_on_demand(ucc_fast_private_t * uccf)
+{
+	out_be16(&uccf->uf_regs->utodr, UCC_FAST_TOD);
+}
+
+void ucc_fast_enable(ucc_fast_private_t * uccf, comm_dir_e mode)
+{
+	ucc_fast_t *uf_regs;
+	u32 gumr;
+
+	uf_regs = uccf->uf_regs;
+
+	/* Enable reception and/or transmission on this UCC. */
+	gumr = in_be32(&uf_regs->gumr);
+	if (mode & COMM_DIR_TX) {
+		gumr |= UCC_FAST_GUMR_ENT;
+		uccf->enabled_tx = 1;
+	}
+	if (mode & COMM_DIR_RX) {
+		gumr |= UCC_FAST_GUMR_ENR;
+		uccf->enabled_rx = 1;
+	}
+	out_be32(&uf_regs->gumr, gumr);
+}
+
+void ucc_fast_disable(ucc_fast_private_t * uccf, comm_dir_e mode)
+{
+	ucc_fast_t *uf_regs;
+	u32 gumr;
+
+	uf_regs = uccf->uf_regs;
+
+	/* Disable reception and/or transmission on this UCC. */
+	gumr = in_be32(&uf_regs->gumr);
+	if (mode & COMM_DIR_TX) {
+		gumr &= ~UCC_FAST_GUMR_ENT;
+		uccf->enabled_tx = 0;
+	}
+	if (mode & COMM_DIR_RX) {
+		gumr &= ~UCC_FAST_GUMR_ENR;
+		uccf->enabled_rx = 0;
+	}
+	out_be32(&uf_regs->gumr, gumr);
+}
+
+int ucc_fast_init(ucc_fast_info_t * uf_info, ucc_fast_private_t ** uccf_ret)
+{
+	ucc_fast_private_t *uccf;
+	ucc_fast_t *uf_regs;
+	u32 gumr = 0;
+	int ret;
+
+	uccf_vdbg("%s: IN", __FUNCTION__);
+
+	if (!uf_info)
+		return -EINVAL;
+
+	/* check if the UCC port number is in range. */
+	if (uf_info->ucc_num > UCC_MAX_NUM) {
+		uccf_err("ucc_fast_init: Illegal UCC number!");
+		return -EINVAL;
+	}
+
+	/* Check that 'max_rx_buf_length' is properly aligned (4). */
+	if (uf_info->max_rx_buf_length & (UCC_FAST_MRBLR_ALIGNMENT - 1)) {
+		uccf_err("ucc_fast_init: max_rx_buf_length not aligned.");
+		return -EINVAL;
+	}
+
+	/* Validate Virtual Fifo register values */
+	if (uf_info->urfs < UCC_FAST_URFS_MIN_VAL) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register urfs too small.");
+		return -EINVAL;
+	}
+
+	if (uf_info->urfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register urfs not aligned.");
+		return -EINVAL;
+	}
+
+	if (uf_info->urfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register urfet not aligned.");
+		return -EINVAL;
+	}
+
+	if (uf_info->urfset & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register urfset not aligned.");
+		return -EINVAL;
+	}
+
+	if (uf_info->utfs & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register utfs not aligned.");
+		return -EINVAL;
+	}
+
+	if (uf_info->utfet & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register utfet not aligned.");
+		return -EINVAL;
+	}
+
+	if (uf_info->utftt & (UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT - 1)) {
+		uccf_err
+		    ("ucc_fast_init: Virtual Fifo register utftt not aligned.");
+		return -EINVAL;
+	}
+
+	uccf =
+	    (ucc_fast_private_t *) kmalloc(sizeof(ucc_fast_private_t),
+					   GFP_KERNEL);
+	if (!uccf) {
+		uccf_err
+		    ("ucc_fast_init: No memory for UCC slow data structure!");
+		return -ENOMEM;
+	}
+	memset(uccf, 0, sizeof(ucc_fast_private_t));
+
+	/* Fill fast UCC structure */
+	uccf->uf_info = uf_info;
+	/* Set the PHY base address */
+	uccf->uf_regs =
+	    (ucc_fast_t *) ioremap(uf_info->regs, sizeof(ucc_fast_t));
+	if (uccf->uf_regs == NULL) {
+		uccf_err
+		    ("ucc_fast_init: No memory map for UCC slow controller!");
+		return -ENOMEM;
+	}
+
+	uccf->enabled_tx = 0;
+	uccf->enabled_rx = 0;
+	uccf->stopped_tx = 0;
+	uccf->stopped_rx = 0;
+	uf_regs = uccf->uf_regs;
+	uccf->p_ucce = (u32 *) & (uf_regs->ucce);
+	uccf->p_uccm = (u32 *) & (uf_regs->uccm);
+#ifdef STATISTICS
+	uccf->tx_frames = 0;
+	uccf->rx_frames = 0;
+	uccf->rx_discarded = 0;
+#endif				/* STATISTICS */
+
+	/* Init Guemr register */
+	if ((ret = ucc_init_guemr((ucc_common_t *) (uf_regs)))) {
+		uccf_err("ucc_fast_init: Could not init the guemr register.");
+		ucc_fast_free(uccf);
+		return ret;
+	}
+
+	/* Set UCC to fast type */
+	if ((ret = ucc_set_type(uf_info->ucc_num,
+				(ucc_common_t *) (uf_regs),
+				UCC_SPEED_TYPE_FAST))) {
+		uccf_err("ucc_fast_init: Could not set type to fast.");
+		ucc_fast_free(uccf);
+		return ret;
+	}
+
+	uccf->mrblr = uf_info->max_rx_buf_length;
+
+	/* Set GUMR.                               */
+	/* For more details see the hardware spec. */
+	/* gumr starts as zero.                    */
+	if (uf_info->tci)
+		gumr |= UCC_FAST_GUMR_TCI;
+	gumr |= uf_info->ttx_trx;
+	if (uf_info->cdp)
+		gumr |= UCC_FAST_GUMR_CDP;
+	if (uf_info->ctsp)
+		gumr |= UCC_FAST_GUMR_CTSP;
+	if (uf_info->cds)
+		gumr |= UCC_FAST_GUMR_CDS;
+	if (uf_info->ctss)
+		gumr |= UCC_FAST_GUMR_CTSS;
+	if (uf_info->txsy)
+		gumr |= UCC_FAST_GUMR_TXSY;
+	if (uf_info->rsyn)
+		gumr |= UCC_FAST_GUMR_RSYN;
+	gumr |= uf_info->synl;
+	if (uf_info->rtsm)
+		gumr |= UCC_FAST_GUMR_RTSM;
+	gumr |= uf_info->renc;
+	if (uf_info->revd)
+		gumr |= UCC_FAST_GUMR_REVD;
+	gumr |= uf_info->tenc;
+	gumr |= uf_info->tcrc;
+	gumr |= uf_info->mode;
+	out_be32(&uf_regs->gumr, gumr);
+
+	/* Allocate memory for Tx Virtual Fifo */
+	uccf->ucc_fast_tx_virtual_fifo_base_offset =
+	    qe_muram_alloc(uf_info->utfs, UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);
+	if (IS_MURAM_ERR(uccf->ucc_fast_tx_virtual_fifo_base_offset)) {
+		uccf_err
+		    ("ucc_fast_init: Can not allocate MURAM memory for ucc_fast_tx_virtual_fifo_base_offset.");
+		uccf->ucc_fast_tx_virtual_fifo_base_offset = 0;
+		ucc_fast_free(uccf);
+		return -ENOMEM;
+	}
+
+	/* Allocate memory for Rx Virtual Fifo */
+	uccf->ucc_fast_rx_virtual_fifo_base_offset =
+	    qe_muram_alloc(uf_info->urfs + (u32)
+			   UCC_FAST_RECEIVE_VIRTUAL_FIFO_SIZE_FUDGE_FACTOR,
+			   UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT);
+	if (IS_MURAM_ERR(uccf->ucc_fast_rx_virtual_fifo_base_offset)) {
+		uccf_err
+		    ("ucc_fast_init: Can not allocate MURAM memory for ucc_fast_rx_virtual_fifo_base_offset.");
+		uccf->ucc_fast_rx_virtual_fifo_base_offset = 0;
+		ucc_fast_free(uccf);
+		return -ENOMEM;
+	}
+
+	/* Set Virtual Fifo registers */
+	out_be16(&uf_regs->urfs, uf_info->urfs);
+	out_be16(&uf_regs->urfet, uf_info->urfet);
+	out_be16(&uf_regs->urfset, uf_info->urfset);
+	out_be16(&uf_regs->utfs, uf_info->utfs);
+	out_be16(&uf_regs->utfet, uf_info->utfet);
+	out_be16(&uf_regs->utftt, uf_info->utftt);
+	/* utfb, urfb are offsets from MURAM base */
+	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
+	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
+
+	/* Mux clocking */
+	/* Grant Support */
+	ucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);
+	/* Breakpoint Support */
+	ucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);
+	/* Set Tsa or NMSI mode. */
+	ucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);
+	/* If NMSI (not Tsa), set Tx and Rx clock. */
+	if (!uf_info->tsa) {
+		/* Rx clock routing */
+		if (uf_info->rx_clock != QE_CLK_NONE) {
+			if (ucc_set_qe_mux_rxtx
+			    (uf_info->ucc_num, uf_info->rx_clock,
+			     COMM_DIR_RX)) {
+				uccf_err
+				    ("ucc_fast_init: Illegal value for parameter 'RxClock'.");
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+		}
+		/* Tx clock routing */
+		if (uf_info->tx_clock != QE_CLK_NONE) {
+			if (ucc_set_qe_mux_rxtx
+			    (uf_info->ucc_num, uf_info->tx_clock,
+			     COMM_DIR_TX)) {
+				uccf_err
+				    ("ucc_fast_init: Illegal value for parameter 'TxClock'.");
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+		}
+	}
+
+	/*
+	 * INTERRUPTS
+	 */
+	/* Set interrupt mask register at UCC level. */
+	out_be32(&uf_regs->uccm, uf_info->uccm_mask);
+
+	/* First, clear anything pending at UCC level, */
+	/* otherwise, old garbage may come through     */
+	/* as soon as the dam is opened.               */
+
+	/* Writing '1' clears */
+	out_be32(&uf_regs->ucce, 0xffffffff);
+
+	*uccf_ret = uccf;
+	return 0;
+}
+
+void ucc_fast_free(ucc_fast_private_t * uccf)
+{
+	if (!uccf)
+		return;
+
+	if (uccf->ucc_fast_tx_virtual_fifo_base_offset)
+		qe_muram_free(uccf->ucc_fast_tx_virtual_fifo_base_offset);
+
+	if (uccf->ucc_fast_rx_virtual_fifo_base_offset)
+		qe_muram_free(uccf->ucc_fast_rx_virtual_fifo_base_offset);
+
+	kfree(uccf);
+}
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_fast.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_fast.h
@@ -0,0 +1,246 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_fast.h
+ *
+ * Internal header file for UCC FAST unit routines.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __UCC_FAST_H__
+#define __UCC_FAST_H__
+
+#include <linux/kernel.h>
+
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+
+/* Receive BD's status.
+*/
+#define R_E     0x80000000	/* buffer empty                                   */
+#define R_W     0x20000000	/* wrap bit                                       */
+#define R_I     0x10000000	/* interrupt on reception                         */
+#define R_L     0x08000000	/* last                                           */
+#define R_F     0x04000000	/* first                                          */
+
+/* transmit BD's status.
+*/
+#define T_R     0x80000000	/* ready bit */
+#define T_W     0x20000000	/* wrap bit */
+#define T_I     0x10000000	/* interrupt on completion */
+#define T_L     0x08000000	/* last */
+
+/* Rx Data buffer must be 4 bytes aligned in most cases.*/
+#define UCC_FAST_RX_ALIGN                  4
+#define UCC_FAST_MRBLR_ALIGNMENT           4
+#define UCC_FAST_VIRT_FIFO_REGS_ALIGNMENT  8
+
+/* Sizes
+*/
+#define UCC_FAST_URFS_MIN_VAL                           0x88
+#define UCC_FAST_RECEIVE_VIRTUAL_FIFO_SIZE_FUDGE_FACTOR 8
+
+/* ucc_fast_channel_protocol_mode - UCC FAST mode.
+*/
+typedef enum ucc_fast_channel_protocol_mode {
+	UCC_FAST_PROTOCOL_MODE_HDLC = 0x00000000,
+	UCC_FAST_PROTOCOL_MODE_RESERVED01 = 0x00000001,
+	UCC_FAST_PROTOCOL_MODE_RESERVED_QMC = 0x00000002,
+	UCC_FAST_PROTOCOL_MODE_RESERVED02 = 0x00000003,
+	UCC_FAST_PROTOCOL_MODE_RESERVED_UART = 0x00000004,
+	UCC_FAST_PROTOCOL_MODE_RESERVED03 = 0x00000005,
+	UCC_FAST_PROTOCOL_MODE_RESERVED_EX_MAC_1 = 0x00000006,
+	UCC_FAST_PROTOCOL_MODE_RESERVED_EX_MAC_2 = 0x00000007,
+	UCC_FAST_PROTOCOL_MODE_RESERVED_BISYNC = 0x00000008,
+	UCC_FAST_PROTOCOL_MODE_RESERVED04 = 0x00000009,
+	UCC_FAST_PROTOCOL_MODE_ATM = 0x0000000A,
+	UCC_FAST_PROTOCOL_MODE_RESERVED05 = 0x0000000B,
+	UCC_FAST_PROTOCOL_MODE_ETHERNET = 0x0000000C,
+	UCC_FAST_PROTOCOL_MODE_RESERVED06 = 0x0000000D,
+	UCC_FAST_PROTOCOL_MODE_POS = 0x0000000E,
+	UCC_FAST_PROTOCOL_MODE_RESERVED07 = 0x0000000F
+} ucc_fast_channel_protocol_mode_e;
+
+/* ucc_fast_transparent_txrx - UCC Fast Transparent TX & RX
+*/
+typedef enum ucc_fast_transparent_txrx {
+	UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_NORMAL = 0x00000000,
+	UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_TRANSPARENT = 0x18000000	/* rx & tx transparent */
+} ucc_fast_transparent_txrx_e;
+
+/* UCC fast diagnostic mode
+*/
+typedef enum ucc_fast_diag_mode {
+	UCC_FAST_DIAGNOSTIC_NORMAL = 0x0,	/* normal             */
+	UCC_FAST_DIAGNOSTIC_LOCAL_LOOP_BACK = 0x40000000,	/* loop back          */
+	UCC_FAST_DIAGNOSTIC_AUTO_ECHO = 0x80000000,	/* echo               */
+	UCC_FAST_DIAGNOSTIC_LOOP_BACK_AND_ECHO = 0xC0000000	/* loop back and echo */
+} ucc_fast_diag_mode_e;
+
+/* UCC fast Sync length (transparent mode only)
+*/
+typedef enum ucc_fast_sync_len {
+	UCC_FAST_SYNC_LEN_NOT_USED = 0x0,	/* not used  */
+	UCC_FAST_SYNC_LEN_AUTOMATIC = 0x00004000,	/* automatic */
+	UCC_FAST_SYNC_LEN_8_BIT = 0x00008000,	/* 8 bit     */
+	UCC_FAST_SYNC_LEN_16_BIT = 0x0000C000	/* 16 bit    */
+} ucc_fast_sync_len_e;
+
+/* UCC fast RTS mode
+*/
+typedef enum ucc_fast_ready_to_send {
+	UCC_FAST_SEND_IDLES_BETWEEN_FRAMES = 0x00000000,	/* idles between frames */
+	UCC_FAST_SEND_FLAGS_BETWEEN_FRAMES = 0x00002000	/* flags between frames */
+} ucc_fast_ready_to_send_e;
+
+/* UCC fast receiver decoding mode
+*/
+typedef enum ucc_fast_rx_decoding_method {
+	UCC_FAST_RX_ENCODING_NRZ = 0x00000000,	/* nrz  */
+	UCC_FAST_RX_ENCODING_NRZI = 0x00000800,	/* nrzi */
+	UCC_FAST_RX_ENCODING_RESERVED0 = 0x00001000,	/*      */
+	UCC_FAST_RX_ENCODING_RESERVED1 = 0x00001800	/*      */
+} ucc_fast_rx_decoding_method_e;
+
+/* UCC fast transmitter encoding mode
+*/
+typedef enum ucc_fast_tx_encoding_method {
+	UCC_FAST_TX_ENCODING_NRZ = 0x00000000,	/* nrz  */
+	UCC_FAST_TX_ENCODING_NRZI = 0x00000100,	/* nrzi */
+	UCC_FAST_TX_ENCODING_RESERVED0 = 0x00000200,	/*      */
+	UCC_FAST_TX_ENCODING_RESERVED1 = 0x00000300	/*      */
+} ucc_fast_tx_encoding_method_e;
+
+/* UCC fast CRC length
+*/
+typedef enum ucc_fast_transparent_tcrc {
+	UCC_FAST_16_BIT_CRC = 0x00000000,	/* 16 bit */
+	UCC_FAST_CRC_RESERVED0 = 0x00000040,	/*        */
+	UCC_FAST_32_BIT_CRC = 0x00000080,	/* 32 bit */
+	UCC_FAST_CRC_RESERVED1 = 0x000000C0	/*        */
+} ucc_fast_transparent_tcrc_e;
+
+/* Fast UCC initialization structure.
+*/
+typedef struct ucc_fast_info {
+	uint ucc_num;
+	qe_clock_e rx_clock;
+	qe_clock_e tx_clock;
+	u32 regs;
+	int irq;
+	u32 uccm_mask;
+	int bd_mem_part;
+	int brkpt_support;
+	int grant_support;
+	int tsa;
+	int cdp;
+	int cds;
+	int ctsp;
+	int ctss;
+	int tci;
+	int txsy;
+	int rtsm;
+	int revd;
+	int rsyn;
+	u16 max_rx_buf_length;
+	u16 urfs;
+	u16 urfet;
+	u16 urfset;
+	u16 utfs;
+	u16 utfet;
+	u16 utftt;
+	u16 ufpt;
+	ucc_fast_channel_protocol_mode_e mode;
+	ucc_fast_transparent_txrx_e ttx_trx;
+	ucc_fast_tx_encoding_method_e tenc;
+	ucc_fast_rx_decoding_method_e renc;
+	ucc_fast_transparent_tcrc_e tcrc;
+	ucc_fast_sync_len_e synl;
+} ucc_fast_info_t;
+
+typedef struct ucc_fast_private {
+	ucc_fast_info_t *uf_info;
+	ucc_fast_t *uf_regs;	/* a pointer to memory map of UCC regs.                                                */
+	u32 *p_ucce;		/* a pointer to the event register in memory.                                               */
+	u32 *p_uccm;		/* a pointer to the mask register in memory.                                                */
+	int enabled_tx;		/* Whether channel is enabled for Tx (ENT)                                                  */
+	int enabled_rx;		/* Whether channel is enabled for Rx (ENR)                                                  */
+	int stopped_tx;		/* Whether channel has been stopped for Tx (STOP_TX, etc.)                                  */
+	int stopped_rx;		/* Whether channel has been stopped for Rx                                                  */
+	u32 ucc_fast_tx_virtual_fifo_base_offset;	/* pointer to base of Tx virtual fifo                                                       */
+	u32 ucc_fast_rx_virtual_fifo_base_offset;	/* pointer to base of Rx virtual fifo                                                       */
+#ifdef STATISTICS
+	u32 tx_frames;		/* Transmitted frames counter.                                                              */
+	u32 rx_frames;		/* Received frames counter (only frames passed to application).                             */
+	u32 tx_discarded;	/* Discarded tx frames counter (frames that were discarded by the driver due to errors).    */
+	u32 rx_discarded;	/* Discarded rx frames counter (frames that were discarded by the driver due to errors).    */
+#endif				/* STATISTICS */
+	u16 mrblr;		/* maximum receive buffer length */
+} ucc_fast_private_t;
+
+/* ucc_fast_init
+ * Initializes Fast UCC according to user provided parameters.
+ *
+ * @Param         uf_info  - (In) pointer to the fast UCC info structure.
+ * @Param         uccf_ret - (Out) pointer to the fast UCC structure.
+ */
+int ucc_fast_init(ucc_fast_info_t * uf_info, ucc_fast_private_t ** uccf_ret);
+
+/* ucc_fast_free
+ * Frees all resources for fast UCC.
+ *
+ * @Param         uccf - (In) pointer to the fast UCC structure.
+ */
+void ucc_fast_free(ucc_fast_private_t * uccf);
+
+/* ucc_fast_enable
+ * Enables a fast UCC port.
+ * This routine enables Tx and/or Rx through the General UCC Mode Register.
+ *
+ * @Param         uccf - (In) pointer to the fast UCC structure.
+ * @Param         mode - (In) TX, RX, or both.
+ */
+void ucc_fast_enable(ucc_fast_private_t * uccf, comm_dir_e mode);
+
+/* ucc_fast_disable
+ * Disables a fast UCC port.
+ * This routine disables Tx and/or Rx through the General UCC Mode Register.
+ *
+ * @Param         uccf - (In) pointer to the fast UCC structure.
+ * @Param         mode - (In) TX, RX, or both.
+ */
+void ucc_fast_disable(ucc_fast_private_t * uccf, comm_dir_e mode);
+
+/* ucc_fast_irq
+ * Handles interrupts on fast UCC.
+ * Called from the general interrupt routine to handle interrupts on fast UCC.
+ *
+ * @Param         uccf - (In) pointer to the fast UCC structure.
+ */
+void ucc_fast_irq(ucc_fast_private_t * uccf);
+
+/* ucc_fast_transmit_on_demand
+ * Immediately forces a poll of the transmitter for data to be sent.
+ * Typically, the hardware performs a periodic poll for data that the
+ * transmit routine has set up to be transmitted. In cases where
+ * this polling cycle is not soon enough, this optional routine can
+ * be invoked to force a poll right away, instead. Proper use for
+ * each transmission for which this functionality is desired is to
+ * call the transmit routine and then this routine right after.
+ *
+ * @Param         uccf - (In) pointer to the fast UCC structure.
+ */
+void ucc_fast_transmit_on_demand(ucc_fast_private_t * uccf);
+
+u32 ucc_fast_get_qe_cr_subblock(int uccf_num);
+
+void ucc_fast_dump_regs(ucc_fast_private_t * uccf);
+
+#endif				/* __UCC_FAST_H__ */
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth.c
@@ -0,0 +1,4315 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_geth.c
+ *
+ * QE UCC Gigabit Ethernet API Set - UCC Gigabit Ethernet specific routines implementations.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/*
+ * NOTE: Several functions were provided in the original Freescale code that
+ * were not used. They are left for reference, but are surrounded by #ifdef
+ * UCC_GETH_UNUSED.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/ethtool.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/fsl_devices.h>
+#include <linux/ethtool.h>
+
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+#include "ucc_fast.h"
+#include "ucc_geth.h"
+#include "ucc_geth_phy.h"
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc");
+MODULE_DESCRIPTION("QE UCC Gigabit Ethernet Driver");
+MODULE_LICENSE("GPL");
+
+#define DEVICE_NAME "%s: QE UCC Gigabit Ethernet Controller Version 1.1, "
+#define DRV_NAME    "ucc-geth-enet"
+
+#define ugeth_printk(level, format, arg...)  \
+        printk(level format "\n", ## arg)
+
+#define ugeth_dbg(format, arg...)            \
+        ugeth_printk(KERN_DEBUG , format , ## arg)
+#define ugeth_err(format, arg...)            \
+        ugeth_printk(KERN_ERR , format , ## arg)
+#define ugeth_info(format, arg...)           \
+        ugeth_printk(KERN_INFO , format , ## arg)
+#define ugeth_warn(format, arg...)           \
+        ugeth_printk(KERN_WARNING , format , ## arg)
+
+#ifdef UGETH_VERBOSE_DEBUG
+#define ugeth_vdbg ugeth_dbg
+#else
+#define ugeth_vdbg(fmt, args...) do { } while (0)
+#endif				/* UGETH_VERBOSE_DEBUG */
+
+static ucc_geth_info_t ugeth_primary_info = {
+	.uf_info = {
+		    .bd_mem_part = MEM_PART_SYSTEM,
+		    .brkpt_support = 0,
+		    .grant_support = 0,
+		    .tsa = 0,
+		    .cdp = 0,
+		    .cds = 0,
+		    .ctsp = 0,
+		    .ctss = 0,
+		    .tci = 0,
+		    .txsy = 0,
+		    .rtsm = UCC_FAST_SEND_IDLES_BETWEEN_FRAMES,
+		    .revd = 0,
+		    .rsyn = 0,
+		    /* following should be changed in run time for 1G and 100T! */
+		    .max_rx_buf_length = 1536,
+#if defined(CONFIG_MPC8360)
+		    .urfs = UCC_GETH_URFS_GIGA_INIT,
+		    .urfet = UCC_GETH_URFET_GIGA_INIT,
+		    .urfset = UCC_GETH_URFSET_GIGA_INIT,
+		    .utfs = UCC_GETH_UTFS_GIGA_INIT,
+		    .utfet = UCC_GETH_UTFET_GIGA_INIT,
+		    .utftt = UCC_GETH_UTFTT_GIGA_INIT,
+#elif defined(CONFIG_MPC832X)
+		    .urfs = UCC_GETH_URFS_INIT,
+		    .urfet = UCC_GETH_URFET_INIT,
+		    .urfset = UCC_GETH_URFSET_INIT,
+		    .utfs = UCC_GETH_UTFS_INIT,
+		    .utfet = UCC_GETH_UTFET_INIT,
+		    .utftt = UCC_GETH_UTFTT_INIT,
+#endif				/* defined(CONFIG_MPC8360) */
+		    .ufpt = 256,
+		    .mode = UCC_FAST_PROTOCOL_MODE_ETHERNET,
+		    .ttx_trx = UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_NORMAL,
+		    .tenc = UCC_FAST_TX_ENCODING_NRZ,
+		    .renc = UCC_FAST_RX_ENCODING_NRZ,
+		    .tcrc = UCC_FAST_16_BIT_CRC,
+		    .synl = UCC_FAST_SYNC_LEN_NOT_USED,
+		    },
+	.numQueuesTx = 1,
+	.numQueuesRx = 1,
+	.ipCheckSumCheck = 0,
+	.ipCheckSumGenerate = 0,
+	.rxExtendedFiltering = 0,
+	.extendedFilteringChainPointer = ((uint32_t) NULL),
+	.typeorlen = 3072 /*1536 */ ,
+	.dynamicMaxFrameLength = 0,
+	.dynamicMinFrameLength = 0,
+	.nonBackToBackIfgPart1 = 0x40,
+	.nonBackToBackIfgPart2 = 0x60,
+	.miminumInterFrameGapEnforcement = 0x50,
+	.backToBackInterFrameGap = 0x60,
+	.ipAddressAlignment = 0,
+	.mblinterval = 128,
+	.nortsrbytetime = 5,
+	.fracsiz = 1,
+	.strictpriorityq = 0xff,
+	.txasap = 0x00,
+	.extrabw = 0x00,
+	.miiPreambleSupress = 0,
+	.altBebTruncation = 0xa,
+	.altBeb = 0,
+	.backPressureNoBackoff = 0,
+	.noBackoff = 0,
+	.excessDefer = 1,
+	.maxRetransmission = 0xf,
+	.collisionWindow = 0x37,
+	.pro = 0,
+	.cap = 0,
+	.rsh = 0,
+	.rlpb = 0,
+	.cam = 0,
+	.bro = 0,
+	.ecm = 0,
+	.receiveFlowControl = 1,
+	.maxGroupAddrInHash = 4,
+	.maxIndAddrInHash = 4,
+	.prel = 7,
+	.maxFrameLength = 1518,
+	.minFrameLength = 64,
+	.maxD1Length = 1520,
+	.maxD2Length = 1520,
+	.vlantype = 0x8100,
+	.vlantci = 0x0000,
+	.ecamptr = ((uint32_t) NULL),
+	.eventRegMask = UCCE_OTHER,
+	.pausePeriod = 0xf000,
+	.extensionField = 0,
+	.weightfactor = {0, 0, 0, 0, 0, 0, 0, 0},
+	.interruptcoalescingmaxvalue = {1, 1, 1, 1, 1, 1, 1, 1},
+	.l2qt = {0, 0, 0, 0, 0, 0, 0, 0},
+	.l3qt = {0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0,
+		 0, 0, 0, 0, 0, 0, 0, 0},
+	.vtagtable = {0, 0, 0, 0, 0, 0, 0, 0},
+	.iphoffset = {0, 0, 0, 0, 0, 0, 0, 0},
+	.bdRingLenTx = {
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN,
+			TX_BD_RING_LEN},
+
+	.bdRingLenRx = {
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN,
+			RX_BD_RING_LEN},
+
+	.numStationAddresses = UCC_GETH_NUM_OF_STATION_ADDRESSES_1,
+	.largestexternallookupkeysize =
+	    QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE,
+	.statisticsMode = UCC_GETH_STATISTICS_GATHERING_MODE_NONE,
+	.vlanOperationTagged = UCC_GETH_VLAN_OPERATION_TAGGED_NOP,
+	.vlanOperationNonTagged = UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP,
+	.rxQoSMode = UCC_GETH_QOS_MODE_DEFAULT,
+	.aufc = UPSMR_AUTOMATIC_FLOW_CONTROL_MODE_NONE,
+	.padAndCrc = MACCFG2_PAD_AND_CRC_MODE_PAD_AND_CRC,
+	.lengthCheckRx = 0,
+	.numThreadsTx = UCC_GETH_NUM_OF_THREADS_4,
+	.numThreadsRx = UCC_GETH_NUM_OF_THREADS_4,
+	.riscTx = QE_RISC_ALLOCATION_RISC1_AND_RISC2,
+	.riscRx = QE_RISC_ALLOCATION_RISC1_AND_RISC2,
+};
+
+static ucc_geth_info_t ugeth_info[8];
+
+static void mem_disp(u8 * addr, int size)
+{
+	u8 *i;
+	int size16Aling = (size >> 4) << 4;
+	int size4Aling = (size >> 2) << 2;
+	int notAlign = 0;
+	if (size % 16)
+		notAlign = 1;
+
+	for (i = addr; (u32) i < (u32) addr + size16Aling; i += 16)
+		printk("0x%08x: %08x %08x %08x %08x\r\n",
+		       (u32) i,
+		       *((u32 *) (i)),
+		       *((u32 *) (i + 4)),
+		       *((u32 *) (i + 8)), *((u32 *) (i + 12)));
+	if (notAlign == 1)
+		printk("0x%08x: ", (u32) i);
+	for (; (u32) i < (u32) addr + size4Aling; i += 4)
+		printk("%08x ", *((u32 *) (i)));
+	for (; (u32) i < (u32) addr + size; i++)
+		printk("%02x", *((u8 *) (i)));
+	if (notAlign == 1)
+		printk("\r\n");
+}
+
+#ifdef UCC_GETH_UNUSED
+static void enqueue(struct list_head *node, struct list_head *lh)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	list_add_tail(node, lh);
+	local_irq_restore(flags);
+}
+#endif
+static struct list_head *dequeue(struct list_head *lh)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (!list_empty(lh)) {
+		struct list_head *node = lh->next;
+		list_del(node);
+		local_irq_restore(flags);
+		return node;
+	} else {
+		local_irq_restore(flags);
+		return NULL;
+	}
+}
+
+static int get_interface_details(enet_interface_e enet_interface,
+				 enet_speed_e * speed,
+				 int *r10m,
+				 int *rmm,
+				 int *rpm,
+				 int *tbi, int *limited_to_full_duplex)
+{
+	/* Analyze enet_interface according to Interface Mode Configuration table */
+	switch (enet_interface) {
+	case ENET_10_MII:
+		*speed = ENET_SPEED_10BT;
+		break;
+	case ENET_10_RMII:
+		*speed = ENET_SPEED_10BT;
+		*r10m = 1;
+		*rmm = 1;
+		break;
+	case ENET_10_RGMII:
+		*speed = ENET_SPEED_10BT;
+		*rpm = 1;
+		*r10m = 1;
+		*limited_to_full_duplex = 1;
+		break;
+	case ENET_100_MII:
+		*speed = ENET_SPEED_100BT;
+		break;
+	case ENET_100_RMII:
+		*speed = ENET_SPEED_100BT;
+		*rmm = 1;
+		break;
+	case ENET_100_RGMII:
+		*speed = ENET_SPEED_100BT;
+		*rpm = 1;
+		*limited_to_full_duplex = 1;
+		break;
+	case ENET_1000_GMII:
+		*speed = ENET_SPEED_1000BT;
+		*limited_to_full_duplex = 1;
+		break;
+	case ENET_1000_RGMII:
+		*speed = ENET_SPEED_1000BT;
+		*rpm = 1;
+		*limited_to_full_duplex = 1;
+		break;
+	case ENET_1000_TBI:
+		*speed = ENET_SPEED_1000BT;
+		*tbi = 1;
+		*limited_to_full_duplex = 1;
+		break;
+	case ENET_1000_RTBI:
+		*speed = ENET_SPEED_1000BT;
+		*rpm = 1;
+		*tbi = 1;
+		*limited_to_full_duplex = 1;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+static struct sk_buff *get_new_skb(ucc_geth_private_t * ugeth, u8 * bd)
+{
+	struct sk_buff *skb = NULL;
+	unsigned int timeout = SKB_ALLOC_TIMEOUT;
+
+	/* We have to allocate the skb, so keep trying till we succeed */
+	while ((!skb) && timeout--)
+		skb =
+		    dev_alloc_skb(ugeth->ug_info->uf_info.max_rx_buf_length +
+				  UCC_GETH_RX_DATA_BUF_ALIGNMENT);
+
+	if (skb == NULL)
+		return NULL;
+
+	/* We need the data buffer to be aligned properly.  We will reserve
+	 * as many bytes as needed to align the data properly
+	 */
+	skb_reserve(skb,
+		    UCC_GETH_RX_DATA_BUF_ALIGNMENT -
+		    (((unsigned)skb->data) & (UCC_GETH_RX_DATA_BUF_ALIGNMENT -
+					      1)));
+
+	skb->dev = ugeth->dev;
+
+	BD_BUFFER_SET(bd,
+		      dma_map_single(NULL,
+				     skb->data,
+				     ugeth->ug_info->uf_info.max_rx_buf_length +
+				     UCC_GETH_RX_DATA_BUF_ALIGNMENT,
+				     DMA_FROM_DEVICE));
+
+	BD_STATUS_AND_LENGTH_SET(bd,
+				 (R_E | R_I |
+				  (BD_STATUS_AND_LENGTH(bd) & R_W)));
+
+	return skb;
+}
+
+static int rx_bd_buffer_set(ucc_geth_private_t * ugeth, u8 rxQ)
+{
+	u8 *bd;
+	u32 bd_status;
+	struct sk_buff *skb;
+	int i;
+
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	bd = ugeth->p_rx_bd_ring[rxQ];
+	i = 0;
+
+	do {
+		bd_status = BD_STATUS_AND_LENGTH(bd);
+		skb = get_new_skb(ugeth, bd);
+
+		if (!skb)	/* If can not allocate data buffer, abort. Cleanup will be elsewhere */
+			return -ENOMEM;
+
+		ugeth->rx_skbuff[rxQ][i] = skb;
+
+		/* advance the BD pointer */
+		bd += UCC_GETH_SIZE_OF_BD;
+		i++;
+	} while (!(bd_status & R_W));
+
+	return 0;
+}
+
+static int fill_init_enet_entries(ucc_geth_private_t * ugeth,
+				  volatile u32 * p_start,
+				  u8 num_entries,
+				  u32 thread_size,
+				  u32 thread_alignment,
+				  qe_risc_allocation_e risc,
+				  int skip_page_for_first_entry)
+{
+	u32 init_enet_offset;
+	u8 i;
+	int snum;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num_entries; i++) {
+		if ((snum = qe_get_snum()) < 0) {
+			ugeth_err("fill_init_enet_entries: Can not get SNUM.");
+			return snum;
+		}
+		if ((i == 0) && skip_page_for_first_entry)	/* First entry of Rx does not have page */
+			init_enet_offset = 0;
+		else {
+			init_enet_offset =
+			    qe_muram_alloc(thread_size, thread_alignment);
+			if (IS_MURAM_ERR(init_enet_offset)) {
+				ugeth_err
+				    ("fill_init_enet_entries: Can not allocate DPRAM memory.");
+				qe_put_snum((u8) snum);
+				return -ENOMEM;
+			}
+		}
+		*(p_start++) =
+		    ((u8) snum << ENET_INIT_PARAM_SNUM_SHIFT) | init_enet_offset
+		    | risc;
+	}
+
+	return 0;
+}
+
+static int return_init_enet_entries(ucc_geth_private_t * ugeth,
+				    volatile u32 * p_start,
+				    u8 num_entries,
+				    qe_risc_allocation_e risc,
+				    int skip_page_for_first_entry)
+{
+	u32 init_enet_offset;
+	u8 i;
+	int snum;
+
+	for (i = 0; i < num_entries; i++) {
+		/* Check that this entry was actually valid -- needed in case failed in allocations */
+		if ((*p_start & ENET_INIT_PARAM_RISC_MASK) == risc) {
+			snum =
+			    (u32) (*p_start & ENET_INIT_PARAM_SNUM_MASK) >>
+			    ENET_INIT_PARAM_SNUM_SHIFT;
+			qe_put_snum((u8) snum);
+			if (!((i == 0) && skip_page_for_first_entry)) {	/* First entry of Rx does not have page */
+				init_enet_offset =
+				    (in_be32(p_start) &
+				     ENET_INIT_PARAM_PTR_MASK);
+				qe_muram_free(init_enet_offset);
+			}
+			*(p_start++) = 0;	/* Just for cosmetics */
+		}
+	}
+
+	return 0;
+}
+
+static int dump_init_enet_entries(ucc_geth_private_t * ugeth,
+				  volatile u32 * p_start,
+				  u8 num_entries,
+				  u32 thread_size,
+				  qe_risc_allocation_e risc,
+				  int skip_page_for_first_entry)
+{
+	u32 init_enet_offset;
+	u8 i;
+	int snum;
+
+	for (i = 0; i < num_entries; i++) {
+		/* Check that this entry was actually valid -- needed in case failed in allocations */
+		if ((*p_start & ENET_INIT_PARAM_RISC_MASK) == risc) {
+			snum =
+			    (u32) (*p_start & ENET_INIT_PARAM_SNUM_MASK) >>
+			    ENET_INIT_PARAM_SNUM_SHIFT;
+			qe_put_snum((u8) snum);
+			if (!((i == 0) && skip_page_for_first_entry)) {	/* First entry of Rx does not have page */
+				init_enet_offset =
+				    (in_be32(p_start) &
+				     ENET_INIT_PARAM_PTR_MASK);
+				ugeth_info("Init enet entry %d:", i);
+				ugeth_info("Base address: 0x%08x", (u32)
+					   qe_muram_addr(init_enet_offset));
+				mem_disp(qe_muram_addr(init_enet_offset),
+					 thread_size);
+			}
+			p_start++;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef UCC_GETH_UNUSED
+static enet_addr_container_t *get_enet_addr_container(void)
+{
+	enet_addr_container_t *enet_addr_cont;
+
+	/* allocate memory */
+	enet_addr_cont =
+	    (enet_addr_container_t *) kmalloc(sizeof(enet_addr_container_t),
+					      GFP_KERNEL);
+	if (!enet_addr_cont) {
+		ugeth_err("%s: No memory for enet_addr_container_t object.",
+			  __FUNCTION__);
+		return NULL;
+	}
+
+	return enet_addr_cont;
+}
+#endif
+static void put_enet_addr_container(enet_addr_container_t * enet_addr_cont)
+{
+	kfree(enet_addr_cont);
+}
+
+#ifdef UCC_GETH_UNUSED
+static int hw_add_addr_in_paddr(ucc_geth_private_t * ugeth,
+				enet_addr_t * p_enet_addr, u8 paddr_num)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+
+	if (!(paddr_num < NUM_OF_PADDRS)) {
+		ugeth_warn("%s: Illagel paddr_num.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	p_82xx_addr_filt =
+	    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->p_rx_glbl_pram->
+	    addressfiltering;
+
+	/* Ethernet frames are defined in Little Endian mode,    */
+	/* therefore to insert the address we reverse the bytes. */
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].h,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[5])) << 8)) |
+			(u16) (*p_enet_addr)[4]));
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].m,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[3])) << 8)) |
+			(u16) (*p_enet_addr)[2]));
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].l,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[1])) << 8)) |
+			(u16) (*p_enet_addr)[0]));
+
+	return 0;
+}
+#endif
+
+static int hw_clear_addr_in_paddr(ucc_geth_private_t * ugeth, u8 paddr_num)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+
+	if (!(paddr_num < NUM_OF_PADDRS)) {
+		ugeth_warn("%s: Illagel paddr_num.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	p_82xx_addr_filt =
+	    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->p_rx_glbl_pram->
+	    addressfiltering;
+
+	/* Writing address ff.ff.ff.ff.ff.ff disables address recognition for this register */
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].h, 0xffff);
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].m, 0xffff);
+	out_be16(&p_82xx_addr_filt->paddr[paddr_num].l, 0xffff);
+
+	return 0;
+}
+
+#ifdef UCC_GETH_UNUSED
+static void hw_add_addr_in_hash(ucc_geth_private_t * ugeth,
+				enet_addr_t * p_enet_addr)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+	u32 cecr_subblock;
+
+	p_82xx_addr_filt =
+	    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->p_rx_glbl_pram->
+	    addressfiltering;
+
+	cecr_subblock =
+	    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);
+
+	/* Ethernet frames are defined in Little Endian mode, therefor to insert */
+	/* the address to the hash (Big Endian mode), we reverse the bytes.      */
+	out_be16(&p_82xx_addr_filt->taddr.h,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[5])) << 8)) |
+			(u16) (*p_enet_addr)[4]));
+	out_be16(&p_82xx_addr_filt->taddr.m,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[3])) << 8)) |
+			(u16) (*p_enet_addr)[2]));
+	out_be16(&p_82xx_addr_filt->taddr.l,
+		 (u16) (((u16) (((u16) ((*p_enet_addr)[1])) << 8)) |
+			(u16) (*p_enet_addr)[0]));
+
+	qe_issue_cmd(QE_SET_GROUP_ADDRESS, cecr_subblock,
+		     (u8) QE_CR_PROTOCOL_ETHERNET, 0);
+}
+#endif
+#ifdef UCC_GETH_UNUSED
+static void magic_packet_detection_enable(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	ucc_geth_t *ug_regs;
+	u32 maccfg2, uccm;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return;
+	}
+
+	uccf = ugeth->uccf;
+	ug_regs = ugeth->ug_regs;
+
+	/* Enable interrupts for magic packet detection */
+	uccm = in_be32(uccf->p_uccm);
+	uccm |= UCCE_MPD;
+	out_be32(uccf->p_uccm, uccm);
+
+	/* Enable magic packet detection */
+	maccfg2 = in_be32(&ug_regs->maccfg2);
+	maccfg2 |= MACCFG2_MPE;
+	out_be32(&ug_regs->maccfg2, maccfg2);
+}
+
+static void magic_packet_detection_disable(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	ucc_geth_t *ug_regs;
+	u32 maccfg2, uccm;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return;
+	}
+
+	uccf = ugeth->uccf;
+	ug_regs = ugeth->ug_regs;
+
+	/* Disable interrupts for magic packet detection */
+	uccm = in_be32(uccf->p_uccm);
+	uccm &= ~UCCE_MPD;
+	out_be32(uccf->p_uccm, uccm);
+
+	/* Disable magic packet detection */
+	maccfg2 = in_be32(&ug_regs->maccfg2);
+	maccfg2 &= ~MACCFG2_MPE;
+	out_be32(&ug_regs->maccfg2, maccfg2);
+}
+#endif
+static inline int compare_addr(enet_addr_t * addr1, enet_addr_t * addr2)
+{
+	return strncmp((char *)addr1, (char *)addr2,
+		       ENET_NUM_OCTETS_PER_ADDRESS);
+}
+
+#ifdef UCC_GETH_UNUSED
+static void get_statistics(ucc_geth_private_t * ugeth,
+			   ucc_geth_tx_firmware_statistics_t *
+			   tx_firmware_statistics,
+			   ucc_geth_rx_firmware_statistics_t *
+			   rx_firmware_statistics,
+			   ucc_geth_hardware_statistics_t * hardware_statistics)
+{
+	ucc_fast_t *uf_regs;
+	ucc_geth_t *ug_regs;
+	ucc_geth_tx_firmware_statistics_pram_t *p_tx_fw_statistics_pram;
+	ucc_geth_rx_firmware_statistics_pram_t *p_rx_fw_statistics_pram;
+
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return;
+	}
+
+	ug_regs = ugeth->ug_regs;
+	uf_regs = (ucc_fast_t *) ug_regs;
+	p_tx_fw_statistics_pram = ugeth->p_tx_fw_statistics_pram;
+	p_rx_fw_statistics_pram = ugeth->p_rx_fw_statistics_pram;
+
+	/* Tx firmware only if user handed pointer and driver actually gathers Tx firmware statistics */
+	if (tx_firmware_statistics && p_tx_fw_statistics_pram) {
+		tx_firmware_statistics->sicoltx =
+		    in_be32(&p_tx_fw_statistics_pram->sicoltx);
+		tx_firmware_statistics->mulcoltx =
+		    in_be32(&p_tx_fw_statistics_pram->mulcoltx);
+		tx_firmware_statistics->latecoltxfr =
+		    in_be32(&p_tx_fw_statistics_pram->latecoltxfr);
+		tx_firmware_statistics->frabortduecol =
+		    in_be32(&p_tx_fw_statistics_pram->frabortduecol);
+		tx_firmware_statistics->frlostinmactxer =
+		    in_be32(&p_tx_fw_statistics_pram->frlostinmactxer);
+		tx_firmware_statistics->carriersenseertx =
+		    in_be32(&p_tx_fw_statistics_pram->carriersenseertx);
+		tx_firmware_statistics->frtxok =
+		    in_be32(&p_tx_fw_statistics_pram->frtxok);
+		tx_firmware_statistics->txfrexcessivedefer =
+		    in_be32(&p_tx_fw_statistics_pram->txfrexcessivedefer);
+		tx_firmware_statistics->txpkts256 =
+		    in_be32(&p_tx_fw_statistics_pram->txpkts256);
+		tx_firmware_statistics->txpkts512 =
+		    in_be32(&p_tx_fw_statistics_pram->txpkts512);
+		tx_firmware_statistics->txpkts1024 =
+		    in_be32(&p_tx_fw_statistics_pram->txpkts1024);
+		tx_firmware_statistics->txpktsjumbo =
+		    in_be32(&p_tx_fw_statistics_pram->txpktsjumbo);
+	}
+
+	/* Rx firmware only if user handed pointer and driver actually gathers Rx firmware statistics */
+	if (rx_firmware_statistics && p_rx_fw_statistics_pram) {
+		int i;
+		rx_firmware_statistics->frrxfcser =
+		    in_be32(&p_rx_fw_statistics_pram->frrxfcser);
+		rx_firmware_statistics->fraligner =
+		    in_be32(&p_rx_fw_statistics_pram->fraligner);
+		rx_firmware_statistics->inrangelenrxer =
+		    in_be32(&p_rx_fw_statistics_pram->inrangelenrxer);
+		rx_firmware_statistics->outrangelenrxer =
+		    in_be32(&p_rx_fw_statistics_pram->outrangelenrxer);
+		rx_firmware_statistics->frtoolong =
+		    in_be32(&p_rx_fw_statistics_pram->frtoolong);
+		rx_firmware_statistics->runt =
+		    in_be32(&p_rx_fw_statistics_pram->runt);
+		rx_firmware_statistics->verylongevent =
+		    in_be32(&p_rx_fw_statistics_pram->verylongevent);
+		rx_firmware_statistics->symbolerror =
+		    in_be32(&p_rx_fw_statistics_pram->symbolerror);
+		rx_firmware_statistics->dropbsy =
+		    in_be32(&p_rx_fw_statistics_pram->dropbsy);
+		for (i = 0; i < 0x8; i++)
+			rx_firmware_statistics->res0[i] =
+			    p_rx_fw_statistics_pram->res0[i];
+		rx_firmware_statistics->mismatchdrop =
+		    in_be32(&p_rx_fw_statistics_pram->mismatchdrop);
+		rx_firmware_statistics->underpkts =
+		    in_be32(&p_rx_fw_statistics_pram->underpkts);
+		rx_firmware_statistics->pkts256 =
+		    in_be32(&p_rx_fw_statistics_pram->pkts256);
+		rx_firmware_statistics->pkts512 =
+		    in_be32(&p_rx_fw_statistics_pram->pkts512);
+		rx_firmware_statistics->pkts1024 =
+		    in_be32(&p_rx_fw_statistics_pram->pkts1024);
+		rx_firmware_statistics->pktsjumbo =
+		    in_be32(&p_rx_fw_statistics_pram->pktsjumbo);
+		rx_firmware_statistics->frlossinmacer =
+		    in_be32(&p_rx_fw_statistics_pram->frlossinmacer);
+		rx_firmware_statistics->pausefr =
+		    in_be32(&p_rx_fw_statistics_pram->pausefr);
+		for (i = 0; i < 0x4; i++)
+			rx_firmware_statistics->res1[i] =
+			    p_rx_fw_statistics_pram->res1[i];
+		rx_firmware_statistics->removevlan =
+		    in_be32(&p_rx_fw_statistics_pram->removevlan);
+		rx_firmware_statistics->replacevlan =
+		    in_be32(&p_rx_fw_statistics_pram->replacevlan);
+		rx_firmware_statistics->insertvlan =
+		    in_be32(&p_rx_fw_statistics_pram->insertvlan);
+	}
+
+	/* Hardware only if user handed pointer and driver actually gathers hardware statistics */
+	if (hardware_statistics && (in_be32(&uf_regs->upsmr) & UPSMR_HSE)) {
+		hardware_statistics->tx64 = in_be32(&ug_regs->tx64);
+		hardware_statistics->tx127 = in_be32(&ug_regs->tx127);
+		hardware_statistics->tx255 = in_be32(&ug_regs->tx255);
+		hardware_statistics->rx64 = in_be32(&ug_regs->rx64);
+		hardware_statistics->rx127 = in_be32(&ug_regs->rx127);
+		hardware_statistics->rx255 = in_be32(&ug_regs->rx255);
+		hardware_statistics->txok = in_be32(&ug_regs->txok);
+		hardware_statistics->txcf = in_be16(&ug_regs->txcf);
+		hardware_statistics->tmca = in_be32(&ug_regs->tmca);
+		hardware_statistics->tbca = in_be32(&ug_regs->tbca);
+		hardware_statistics->rxfok = in_be32(&ug_regs->rxfok);
+		hardware_statistics->rxbok = in_be32(&ug_regs->rxbok);
+		hardware_statistics->rbyt = in_be32(&ug_regs->rbyt);
+		hardware_statistics->rmca = in_be32(&ug_regs->rmca);
+		hardware_statistics->rbca = in_be32(&ug_regs->rbca);
+	}
+}
+#endif
+static void dump_bds(ucc_geth_private_t * ugeth)
+{
+	int i;
+	int length;
+
+	for (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {
+		if (ugeth->p_tx_bd_ring[i]) {
+			length =
+			    (ugeth->ug_info->bdRingLenTx[i] *
+			     UCC_GETH_SIZE_OF_BD);
+			ugeth_info("TX BDs[%d]", i);
+			mem_disp(ugeth->p_tx_bd_ring[i], length);
+		}
+	}
+	for (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {
+		if (ugeth->p_rx_bd_ring[i]) {
+			length =
+			    (ugeth->ug_info->bdRingLenRx[i] *
+			     UCC_GETH_SIZE_OF_BD);
+			ugeth_info("RX BDs[%d]", i);
+			mem_disp(ugeth->p_rx_bd_ring[i], length);
+		}
+	}
+}
+
+static void dump_regs(ucc_geth_private_t * ugeth)
+{
+	int i;
+
+	ugeth_info("UCC%d Geth registers:", ugeth->ug_info->uf_info.ucc_num);
+	ugeth_info("Base address: 0x%08x", (u32) ugeth->ug_regs);
+
+	ugeth_info("maccfg1    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->maccfg1,
+		   in_be32(&ugeth->ug_regs->maccfg1));
+	ugeth_info("maccfg2    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->maccfg2,
+		   in_be32(&ugeth->ug_regs->maccfg2));
+	ugeth_info("ipgifg     : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->ipgifg,
+		   in_be32(&ugeth->ug_regs->ipgifg));
+	ugeth_info("hafdup     : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->hafdup,
+		   in_be32(&ugeth->ug_regs->hafdup));
+	ugeth_info("miimcfg    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimcfg,
+		   in_be32(&ugeth->ug_regs->miimng.miimcfg));
+	ugeth_info("miimcom    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimcom,
+		   in_be32(&ugeth->ug_regs->miimng.miimcom));
+	ugeth_info("miimadd    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimadd,
+		   in_be32(&ugeth->ug_regs->miimng.miimadd));
+	ugeth_info("miimcon    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimcon,
+		   in_be32(&ugeth->ug_regs->miimng.miimcon));
+	ugeth_info("miimstat   : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimstat,
+		   in_be32(&ugeth->ug_regs->miimng.miimstat));
+	ugeth_info("miimmind   : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->miimng.miimind,
+		   in_be32(&ugeth->ug_regs->miimng.miimind));
+	ugeth_info("ifctl      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->ifctl,
+		   in_be32(&ugeth->ug_regs->ifctl));
+	ugeth_info("ifstat     : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->ifstat,
+		   in_be32(&ugeth->ug_regs->ifstat));
+	ugeth_info("macstnaddr1: addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->macstnaddr1,
+		   in_be32(&ugeth->ug_regs->macstnaddr1));
+	ugeth_info("macstnaddr2: addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->macstnaddr2,
+		   in_be32(&ugeth->ug_regs->macstnaddr2));
+	ugeth_info("uempr      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->uempr,
+		   in_be32(&ugeth->ug_regs->uempr));
+	ugeth_info("utbipar    : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->utbipar,
+		   in_be32(&ugeth->ug_regs->utbipar));
+	ugeth_info("uescr      : addr - 0x%08x, val - 0x%04x",
+		   (u32) & ugeth->ug_regs->uescr,
+		   in_be16(&ugeth->ug_regs->uescr));
+	ugeth_info("tx64       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->tx64,
+		   in_be32(&ugeth->ug_regs->tx64));
+	ugeth_info("tx127      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->tx127,
+		   in_be32(&ugeth->ug_regs->tx127));
+	ugeth_info("tx255      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->tx255,
+		   in_be32(&ugeth->ug_regs->tx255));
+	ugeth_info("rx64       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rx64,
+		   in_be32(&ugeth->ug_regs->rx64));
+	ugeth_info("rx127      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rx127,
+		   in_be32(&ugeth->ug_regs->rx127));
+	ugeth_info("rx255      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rx255,
+		   in_be32(&ugeth->ug_regs->rx255));
+	ugeth_info("txok       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->txok,
+		   in_be32(&ugeth->ug_regs->txok));
+	ugeth_info("txcf       : addr - 0x%08x, val - 0x%04x",
+		   (u32) & ugeth->ug_regs->txcf,
+		   in_be16(&ugeth->ug_regs->txcf));
+	ugeth_info("tmca       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->tmca,
+		   in_be32(&ugeth->ug_regs->tmca));
+	ugeth_info("tbca       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->tbca,
+		   in_be32(&ugeth->ug_regs->tbca));
+	ugeth_info("rxfok      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rxfok,
+		   in_be32(&ugeth->ug_regs->rxfok));
+	ugeth_info("rxbok      : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rxbok,
+		   in_be32(&ugeth->ug_regs->rxbok));
+	ugeth_info("rbyt       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rbyt,
+		   in_be32(&ugeth->ug_regs->rbyt));
+	ugeth_info("rmca       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rmca,
+		   in_be32(&ugeth->ug_regs->rmca));
+	ugeth_info("rbca       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->rbca,
+		   in_be32(&ugeth->ug_regs->rbca));
+	ugeth_info("scar       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->scar,
+		   in_be32(&ugeth->ug_regs->scar));
+	ugeth_info("scam       : addr - 0x%08x, val - 0x%08x",
+		   (u32) & ugeth->ug_regs->scam,
+		   in_be32(&ugeth->ug_regs->scam));
+
+	if (ugeth->p_thread_data_tx) {
+		int numThreadsTxNumerical;
+		switch (ugeth->ug_info->numThreadsTx) {
+		case UCC_GETH_NUM_OF_THREADS_1:
+			numThreadsTxNumerical = 1;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_2:
+			numThreadsTxNumerical = 2;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_4:
+			numThreadsTxNumerical = 4;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_6:
+			numThreadsTxNumerical = 6;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_8:
+			numThreadsTxNumerical = 8;
+			break;
+		default:
+			numThreadsTxNumerical = 0;
+			break;
+		}
+
+		ugeth_info("Thread data TXs:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_thread_data_tx);
+		for (i = 0; i < numThreadsTxNumerical; i++) {
+			ugeth_info("Thread data TX[%d]:", i);
+			ugeth_info("Base address: 0x%08x",
+				   (u32) & ugeth->p_thread_data_tx[i]);
+			mem_disp((u8 *) & ugeth->p_thread_data_tx[i],
+				 sizeof(ucc_geth_thread_data_tx_t));
+		}
+	}
+	if (ugeth->p_thread_data_rx) {
+		int numThreadsRxNumerical;
+		switch (ugeth->ug_info->numThreadsRx) {
+		case UCC_GETH_NUM_OF_THREADS_1:
+			numThreadsRxNumerical = 1;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_2:
+			numThreadsRxNumerical = 2;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_4:
+			numThreadsRxNumerical = 4;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_6:
+			numThreadsRxNumerical = 6;
+			break;
+		case UCC_GETH_NUM_OF_THREADS_8:
+			numThreadsRxNumerical = 8;
+			break;
+		default:
+			numThreadsRxNumerical = 0;
+			break;
+		}
+
+		ugeth_info("Thread data RX:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_thread_data_rx);
+		for (i = 0; i < numThreadsRxNumerical; i++) {
+			ugeth_info("Thread data RX[%d]:", i);
+			ugeth_info("Base address: 0x%08x",
+				   (u32) & ugeth->p_thread_data_rx[i]);
+			mem_disp((u8 *) & ugeth->p_thread_data_rx[i],
+				 sizeof(ucc_geth_thread_data_rx_t));
+		}
+	}
+	if (ugeth->p_exf_glbl_param) {
+		ugeth_info("EXF global param:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_exf_glbl_param);
+		mem_disp((u8 *) ugeth->p_exf_glbl_param,
+			 sizeof(*ugeth->p_exf_glbl_param));
+	}
+	if (ugeth->p_tx_glbl_pram) {
+		ugeth_info("TX global param:");
+		ugeth_info("Base address: 0x%08x", (u32) ugeth->p_tx_glbl_pram);
+		ugeth_info("temoder      : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_tx_glbl_pram->temoder,
+			   in_be16(&ugeth->p_tx_glbl_pram->temoder));
+		ugeth_info("sqptr        : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->sqptr,
+			   in_be32(&ugeth->p_tx_glbl_pram->sqptr));
+		ugeth_info("schedulerbasepointer: addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->schedulerbasepointer,
+			   in_be32(&ugeth->p_tx_glbl_pram->
+				   schedulerbasepointer));
+		ugeth_info("txrmonbaseptr: addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->txrmonbaseptr,
+			   in_be32(&ugeth->p_tx_glbl_pram->txrmonbaseptr));
+		ugeth_info("tstate       : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->tstate,
+			   in_be32(&ugeth->p_tx_glbl_pram->tstate));
+		ugeth_info("iphoffset[0] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[0],
+			   ugeth->p_tx_glbl_pram->iphoffset[0]);
+		ugeth_info("iphoffset[1] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[1],
+			   ugeth->p_tx_glbl_pram->iphoffset[1]);
+		ugeth_info("iphoffset[2] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[2],
+			   ugeth->p_tx_glbl_pram->iphoffset[2]);
+		ugeth_info("iphoffset[3] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[3],
+			   ugeth->p_tx_glbl_pram->iphoffset[3]);
+		ugeth_info("iphoffset[4] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[4],
+			   ugeth->p_tx_glbl_pram->iphoffset[4]);
+		ugeth_info("iphoffset[5] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[5],
+			   ugeth->p_tx_glbl_pram->iphoffset[5]);
+		ugeth_info("iphoffset[6] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[6],
+			   ugeth->p_tx_glbl_pram->iphoffset[6]);
+		ugeth_info("iphoffset[7] : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_tx_glbl_pram->iphoffset[7],
+			   ugeth->p_tx_glbl_pram->iphoffset[7]);
+		ugeth_info("vtagtable[0] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[0],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[0]));
+		ugeth_info("vtagtable[1] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[1],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[1]));
+		ugeth_info("vtagtable[2] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[2],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[2]));
+		ugeth_info("vtagtable[3] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[3],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[3]));
+		ugeth_info("vtagtable[4] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[4],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[4]));
+		ugeth_info("vtagtable[5] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[5],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[5]));
+		ugeth_info("vtagtable[6] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[6],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[6]));
+		ugeth_info("vtagtable[7] : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->vtagtable[7],
+			   in_be32(&ugeth->p_tx_glbl_pram->vtagtable[7]));
+		ugeth_info("tqptr        : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_tx_glbl_pram->tqptr,
+			   in_be32(&ugeth->p_tx_glbl_pram->tqptr));
+	}
+	if (ugeth->p_rx_glbl_pram) {
+		ugeth_info("RX global param:");
+		ugeth_info("Base address: 0x%08x", (u32) ugeth->p_rx_glbl_pram);
+		ugeth_info("remoder         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->remoder,
+			   in_be32(&ugeth->p_rx_glbl_pram->remoder));
+		ugeth_info("rqptr           : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->rqptr,
+			   in_be32(&ugeth->p_rx_glbl_pram->rqptr));
+		ugeth_info("typeorlen       : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->typeorlen,
+			   in_be16(&ugeth->p_rx_glbl_pram->typeorlen));
+		ugeth_info("rxgstpack       : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_rx_glbl_pram->rxgstpack,
+			   ugeth->p_rx_glbl_pram->rxgstpack);
+		ugeth_info("rxrmonbaseptr   : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->rxrmonbaseptr,
+			   in_be32(&ugeth->p_rx_glbl_pram->rxrmonbaseptr));
+		ugeth_info("intcoalescingptr: addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->intcoalescingptr,
+			   in_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr));
+		ugeth_info("rstate          : addr - 0x%08x, val - 0x%02x",
+			   (u32) & ugeth->p_rx_glbl_pram->rstate,
+			   ugeth->p_rx_glbl_pram->rstate);
+		ugeth_info("mrblr           : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->mrblr,
+			   in_be16(&ugeth->p_rx_glbl_pram->mrblr));
+		ugeth_info("rbdqptr         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->rbdqptr,
+			   in_be32(&ugeth->p_rx_glbl_pram->rbdqptr));
+		ugeth_info("mflr            : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->mflr,
+			   in_be16(&ugeth->p_rx_glbl_pram->mflr));
+		ugeth_info("minflr          : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->minflr,
+			   in_be16(&ugeth->p_rx_glbl_pram->minflr));
+		ugeth_info("maxd1           : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->maxd1,
+			   in_be16(&ugeth->p_rx_glbl_pram->maxd1));
+		ugeth_info("maxd2           : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->maxd2,
+			   in_be16(&ugeth->p_rx_glbl_pram->maxd2));
+		ugeth_info("ecamptr         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->ecamptr,
+			   in_be32(&ugeth->p_rx_glbl_pram->ecamptr));
+		ugeth_info("l2qt            : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l2qt,
+			   in_be32(&ugeth->p_rx_glbl_pram->l2qt));
+		ugeth_info("l3qt[0]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[0],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[0]));
+		ugeth_info("l3qt[1]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[1],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[1]));
+		ugeth_info("l3qt[2]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[2],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[2]));
+		ugeth_info("l3qt[3]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[3],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[3]));
+		ugeth_info("l3qt[4]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[4],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[4]));
+		ugeth_info("l3qt[5]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[5],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[5]));
+		ugeth_info("l3qt[6]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[6],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[6]));
+		ugeth_info("l3qt[7]         : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->l3qt[7],
+			   in_be32(&ugeth->p_rx_glbl_pram->l3qt[7]));
+		ugeth_info("vlantype        : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->vlantype,
+			   in_be16(&ugeth->p_rx_glbl_pram->vlantype));
+		ugeth_info("vlantci         : addr - 0x%08x, val - 0x%04x",
+			   (u32) & ugeth->p_rx_glbl_pram->vlantci,
+			   in_be16(&ugeth->p_rx_glbl_pram->vlantci));
+		for (i = 0; i < 64; i++)
+			ugeth_info
+			    ("addressfiltering[%d]: addr - 0x%08x, val - 0x%02x",
+			     i,
+			     (u32) & ugeth->p_rx_glbl_pram->addressfiltering[i],
+			     ugeth->p_rx_glbl_pram->addressfiltering[i]);
+		ugeth_info("exfGlobalParam  : addr - 0x%08x, val - 0x%08x",
+			   (u32) & ugeth->p_rx_glbl_pram->exfGlobalParam,
+			   in_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam));
+	}
+	if (ugeth->p_send_q_mem_reg) {
+		ugeth_info("Send Q memory registers:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_send_q_mem_reg);
+		for (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {
+			ugeth_info("SQQD[%d]:", i);
+			ugeth_info("Base address: 0x%08x",
+				   (u32) & ugeth->p_send_q_mem_reg->sqqd[i]);
+			mem_disp((u8 *) & ugeth->p_send_q_mem_reg->sqqd[i],
+				 sizeof(ucc_geth_send_queue_qd_t));
+		}
+	}
+	if (ugeth->p_scheduler) {
+		ugeth_info("Scheduler:");
+		ugeth_info("Base address: 0x%08x", (u32) ugeth->p_scheduler);
+		mem_disp((u8 *) ugeth->p_scheduler,
+			 sizeof(*ugeth->p_scheduler));
+	}
+	if (ugeth->p_tx_fw_statistics_pram) {
+		ugeth_info("TX FW statistics pram:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_tx_fw_statistics_pram);
+		mem_disp((u8 *) ugeth->p_tx_fw_statistics_pram,
+			 sizeof(*ugeth->p_tx_fw_statistics_pram));
+	}
+	if (ugeth->p_rx_fw_statistics_pram) {
+		ugeth_info("RX FW statistics pram:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_rx_fw_statistics_pram);
+		mem_disp((u8 *) ugeth->p_rx_fw_statistics_pram,
+			 sizeof(*ugeth->p_rx_fw_statistics_pram));
+	}
+	if (ugeth->p_rx_irq_coalescing_tbl) {
+		ugeth_info("RX IRQ coalescing tables:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_rx_irq_coalescing_tbl);
+		for (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {
+			ugeth_info("RX IRQ coalescing table entry[%d]:", i);
+			ugeth_info("Base address: 0x%08x",
+				   (u32) & ugeth->p_rx_irq_coalescing_tbl->
+				   coalescingentry[i]);
+			ugeth_info
+			    ("interruptcoalescingmaxvalue: addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_irq_coalescing_tbl->
+			     coalescingentry[i].interruptcoalescingmaxvalue,
+			     in_be32(&ugeth->p_rx_irq_coalescing_tbl->
+				     coalescingentry[i].
+				     interruptcoalescingmaxvalue));
+			ugeth_info
+			    ("interruptcoalescingcounter : addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_irq_coalescing_tbl->
+			     coalescingentry[i].interruptcoalescingcounter,
+			     in_be32(&ugeth->p_rx_irq_coalescing_tbl->
+				     coalescingentry[i].
+				     interruptcoalescingcounter));
+		}
+	}
+	if (ugeth->p_rx_bd_qs_tbl) {
+		ugeth_info("RX BD QS tables:");
+		ugeth_info("Base address: 0x%08x", (u32) ugeth->p_rx_bd_qs_tbl);
+		for (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {
+			ugeth_info("RX BD QS table[%d]:", i);
+			ugeth_info("Base address: 0x%08x",
+				   (u32) & ugeth->p_rx_bd_qs_tbl[i]);
+			ugeth_info
+			    ("bdbaseptr        : addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_bd_qs_tbl[i].bdbaseptr,
+			     in_be32(&ugeth->p_rx_bd_qs_tbl[i].bdbaseptr));
+			ugeth_info
+			    ("bdptr            : addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_bd_qs_tbl[i].bdptr,
+			     in_be32(&ugeth->p_rx_bd_qs_tbl[i].bdptr));
+			ugeth_info
+			    ("externalbdbaseptr: addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,
+			     in_be32(&ugeth->p_rx_bd_qs_tbl[i].
+				     externalbdbaseptr));
+			ugeth_info
+			    ("externalbdptr    : addr - 0x%08x, val - 0x%08x",
+			     (u32) & ugeth->p_rx_bd_qs_tbl[i].externalbdptr,
+			     in_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdptr));
+			ugeth_info("ucode RX Prefetched BDs:");
+			ugeth_info("Base address: 0x%08x", (u32)
+				   qe_muram_addr(in_be32
+						 (&ugeth->p_rx_bd_qs_tbl[i].
+						  bdbaseptr)));
+			mem_disp((u8 *)
+				 qe_muram_addr(in_be32
+					       (&ugeth->p_rx_bd_qs_tbl[i].
+						bdbaseptr)),
+				 sizeof(ucc_geth_rx_prefetched_bds_t));
+		}
+	}
+	if (ugeth->p_init_enet_param_shadow) {
+		int size;
+		ugeth_info("Init enet param shadow:");
+		ugeth_info("Base address: 0x%08x",
+			   (u32) ugeth->p_init_enet_param_shadow);
+		mem_disp((u8 *) ugeth->p_init_enet_param_shadow,
+			 sizeof(*ugeth->p_init_enet_param_shadow));
+
+		size = sizeof(ucc_geth_thread_rx_pram_t);
+		if (ugeth->ug_info->rxExtendedFiltering) {
+			size +=
+			    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;
+			if (ugeth->ug_info->largestexternallookupkeysize ==
+			    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES)
+				size +=
+				    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;
+			if (ugeth->ug_info->largestexternallookupkeysize ==
+			    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES)
+				size +=
+				    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;
+		}
+
+		dump_init_enet_entries(ugeth,
+				       &(ugeth->p_init_enet_param_shadow->
+					 txthread[0]),
+				       ENET_INIT_PARAM_MAX_ENTRIES_TX,
+				       sizeof(ucc_geth_thread_tx_pram_t),
+				       ugeth->ug_info->riscTx, 0);
+		dump_init_enet_entries(ugeth,
+				       &(ugeth->p_init_enet_param_shadow->
+					 rxthread[0]),
+				       ENET_INIT_PARAM_MAX_ENTRIES_RX, size,
+				       ugeth->ug_info->riscRx, 1);
+	}
+}
+
+static void init_default_reg_vals(volatile u32 * upsmr_register,
+				  volatile u32 * maccfg1_register,
+				  volatile u32 * maccfg2_register)
+{
+	out_be32(upsmr_register, UCC_GETH_UPSMR_INIT);
+	out_be32(maccfg1_register, UCC_GETH_MACCFG1_INIT);
+	out_be32(maccfg2_register, UCC_GETH_MACCFG2_INIT);
+}
+
+static int init_half_duplex_params(int alt_beb,
+				   int back_pressure_no_backoff,
+				   int no_backoff,
+				   int excess_defer,
+				   u8 alt_beb_truncation,
+				   u8 max_retransmissions,
+				   u8 collision_window,
+				   volatile u32 * hafdup_register)
+{
+	u32 value = 0;
+
+	if ((alt_beb_truncation > HALFDUP_ALT_BEB_TRUNCATION_MAX) ||
+	    (max_retransmissions > HALFDUP_MAX_RETRANSMISSION_MAX) ||
+	    (collision_window > HALFDUP_COLLISION_WINDOW_MAX))
+		return -EINVAL;
+
+	value = (u32) (alt_beb_truncation << HALFDUP_ALT_BEB_TRUNCATION_SHIFT);
+
+	if (alt_beb)
+		value |= HALFDUP_ALT_BEB;
+	if (back_pressure_no_backoff)
+		value |= HALFDUP_BACK_PRESSURE_NO_BACKOFF;
+	if (no_backoff)
+		value |= HALFDUP_NO_BACKOFF;
+	if (excess_defer)
+		value |= HALFDUP_EXCESSIVE_DEFER;
+
+	value |= (max_retransmissions << HALFDUP_MAX_RETRANSMISSION_SHIFT);
+
+	value |= collision_window;
+
+	out_be32(hafdup_register, value);
+	return 0;
+}
+
+static int init_inter_frame_gap_params(u8 non_btb_cs_ipg,
+				       u8 non_btb_ipg,
+				       u8 min_ifg,
+				       u8 btb_ipg,
+				       volatile u32 * ipgifg_register)
+{
+	u32 value = 0;
+
+	/* Non-Back-to-back IPG part 1 should be <= Non-Back-to-back IPG part 2 */
+	if (non_btb_cs_ipg > non_btb_ipg)
+		return -EINVAL;
+
+	if ((non_btb_cs_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART1_MAX) ||
+	    (non_btb_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART2_MAX) ||
+	    /*(min_ifg        > IPGIFG_MINIMUM_IFG_ENFORCEMENT_MAX) || */
+	    (btb_ipg > IPGIFG_BACK_TO_BACK_IFG_MAX))
+		return -EINVAL;
+
+	value |=
+	    ((non_btb_cs_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART1_SHIFT) &
+	     IPGIFG_NBTB_CS_IPG_MASK);
+	value |=
+	    ((non_btb_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART2_SHIFT) &
+	     IPGIFG_NBTB_IPG_MASK);
+	value |=
+	    ((min_ifg << IPGIFG_MINIMUM_IFG_ENFORCEMENT_SHIFT) &
+	     IPGIFG_MIN_IFG_MASK);
+	value |= (btb_ipg & IPGIFG_BTB_IPG_MASK);
+
+	out_be32(ipgifg_register, value);
+	return 0;
+}
+
+static int init_flow_control_params(u32 automatic_flow_control_mode,
+				    int rx_flow_control_enable,
+				    int tx_flow_control_enable,
+				    u16 pause_period,
+				    u16 extension_field,
+				    volatile u32 * upsmr_register,
+				    volatile u32 * uempr_register,
+				    volatile u32 * maccfg1_register)
+{
+	u32 value = 0;
+
+	/* Set UEMPR register */
+	value = (u32) pause_period << UEMPR_PAUSE_TIME_VALUE_SHIFT;
+	value |= (u32) extension_field << UEMPR_EXTENDED_PAUSE_TIME_VALUE_SHIFT;
+	out_be32(uempr_register, value);
+
+	/* Set UPSMR register */
+	value = in_be32(upsmr_register);
+	value |= automatic_flow_control_mode;
+	out_be32(upsmr_register, value);
+
+	value = in_be32(maccfg1_register);
+	if (rx_flow_control_enable)
+		value |= MACCFG1_FLOW_RX;
+	if (tx_flow_control_enable)
+		value |= MACCFG1_FLOW_TX;
+	out_be32(maccfg1_register, value);
+
+	return 0;
+}
+
+static int init_hw_statistics_gathering_mode(int enable_hardware_statistics,
+					     int auto_zero_hardware_statistics,
+					     volatile u32 * upsmr_register,
+					     volatile u16 * uescr_register)
+{
+	u32 upsmr_value = 0;
+	u16 uescr_value = 0;
+	/* Enable hardware statistics gathering if requested */
+	if (enable_hardware_statistics) {
+		upsmr_value = in_be32(upsmr_register);
+		upsmr_value |= UPSMR_HSE;
+		out_be32(upsmr_register, upsmr_value);
+	}
+
+	/* Clear hardware statistics counters */
+	uescr_value = in_be16(uescr_register);
+	uescr_value |= UESCR_CLRCNT;
+	/* Automatically zero hardware statistics counters on read, if requested */
+	if (auto_zero_hardware_statistics)
+		uescr_value |= UESCR_AUTOZ;
+	out_be16(uescr_register, uescr_value);
+
+	return 0;
+}
+
+static int init_firmware_statistics_gathering_mode(int
+						   enable_tx_firmware_statistics,
+						   int
+						   enable_rx_firmware_statistics,
+						   volatile u32 *
+						   tx_rmon_base_ptr,
+						   u32
+						   tx_firmware_statistics_structure_address,
+						   volatile u32 *
+						   rx_rmon_base_ptr,
+						   u32
+						   rx_firmware_statistics_structure_address,
+						   volatile u16 *
+						   temoder_register,
+						   volatile u32 *
+						   remoder_register)
+{
+	/* Note: this function does not check if */
+	/* the parameters it receives are NULL   */
+	u16 temoder_value;
+	u32 remoder_value;
+
+	if (enable_tx_firmware_statistics) {
+		out_be32(tx_rmon_base_ptr,
+			 tx_firmware_statistics_structure_address);
+		temoder_value = in_be16(temoder_register);
+		temoder_value |= TEMODER_TX_RMON_STATISTICS_ENABLE;
+		out_be16(temoder_register, temoder_value);
+	}
+
+	if (enable_rx_firmware_statistics) {
+		out_be32(rx_rmon_base_ptr,
+			 rx_firmware_statistics_structure_address);
+		remoder_value = in_be32(remoder_register);
+		remoder_value |= REMODER_RX_RMON_STATISTICS_ENABLE;
+		out_be32(remoder_register, remoder_value);
+	}
+
+	return 0;
+}
+
+static int init_mac_station_addr_regs(u8 address_byte_0,
+				      u8 address_byte_1,
+				      u8 address_byte_2,
+				      u8 address_byte_3,
+				      u8 address_byte_4,
+				      u8 address_byte_5,
+				      volatile u32 * macstnaddr1_register,
+				      volatile u32 * macstnaddr2_register)
+{
+	u32 value = 0;
+
+	/* Example: for a station address of 0x12345678ABCD, */
+	/* 0x12 is byte 0, 0x34 is byte 1 and so on and 0xCD is byte 5 */
+
+	/* MACSTNADDR1 Register: */
+
+	/* 0                      7   8                      15  */
+	/* station address byte 5     station address byte 4     */
+	/* 16                     23  24                     31  */
+	/* station address byte 3     station address byte 2     */
+	value |= (u32) ((address_byte_2 << 0) & 0x000000FF);
+	value |= (u32) ((address_byte_3 << 8) & 0x0000FF00);
+	value |= (u32) ((address_byte_4 << 16) & 0x00FF0000);
+	value |= (u32) ((address_byte_5 << 24) & 0xFF000000);
+
+	out_be32(macstnaddr1_register, value);
+
+	/* MACSTNADDR2 Register: */
+
+	/* 0                      7   8                      15  */
+	/* station address byte 1     station address byte 0     */
+	/* 16                     23  24                     31  */
+	/*         reserved                   reserved           */
+	value = 0;
+	value |= (u32) ((address_byte_0 << 16) & 0x00FF0000);
+	value |= (u32) ((address_byte_1 << 24) & 0xFF000000);
+
+	out_be32(macstnaddr2_register, value);
+
+	return 0;
+}
+
+static int init_mac_duplex_mode(int full_duplex,
+				int limited_to_full_duplex,
+				volatile u32 * maccfg2_register)
+{
+	u32 value = 0;
+
+	/* some interfaces must work in full duplex mode */
+	if ((full_duplex == 0) && (limited_to_full_duplex == 1))
+		return -EINVAL;
+
+	value = in_be32(maccfg2_register);
+
+	if (full_duplex)
+		value |= MACCFG2_FDX;
+	else
+		value &= ~MACCFG2_FDX;
+
+	out_be32(maccfg2_register, value);
+	return 0;
+}
+
+static int init_check_frame_length_mode(int length_check,
+					volatile u32 * maccfg2_register)
+{
+	u32 value = 0;
+
+	value = in_be32(maccfg2_register);
+
+	if (length_check)
+		value |= MACCFG2_LC;
+	else
+		value &= ~MACCFG2_LC;
+
+	out_be32(maccfg2_register, value);
+	return 0;
+}
+
+static int init_preamble_length(u8 preamble_length,
+				volatile u32 * maccfg2_register)
+{
+	u32 value = 0;
+
+	if ((preamble_length < 3) || (preamble_length > 7))
+		return -EINVAL;
+
+	value = in_be32(maccfg2_register);
+	value &= ~MACCFG2_PREL_MASK;
+	value |= (preamble_length << MACCFG2_PREL_SHIFT);
+	out_be32(maccfg2_register, value);
+	return 0;
+}
+
+static int init_mii_management_configuration(int reset_mgmt,
+					     int preamble_supress,
+					     volatile u32 * miimcfg_register,
+					     volatile u32 * miimind_register)
+{
+	unsigned int timeout = PHY_INIT_TIMEOUT;
+	u32 value = 0;
+
+	value = in_be32(miimcfg_register);
+	if (reset_mgmt) {
+		value |= MIIMCFG_RESET_MANAGEMENT;
+		out_be32(miimcfg_register, value);
+	}
+
+	value = 0;
+
+	if (preamble_supress)
+		value |= MIIMCFG_NO_PREAMBLE;
+
+	value |= UCC_GETH_MIIMCFG_MNGMNT_CLC_DIV_INIT;
+	out_be32(miimcfg_register, value);
+
+	/* Wait until the bus is free */
+	while ((in_be32(miimind_register) & MIIMIND_BUSY) && timeout--)
+		cpu_relax();
+
+	if (timeout <= 0) {
+		ugeth_err("%s: The MII Bus is stuck!", __FUNCTION__);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int init_rx_parameters(int reject_broadcast,
+			      int receive_short_frames,
+			      int promiscuous, volatile u32 * upsmr_register)
+{
+	u32 value = 0;
+
+	value = in_be32(upsmr_register);
+
+	if (reject_broadcast)
+		value |= UPSMR_BRO;
+	else
+		value &= ~UPSMR_BRO;
+
+	if (receive_short_frames)
+		value |= UPSMR_RSH;
+	else
+		value &= ~UPSMR_RSH;
+
+	if (promiscuous)
+		value |= UPSMR_PRO;
+	else
+		value &= ~UPSMR_PRO;
+
+	out_be32(upsmr_register, value);
+
+	return 0;
+}
+
+static int init_max_rx_buff_len(u16 max_rx_buf_len,
+				volatile u16 * mrblr_register)
+{
+	/* max_rx_buf_len value must be a multiple of 128 */
+	if ((max_rx_buf_len == 0)
+	    || (max_rx_buf_len % UCC_GETH_MRBLR_ALIGNMENT))
+		return -EINVAL;
+
+	out_be16(mrblr_register, max_rx_buf_len);
+	return 0;
+}
+
+static int init_min_frame_len(u16 min_frame_length,
+			      volatile u16 * minflr_register,
+			      volatile u16 * mrblr_register)
+{
+	u16 mrblr_value = 0;
+
+	mrblr_value = in_be16(mrblr_register);
+	if (min_frame_length >= (mrblr_value - 4))
+		return -EINVAL;
+
+	out_be16(minflr_register, min_frame_length);
+	return 0;
+}
+
+static int adjust_enet_interface(ucc_geth_private_t * ugeth)
+{
+	ucc_geth_info_t *ug_info;
+	ucc_geth_t *ug_regs;
+	ucc_fast_t *uf_regs;
+	enet_speed_e speed;
+	int ret_val, rpm = 0, tbi = 0, r10m = 0, rmm =
+	    0, limited_to_full_duplex = 0;
+	u32 upsmr, maccfg2, utbipar, tbiBaseAddress;
+	u16 value;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	/* Check some parameters */
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ug_info = ugeth->ug_info;
+	ug_regs = ugeth->ug_regs;
+	uf_regs = ugeth->uccf->uf_regs;
+
+	/* Analyze enet_interface according to Interface Mode Configuration table */
+	ret_val =
+	    get_interface_details(ug_info->enet_interface, &speed, &r10m, &rmm,
+				  &rpm, &tbi, &limited_to_full_duplex);
+	if (ret_val != 0) {
+		ugeth_err
+		    ("%s: half duplex not supported in requested configuration.",
+		     __FUNCTION__);
+		return ret_val;
+	}
+
+	/*                    Set MACCFG2                    */
+	maccfg2 = in_be32(&ug_regs->maccfg2);
+	maccfg2 &= ~MACCFG2_INTERFACE_MODE_MASK;
+	if ((speed == ENET_SPEED_10BT) || (speed == ENET_SPEED_100BT))
+		maccfg2 |= MACCFG2_INTERFACE_MODE_NIBBLE;
+	else if (speed == ENET_SPEED_1000BT)
+		maccfg2 |= MACCFG2_INTERFACE_MODE_BYTE;
+	maccfg2 |= ug_info->padAndCrc;
+	out_be32(&ug_regs->maccfg2, maccfg2);
+
+	/*                    Set UPSMR                      */
+	upsmr = in_be32(&uf_regs->upsmr);
+	upsmr &= ~(UPSMR_RPM | UPSMR_R10M | UPSMR_TBIM | UPSMR_RMM);
+	if (rpm)
+		upsmr |= UPSMR_RPM;
+	if (r10m)
+		upsmr |= UPSMR_R10M;
+	if (tbi)
+		upsmr |= UPSMR_TBIM;
+	if (rmm)
+		upsmr |= UPSMR_RMM;
+	out_be32(&uf_regs->upsmr, upsmr);
+
+	/*                    Set UTBIPAR                    */
+	utbipar = in_be32(&ug_regs->utbipar);
+	utbipar &= ~UTBIPAR_PHY_ADDRESS_MASK;
+	if (tbi)
+		utbipar |=
+		    (ug_info->phy_address +
+		     ugeth->ug_info->uf_info.
+		     ucc_num) << UTBIPAR_PHY_ADDRESS_SHIFT;
+	else
+		utbipar |=
+		    (0x10 +
+		     ugeth->ug_info->uf_info.
+		     ucc_num) << UTBIPAR_PHY_ADDRESS_SHIFT;
+	out_be32(&ug_regs->utbipar, utbipar);
+
+	/* Disable autonegotiation in tbi mode, because by default it comes up in autonegotiation mode. */
+	/* Note that this depends on proper setting in utbipar register. */
+	if (tbi) {
+		tbiBaseAddress = in_be32(&ug_regs->utbipar);
+		tbiBaseAddress &= UTBIPAR_PHY_ADDRESS_MASK;
+		tbiBaseAddress >>= UTBIPAR_PHY_ADDRESS_SHIFT;
+		value =
+		    ugeth->mii_info->mdio_read(ugeth->dev, (u8) tbiBaseAddress,
+					       ENET_TBI_MII_CR);
+		value &= ~0x1000;	/* Turn off autonegotiation */
+		ugeth->mii_info->mdio_write(ugeth->dev, (u8) tbiBaseAddress,
+					    ENET_TBI_MII_CR, value);
+	}
+
+	ret_val = init_mac_duplex_mode(1,
+				       limited_to_full_duplex,
+				       &ug_regs->maccfg2);
+	if (ret_val != 0) {
+		ugeth_err
+		    ("%s: half duplex not supported in requested configuration.",
+		     __FUNCTION__);
+		return ret_val;
+	}
+
+	init_check_frame_length_mode(ug_info->lengthCheckRx, &ug_regs->maccfg2);
+
+	ret_val = init_preamble_length(ug_info->prel, &ug_regs->maccfg2);
+	if (ret_val != 0) {
+		ugeth_err
+		    ("%s: Preamble length must be between 3 and 7 inclusive.",
+		     __FUNCTION__);
+		return ret_val;
+	}
+
+	return 0;
+}
+
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the ugeth structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+#include <linux/mii.h>
+static void adjust_link(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	ucc_geth_t *ug_regs;
+	u32 tempval;
+	struct ugeth_mii_info *mii_info = ugeth->mii_info;
+
+	ug_regs = ugeth->ug_regs;
+
+	if (mii_info->link) {
+		/* Now we make sure that we can be in full duplex mode.
+		 * If not, we operate in half-duplex mode. */
+		if (mii_info->duplex != ugeth->oldduplex) {
+			if (!(mii_info->duplex)) {
+				tempval = in_be32(&ug_regs->maccfg2);
+				tempval &= ~(MACCFG2_FDX);
+				out_be32(&ug_regs->maccfg2, tempval);
+
+				ugeth_info("%s: Half Duplex", dev->name);
+			} else {
+				tempval = in_be32(&ug_regs->maccfg2);
+				tempval |= MACCFG2_FDX;
+				out_be32(&ug_regs->maccfg2, tempval);
+
+				ugeth_info("%s: Full Duplex", dev->name);
+			}
+
+			ugeth->oldduplex = mii_info->duplex;
+		}
+
+		if (mii_info->speed != ugeth->oldspeed) {
+			switch (mii_info->speed) {
+			case 1000:
+#ifdef CONFIG_MPC8360
+				/*
+				 * This code is for 1000Mbs BUG fixing, remove when fixed!!!
+				 */
+
+				if (ugeth->ug_info->enet_interface ==
+				    ENET_1000_GMII)
+					/* Run the commands which initialize the PHY */
+				{
+					tempval =
+					    (u32) mii_info->mdio_read(ugeth->
+								      dev,
+								      mii_info->
+								      mii_id,
+								      0x1b);
+					tempval |= 0x000f;
+					mii_info->mdio_write(ugeth->dev,
+							     mii_info->mii_id,
+							     0x1b,
+							     (u16) tempval);
+					tempval =
+					    (u32) mii_info->mdio_read(ugeth->
+								      dev,
+								      mii_info->
+								      mii_id,
+								      MII_BMCR);
+					mii_info->mdio_write(ugeth->dev,
+							     mii_info->mii_id,
+							     MII_BMCR,
+							     (u16) (tempval |
+								    BMCR_RESET));
+				} else if (ugeth->ug_info->enet_interface ==
+					   ENET_1000_RGMII)
+					/* Run the commands which initialize the PHY */
+				{
+					tempval =
+					    (u32) mii_info->mdio_read(ugeth->
+								      dev,
+								      mii_info->
+								      mii_id,
+								      0x1b);
+					tempval = (tempval & ~0x000f) | 0x000b;
+					mii_info->mdio_write(ugeth->dev,
+							     mii_info->mii_id,
+							     0x1b,
+							     (u16) tempval);
+					tempval =
+					    (u32) mii_info->mdio_read(ugeth->
+								      dev,
+								      mii_info->
+								      mii_id,
+								      MII_BMCR);
+					mii_info->mdio_write(ugeth->dev,
+							     mii_info->mii_id,
+							     MII_BMCR,
+							     (u16) (tempval |
+								    BMCR_RESET));
+				}
+#endif				/* CONFIG_MPC8360 */
+				adjust_enet_interface(ugeth);
+				break;
+			case 100:
+			case 10:
+#ifdef CONFIG_MPC8360
+				/* This code is for 100Mbs BUG fixing, remove when fixed!!! */
+				ugeth->ug_info->enet_interface = ENET_100_RGMII;
+				tempval =
+				    (u32) mii_info->mdio_read(ugeth->dev,
+							      mii_info->mii_id,
+							      0x1b);
+				tempval = (tempval & ~0x000f) | 0x000b;
+				mii_info->mdio_write(ugeth->dev,
+						     mii_info->mii_id, 0x1b,
+						     (u16) tempval);
+				tempval =
+				    (u32) mii_info->mdio_read(ugeth->dev,
+							      mii_info->mii_id,
+							      MII_BMCR);
+				mii_info->mdio_write(ugeth->dev,
+						     mii_info->mii_id, MII_BMCR,
+						     (u16) (tempval |
+							    BMCR_RESET));
+#endif				/* CONFIG_MPC8360 */
+				adjust_enet_interface(ugeth);
+				break;
+			default:
+				ugeth_warn
+				    ("%s: Ack!  Speed (%d) is not 10/100/1000!",
+				     dev->name, mii_info->speed);
+				break;
+			}
+
+			ugeth_info("%s: Speed %dBT", dev->name,
+				   mii_info->speed);
+
+			ugeth->oldspeed = mii_info->speed;
+		}
+
+		if (!ugeth->oldlink) {
+			ugeth_info("%s: Link is up", dev->name);
+			ugeth->oldlink = 1;
+			netif_carrier_on(dev);
+			netif_schedule(dev);
+		}
+	} else {
+		if (ugeth->oldlink) {
+			ugeth_info("%s: Link is down", dev->name);
+			ugeth->oldlink = 0;
+			ugeth->oldspeed = 0;
+			ugeth->oldduplex = -1;
+			netif_carrier_off(dev);
+		}
+	}
+}
+
+/* Configure the PHY for dev.
+ * returns 0 if success.  -1 if failure
+ */
+static int init_phy(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	struct phy_info *curphy;
+	ucc_mii_mng_t *mii_regs;
+	struct ugeth_mii_info *mii_info;
+	int err;
+
+	mii_regs = &ugeth->ug_regs->miimng;
+
+	ugeth->oldlink = 0;
+	ugeth->oldspeed = 0;
+	ugeth->oldduplex = -1;
+
+	mii_info = kmalloc(sizeof(struct ugeth_mii_info), GFP_KERNEL);
+
+	if (NULL == mii_info) {
+		ugeth_err("%s: Could not allocate mii_info", dev->name);
+		return -ENOMEM;
+	}
+
+	mii_info->mii_regs = mii_regs;
+	mii_info->speed = SPEED_1000;
+	mii_info->duplex = DUPLEX_FULL;
+	mii_info->pause = 0;
+	mii_info->link = 0;
+
+	mii_info->advertising = (ADVERTISED_10baseT_Half |
+				 ADVERTISED_10baseT_Full |
+				 ADVERTISED_100baseT_Half |
+				 ADVERTISED_100baseT_Full |
+				 ADVERTISED_1000baseT_Full);
+	mii_info->autoneg = 1;
+
+	mii_info->mii_id = ugeth->ug_info->phy_address;
+
+	mii_info->dev = dev;
+
+	mii_info->mdio_read = &read_phy_reg;
+	mii_info->mdio_write = &write_phy_reg;
+
+	ugeth->mii_info = mii_info;
+
+	spin_lock_irq(&ugeth->lock);
+
+	/* Set this UCC to be the master of the MII managment */
+	ucc_set_qe_mux_mii_mng(ugeth->ug_info->uf_info.ucc_num);
+
+	if (init_mii_management_configuration(1,
+					      ugeth->ug_info->
+					      miiPreambleSupress,
+					      &mii_regs->miimcfg,
+					      &mii_regs->miimind)) {
+		ugeth_err("%s: The MII Bus is stuck!", dev->name);
+		err = -1;
+		goto bus_fail;
+	}
+
+	spin_unlock_irq(&ugeth->lock);
+
+	/* get info for this PHY */
+	curphy = get_phy_info(ugeth->mii_info);
+
+	if (curphy == NULL) {
+		ugeth_err("%s: No PHY found", dev->name);
+		err = -1;
+		goto no_phy;
+	}
+
+	mii_info->phyinfo = curphy;
+
+	/* Run the commands which initialize the PHY */
+	if (curphy->init) {
+		err = curphy->init(ugeth->mii_info);
+		if (err)
+			goto phy_init_fail;
+	}
+
+	return 0;
+
+      phy_init_fail:
+      no_phy:
+      bus_fail:
+	kfree(mii_info);
+
+	return err;
+}
+
+#ifdef UCC_GETH_UNUSED
+static int ugeth_transmit_on_demand(ucc_geth_private_t * ugeth)
+{
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ucc_fast_transmit_on_demand(ugeth->uccf);
+
+	return 0;
+}
+#endif
+static int ugeth_graceful_stop_tx(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	u32 cecr_subblock;
+	u32 temp;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	/* Mask GRACEFUL STOP TX interrupt bit and clear it */
+	temp = in_be32(uccf->p_uccm);
+	temp &= ~UCCE_GRA;
+	out_be32(uccf->p_uccm, temp);
+	out_be32(uccf->p_ucce, UCCE_GRA);	/* clear by writing 1 */
+
+	/* Issue host command */
+	cecr_subblock =
+	    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);
+	qe_issue_cmd(QE_GRACEFUL_STOP_TX, cecr_subblock,
+		     (u8) QE_CR_PROTOCOL_ETHERNET, 0);
+
+	/* Wait for command to complete */
+	do {
+		temp = in_be32(uccf->p_ucce);
+	} while (!(temp & UCCE_GRA));
+
+	uccf->stopped_tx = 1;
+
+	return 0;
+}
+
+static int ugeth_graceful_stop_rx(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	u32 cecr_subblock;
+	u8 temp;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	/* Clear acknowledge bit */
+	temp = ugeth->p_rx_glbl_pram->rxgstpack;
+	temp &= ~GRACEFUL_STOP_ACKNOWLEDGE_RX;
+	ugeth->p_rx_glbl_pram->rxgstpack = temp;
+
+	/* Keep issuing command and checking acknowledge bit until it is asserted, according to spec */
+	do {
+		/* Issue host command */
+		cecr_subblock =
+		    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.
+						ucc_num);
+		qe_issue_cmd(QE_GRACEFUL_STOP_RX, cecr_subblock,
+			     (u8) QE_CR_PROTOCOL_ETHERNET, 0);
+
+		temp = ugeth->p_rx_glbl_pram->rxgstpack;
+	} while (!(temp & GRACEFUL_STOP_ACKNOWLEDGE_RX));
+
+	uccf->stopped_rx = 1;
+
+	return 0;
+}
+
+static int ugeth_restart_tx(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	u32 cecr_subblock;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	cecr_subblock =
+	    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);
+	qe_issue_cmd(QE_RESTART_TX, cecr_subblock, (u8) QE_CR_PROTOCOL_ETHERNET,
+		     0);
+	uccf->stopped_tx = 0;
+
+	return 0;
+}
+
+static int ugeth_restart_rx(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_private_t *uccf;
+	u32 cecr_subblock;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	cecr_subblock =
+	    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);
+	qe_issue_cmd(QE_RESTART_RX, cecr_subblock, (u8) QE_CR_PROTOCOL_ETHERNET,
+		     0);
+	uccf->stopped_rx = 0;
+
+	return 0;
+}
+
+static int ugeth_enable(ucc_geth_private_t * ugeth, comm_dir_e mode)
+{
+	ucc_fast_private_t *uccf;
+	int enabled_tx, enabled_rx;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	/* check if the UCC number is in range. */
+	if (ugeth->ug_info->uf_info.ucc_num > UCC_MAX_NUM) {
+		ugeth_err("%s: ucc_num out of range.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	enabled_tx = uccf->enabled_tx;
+	enabled_rx = uccf->enabled_rx;
+
+	/* Get Tx and Rx going again, in case this channel was actively disabled. */
+	if ((mode & COMM_DIR_TX) && (!enabled_tx) && uccf->stopped_tx)
+		ugeth_restart_tx(ugeth);
+	if ((mode & COMM_DIR_RX) && (!enabled_rx) && uccf->stopped_rx)
+		ugeth_restart_rx(ugeth);
+
+	ucc_fast_enable(uccf, mode);	/* OK to do even if not disabled */
+
+	return 0;
+
+}
+
+static int ugeth_disable(ucc_geth_private_t * ugeth, comm_dir_e mode)
+{
+	ucc_fast_private_t *uccf;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	/* check if the UCC number is in range. */
+	if (ugeth->ug_info->uf_info.ucc_num > UCC_MAX_NUM) {
+		ugeth_err("%s: ucc_num out of range.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Stop any transmissions */
+	if ((mode & COMM_DIR_TX) && uccf->enabled_tx && !uccf->stopped_tx)
+		ugeth_graceful_stop_tx(ugeth);
+
+	/* Stop any receptions */
+	if ((mode & COMM_DIR_RX) && uccf->enabled_rx && !uccf->stopped_rx)
+		ugeth_graceful_stop_rx(ugeth);
+
+	ucc_fast_disable(ugeth->uccf, mode);	/* OK to do even if not enabled */
+
+	return 0;
+}
+
+static void ugeth_dump_regs(ucc_geth_private_t * ugeth)
+{
+	ucc_fast_dump_regs(ugeth->uccf);
+	dump_regs(ugeth);
+	dump_bds(ugeth);
+}
+
+#ifdef UCC_GETH_UNUSED
+static int ugeth_ext_filtering_serialize_tad(ucc_geth_tad_params_t *
+					     p_UccGethTadParams,
+					     qe_fltr_tad_t * qe_fltr_tad)
+{
+	u16 temp;
+
+	/* Zero serialized TAD */
+	memset(qe_fltr_tad, 0, QE_FLTR_TAD_SIZE);
+
+	qe_fltr_tad->serialized[0] |= UCC_GETH_TAD_V;	/* Must have this */
+	if (p_UccGethTadParams->rx_non_dynamic_extended_features_mode ||
+	    (p_UccGethTadParams->vtag_op != UCC_GETH_VLAN_OPERATION_TAGGED_NOP)
+	    || (p_UccGethTadParams->vnontag_op !=
+		UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP)
+	    )
+		qe_fltr_tad->serialized[0] |= UCC_GETH_TAD_EF;
+	if (p_UccGethTadParams->reject_frame)
+		qe_fltr_tad->serialized[0] |= UCC_GETH_TAD_REJ;
+	temp =
+	    (u16) (((u16) p_UccGethTadParams->
+		    vtag_op) << UCC_GETH_TAD_VTAG_OP_SHIFT);
+	qe_fltr_tad->serialized[0] |= (u8) (temp >> 8);	/* upper bits */
+
+	qe_fltr_tad->serialized[1] |= (u8) (temp & 0x00ff);	/* lower bits */
+	if (p_UccGethTadParams->vnontag_op ==
+	    UCC_GETH_VLAN_OPERATION_NON_TAGGED_Q_TAG_INSERT)
+		qe_fltr_tad->serialized[1] |= UCC_GETH_TAD_V_NON_VTAG_OP;
+	qe_fltr_tad->serialized[1] |=
+	    p_UccGethTadParams->rqos << UCC_GETH_TAD_RQOS_SHIFT;
+
+	qe_fltr_tad->serialized[2] |=
+	    p_UccGethTadParams->vpri << UCC_GETH_TAD_V_PRIORITY_SHIFT;
+	qe_fltr_tad->serialized[2] |= (u8) (p_UccGethTadParams->vid >> 8);	/* upper bits */
+
+	qe_fltr_tad->serialized[3] |= (u8) (p_UccGethTadParams->vid & 0x00ff);	/* lower bits */
+
+	return 0;
+}
+#endif
+#ifdef UCC_GETH_UNUSED
+static enet_addr_container_t
+    * ugeth_82xx_filtering_get_match_addr_in_hash(ucc_geth_private_t * ugeth,
+						  enet_addr_t * p_enet_addr)
+{
+	enet_addr_container_t *enet_addr_cont;
+	struct list_head *p_lh;
+	u16 i, num;
+	int32_t j;
+	u8 *p_counter;
+
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return NULL;
+	}
+
+	if ((*p_enet_addr)[0] & ENET_GROUP_ADDR) {
+		p_lh = &ugeth->group_hash_q;
+		p_counter = &(ugeth->numGroupAddrInHash);
+	} else {
+		p_lh = &ugeth->ind_hash_q;
+		p_counter = &(ugeth->numIndAddrInHash);
+	}
+
+	if (!p_lh)
+		return NULL;
+
+	num = *p_counter;
+
+	for (i = 0; i < num; i++) {
+		enet_addr_cont = (enet_addr_container_t *)
+		    ENET_ADDR_CONT_ENTRY(dequeue(p_lh));
+		for (j = ENET_NUM_OCTETS_PER_ADDRESS - 1; j >= 0; j--) {
+			if ((*p_enet_addr)[j] != (enet_addr_cont->address)[j])
+				break;
+			if (j == 0)
+				return enet_addr_cont;	/* Found */
+		}
+		enqueue(p_lh, &enet_addr_cont->node);	/* Put it back */
+	}
+	return NULL;
+}
+#endif
+#ifdef UCC_GET_UNUSED
+static int ugeth_82xx_filtering_add_addr_in_hash(ucc_geth_private_t * ugeth,
+						 enet_addr_t * p_enet_addr)
+{
+	ucc_geth_enet_address_recognition_location_e location;
+	enet_addr_container_t *enet_addr_cont;
+	struct list_head *p_lh;
+	u8 i;
+	u32 limit;
+	u8 *p_counter;
+
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if ((*p_enet_addr)[0] & ENET_GROUP_ADDR) {
+		p_lh = &ugeth->group_hash_q;
+		limit = ugeth->ug_info->maxGroupAddrInHash;
+		location =
+		    UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_GROUP_HASH;
+		p_counter = &(ugeth->numGroupAddrInHash);
+	} else {
+		p_lh = &ugeth->ind_hash_q;
+		limit = ugeth->ug_info->maxIndAddrInHash;
+		location =
+		    UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_INDIVIDUAL_HASH;
+		p_counter = &(ugeth->numIndAddrInHash);
+	}
+
+	if ((enet_addr_cont =
+	     ugeth_82xx_filtering_get_match_addr_in_hash(ugeth, p_enet_addr))) {
+		list_add(p_lh, &enet_addr_cont->node);	/* Put it back */
+		return 0;
+	}
+	if ((!p_lh) || (!(*p_counter < limit)))
+		return -EBUSY;
+	if (!(enet_addr_cont = get_enet_addr_container()))
+		return -ENOMEM;
+	for (i = 0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)
+		(enet_addr_cont->address)[i] = (*p_enet_addr)[i];
+	enet_addr_cont->location = location;
+	enqueue(p_lh, &enet_addr_cont->node);	/* Put it back */
+	++(*p_counter);
+
+	hw_add_addr_in_hash(ugeth, &(enet_addr_cont->address));
+
+	return 0;
+}
+#endif
+#ifdef UCC_GETH_UNUSED
+static int ugeth_82xx_filtering_clear_addr_in_hash(ucc_geth_private_t * ugeth,
+						   enet_addr_t * p_enet_addr)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+	enet_addr_container_t *enet_addr_cont;
+	ucc_fast_private_t *uccf;
+	comm_dir_e comm_dir;
+	u16 i, num;
+	struct list_head *p_lh;
+	u32 *addr_h, *addr_l;
+	u8 *p_counter;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	p_82xx_addr_filt =
+	    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->p_rx_glbl_pram->
+	    addressfiltering;
+
+	if (!
+	    (enet_addr_cont =
+	     ugeth_82xx_filtering_get_match_addr_in_hash(ugeth, p_enet_addr)))
+		return -ENOENT;
+
+	/* It's been found and removed from the CQ. */
+	/* Now destroy its container */
+	put_enet_addr_container(enet_addr_cont);
+
+	if ((*p_enet_addr)[0] & ENET_GROUP_ADDR) {
+		addr_h = &(p_82xx_addr_filt->gaddr_h);
+		addr_l = &(p_82xx_addr_filt->gaddr_l);
+		p_lh = &ugeth->group_hash_q;
+		p_counter = &(ugeth->numGroupAddrInHash);
+	} else {
+		addr_h = &(p_82xx_addr_filt->iaddr_h);
+		addr_l = &(p_82xx_addr_filt->iaddr_l);
+		p_lh = &ugeth->ind_hash_q;
+		p_counter = &(ugeth->numIndAddrInHash);
+	}
+
+	comm_dir = 0;
+	if (uccf->enabled_tx)
+		comm_dir |= COMM_DIR_TX;
+	if (uccf->enabled_rx)
+		comm_dir |= COMM_DIR_RX;
+	if (comm_dir)
+		ugeth_disable(ugeth, comm_dir);
+
+	/* Clear the hash table. */
+	out_be32(addr_h, 0x00000000);
+	out_be32(addr_l, 0x00000000);
+
+	/* Add all remaining CQ elements back into hash */
+	num = --(*p_counter);
+	for (i = 0; i < num; i++) {
+		enet_addr_cont = (enet_addr_container_t *)
+		    ENET_ADDR_CONT_ENTRY(dequeue(p_lh));
+		hw_add_addr_in_hash(ugeth, &(enet_addr_cont->address));
+		enqueue(p_lh, &enet_addr_cont->node);	/* Put it back */
+	}
+
+	if (comm_dir)
+		ugeth_enable(ugeth, comm_dir);
+
+	return 0;
+}
+#endif
+static int ugeth_82xx_filtering_clear_all_addr_in_hash(ucc_geth_private_t *
+						       ugeth,
+						       enet_addr_type_e
+						       enet_addr_type)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+	ucc_fast_private_t *uccf;
+	comm_dir_e comm_dir;
+	struct list_head *p_lh;
+	u16 i, num;
+	u32 *addr_h, *addr_l;
+	u8 *p_counter;
+
+	if (!ugeth || !ugeth->uccf) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	uccf = ugeth->uccf;
+
+	p_82xx_addr_filt =
+	    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->p_rx_glbl_pram->
+	    addressfiltering;
+
+	if (enet_addr_type == ENET_ADDR_TYPE_GROUP) {
+		addr_h = &(p_82xx_addr_filt->gaddr_h);
+		addr_l = &(p_82xx_addr_filt->gaddr_l);
+		p_lh = &ugeth->group_hash_q;
+		p_counter = &(ugeth->numGroupAddrInHash);
+	} else if (enet_addr_type == ENET_ADDR_TYPE_INDIVIDUAL) {
+		addr_h = &(p_82xx_addr_filt->iaddr_h);
+		addr_l = &(p_82xx_addr_filt->iaddr_l);
+		p_lh = &ugeth->ind_hash_q;
+		p_counter = &(ugeth->numIndAddrInHash);
+	} else
+		return -EINVAL;
+
+	comm_dir = 0;
+	if (uccf->enabled_tx)
+		comm_dir |= COMM_DIR_TX;
+	if (uccf->enabled_rx)
+		comm_dir |= COMM_DIR_RX;
+	if (comm_dir)
+		ugeth_disable(ugeth, comm_dir);
+
+	/* Clear the hash table. */
+	out_be32(addr_h, 0x00000000);
+	out_be32(addr_l, 0x00000000);
+
+	if (!p_lh)
+		return 0;
+
+	num = *p_counter;
+
+	/* Delete all remaining CQ elements */
+	for (i = 0; i < num; i++)
+		put_enet_addr_container(ENET_ADDR_CONT_ENTRY(dequeue(p_lh)));
+
+	*p_counter = 0;
+
+	if (comm_dir)
+		ugeth_enable(ugeth, comm_dir);
+
+	return 0;
+}
+
+#ifdef UCC_GETH_UNUSED
+static int ugeth_82xx_filtering_add_addr_in_paddr(ucc_geth_private_t * ugeth,
+						  enet_addr_t * p_enet_addr,
+						  u8 paddr_num)
+{
+	int i;
+
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if ((*p_enet_addr)[0] & ENET_GROUP_ADDR)
+		ugeth_warn
+		    ("%s: multicast address added to paddr will have no effect - is this what you wanted?",
+		     __FUNCTION__);
+
+	ugeth->indAddrRegUsed[paddr_num] = 1;	/* mark this paddr as used */
+	for (i = 0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)	/* store address in our database */
+		ugeth->paddr[paddr_num][i] = (*p_enet_addr)[i];
+	return hw_add_addr_in_paddr(ugeth, p_enet_addr, paddr_num);	/* put in hardware */
+}
+#endif
+
+static int ugeth_82xx_filtering_clear_addr_in_paddr(ucc_geth_private_t * ugeth,
+						    u8 paddr_num)
+{
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ugeth->indAddrRegUsed[paddr_num] = 0;	/* mark this paddr as not used */
+	return hw_clear_addr_in_paddr(ugeth, paddr_num);	/* clear in hardware */
+}
+
+static void ucc_geth_memclean(ucc_geth_private_t * ugeth)
+{
+	u16 i, j;
+	u8 *bd;
+
+	if (!ugeth)
+		return;
+
+	if (ugeth->uccf)
+		ucc_fast_free(ugeth->uccf);
+
+	if (ugeth->p_thread_data_tx) {
+		qe_muram_free(ugeth->thread_dat_tx_offset);
+		ugeth->p_thread_data_tx = NULL;
+	}
+	if (ugeth->p_thread_data_rx) {
+		qe_muram_free(ugeth->thread_dat_rx_offset);
+		ugeth->p_thread_data_rx = NULL;
+	}
+	if (ugeth->p_exf_glbl_param) {
+		qe_muram_free(ugeth->exf_glbl_param_offset);
+		ugeth->p_exf_glbl_param = NULL;
+	}
+	if (ugeth->p_rx_glbl_pram) {
+		qe_muram_free(ugeth->rx_glbl_pram_offset);
+		ugeth->p_rx_glbl_pram = NULL;
+	}
+	if (ugeth->p_tx_glbl_pram) {
+		qe_muram_free(ugeth->tx_glbl_pram_offset);
+		ugeth->p_tx_glbl_pram = NULL;
+	}
+	if (ugeth->p_send_q_mem_reg) {
+		qe_muram_free(ugeth->send_q_mem_reg_offset);
+		ugeth->p_send_q_mem_reg = NULL;
+	}
+	if (ugeth->p_scheduler) {
+		qe_muram_free(ugeth->scheduler_offset);
+		ugeth->p_scheduler = NULL;
+	}
+	if (ugeth->p_tx_fw_statistics_pram) {
+		qe_muram_free(ugeth->tx_fw_statistics_pram_offset);
+		ugeth->p_tx_fw_statistics_pram = NULL;
+	}
+	if (ugeth->p_rx_fw_statistics_pram) {
+		qe_muram_free(ugeth->rx_fw_statistics_pram_offset);
+		ugeth->p_rx_fw_statistics_pram = NULL;
+	}
+	if (ugeth->p_rx_irq_coalescing_tbl) {
+		qe_muram_free(ugeth->rx_irq_coalescing_tbl_offset);
+		ugeth->p_rx_irq_coalescing_tbl = NULL;
+	}
+	if (ugeth->p_rx_bd_qs_tbl) {
+		qe_muram_free(ugeth->rx_bd_qs_tbl_offset);
+		ugeth->p_rx_bd_qs_tbl = NULL;
+	}
+	if (ugeth->p_init_enet_param_shadow) {
+		return_init_enet_entries(ugeth,
+					 &(ugeth->p_init_enet_param_shadow->
+					   rxthread[0]),
+					 ENET_INIT_PARAM_MAX_ENTRIES_RX,
+					 ugeth->ug_info->riscRx, 1);
+		return_init_enet_entries(ugeth,
+					 &(ugeth->p_init_enet_param_shadow->
+					   txthread[0]),
+					 ENET_INIT_PARAM_MAX_ENTRIES_TX,
+					 ugeth->ug_info->riscTx, 0);
+		kfree(ugeth->p_init_enet_param_shadow);
+		ugeth->p_init_enet_param_shadow = NULL;
+	}
+	for (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {
+
+		if ((bd = ugeth->p_tx_bd_ring[i])) {
+			for (j = 0; j < ugeth->ug_info->bdRingLenTx[i]; j++) {
+				if (ugeth->tx_skbuff[i][j]) {
+					dma_unmap_single(NULL,
+							 BD_BUFFER_ARG(bd),
+							 (BD_STATUS_AND_LENGTH
+							  (bd) &
+							  BD_LENGTH_MASK),
+							 DMA_TO_DEVICE);
+					dev_kfree_skb_any(ugeth->
+							  tx_skbuff[i][j]);
+					ugeth->tx_skbuff[i][j] = NULL;
+				}
+				bd += UCC_GETH_SIZE_OF_BD;
+			}
+
+			kfree(ugeth->tx_skbuff[i]);
+
+			if (ugeth->ug_info->uf_info.bd_mem_part ==
+			    MEM_PART_SYSTEM)
+				kfree((void *)ugeth->tx_bd_ring_offset[i]);
+			else if (ugeth->ug_info->uf_info.bd_mem_part ==
+				 MEM_PART_MURAM)
+				qe_muram_free(ugeth->tx_bd_ring_offset[i]);
+			ugeth->p_tx_bd_ring[i] = NULL;
+		}
+	}
+	for (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {
+		if ((bd = ugeth->p_rx_bd_ring[i])) {
+			/* Return existing data buffers in ring */
+			for (j = 0; j < ugeth->ug_info->bdRingLenRx[i]; j++) {
+				if (ugeth->rx_skbuff[i][j]) {
+					dma_unmap_single(NULL, BD_BUFFER(bd),
+							 ugeth->ug_info->
+							 uf_info.
+							 max_rx_buf_length +
+							 UCC_GETH_RX_DATA_BUF_ALIGNMENT,
+							 DMA_FROM_DEVICE);
+
+					dev_kfree_skb_any(ugeth->
+							  rx_skbuff[i][j]);
+					ugeth->rx_skbuff[i][j] = NULL;
+				}
+				bd += UCC_GETH_SIZE_OF_BD;
+			}
+
+			kfree(ugeth->rx_skbuff[i]);
+
+			if (ugeth->ug_info->uf_info.bd_mem_part ==
+			    MEM_PART_SYSTEM)
+				kfree((void *)ugeth->rx_bd_ring_offset[i]);
+			else if (ugeth->ug_info->uf_info.bd_mem_part ==
+				 MEM_PART_MURAM)
+				qe_muram_free(ugeth->rx_bd_ring_offset[i]);
+			ugeth->p_rx_bd_ring[i] = NULL;
+		}
+	}
+	while (!list_empty(&ugeth->group_hash_q))
+		put_enet_addr_container(ENET_ADDR_CONT_ENTRY
+					(dequeue(&ugeth->group_hash_q)));
+	while (!list_empty(&ugeth->ind_hash_q))
+		put_enet_addr_container(ENET_ADDR_CONT_ENTRY
+					(dequeue(&ugeth->ind_hash_q)));
+}
+
+static void ucc_geth_stop(ucc_geth_private_t * ugeth)
+{
+	ucc_geth_t *ug_regs = ugeth->ug_regs;
+	u32 tempval;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	/* Disable the controller */
+	ugeth_disable(ugeth, COMM_DIR_RX_AND_TX);
+
+	/* Tell the kernel the link is down */
+	ugeth->mii_info->link = 0;
+	adjust_link(ugeth->dev);
+
+	/* Mask all interrupts */
+	out_be32(ugeth->uccf->p_uccm, 0x00000000);
+
+	/* Clear all interrupts */
+	out_be32(ugeth->uccf->p_ucce, 0xffffffff);
+
+	/* Disable Rx and Tx */
+	tempval = in_be32(&ug_regs->maccfg1);
+	tempval &= ~(MACCFG1_ENABLE_RX | MACCFG1_ENABLE_TX);
+	out_be32(&ug_regs->maccfg1, tempval);
+
+	if (ugeth->ug_info->board_flags & FSL_UGETH_BRD_HAS_PHY_INTR) {
+		/* Clear any pending interrupts */
+		mii_clear_phy_interrupt(ugeth->mii_info);
+
+		/* Disable PHY Interrupts */
+		mii_configure_phy_interrupt(ugeth->mii_info,
+					    MII_INTERRUPT_DISABLED);
+	}
+
+	free_irq(ugeth->ug_info->uf_info.irq, ugeth->dev);
+
+	if (ugeth->ug_info->board_flags & FSL_UGETH_BRD_HAS_PHY_INTR) {
+		free_irq(ugeth->ug_info->phy_interrupt, ugeth->dev);
+	} else {
+		del_timer_sync(&ugeth->phy_info_timer);
+	}
+
+	ucc_geth_memclean(ugeth);
+}
+
+static int ucc_geth_startup(ucc_geth_private_t * ugeth)
+{
+	ucc_geth_82xx_address_filtering_pram_t *p_82xx_addr_filt;
+	ucc_geth_init_pram_t *p_init_enet_pram;
+	ucc_fast_private_t *uccf;
+	ucc_geth_info_t *ug_info;
+	ucc_fast_info_t *uf_info;
+	ucc_fast_t *uf_regs;
+	ucc_geth_t *ug_regs;
+	int ret_val = -EINVAL;
+	u32 remoder = UCC_GETH_REMODER_INIT;
+	u32 init_enet_pram_offset, cecr_subblock, command, maccfg1;
+	u32 ifstat, i, j, size, l2qt, l3qt, length;
+	u16 temoder = UCC_GETH_TEMODER_INIT;
+	u16 test;
+	u8 function_code = 0;
+	u8 *bd, *endOfRing;
+	u8 numThreadsRxNumerical, numThreadsTxNumerical;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	/* Check some parameters */
+	if (!ugeth) {
+		ugeth_err("%s: No handle passed.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ug_info = ugeth->ug_info;
+	uf_info = &ug_info->uf_info;
+
+	if (!((uf_info->bd_mem_part == MEM_PART_SYSTEM) ||
+	      (uf_info->bd_mem_part == MEM_PART_MURAM))) {
+		ugeth_err("%s: Bad memory partition value.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Rx BD lengths */
+	for (i = 0; i < ug_info->numQueuesRx; i++) {
+		if ((ug_info->bdRingLenRx[i] < UCC_GETH_RX_BD_RING_SIZE_MIN) ||
+		    (ug_info->bdRingLenRx[i] %
+		     UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT)) {
+			ugeth_err
+			    ("%s: Rx BD ring length must be multiple of 4, no smaller than 8.",
+			     __FUNCTION__);
+			return -EINVAL;
+		}
+	}
+
+	/* Tx BD lengths */
+	for (i = 0; i < ug_info->numQueuesTx; i++) {
+		if (ug_info->bdRingLenTx[i] < UCC_GETH_TX_BD_RING_SIZE_MIN) {
+			ugeth_err
+			    ("%s: Tx BD ring length must be no smaller than 2.",
+			     __FUNCTION__);
+			return -EINVAL;
+		}
+	}
+
+	/* mrblr */
+	if ((uf_info->max_rx_buf_length == 0) ||
+	    (uf_info->max_rx_buf_length % UCC_GETH_MRBLR_ALIGNMENT)) {
+		ugeth_err
+		    ("%s: max_rx_buf_length must be non-zero multiple of 128.",
+		     __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* num Tx queues */
+	if (ug_info->numQueuesTx > NUM_TX_QUEUES) {
+		ugeth_err("%s: number of tx queues too large.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* num Rx queues */
+	if (ug_info->numQueuesRx > NUM_RX_QUEUES) {
+		ugeth_err("%s: number of rx queues too large.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* l2qt */
+	for (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++) {
+		if (ug_info->l2qt[i] >= ug_info->numQueuesRx) {
+			ugeth_err
+			    ("%s: VLAN priority table entry must not be larger than number of Rx queues.",
+			     __FUNCTION__);
+			return -EINVAL;
+		}
+	}
+
+	/* l3qt */
+	for (i = 0; i < UCC_GETH_IP_PRIORITY_MAX; i++) {
+		if (ug_info->l3qt[i] >= ug_info->numQueuesRx) {
+			ugeth_err
+			    ("%s: IP priority table entry must not be larger than number of Rx queues.",
+			     __FUNCTION__);
+			return -EINVAL;
+		}
+	}
+
+	if (ug_info->cam && !ug_info->ecamptr) {
+		ugeth_err("%s: If cam mode is chosen, must supply cam ptr.",
+			  __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if ((ug_info->numStationAddresses !=
+	     UCC_GETH_NUM_OF_STATION_ADDRESSES_1)
+	    && ug_info->rxExtendedFiltering) {
+		ugeth_err("%s: Number of station addresses greater than 1 "
+			  "not allowed in extended parsing mode.",
+			  __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Generate uccm_mask for receive */
+	uf_info->uccm_mask = ug_info->eventRegMask & UCCE_OTHER;	/* Errors */
+	for (i = 0; i < ug_info->numQueuesRx; i++)
+		uf_info->uccm_mask |= (UCCE_RXBF_SINGLE_MASK << i);
+
+	for (i = 0; i < ug_info->numQueuesTx; i++)
+		uf_info->uccm_mask |= (UCCE_TXBF_SINGLE_MASK << i);
+
+	INIT_LIST_HEAD(&ugeth->group_hash_q);
+
+	INIT_LIST_HEAD(&ugeth->ind_hash_q);
+
+	/* Initialize the general fast UCC block. */
+	if (ucc_fast_init(uf_info, &uccf)) {
+		ugeth_err("%s: Failed to init uccf.", __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+	ugeth->uccf = uccf;
+
+	switch (ug_info->numThreadsRx) {
+	case UCC_GETH_NUM_OF_THREADS_1:
+		numThreadsRxNumerical = 1;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_2:
+		numThreadsRxNumerical = 2;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_4:
+		numThreadsRxNumerical = 4;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_6:
+		numThreadsRxNumerical = 6;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_8:
+		numThreadsRxNumerical = 8;
+		break;
+	default:
+		ugeth_err("%s: Bad number of Rx threads value.", __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -EINVAL;
+		break;
+	}
+
+	switch (ug_info->numThreadsTx) {
+	case UCC_GETH_NUM_OF_THREADS_1:
+		numThreadsTxNumerical = 1;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_2:
+		numThreadsTxNumerical = 2;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_4:
+		numThreadsTxNumerical = 4;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_6:
+		numThreadsTxNumerical = 6;
+		break;
+	case UCC_GETH_NUM_OF_THREADS_8:
+		numThreadsTxNumerical = 8;
+		break;
+	default:
+		ugeth_err("%s: Bad number of Tx threads value.", __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -EINVAL;
+		break;
+	}
+
+	/* Calculate rx_extended_features */
+	ugeth->rx_non_dynamic_extended_features = ug_info->ipCheckSumCheck ||
+	    ug_info->ipAddressAlignment ||
+	    (ug_info->numStationAddresses !=
+	     UCC_GETH_NUM_OF_STATION_ADDRESSES_1);
+
+	ugeth->rx_extended_features = ugeth->rx_non_dynamic_extended_features ||
+	    (ug_info->vlanOperationTagged != UCC_GETH_VLAN_OPERATION_TAGGED_NOP)
+	    || (ug_info->vlanOperationNonTagged !=
+		UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP);
+
+	uf_regs = uccf->uf_regs;
+	ug_regs = (ucc_geth_t *) (uccf->uf_regs);
+	ugeth->ug_regs = ug_regs;
+
+	init_default_reg_vals(&uf_regs->upsmr,
+			      &ug_regs->maccfg1, &ug_regs->maccfg2);
+
+	/*                    Set UPSMR                      */
+	/* For more details see the hardware spec.           */
+	init_rx_parameters(ug_info->bro,
+			   ug_info->rsh, ug_info->pro, &uf_regs->upsmr);
+
+	/* We're going to ignore other registers for now, */
+	/* except as needed to get up and running         */
+
+	/*                    Set MACCFG1                    */
+	/* For more details see the hardware spec.           */
+	init_flow_control_params(ug_info->aufc,
+				 ug_info->receiveFlowControl,
+				 1,
+				 ug_info->pausePeriod,
+				 ug_info->extensionField,
+				 &uf_regs->upsmr,
+				 &ug_regs->uempr, &ug_regs->maccfg1);
+
+	maccfg1 = in_be32(&ug_regs->maccfg1);
+	maccfg1 |= MACCFG1_ENABLE_RX;
+	maccfg1 |= MACCFG1_ENABLE_TX;
+	out_be32(&ug_regs->maccfg1, maccfg1);
+
+	/*                    Set IPGIFG                     */
+	/* For more details see the hardware spec.           */
+	ret_val = init_inter_frame_gap_params(ug_info->nonBackToBackIfgPart1,
+					      ug_info->nonBackToBackIfgPart2,
+					      ug_info->
+					      miminumInterFrameGapEnforcement,
+					      ug_info->backToBackInterFrameGap,
+					      &ug_regs->ipgifg);
+	if (ret_val != 0) {
+		ugeth_err("%s: IPGIFG initialization parameter too large.",
+			  __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return ret_val;
+	}
+
+	/*                    Set HAFDUP                     */
+	/* For more details see the hardware spec.           */
+	ret_val = init_half_duplex_params(ug_info->altBeb,
+					  ug_info->backPressureNoBackoff,
+					  ug_info->noBackoff,
+					  ug_info->excessDefer,
+					  ug_info->altBebTruncation,
+					  ug_info->maxRetransmission,
+					  ug_info->collisionWindow,
+					  &ug_regs->hafdup);
+	if (ret_val != 0) {
+		ugeth_err("%s: Half Duplex initialization parameter too large.",
+			  __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return ret_val;
+	}
+
+	/*                    Set IFSTAT                     */
+	/* For more details see the hardware spec.           */
+	/* Read only - resets upon read                      */
+	ifstat = in_be32(&ug_regs->ifstat);
+
+	/*                    Clear UEMPR                    */
+	/* For more details see the hardware spec.           */
+	out_be32(&ug_regs->uempr, 0);
+
+	/*                    Set UESCR                      */
+	/* For more details see the hardware spec.           */
+	init_hw_statistics_gathering_mode((ug_info->statisticsMode &
+					   UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE),
+					  0, &uf_regs->upsmr, &ug_regs->uescr);
+
+	/* Allocate Tx bds */
+	for (j = 0; j < ug_info->numQueuesTx; j++) {
+		/* Allocate in multiple of UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT, according to spec */
+		length = ((ug_info->bdRingLenTx[j] * UCC_GETH_SIZE_OF_BD)
+			  / UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT)
+		    * UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT;
+		if ((ug_info->bdRingLenTx[j] * UCC_GETH_SIZE_OF_BD) %
+		    UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT)
+			length += UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT;
+		if (uf_info->bd_mem_part == MEM_PART_SYSTEM) {
+			u32 align = 4;
+			if (UCC_GETH_TX_BD_RING_ALIGNMENT > 4)
+				align = UCC_GETH_TX_BD_RING_ALIGNMENT;
+			ugeth->tx_bd_ring_offset[j] =
+			    (u32) (kmalloc((u32) (length + align), GFP_KERNEL));
+			if (ugeth->tx_bd_ring_offset[j] != 0)
+				ugeth->p_tx_bd_ring[j] =
+				    (void
+				     *)((ugeth->tx_bd_ring_offset[j] +
+					 align) & ~(align - 1));
+		} else if (uf_info->bd_mem_part == MEM_PART_MURAM) {
+			ugeth->tx_bd_ring_offset[j] =
+			    qe_muram_alloc(length,
+					   UCC_GETH_TX_BD_RING_ALIGNMENT);
+			if (!IS_MURAM_ERR(ugeth->tx_bd_ring_offset[j]))
+				ugeth->p_tx_bd_ring[j] =
+				    (u8 *) qe_muram_addr(ugeth->
+							 tx_bd_ring_offset[j]);
+		}
+		if (!ugeth->p_tx_bd_ring[j]) {
+			ugeth_err
+			    ("%s: Can not allocate memory for Tx bd rings.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+		/* Zero unused end of bd ring, according to spec */
+		memset(ugeth->p_tx_bd_ring[j] +
+		       ug_info->bdRingLenTx[j] * UCC_GETH_SIZE_OF_BD, 0,
+		       length - ug_info->bdRingLenTx[j] * UCC_GETH_SIZE_OF_BD);
+	}
+
+	/* Allocate Rx bds */
+	for (j = 0; j < ug_info->numQueuesRx; j++) {
+		length = ug_info->bdRingLenRx[j] * UCC_GETH_SIZE_OF_BD;
+		if (uf_info->bd_mem_part == MEM_PART_SYSTEM) {
+			u32 align = 4;
+			if (UCC_GETH_RX_BD_RING_ALIGNMENT > 4)
+				align = UCC_GETH_RX_BD_RING_ALIGNMENT;
+			ugeth->rx_bd_ring_offset[j] =
+			    (u32) (kmalloc((u32) (length + align), GFP_KERNEL));
+			if (ugeth->rx_bd_ring_offset[j] != 0)
+				ugeth->p_rx_bd_ring[j] =
+				    (void
+				     *)((ugeth->rx_bd_ring_offset[j] +
+					 align) & ~(align - 1));
+		} else if (uf_info->bd_mem_part == MEM_PART_MURAM) {
+			ugeth->rx_bd_ring_offset[j] =
+			    qe_muram_alloc(length,
+					   UCC_GETH_RX_BD_RING_ALIGNMENT);
+			if (!IS_MURAM_ERR(ugeth->rx_bd_ring_offset[j]))
+				ugeth->p_rx_bd_ring[j] =
+				    (u8 *) qe_muram_addr(ugeth->
+							 rx_bd_ring_offset[j]);
+		}
+		if (!ugeth->p_rx_bd_ring[j]) {
+			ugeth_err
+			    ("%s: Can not allocate memory for Rx bd rings.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+	}
+
+	/* Init Tx bds */
+	for (j = 0; j < ug_info->numQueuesTx; j++) {
+		/* Setup the skbuff rings */
+		ugeth->tx_skbuff[j] =
+		    (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) *
+					       ugeth->ug_info->bdRingLenTx[j],
+					       GFP_KERNEL);
+
+		if (ugeth->tx_skbuff[j] == NULL) {
+			ugeth_err("%s: Could not allocate tx_skbuff",
+				  __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < ugeth->ug_info->bdRingLenTx[j]; i++)
+			ugeth->tx_skbuff[j][i] = NULL;
+
+		ugeth->skb_curtx[j] = ugeth->skb_dirtytx[j] = 0;
+		bd = ugeth->confBd[j] = ugeth->txBd[j] = ugeth->p_tx_bd_ring[j];
+		for (i = 0; i < ug_info->bdRingLenTx[j]; i++) {
+			BD_BUFFER_CLEAR(bd);
+			BD_STATUS_AND_LENGTH_SET(bd, 0);
+			bd += UCC_GETH_SIZE_OF_BD;
+		}
+		bd -= UCC_GETH_SIZE_OF_BD;
+		BD_STATUS_AND_LENGTH_SET(bd, T_W);	/* for last BD set Wrap bit */
+	}
+
+	/* Init Rx bds */
+	for (j = 0; j < ug_info->numQueuesRx; j++) {
+		/* Setup the skbuff rings */
+		ugeth->rx_skbuff[j] =
+		    (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) *
+					       ugeth->ug_info->bdRingLenRx[j],
+					       GFP_KERNEL);
+
+		if (ugeth->rx_skbuff[j] == NULL) {
+			ugeth_err("%s: Could not allocate rx_skbuff",
+				  __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < ugeth->ug_info->bdRingLenRx[j]; i++)
+			ugeth->rx_skbuff[j][i] = NULL;
+
+		ugeth->skb_currx[j] = 0;
+		bd = ugeth->rxBd[j] = ugeth->p_rx_bd_ring[j];
+		for (i = 0; i < ug_info->bdRingLenRx[j]; i++) {
+			BD_STATUS_AND_LENGTH_SET(bd, R_I);
+			BD_BUFFER_CLEAR(bd);
+			bd += UCC_GETH_SIZE_OF_BD;
+		}
+		bd -= UCC_GETH_SIZE_OF_BD;
+		BD_STATUS_AND_LENGTH_SET(bd, R_W);	/* for last BD set Wrap bit */
+	}
+
+	/*
+	 * Global PRAM
+	 */
+	/* Tx global PRAM */
+	/* Allocate global tx parameter RAM page */
+	ugeth->tx_glbl_pram_offset =
+	    qe_muram_alloc(sizeof(ucc_geth_tx_global_pram_t),
+			   UCC_GETH_TX_GLOBAL_PRAM_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->tx_glbl_pram_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_tx_glbl_pram.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+	ugeth->p_tx_glbl_pram =
+	    (ucc_geth_tx_global_pram_t *) qe_muram_addr(ugeth->
+							tx_glbl_pram_offset);
+	/* Zero out p_tx_glbl_pram */
+	memset(ugeth->p_tx_glbl_pram, 0, sizeof(ucc_geth_tx_global_pram_t));
+
+	/* Fill global PRAM */
+
+	/* TQPTR */
+	/* Size varies with number of Tx threads */
+	ugeth->thread_dat_tx_offset =
+	    qe_muram_alloc(numThreadsTxNumerical *
+			   sizeof(ucc_geth_thread_data_tx_t) +
+			   32 * (numThreadsTxNumerical == 1),
+			   UCC_GETH_THREAD_DATA_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->thread_dat_tx_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_thread_data_tx.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+
+	ugeth->p_thread_data_tx =
+	    (ucc_geth_thread_data_tx_t *) qe_muram_addr(ugeth->
+							thread_dat_tx_offset);
+	out_be32(&ugeth->p_tx_glbl_pram->tqptr, ugeth->thread_dat_tx_offset);
+
+	/* vtagtable */
+	for (i = 0; i < UCC_GETH_TX_VTAG_TABLE_ENTRY_MAX; i++)
+		out_be32(&ugeth->p_tx_glbl_pram->vtagtable[i],
+			 ug_info->vtagtable[i]);
+
+	/* iphoffset */
+	for (i = 0; i < TX_IP_OFFSET_ENTRY_MAX; i++)
+		ugeth->p_tx_glbl_pram->iphoffset[i] = ug_info->iphoffset[i];
+
+	/* SQPTR */
+	/* Size varies with number of Tx queues */
+	ugeth->send_q_mem_reg_offset =
+	    qe_muram_alloc(ug_info->numQueuesTx *
+			   sizeof(ucc_geth_send_queue_qd_t),
+			   UCC_GETH_SEND_QUEUE_QUEUE_DESCRIPTOR_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->send_q_mem_reg_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_send_q_mem_reg.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+
+	ugeth->p_send_q_mem_reg =
+	    (ucc_geth_send_queue_mem_region_t *) qe_muram_addr(ugeth->
+							       send_q_mem_reg_offset);
+	out_be32(&ugeth->p_tx_glbl_pram->sqptr, ugeth->send_q_mem_reg_offset);
+
+	/* Setup the table */
+	/* Assume BD rings are already established */
+	for (i = 0; i < ug_info->numQueuesTx; i++) {
+		endOfRing =
+		    ugeth->p_tx_bd_ring[i] + (ug_info->bdRingLenTx[i] -
+					      1) * UCC_GETH_SIZE_OF_BD;
+		if (ugeth->ug_info->uf_info.bd_mem_part == MEM_PART_SYSTEM) {
+			out_be32(&ugeth->p_send_q_mem_reg->sqqd[i].bd_ring_base,
+				 (u32) virt_to_phys(ugeth->p_tx_bd_ring[i]));
+			out_be32(&ugeth->p_send_q_mem_reg->sqqd[i].
+				 last_bd_completed_address,
+				 (u32) virt_to_phys(endOfRing));
+		} else if (ugeth->ug_info->uf_info.bd_mem_part ==
+			   MEM_PART_MURAM) {
+			out_be32(&ugeth->p_send_q_mem_reg->sqqd[i].bd_ring_base,
+				 (u32) immrbar_virt_to_phys(ugeth->
+							    p_tx_bd_ring[i]));
+			out_be32(&ugeth->p_send_q_mem_reg->sqqd[i].
+				 last_bd_completed_address,
+				 (u32) immrbar_virt_to_phys(endOfRing));
+		}
+	}
+
+	/* schedulerbasepointer */
+
+	if (ug_info->numQueuesTx > 1) {	/* scheduler exists only if more than 1 tx queue */
+		ugeth->scheduler_offset =
+		    qe_muram_alloc(sizeof(ucc_geth_scheduler_t),
+				   UCC_GETH_SCHEDULER_ALIGNMENT);
+		if (IS_MURAM_ERR(ugeth->scheduler_offset)) {
+			ugeth_err
+			    ("%s: Can not allocate DPRAM memory for p_scheduler.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+
+		ugeth->p_scheduler =
+		    (ucc_geth_scheduler_t *) qe_muram_addr(ugeth->
+							   scheduler_offset);
+		out_be32(&ugeth->p_tx_glbl_pram->schedulerbasepointer,
+			 ugeth->scheduler_offset);
+		/* Zero out p_scheduler */
+		memset(ugeth->p_scheduler, 0, sizeof(ucc_geth_scheduler_t));
+
+		/* Set values in scheduler */
+		out_be32(&ugeth->p_scheduler->mblinterval,
+			 ug_info->mblinterval);
+		out_be16(&ugeth->p_scheduler->nortsrbytetime,
+			 ug_info->nortsrbytetime);
+		ugeth->p_scheduler->fracsiz = ug_info->fracsiz;
+		ugeth->p_scheduler->strictpriorityq = ug_info->strictpriorityq;
+		ugeth->p_scheduler->txasap = ug_info->txasap;
+		ugeth->p_scheduler->extrabw = ug_info->extrabw;
+		for (i = 0; i < NUM_TX_QUEUES; i++)
+			ugeth->p_scheduler->weightfactor[i] =
+			    ug_info->weightfactor[i];
+
+		/* Set pointers to cpucount registers in scheduler */
+		ugeth->p_cpucount[0] = &(ugeth->p_scheduler->cpucount0);
+		ugeth->p_cpucount[1] = &(ugeth->p_scheduler->cpucount1);
+		ugeth->p_cpucount[2] = &(ugeth->p_scheduler->cpucount2);
+		ugeth->p_cpucount[3] = &(ugeth->p_scheduler->cpucount3);
+		ugeth->p_cpucount[4] = &(ugeth->p_scheduler->cpucount4);
+		ugeth->p_cpucount[5] = &(ugeth->p_scheduler->cpucount5);
+		ugeth->p_cpucount[6] = &(ugeth->p_scheduler->cpucount6);
+		ugeth->p_cpucount[7] = &(ugeth->p_scheduler->cpucount7);
+	}
+
+	/* schedulerbasepointer */
+	/* TxRMON_PTR (statistics) */
+	if (ug_info->
+	    statisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {
+		ugeth->tx_fw_statistics_pram_offset =
+		    qe_muram_alloc(sizeof
+				   (ucc_geth_tx_firmware_statistics_pram_t),
+				   UCC_GETH_TX_STATISTICS_ALIGNMENT);
+		if (IS_MURAM_ERR(ugeth->tx_fw_statistics_pram_offset)) {
+			ugeth_err
+			    ("%s: Can not allocate DPRAM memory for p_tx_fw_statistics_pram.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+		ugeth->p_tx_fw_statistics_pram =
+		    (ucc_geth_tx_firmware_statistics_pram_t *)
+		    qe_muram_addr(ugeth->tx_fw_statistics_pram_offset);
+		/* Zero out p_tx_fw_statistics_pram */
+		memset(ugeth->p_tx_fw_statistics_pram,
+		       0, sizeof(ucc_geth_tx_firmware_statistics_pram_t));
+	}
+
+	/* temoder */
+	/* Already has speed set */
+
+	if (ug_info->numQueuesTx > 1)
+		temoder |= TEMODER_SCHEDULER_ENABLE;
+	if (ug_info->ipCheckSumGenerate)
+		temoder |= TEMODER_IP_CHECKSUM_GENERATE;
+	temoder |= ((ug_info->numQueuesTx - 1) << TEMODER_NUM_OF_QUEUES_SHIFT);
+	out_be16(&ugeth->p_tx_glbl_pram->temoder, temoder);
+
+	test = in_be16(&ugeth->p_tx_glbl_pram->temoder);
+
+	/* Function code register value to be used later */
+	function_code = QE_BMR_BYTE_ORDER_BO_MOT | UCC_FAST_FUNCTION_CODE_GBL;	/* Required for QE */
+
+	/* function code register */
+	out_be32(&ugeth->p_tx_glbl_pram->tstate, ((u32) function_code) << 24);
+
+	/* Rx global PRAM */
+	/* Allocate global rx parameter RAM page */
+	ugeth->rx_glbl_pram_offset =
+	    qe_muram_alloc(sizeof(ucc_geth_rx_global_pram_t),
+			   UCC_GETH_RX_GLOBAL_PRAM_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->rx_glbl_pram_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_rx_glbl_pram.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+	ugeth->p_rx_glbl_pram =
+	    (ucc_geth_rx_global_pram_t *) qe_muram_addr(ugeth->
+							rx_glbl_pram_offset);
+	/* Zero out p_rx_glbl_pram */
+	memset(ugeth->p_rx_glbl_pram, 0, sizeof(ucc_geth_rx_global_pram_t));
+
+	/* Fill global PRAM */
+
+	/* RQPTR */
+	/* Size varies with number of Rx threads */
+	ugeth->thread_dat_rx_offset =
+	    qe_muram_alloc(numThreadsRxNumerical *
+			   sizeof(ucc_geth_thread_data_rx_t),
+			   UCC_GETH_THREAD_DATA_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->thread_dat_rx_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_thread_data_rx.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+
+	ugeth->p_thread_data_rx =
+	    (ucc_geth_thread_data_rx_t *) qe_muram_addr(ugeth->
+							thread_dat_rx_offset);
+	out_be32(&ugeth->p_rx_glbl_pram->rqptr, ugeth->thread_dat_rx_offset);
+
+	/* typeorlen */
+	out_be16(&ugeth->p_rx_glbl_pram->typeorlen, ug_info->typeorlen);
+
+	/* rxrmonbaseptr (statistics) */
+	if (ug_info->
+	    statisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX) {
+		ugeth->rx_fw_statistics_pram_offset =
+		    qe_muram_alloc(sizeof
+				   (ucc_geth_rx_firmware_statistics_pram_t),
+				   UCC_GETH_RX_STATISTICS_ALIGNMENT);
+		if (IS_MURAM_ERR(ugeth->rx_fw_statistics_pram_offset)) {
+			ugeth_err
+			    ("%s: Can not allocate DPRAM memory for p_rx_fw_statistics_pram.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+		ugeth->p_rx_fw_statistics_pram =
+		    (ucc_geth_rx_firmware_statistics_pram_t *)
+		    qe_muram_addr(ugeth->rx_fw_statistics_pram_offset);
+		/* Zero out p_rx_fw_statistics_pram */
+		memset(ugeth->p_rx_fw_statistics_pram, 0,
+		       sizeof(ucc_geth_rx_firmware_statistics_pram_t));
+	}
+
+	/* intCoalescingPtr */
+
+	/* Size varies with number of Rx queues */
+	ugeth->rx_irq_coalescing_tbl_offset =
+	    qe_muram_alloc(ug_info->numQueuesRx *
+			   sizeof(ucc_geth_rx_interrupt_coalescing_entry_t),
+			   UCC_GETH_RX_INTERRUPT_COALESCING_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->rx_irq_coalescing_tbl_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_rx_irq_coalescing_tbl.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+
+	ugeth->p_rx_irq_coalescing_tbl =
+	    (ucc_geth_rx_interrupt_coalescing_table_t *)
+	    qe_muram_addr(ugeth->rx_irq_coalescing_tbl_offset);
+	out_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr,
+		 ugeth->rx_irq_coalescing_tbl_offset);
+
+	/* Fill interrupt coalescing table */
+	for (i = 0; i < ug_info->numQueuesRx; i++) {
+		out_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].
+			 interruptcoalescingmaxvalue,
+			 ug_info->interruptcoalescingmaxvalue[i]);
+		out_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].
+			 interruptcoalescingcounter,
+			 ug_info->interruptcoalescingmaxvalue[i]);
+	}
+
+	/* MRBLR */
+	init_max_rx_buff_len(uf_info->max_rx_buf_length,
+			     &ugeth->p_rx_glbl_pram->mrblr);
+	/* MFLR */
+	out_be16(&ugeth->p_rx_glbl_pram->mflr, ug_info->maxFrameLength);
+	/* MINFLR */
+	init_min_frame_len(ug_info->minFrameLength,
+			   &ugeth->p_rx_glbl_pram->minflr,
+			   &ugeth->p_rx_glbl_pram->mrblr);
+	/* MAXD1 */
+	out_be16(&ugeth->p_rx_glbl_pram->maxd1, ug_info->maxD1Length);
+	/* MAXD2 */
+	out_be16(&ugeth->p_rx_glbl_pram->maxd2, ug_info->maxD2Length);
+
+	/* l2qt */
+	l2qt = 0;
+	for (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++)
+		l2qt |= (ug_info->l2qt[i] << (28 - 4 * i));
+	out_be32(&ugeth->p_rx_glbl_pram->l2qt, l2qt);
+
+	/* l3qt */
+	for (j = 0; j < UCC_GETH_IP_PRIORITY_MAX; j += 8) {
+		l3qt = 0;
+		for (i = 0; i < 8; i++)
+			l3qt |= (ug_info->l3qt[j + i] << (28 - 4 * i));
+		out_be32(&ugeth->p_rx_glbl_pram->l3qt[j], l3qt);
+	}
+
+	/* vlantype */
+	out_be16(&ugeth->p_rx_glbl_pram->vlantype, ug_info->vlantype);
+
+	/* vlantci */
+	out_be16(&ugeth->p_rx_glbl_pram->vlantci, ug_info->vlantci);
+
+	/* ecamptr */
+	out_be32(&ugeth->p_rx_glbl_pram->ecamptr, ug_info->ecamptr);
+
+	/* RBDQPTR */
+	/* Size varies with number of Rx queues */
+	ugeth->rx_bd_qs_tbl_offset =
+	    qe_muram_alloc(ug_info->numQueuesRx *
+			   (sizeof(ucc_geth_rx_bd_queues_entry_t) +
+			    sizeof(ucc_geth_rx_prefetched_bds_t)),
+			   UCC_GETH_RX_BD_QUEUES_ALIGNMENT);
+	if (IS_MURAM_ERR(ugeth->rx_bd_qs_tbl_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_rx_bd_qs_tbl.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+
+	ugeth->p_rx_bd_qs_tbl =
+	    (ucc_geth_rx_bd_queues_entry_t *) qe_muram_addr(ugeth->
+							    rx_bd_qs_tbl_offset);
+	out_be32(&ugeth->p_rx_glbl_pram->rbdqptr, ugeth->rx_bd_qs_tbl_offset);
+	/* Zero out p_rx_bd_qs_tbl */
+	memset(ugeth->p_rx_bd_qs_tbl,
+	       0,
+	       ug_info->numQueuesRx * (sizeof(ucc_geth_rx_bd_queues_entry_t) +
+				       sizeof(ucc_geth_rx_prefetched_bds_t)));
+
+	/* Setup the table */
+	/* Assume BD rings are already established */
+	for (i = 0; i < ug_info->numQueuesRx; i++) {
+		if (ugeth->ug_info->uf_info.bd_mem_part == MEM_PART_SYSTEM) {
+			out_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,
+				 (u32) virt_to_phys(ugeth->p_rx_bd_ring[i]));
+		} else if (ugeth->ug_info->uf_info.bd_mem_part ==
+			   MEM_PART_MURAM) {
+			out_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,
+				 (u32) immrbar_virt_to_phys(ugeth->
+							    p_rx_bd_ring[i]));
+		}
+		/* rest of fields handled by QE */
+	}
+
+	/* remoder */
+	/* Already has speed set */
+
+	if (ugeth->rx_extended_features)
+		remoder |= REMODER_RX_EXTENDED_FEATURES;
+	if (ug_info->rxExtendedFiltering)
+		remoder |= REMODER_RX_EXTENDED_FILTERING;
+	if (ug_info->dynamicMaxFrameLength)
+		remoder |= REMODER_DYNAMIC_MAX_FRAME_LENGTH;
+	if (ug_info->dynamicMinFrameLength)
+		remoder |= REMODER_DYNAMIC_MIN_FRAME_LENGTH;
+	remoder |=
+	    ug_info->vlanOperationTagged << REMODER_VLAN_OPERATION_TAGGED_SHIFT;
+	remoder |=
+	    ug_info->
+	    vlanOperationNonTagged << REMODER_VLAN_OPERATION_NON_TAGGED_SHIFT;
+	remoder |= ug_info->rxQoSMode << REMODER_RX_QOS_MODE_SHIFT;
+	remoder |= ((ug_info->numQueuesRx - 1) << REMODER_NUM_OF_QUEUES_SHIFT);
+	if (ug_info->ipCheckSumCheck)
+		remoder |= REMODER_IP_CHECKSUM_CHECK;
+	if (ug_info->ipAddressAlignment)
+		remoder |= REMODER_IP_ADDRESS_ALIGNMENT;
+	out_be32(&ugeth->p_rx_glbl_pram->remoder, remoder);
+
+	/* Note that this function must be called */
+	/* ONLY AFTER p_tx_fw_statistics_pram */
+	/* andp_UccGethRxFirmwareStatisticsPram are allocated ! */
+	init_firmware_statistics_gathering_mode((ug_info->
+						 statisticsMode &
+						 UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX),
+						(ug_info->
+						 statisticsMode &
+						 UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX),
+						&ugeth->p_tx_glbl_pram->
+						txrmonbaseptr,
+						ugeth->
+						tx_fw_statistics_pram_offset,
+						&ugeth->p_rx_glbl_pram->
+						rxrmonbaseptr,
+						ugeth->
+						rx_fw_statistics_pram_offset,
+						&ugeth->p_tx_glbl_pram->temoder,
+						&ugeth->p_rx_glbl_pram->
+						remoder);
+
+	/* function code register */
+	ugeth->p_rx_glbl_pram->rstate = function_code;
+
+	/* initialize extended filtering */
+	if (ug_info->rxExtendedFiltering) {
+		if (!ug_info->extendedFilteringChainPointer) {
+			ugeth_err("%s: Null Extended Filtering Chain Pointer.",
+				  __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -EINVAL;
+		}
+
+		/* Allocate memory for extended filtering Mode Global Parameters */
+		ugeth->exf_glbl_param_offset =
+		    qe_muram_alloc(sizeof(ucc_geth_exf_global_pram_t),
+				   UCC_GETH_RX_EXTENDED_FILTERING_GLOBAL_PARAMETERS_ALIGNMENT);
+		if (IS_MURAM_ERR(ugeth->exf_glbl_param_offset)) {
+			ugeth_err
+			    ("%s: Can not allocate DPRAM memory for p_exf_glbl_param.",
+			     __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return -ENOMEM;
+		}
+
+		ugeth->p_exf_glbl_param =
+		    (ucc_geth_exf_global_pram_t *) qe_muram_addr(ugeth->
+								 exf_glbl_param_offset);
+		out_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam,
+			 ugeth->exf_glbl_param_offset);
+		out_be32(&ugeth->p_exf_glbl_param->l2pcdptr,
+			 (u32) ug_info->extendedFilteringChainPointer);
+
+	} else {		/* initialize 82xx style address filtering */
+
+		/* Init individual address recognition registers to disabled */
+
+		for (j = 0; j < NUM_OF_PADDRS; j++)
+			ugeth_82xx_filtering_clear_addr_in_paddr(ugeth, (u8) j);
+
+		p_82xx_addr_filt =
+		    (ucc_geth_82xx_address_filtering_pram_t *) ugeth->
+		    p_rx_glbl_pram->addressfiltering;
+
+		ugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,
+							    ENET_ADDR_TYPE_GROUP);
+		ugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,
+							    ENET_ADDR_TYPE_INDIVIDUAL);
+	}
+
+	/*
+	 * Initialize UCC at QE level
+	 */
+
+	command = QE_INIT_TX_RX;
+
+	/* Allocate shadow InitEnet command parameter structure.
+	 * This is needed because after the InitEnet command is executed,
+	 * the structure in DPRAM is released, because DPRAM is a premium resource.
+	 * This shadow structure keeps a copy of what was done so that the
+	 * allocated resources can be released when the channel is freed.
+	 */
+	if (!
+	    (ugeth->p_init_enet_param_shadow =
+	     (ucc_geth_init_pram_t *) kmalloc(sizeof(ucc_geth_init_pram_t),
+					      GFP_KERNEL))) {
+		ugeth_err
+		    ("%s: Can not allocate memory for p_UccInitEnetParamShadows.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+	/* Zero out *p_init_enet_param_shadow */
+	memset((char *)ugeth->p_init_enet_param_shadow,
+	       0, sizeof(ucc_geth_init_pram_t));
+
+	/* Fill shadow InitEnet command parameter structure */
+
+	ugeth->p_init_enet_param_shadow->resinit1 =
+	    ENET_INIT_PARAM_MAGIC_RES_INIT1;
+	ugeth->p_init_enet_param_shadow->resinit2 =
+	    ENET_INIT_PARAM_MAGIC_RES_INIT2;
+	ugeth->p_init_enet_param_shadow->resinit3 =
+	    ENET_INIT_PARAM_MAGIC_RES_INIT3;
+	ugeth->p_init_enet_param_shadow->resinit4 =
+	    ENET_INIT_PARAM_MAGIC_RES_INIT4;
+	ugeth->p_init_enet_param_shadow->resinit5 =
+	    ENET_INIT_PARAM_MAGIC_RES_INIT5;
+	ugeth->p_init_enet_param_shadow->rgftgfrxglobal |=
+	    ((u32) ug_info->numThreadsRx) << ENET_INIT_PARAM_RGF_SHIFT;
+	ugeth->p_init_enet_param_shadow->rgftgfrxglobal |=
+	    ((u32) ug_info->numThreadsTx) << ENET_INIT_PARAM_TGF_SHIFT;
+
+	ugeth->p_init_enet_param_shadow->rgftgfrxglobal |=
+	    ugeth->rx_glbl_pram_offset | ug_info->riscRx;
+	if ((ug_info->largestexternallookupkeysize !=
+	     QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE)
+	    && (ug_info->largestexternallookupkeysize !=
+		QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_8_BYTES)
+	    && (ug_info->largestexternallookupkeysize !=
+		QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_16_BYTES)) {
+		ugeth_err("%s: Invalid largest External Lookup Key Size.",
+			  __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -EINVAL;
+	}
+	ugeth->p_init_enet_param_shadow->largestexternallookupkeysize =
+	    ug_info->largestexternallookupkeysize;
+	size = sizeof(ucc_geth_thread_rx_pram_t);
+	if (ug_info->rxExtendedFiltering) {
+		size += THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;
+		if (ug_info->largestexternallookupkeysize ==
+		    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES)
+			size +=
+			    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;
+		if (ug_info->largestexternallookupkeysize ==
+		    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES)
+			size +=
+			    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;
+	}
+
+	if ((ret_val = fill_init_enet_entries(ugeth,
+					      &(ugeth->
+						p_init_enet_param_shadow->
+						rxthread[0]),
+					      (u8) (numThreadsRxNumerical + 1)
+					      /* Rx needs one extra for terminator */
+					      ,
+					      size,
+					      UCC_GETH_THREAD_RX_PRAM_ALIGNMENT,
+					      ug_info->riscRx, 1)) != 0) {
+		ugeth_err("%s: Can not fill p_init_enet_param_shadow.",
+			  __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return ret_val;
+	}
+
+	ugeth->p_init_enet_param_shadow->txglobal =
+	    ugeth->tx_glbl_pram_offset | ug_info->riscTx;
+	if ((ret_val =
+	     fill_init_enet_entries(ugeth,
+				    &(ugeth->p_init_enet_param_shadow->
+				      txthread[0]), numThreadsTxNumerical,
+				    sizeof(ucc_geth_thread_tx_pram_t),
+				    UCC_GETH_THREAD_TX_PRAM_ALIGNMENT,
+				    ug_info->riscTx, 0)) != 0) {
+		ugeth_err("%s: Can not fill p_init_enet_param_shadow.",
+			  __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return ret_val;
+	}
+
+	/* Load Rx bds with buffers */
+	for (i = 0; i < ug_info->numQueuesRx; i++) {
+		if ((ret_val = rx_bd_buffer_set(ugeth, (u8) i)) != 0) {
+			ugeth_err("%s: Can not fill Rx bds with buffers.",
+				  __FUNCTION__);
+			ucc_geth_memclean(ugeth);
+			return ret_val;
+		}
+	}
+
+	/* Allocate InitEnet command parameter structure */
+	init_enet_pram_offset = qe_muram_alloc(sizeof(ucc_geth_init_pram_t), 4);
+	if (IS_MURAM_ERR(init_enet_pram_offset)) {
+		ugeth_err
+		    ("%s: Can not allocate DPRAM memory for p_init_enet_pram.",
+		     __FUNCTION__);
+		ucc_geth_memclean(ugeth);
+		return -ENOMEM;
+	}
+	p_init_enet_pram =
+	    (ucc_geth_init_pram_t *) qe_muram_addr(init_enet_pram_offset);
+
+	/* Copy shadow InitEnet command parameter structure into PRAM */
+	p_init_enet_pram->resinit1 = ugeth->p_init_enet_param_shadow->resinit1;
+	p_init_enet_pram->resinit2 = ugeth->p_init_enet_param_shadow->resinit2;
+	p_init_enet_pram->resinit3 = ugeth->p_init_enet_param_shadow->resinit3;
+	p_init_enet_pram->resinit4 = ugeth->p_init_enet_param_shadow->resinit4;
+	out_be16(&p_init_enet_pram->resinit5,
+		 ugeth->p_init_enet_param_shadow->resinit5);
+	p_init_enet_pram->largestexternallookupkeysize =
+	    ugeth->p_init_enet_param_shadow->largestexternallookupkeysize;
+	out_be32(&p_init_enet_pram->rgftgfrxglobal,
+		 ugeth->p_init_enet_param_shadow->rgftgfrxglobal);
+	for (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_RX; i++)
+		out_be32(&p_init_enet_pram->rxthread[i],
+			 ugeth->p_init_enet_param_shadow->rxthread[i]);
+	out_be32(&p_init_enet_pram->txglobal,
+		 ugeth->p_init_enet_param_shadow->txglobal);
+	for (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_TX; i++)
+		out_be32(&p_init_enet_pram->txthread[i],
+			 ugeth->p_init_enet_param_shadow->txthread[i]);
+
+	/* Issue QE command */
+	cecr_subblock =
+	    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);
+	qe_issue_cmd(command, cecr_subblock, (u8) QE_CR_PROTOCOL_ETHERNET,
+		     init_enet_pram_offset);
+
+	/* Free InitEnet command parameter */
+	qe_muram_free(init_enet_pram_offset);
+
+	return 0;
+}
+
+/* returns a net_device_stats structure pointer */
+static struct net_device_stats *ucc_geth_get_stats(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+
+	return &(ugeth->stats);
+}
+
+/* ucc_geth_timeout gets called when a packet has not been
+ * transmitted after a set amount of time.
+ * For now, assume that clearing out all the structures, and
+ * starting over will fix the problem. */
+static void ucc_geth_timeout(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	ugeth->stats.tx_errors++;
+
+	ugeth_dump_regs(ugeth);
+
+	if (dev->flags & IFF_UP) {
+		ucc_geth_stop(ugeth);
+		ucc_geth_startup(ugeth);
+	}
+
+	netif_schedule(dev);
+}
+
+/* This is called by the kernel when a frame is ready for transmission. */
+/* It is pointed to by the dev->hard_start_xmit function pointer */
+static int ucc_geth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	u8 *bd;			/* BD pointer */
+	u32 bd_status;
+#if (DEFAULT_numQueuesTx > 1)
+#error "We support only 1 transmit queue!"
+#endif				/* (DEFAULT_numQueuesTx > 1) */
+	u8 txQ = 0;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irq(&ugeth->lock);
+
+	ugeth->stats.tx_bytes += skb->len;
+
+	/* Start from the next BD that should be filled */
+	bd = ugeth->txBd[txQ];
+	bd_status = BD_STATUS_AND_LENGTH(bd);
+	/* Save the skb pointer so we can free it later */
+	ugeth->tx_skbuff[txQ][ugeth->skb_curtx[txQ]] = skb;
+
+	/* Update the current skb pointer (wrapping if this was the last) */
+	ugeth->skb_curtx[txQ] =
+	    (ugeth->skb_curtx[txQ] +
+	     1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);
+
+	/* set up the buffer descriptor */
+	BD_BUFFER_SET(bd,
+		      dma_map_single(NULL, skb->data, skb->len, DMA_TO_DEVICE));
+
+	ugeth_vdbg("skb->data is 0x%x\n", skb->data);
+
+	bd_status = (bd_status & T_W) | T_R | T_I | T_L | skb->len;
+
+	BD_STATUS_AND_LENGTH_SET(bd, bd_status);
+
+	dev->trans_start = jiffies;
+
+	/* Move to next BD in the ring */
+	if (bd_status & T_W)
+		ugeth->txBd[txQ] = ugeth->p_tx_bd_ring[txQ];
+	else
+		ugeth->txBd[txQ] = bd + UCC_GETH_SIZE_OF_BD;
+
+	/* If the next BD still needs to be cleaned up, then the bds
+	   are full.  We need to tell the kernel to stop sending us stuff. */
+	if (ugeth->txBd[txQ] == ugeth->confBd[txQ]) {
+		if (!netif_queue_stopped(dev))
+			netif_stop_queue(dev);
+	}
+
+	if (ugeth->p_scheduler) {
+		ugeth->cpucount[txQ]++;
+		/* Indicate to QE that there are more Tx bds ready for transmission                 */
+		/* This is done by writing a running counter of the bd count to the scheduler PRAM. */
+		out_be16(ugeth->p_cpucount[txQ], ugeth->cpucount[txQ]);
+	}
+
+	spin_unlock_irq(&ugeth->lock);
+
+	return 0;
+}
+
+static int ucc_geth_rx(ucc_geth_private_t * ugeth, u8 rxQ, int rx_work_limit)
+{
+	struct sk_buff *skb;
+	u8 *bd;
+	u16 length, howmany = 0;
+	u32 bd_status;
+	u8 *bdBuffer;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock(&ugeth->lock);
+	/* collect received buffers */
+	bd = ugeth->rxBd[rxQ];
+
+	bd_status = BD_STATUS_AND_LENGTH(bd);
+
+	/* while there are received buffers and BD is full (~R_E) */
+	while (!(bd_status & (R_E)) && (rx_work_limit-- > 0)) {
+		bdBuffer = (u8 *) BD_BUFFER(bd);
+		length = (u16) ((bd_status & BD_LENGTH_MASK) - 4);
+		skb = ugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]];
+
+		/* determine whether buffer is first, last, first and last (single  */
+		/* buffer frame) or middle (not first and not last)                 */
+		if (!skb ||
+		    (!(bd_status & (R_F | R_L))) ||
+		    (bd_status & R_ERRORS_FATAL)) {
+			ugeth_vdbg("%s, %d: ERROR!!! skb - 0x%08x",
+				   __FUNCTION__, __LINE__, (u32) skb);
+			if (skb)
+				dev_kfree_skb_any(skb);
+
+			ugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = NULL;
+			ugeth->stats.rx_dropped++;
+		} else {
+			ugeth->stats.rx_packets++;
+			howmany++;
+
+			/* Prep the skb for the packet */
+			skb_put(skb, length);
+
+			/* Tell the skb what kind of packet this is */
+			skb->protocol = eth_type_trans(skb, ugeth->dev);
+
+			ugeth->stats.rx_bytes += length;
+			/* Send the packet up the stack */
+			netif_rx(skb);
+		}
+
+		ugeth->dev->last_rx = jiffies;
+
+		skb = get_new_skb(ugeth, bd);
+		if (!skb) {
+			ugeth_warn("%s: No Rx Data Buffer", __FUNCTION__);
+			spin_unlock(&ugeth->lock);
+			ugeth->stats.rx_dropped++;
+			break;
+		}
+
+		ugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = skb;
+
+		/* update to point at the next skb */
+		ugeth->skb_currx[rxQ] =
+		    (ugeth->skb_currx[rxQ] +
+		     1) & RX_RING_MOD_MASK(ugeth->ug_info->bdRingLenRx[rxQ]);
+
+		if (bd_status & R_W)
+			bd = ugeth->p_rx_bd_ring[rxQ];
+		else
+			bd += UCC_GETH_SIZE_OF_BD;
+
+		bd_status = BD_STATUS_AND_LENGTH(bd);
+	}
+
+	ugeth->rxBd[rxQ] = bd;
+	spin_unlock(&ugeth->lock);
+	return howmany;
+}
+
+static int ucc_geth_tx(struct net_device *dev, u8 txQ)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	u8 *bd;			/* BD pointer */
+	u32 bd_status;
+
+	bd = ugeth->confBd[txQ];
+	bd_status = BD_STATUS_AND_LENGTH(bd);
+
+	/* Normal processing. */
+	while ((bd_status & T_R) == 0) {
+		/* If confBd and txBd are the same, then either the
+		 * ring is empty or full now (it could only be full in the
+		 * beginning, obviously).  If it is empty, we are done.
+		 */
+		if ((bd == ugeth->txBd[txQ]) && (netif_queue_stopped(dev) == 0))
+			break;
+
+		ugeth->stats.tx_packets++;
+
+		/* Free the sk buffer associated with this TxBD */
+		dev_kfree_skb_irq(ugeth->
+				  tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]]);
+		ugeth->tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]] = NULL;
+		ugeth->skb_dirtytx[txQ] =
+		    (ugeth->skb_dirtytx[txQ] +
+		     1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);
+
+		/* We freed a buffer, so now we can restart transmission */
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+
+		/* Advance the confirmation BD pointer */
+		if (bd_status & T_W)
+			bd = ugeth->p_tx_bd_ring[txQ];
+		else
+			bd += UCC_GETH_SIZE_OF_BD;
+
+		ugeth->confBd[txQ] = bd;
+		bd_status = BD_STATUS_AND_LENGTH(bd);
+	}
+
+	return 0;
+}
+
+static irqreturn_t ucc_geth_irq_handler(int irq, void *info,
+					struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)info;
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	ucc_fast_private_t *uccf;
+	ucc_geth_info_t *ug_info;
+	register u32 ucce = 0;
+	register u32 bit_mask = UCCE_RXBF_SINGLE_MASK;
+	register u32 tx_mask = UCCE_TXBF_SINGLE_MASK;
+	register u8 i;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	if (!ugeth)
+		return IRQ_NONE;
+
+	uccf = ugeth->uccf;
+	ug_info = ugeth->ug_info;
+
+	do {
+		ucce |= (u32) (in_be32(uccf->p_ucce) & in_be32(uccf->p_uccm));
+
+		/* clear event bits for next time */
+		/* Side effect here is to mask ucce variable for future processing below. */
+		out_be32(uccf->p_ucce, ucce);	/* Clear with ones, but only bits in UCCM */
+
+		/* We ignore Tx interrupts because Tx confirmation is done inside Tx routine */
+
+		for (i = 0; i < ug_info->numQueuesRx; i++) {
+			if (ucce & bit_mask)
+				ucc_geth_rx(ugeth, i,
+					    (int)ugeth->ug_info->
+					    bdRingLenRx[i]);
+			ucce &= ~bit_mask;
+			bit_mask <<= 1;
+		}
+
+		for (i = 0; i < ug_info->numQueuesTx; i++) {
+			if (ucce & tx_mask)
+				ucc_geth_tx(dev, i);
+			ucce &= ~tx_mask;
+			tx_mask <<= 1;
+		}
+
+		/* Exceptions */
+		if (ucce & UCCE_BSY) {
+			ugeth_vdbg("Got BUSY irq!!!!");
+			ugeth->stats.rx_errors++;
+			ucce &= ~UCCE_BSY;
+		}
+		if (ucce & UCCE_OTHER) {
+			ugeth_vdbg("Got frame with error (ucce - 0x%08x)!!!!",
+				   ucce);
+			ugeth->stats.rx_errors++;
+			ucce &= ~ucce;
+		}
+	}
+	while (ucce);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t phy_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	/* Clear the interrupt */
+	mii_clear_phy_interrupt(ugeth->mii_info);
+
+	/* Disable PHY interrupts */
+	mii_configure_phy_interrupt(ugeth->mii_info, MII_INTERRUPT_DISABLED);
+
+	/* Schedule the phy change */
+	schedule_work(&ugeth->tq);
+
+	return IRQ_HANDLED;
+}
+
+/* Scheduled by the phy_interrupt/timer to handle PHY changes */
+static void ugeth_phy_change(void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	ucc_geth_t *ug_regs;
+	int result = 0;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	ug_regs = ugeth->ug_regs;
+
+	/* Delay to give the PHY a chance to change the
+	 * register state */
+	msleep(1);
+
+	/* Update the link, speed, duplex */
+	result = ugeth->mii_info->phyinfo->read_status(ugeth->mii_info);
+
+	/* Adjust the known status as long as the link
+	 * isn't still coming up */
+	if ((0 == result) || (ugeth->mii_info->link == 0))
+		adjust_link(dev);
+
+	/* Reenable interrupts, if needed */
+	if (ugeth->ug_info->board_flags & FSL_UGETH_BRD_HAS_PHY_INTR)
+		mii_configure_phy_interrupt(ugeth->mii_info,
+					    MII_INTERRUPT_ENABLED);
+}
+
+/* Called every so often on systems that don't interrupt
+ * the core for PHY changes */
+static void ugeth_phy_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+
+	schedule_work(&ugeth->tq);
+
+	mod_timer(&ugeth->phy_info_timer, jiffies + PHY_CHANGE_TIME * HZ);
+}
+
+/* Keep trying aneg for some time
+ * If, after GFAR_AN_TIMEOUT seconds, it has not
+ * finished, we switch to forced.
+ * Either way, once the process has completed, we either
+ * request the interrupt, or switch the timer over to
+ * using ugeth_phy_timer to check status */
+static void ugeth_phy_startup_timer(unsigned long data)
+{
+	struct ugeth_mii_info *mii_info = (struct ugeth_mii_info *)data;
+	ucc_geth_private_t *ugeth = netdev_priv(mii_info->dev);
+	static int secondary = UGETH_AN_TIMEOUT;
+	int result;
+
+	/* Configure the Auto-negotiation */
+	result = mii_info->phyinfo->config_aneg(mii_info);
+
+	/* If autonegotiation failed to start, and
+	 * we haven't timed out, reset the timer, and return */
+	if (result && secondary--) {
+		mod_timer(&ugeth->phy_info_timer, jiffies + HZ);
+		return;
+	} else if (result) {
+		/* Couldn't start autonegotiation.
+		 * Try switching to forced */
+		mii_info->autoneg = 0;
+		result = mii_info->phyinfo->config_aneg(mii_info);
+
+		/* Forcing failed!  Give up */
+		if (result) {
+			ugeth_err("%s: Forcing failed!", mii_info->dev->name);
+			return;
+		}
+	}
+
+	/* Kill the timer so it can be restarted */
+	del_timer_sync(&ugeth->phy_info_timer);
+
+	/* Grab the PHY interrupt, if necessary/possible */
+	if (ugeth->ug_info->board_flags & FSL_UGETH_BRD_HAS_PHY_INTR) {
+		if (request_irq(ugeth->ug_info->phy_interrupt,
+				phy_interrupt,
+				SA_SHIRQ, "phy_interrupt", mii_info->dev) < 0) {
+			ugeth_err("%s: Can't get IRQ %d (PHY)",
+				  mii_info->dev->name,
+				  ugeth->ug_info->phy_interrupt);
+		} else {
+			mii_configure_phy_interrupt(ugeth->mii_info,
+						    MII_INTERRUPT_ENABLED);
+			return;
+		}
+	}
+
+	/* Start the timer again, this time in order to
+	 * handle a change in status */
+	init_timer(&ugeth->phy_info_timer);
+	ugeth->phy_info_timer.function = &ugeth_phy_timer;
+	ugeth->phy_info_timer.data = (unsigned long)mii_info->dev;
+	mod_timer(&ugeth->phy_info_timer, jiffies + PHY_CHANGE_TIME * HZ);
+}
+
+/* Called when something needs to use the ethernet device */
+/* Returns 0 for success. */
+static int ucc_geth_open(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	int err;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	/* Test station address */
+	if (dev->dev_addr[0] & ENET_GROUP_ADDR) {
+		ugeth_err("%s: Multicast address used for station address"
+			  " - is this what you wanted?", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	err = ucc_geth_startup(ugeth);
+	if (err) {
+		ugeth_err("%s: Cannot configure net device, aborting.",
+			  dev->name);
+		return err;
+	}
+
+	err = adjust_enet_interface(ugeth);
+	if (err) {
+		ugeth_err("%s: Cannot configure net device, aborting.",
+			  dev->name);
+		return err;
+	}
+
+	/*       Set MACSTNADDR1, MACSTNADDR2                */
+	/* For more details see the hardware spec.           */
+	init_mac_station_addr_regs(dev->dev_addr[0],
+				   dev->dev_addr[1],
+				   dev->dev_addr[2],
+				   dev->dev_addr[3],
+				   dev->dev_addr[4],
+				   dev->dev_addr[5],
+				   &ugeth->ug_regs->macstnaddr1,
+				   &ugeth->ug_regs->macstnaddr2);
+
+	err = init_phy(dev);
+	if (err) {
+		ugeth_err("%s: Cannot initialzie PHY, aborting.", dev->name);
+		return err;
+	}
+
+	err =
+	    request_irq(ugeth->ug_info->uf_info.irq, ucc_geth_irq_handler, 0,
+			"UCC Geth", dev);
+	if (err) {
+		ugeth_err("%s: Cannot get IRQ for net device, aborting.",
+			  dev->name);
+		ucc_geth_stop(ugeth);
+		return err;
+	}
+
+	/* Set up the PHY change work queue */
+	INIT_WORK(&ugeth->tq, ugeth_phy_change, dev);
+
+	init_timer(&ugeth->phy_info_timer);
+	ugeth->phy_info_timer.function = &ugeth_phy_startup_timer;
+	ugeth->phy_info_timer.data = (unsigned long)ugeth->mii_info;
+	mod_timer(&ugeth->phy_info_timer, jiffies + HZ);
+
+	err = ugeth_enable(ugeth, COMM_DIR_RX_AND_TX);
+	if (err) {
+		ugeth_err("%s: Cannot enable net device, aborting.", dev->name);
+		ucc_geth_stop(ugeth);
+		return err;
+	}
+
+	netif_start_queue(dev);
+
+	return err;
+}
+
+/* Stops the kernel queue, and halts the controller */
+static int ucc_geth_close(struct net_device *dev)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	netif_stop_queue(dev);
+
+	ucc_geth_stop(ugeth);
+
+	/* Shutdown the PHY */
+	if (ugeth->mii_info->phyinfo->close)
+		ugeth->mii_info->phyinfo->close(ugeth->mii_info);
+
+	kfree(ugeth->mii_info);
+
+	return 0;
+}
+
+struct ethtool_ops ucc_geth_ethtool_ops = {
+	.get_settings = NULL,
+	.get_drvinfo = NULL,
+	.get_regs_len = NULL,
+	.get_regs = NULL,
+	.get_link = NULL,
+	.get_coalesce = NULL,
+	.set_coalesce = NULL,
+	.get_ringparam = NULL,
+	.set_ringparam = NULL,
+	.get_strings = NULL,
+	.get_stats_count = NULL,
+	.get_ethtool_stats = NULL,
+};
+
+static int ucc_geth_probe(struct device *device)
+{
+	struct platform_device *pdev = to_platform_device(device);
+	struct ucc_geth_platform_data *ugeth_pdata;
+	struct net_device *dev = NULL;
+	struct ucc_geth_private *ugeth = NULL;
+	struct ucc_geth_info *ug_info;
+	int err;
+	static int mii_mng_configured = 0;
+
+	ugeth_vdbg("%s: IN", __FUNCTION__);
+
+	ugeth_pdata = (struct ucc_geth_platform_data *)pdev->dev.platform_data;
+
+	if (ugeth_pdata == NULL) {
+		ugeth_err("%s: [%d] Missing additional data!", __FUNCTION__,
+			  pdev->id);
+		return -ENODEV;
+	}
+
+	ug_info = &ugeth_info[pdev->id];
+	ug_info->uf_info.ucc_num = pdev->id;
+	ug_info->uf_info.rx_clock = ugeth_pdata->rx_clock;
+	ug_info->uf_info.tx_clock = ugeth_pdata->tx_clock;
+	ug_info->uf_info.regs = ugeth_pdata->phy_reg_addr;
+	ug_info->uf_info.irq = platform_get_irq(pdev, 0);
+	ug_info->phy_address = ugeth_pdata->phy_id;
+	ug_info->enet_interface = ugeth_pdata->phy_interface;
+	ug_info->board_flags = ugeth_pdata->board_flags;
+	ug_info->phy_interrupt = ugeth_pdata->phy_interrupt;
+
+	if (!mii_mng_configured) {
+		ucc_set_qe_mux_mii_mng(ug_info->uf_info.ucc_num);
+		mii_mng_configured = 1;
+	}
+
+	/* Create an ethernet device instance */
+	dev = alloc_etherdev(sizeof(*ugeth));
+
+	if (dev == NULL)
+		return -ENOMEM;
+
+	ugeth = netdev_priv(dev);
+	spin_lock_init(&ugeth->lock);
+
+	dev_set_drvdata(device, dev);
+
+	/* Set the dev->base_addr to the gfar reg region */
+	dev->base_addr = (unsigned long)(ug_info->uf_info.regs);
+
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, device);
+
+	/* Fill in the dev structure */
+	dev->open = ucc_geth_open;
+	dev->hard_start_xmit = ucc_geth_start_xmit;
+	dev->tx_timeout = ucc_geth_timeout;
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->stop = ucc_geth_close;
+	dev->get_stats = ucc_geth_get_stats;
+	dev->mtu = 1500;
+	dev->ethtool_ops = &ucc_geth_ethtool_ops;
+
+	err = register_netdev(dev);
+	if (err) {
+		ugeth_err("%s: Cannot register net device, aborting.",
+			  dev->name);
+		free_netdev(dev);
+		return err;
+	}
+
+	ugeth->ug_info = ug_info;
+	ugeth->dev = dev;
+	memcpy(dev->dev_addr, ugeth_pdata->mac_addr, 6);
+
+	return 0;
+}
+
+static int ucc_geth_remove(struct device *device)
+{
+	struct net_device *dev = dev_get_drvdata(device);
+	struct ucc_geth_private *ugeth = netdev_priv(dev);
+
+	dev_set_drvdata(device, NULL);
+	ucc_geth_memclean(ugeth);
+	free_netdev(dev);
+
+	return 0;
+}
+
+/* Structure for a device driver */
+static struct device_driver ucc_geth_driver = {
+	.name = "fsl-ucc-geth",
+	.bus = &platform_bus_type,
+	.probe = ucc_geth_probe,
+	.remove = ucc_geth_remove,
+};
+
+static int __init ucc_geth_init(void)
+{
+	int i;
+	for (i = 0; i < 8; i++)
+		memcpy(&(ugeth_info[i]), &ugeth_primary_info,
+		       sizeof(ugeth_primary_info));
+
+	return driver_register(&ucc_geth_driver);
+}
+
+static void __exit ucc_geth_exit(void)
+{
+	driver_unregister(&ucc_geth_driver);
+}
+
+module_init(ucc_geth_init);
+module_exit(ucc_geth_exit);
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth.h
@@ -0,0 +1,1019 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_geth.h
+ *
+ * Internal header file for UCC Gigabit Ethernet unit routines.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __UCC_GETH_H__
+#define __UCC_GETH_H__
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/fsl_devices.h>
+
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+#include "ucc_fast.h"
+
+#define NUM_TX_QUEUES                   8
+#define NUM_RX_QUEUES                   8
+#define NUM_BDS_IN_PREFETCHED_BDS       4
+#define TX_IP_OFFSET_ENTRY_MAX          8
+#define NUM_OF_PADDRS                   4
+#define ENET_INIT_PARAM_MAX_ENTRIES_RX  9
+#define ENET_INIT_PARAM_MAX_ENTRIES_TX  8
+
+typedef struct ucc_mii_mng {
+	u32 miimcfg;		/* MII management configuration reg    */
+	u32 miimcom;		/* MII management command reg          */
+	u32 miimadd;		/* MII management address reg          */
+	u32 miimcon;		/* MII management control reg          */
+	u32 miimstat;		/* MII management status reg           */
+	u32 miimind;		/* MII management indication reg       */
+} __attribute__ ((packed)) ucc_mii_mng_t;
+
+typedef struct ucc_geth {
+	ucc_fast_t uccf;
+
+	u32 maccfg1;		/* mac configuration reg. 1            */
+	u32 maccfg2;		/* mac configuration reg. 2            */
+	u32 ipgifg;		/* interframe gap reg.                 */
+	u32 hafdup;		/* half-duplex reg.                    */
+	u8 res1[0x10];
+	ucc_mii_mng_t miimng;	/* MII management structure            */
+	u32 ifctl;		/* interface control reg               */
+	u32 ifstat;		/* interface statux reg                */
+	u32 macstnaddr1;	/* mac station address part 1 reg      */
+	u32 macstnaddr2;	/* mac station address part 2 reg      */
+	u8 res2[0x8];
+	u32 uempr;		/* UCC Ethernet Mac parameter reg      */
+	u32 utbipar;		/* UCC tbi address reg                 */
+	u16 uescr;		/* UCC Ethernet statistics control reg */
+	u8 res3[0x180 - 0x15A];
+	u32 tx64;		/* Total number of frames (including bad frames) transmitted that were exactly of the minimal length (64 for un tagged, 68 for tagged, or with length exactly equal to the parameter MINLength */
+	u32 tx127;		/* Total number of frames (including bad frames) transmitted that were between MINLength (Including FCS length==4) and 127 octets */
+	u32 tx255;		/* Total number of frames (including bad frames) transmitted that were between 128 (Including FCS length==4) and 255 octets */
+	u32 rx64;		/* Total number of frames received including bad frames that were exactly of the mninimal length (64 bytes) */
+	u32 rx127;		/* Total number of frames (including bad frames) received that were between MINLength (Including FCS length==4) and 127 octets */
+	u32 rx255;		/* Total number of frames (including bad frames) received that were between 128 (Including FCS length==4) and 255 octets */
+	u32 txok;		/* Total number of octets residing in frames that where involved in succesfull transmission */
+	u16 txcf;		/* Total number of PAUSE control frames transmitted by this MAC */
+	u8 res4[0x2];
+	u32 tmca;		/* Total number of frames that were transmitted succesfully with the group address bit set that are not broadcast frames */
+	u32 tbca;		/* Total number of frames transmitted succesfully that had destination address field equal to the broadcast address */
+	u32 rxfok;		/* Total number of frames received OK */
+	u32 rxbok;		/* Total number of octets received OK */
+	u32 rbyt;		/* Total number of octets received including octets in bad frames. Must be implemented in HW because it includes octets in frames that never even reach the UCC */
+	u32 rmca;		/* Total number of frames that were received succesfully with the group address bit set that are not broadcast frames */
+	u32 rbca;		/* Total number of frames received succesfully that had destination address equal to the broadcast address */
+	u32 scar;		/* Statistics carry register */
+	u32 scam;		/* Statistics caryy mask register */
+	u8 res5[0x200 - 0x1c4];
+} __attribute__ ((packed)) ucc_geth_t;
+
+/* UCC GETH TEMODR Register
+*/
+#define TEMODER_TX_RMON_STATISTICS_ENABLE       0x0100	/* enable Tx statistics      */
+#define TEMODER_SCHEDULER_ENABLE                0x2000	/* enable scheduler          */
+#define TEMODER_IP_CHECKSUM_GENERATE            0x0400	/* generate IPv4 checksums   */
+#define TEMODER_PERFORMANCE_OPTIMIZATION_MODE1  0x0200	/* enable performance optimization enhancement (mode1) */
+#define TEMODER_RMON_STATISTICS                 0x0100	/* enable tx statistics      */
+#define TEMODER_NUM_OF_QUEUES_SHIFT             (15-15)	/* Number of queues << shift */
+
+/* UCC GETH TEMODR Register
+*/
+#define REMODER_RX_RMON_STATISTICS_ENABLE       0x00001000	/* enable Rx statistics */
+#define REMODER_RX_EXTENDED_FEATURES            0x80000000	/* enable extended features                      */
+#define REMODER_VLAN_OPERATION_TAGGED_SHIFT     (31-9 )	/* vlan operation tagged << shift                */
+#define REMODER_VLAN_OPERATION_NON_TAGGED_SHIFT (31-10)	/* vlan operation non tagged << shift            */
+#define REMODER_RX_QOS_MODE_SHIFT               (31-15)	/* rx QoS mode << shift                          */
+#define REMODER_RMON_STATISTICS                 0x00001000	/* enable rx statistics                          */
+#define REMODER_RX_EXTENDED_FILTERING           0x00000800	/* extended filtering vs. mpc82xx-like filtering */
+#define REMODER_NUM_OF_QUEUES_SHIFT             (31-23)	/* Number of queues << shift                     */
+#define REMODER_DYNAMIC_MAX_FRAME_LENGTH        0x00000008	/* enable dynamic max frame length               */
+#define REMODER_DYNAMIC_MIN_FRAME_LENGTH        0x00000004	/* enable dynamic min frame length               */
+#define REMODER_IP_CHECKSUM_CHECK               0x00000002	/* check IPv4 checksums                          */
+#define REMODER_IP_ADDRESS_ALIGNMENT            0x00000001	/* align ip address to 4-byte boundary           */
+
+/* UCC GETH Event Register
+*/
+#define UCCE_MPD                                0x80000000	/* Magic packet detection */
+#define UCCE_SCAR                               0x40000000
+#define UCCE_GRA                                0x20000000	/* Tx graceful stop complete */
+#define UCCE_CBPR                               0x10000000
+#define UCCE_BSY                                0x08000000
+#define UCCE_RXC                                0x04000000
+#define UCCE_TXC                                0x02000000
+#define UCCE_TXE                                0x01000000
+#define UCCE_TXB7                               0x00800000
+#define UCCE_TXB6                               0x00400000
+#define UCCE_TXB5                               0x00200000
+#define UCCE_TXB4                               0x00100000
+#define UCCE_TXB3                               0x00080000
+#define UCCE_TXB2                               0x00040000
+#define UCCE_TXB1                               0x00020000
+#define UCCE_TXB0                               0x00010000
+#define UCCE_RXB7                               0x00008000
+#define UCCE_RXB6                               0x00004000
+#define UCCE_RXB5                               0x00002000
+#define UCCE_RXB4                               0x00001000
+#define UCCE_RXB3                               0x00000800
+#define UCCE_RXB2                               0x00000400
+#define UCCE_RXB1                               0x00000200
+#define UCCE_RXB0                               0x00000100
+#define UCCE_RXF7                               0x00000080
+#define UCCE_RXF6                               0x00000040
+#define UCCE_RXF5                               0x00000020
+#define UCCE_RXF4                               0x00000010
+#define UCCE_RXF3                               0x00000008
+#define UCCE_RXF2                               0x00000004
+#define UCCE_RXF1                               0x00000002
+#define UCCE_RXF0                               0x00000001
+
+#define UCCE_RXBF_SINGLE_MASK                   (UCCE_RXF0)
+#define UCCE_TXBF_SINGLE_MASK                   (UCCE_TXB0)
+
+#define UCCE_TXB         (UCCE_TXB7 | UCCE_TXB6 | UCCE_TXB5 | UCCE_TXB4 | UCCE_TXB3 | UCCE_TXB2 | UCCE_TXB1 | UCCE_TXB0)
+#define UCCE_RXB         (UCCE_RXB7 | UCCE_RXB6 | UCCE_RXB5 | UCCE_RXB4 | UCCE_RXB3 | UCCE_RXB2 | UCCE_RXB1 | UCCE_RXB0)
+#define UCCE_RXF         (UCCE_RXF7 | UCCE_RXF6 | UCCE_RXF5 | UCCE_RXF4 | UCCE_RXF3 | UCCE_RXF2 | UCCE_RXF1 | UCCE_RXF0)
+#define UCCE_OTHER       (UCCE_SCAR | UCCE_GRA  | UCCE_CBPR | UCCE_BSY  | UCCE_RXC  | UCCE_TXC  | UCCE_TXE)
+
+/* UCC GETH UPSMR (Protocol Specific Mode Register)
+ */
+#define UPSMR_ECM                               0x04000000	/* Enable CAM Miss or Enable Filtering Miss       */
+#define UPSMR_HSE                               0x02000000	/* Hardware Statistics Enable                     */
+#define UPSMR_PRO                               0x00400000	/* Promiscuous                                    */
+#define UPSMR_CAP                               0x00200000	/* CAM polarity                                   */
+#define UPSMR_RSH                               0x00100000	/* Receive Short Frames                           */
+#define UPSMR_RPM                               0x00080000	/* Reduced Pin Mode interfaces                    */
+#define UPSMR_R10M                              0x00040000	/* RGMII/RMII 10 Mode                             */
+#define UPSMR_RLPB                              0x00020000	/* RMII Loopback Mode                             */
+#define UPSMR_TBIM                              0x00010000	/* Ten-bit Interface Mode                         */
+#define UPSMR_RMM                               0x00001000	/* RMII/RGMII Mode                                */
+#define UPSMR_CAM                               0x00000400	/* CAM Address Matching                           */
+#define UPSMR_BRO                               0x00000200	/* Broadcast Address                              */
+#define UPSMR_RES1                              0x00002000	/* Reserved feild - must be 1                     */
+
+/* UCC GETH MACCFG1 (MAC Configuration 1 Register)
+ */
+#define MACCFG1_FLOW_RX                         0x00000020	/* Flow Control Rx                         */
+#define MACCFG1_FLOW_TX                         0x00000010	/* Flow Control Tx                         */
+#define MACCFG1_ENABLE_SYNCHED_RX               0x00000008	/* Rx Enable synchronized to Rx stream     */
+#define MACCFG1_ENABLE_RX                       0x00000004	/* Enable Rx                               */
+#define MACCFG1_ENABLE_SYNCHED_TX               0x00000002	/* Tx Enable synchronized to Tx stream     */
+#define MACCFG1_ENABLE_TX                       0x00000001	/* Enable Tx                               */
+
+/* UCC GETH MACCFG2 (MAC Configuration 2 Register)
+ */
+#define MACCFG2_PREL_SHIFT                      (31 - 19)	/* Preamble Length << shift                */
+#define MACCFG2_PREL_MASK                       0x0000f000	/* Preamble Length mask                    */
+#define MACCFG2_SRP                             0x00000080	/* Soft Receive  Preamble                  */
+#define MACCFG2_STP                             0x00000040	/* Soft Transmit Preamble                  */
+#define MACCFG2_RESERVED_1                      0x00000020	/* Reserved - must be set to 1             */
+#define MACCFG2_LC                              0x00000010	/* Length Check                            */
+#define MACCFG2_MPE                             0x00000008	/* Magic packet detect                     */
+#define MACCFG2_FDX                             0x00000001	/* Full Duplex                             */
+#define MACCFG2_FDX_MASK                        0x00000001	/* Full Duplex mask                        */
+#define MACCFG2_PAD_CRC                         0x00000004
+#define MACCFG2_CRC_EN                          0x00000002
+#define MACCFG2_PAD_AND_CRC_MODE_NONE           0x00000000	/* Neither Padding short frames nor CRC */
+#define MACCFG2_PAD_AND_CRC_MODE_CRC_ONLY       0x00000002	/* Append CRC only                      */
+#define MACCFG2_PAD_AND_CRC_MODE_PAD_AND_CRC    0x00000004
+#define MACCFG2_INTERFACE_MODE_NIBBLE           0x00000100	/* nibble mode (MII/RMII/RGMII     10/100bps)    */
+#define MACCFG2_INTERFACE_MODE_BYTE             0x00000200	/* byte mode   (GMII/TBI/RTB/RGMII 1000bps  )    */
+#define MACCFG2_INTERFACE_MODE_MASK             0x00000300	/* mask covering all relevant bits               */
+
+/* UCC GETH IPGIFG (Inter-frame Gap / Inter-Frame Gap Register)
+ */
+#define IPGIFG_NON_BACK_TO_BACK_IFG_PART1_SHIFT (31 -  7)	/* Non back-to-back inter frame gap part 1. << shift */
+#define IPGIFG_NON_BACK_TO_BACK_IFG_PART2_SHIFT (31 - 15)	/* Non back-to-back inter frame gap part 2. << shift */
+#define IPGIFG_MINIMUM_IFG_ENFORCEMENT_SHIFT    (31 - 23)	/* Mimimum IFG Enforcement << shift                  */
+#define IPGIFG_BACK_TO_BACK_IFG_SHIFT           (31 - 31)	/* back-to-back inter frame gap << shift             */
+#define IPGIFG_NON_BACK_TO_BACK_IFG_PART1_MAX   127	/* Non back-to-back inter frame gap part 1. max val  */
+#define IPGIFG_NON_BACK_TO_BACK_IFG_PART2_MAX   127	/* Non back-to-back inter frame gap part 2. max val  */
+#define IPGIFG_MINIMUM_IFG_ENFORCEMENT_MAX      255	/* Mimimum IFG Enforcement max val                   */
+#define IPGIFG_BACK_TO_BACK_IFG_MAX             127	/* back-to-back inter frame gap max val              */
+#define IPGIFG_NBTB_CS_IPG_MASK                 0x7F000000
+#define IPGIFG_NBTB_IPG_MASK                    0x007F0000
+#define IPGIFG_MIN_IFG_MASK                     0x0000FF00
+#define IPGIFG_BTB_IPG_MASK                     0x0000007F
+
+/* UCC GETH HAFDUP (Half Duplex Register)
+ */
+#define HALFDUP_ALT_BEB_TRUNCATION_SHIFT        (31 - 11)	/* Alternate Binary Exponential Backoff Truncation << shift */
+#define HALFDUP_ALT_BEB_TRUNCATION_MAX          0xf	/* Alternate Binary Exponential Backoff Truncation max val  */
+#define HALFDUP_ALT_BEB                         0x00080000	/* Alternate Binary Exponential Backoff                     */
+#define HALFDUP_BACK_PRESSURE_NO_BACKOFF        0x00040000	/* Back pressure no backoff                                 */
+#define HALFDUP_NO_BACKOFF                      0x00020000	/* No Backoff                                               */
+#define HALFDUP_EXCESSIVE_DEFER                 0x00010000	/* Excessive Defer                                          */
+#define HALFDUP_MAX_RETRANSMISSION_SHIFT        (31 - 19)	/* Maximum Retransmission << shift                          */
+#define HALFDUP_MAX_RETRANSMISSION_MAX          0xf	/* Maximum Retransmission max val                           */
+#define HALFDUP_COLLISION_WINDOW_SHIFT          (31 - 31)	/* Collision Window << shift                                */
+#define HALFDUP_COLLISION_WINDOW_MAX            0x3f	/* Collision Window max val                                 */
+#define HALFDUP_ALT_BEB_TR_MASK                 0x00F00000
+#define HALFDUP_RETRANS_MASK                    0x0000F000
+#define HALFDUP_COL_WINDOW_MASK                 0x0000003F
+
+/* UCC GETH UCCS (Ethernet Status Register)
+ */
+#define UCCS_BPR                                0x02	/* Back pressure (in half duplex mode) */
+#define UCCS_PAU                                0x02	/* Pause state   (in full duplex mode) */
+#define UCCS_MPD                                0x01	/* Magic Packet Detected               */
+
+/* UCC GETH MIIMCFG (MII Management Configuration Register)
+ */
+#define MIIMCFG_RESET_MANAGEMENT                0x80000000	/* Reset management                  */
+#define MIIMCFG_NO_PREAMBLE                     0x00000010	/* Preamble suppress                 */
+#define MIIMCFG_CLOCK_DIVIDE_SHIFT              (31 - 31)	/* clock divide << shift             */
+#define MIIMCFG_CLOCK_DIVIDE_MAX                0xf	/* clock divide max val              */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_2    0x00000000	/* divide by 2   */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_4    0x00000001	/* divide by 4   */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_6    0x00000002	/* divide by 6   */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_8    0x00000003	/* divide by 8   */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_10   0x00000004	/* divide by 10  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_14   0x00000005	/* divide by 14  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_16   0x00000008	/* divide by 16  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_20   0x00000006	/* divide by 20  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_28   0x00000007	/* divide by 28  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_32   0x00000009	/* divide by 32  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_48   0x0000000a	/* divide by 48  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_64   0x0000000b	/* divide by 64  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_80   0x0000000c	/* divide by 80  */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_112  0x0000000d	/* divide by 112 */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_160  0x0000000e	/* divide by 160 */
+#define MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_224  0x0000000f	/* divide by 224 */
+
+/* UCC GETH MIIMCOM (MII Management Command Register)
+ */
+#define MIIMCOM_SCAN_CYCLE                      0x00000002	/* Scan cycle                        */
+#define MIIMCOM_READ_CYCLE                      0x00000001	/* Read cycle                        */
+
+/* UCC GETH MIIMADD (MII Management Address Register)
+ */
+#define MIIMADD_PHY_ADDRESS_SHIFT               (31 - 23)	/* PHY Address  << shift             */
+#define MIIMADD_PHY_REGISTER_SHIFT              (31 - 31)	/* PHY Register << shift             */
+
+/* UCC GETH MIIMCON (MII Management Control Register)
+ */
+#define MIIMCON_PHY_CONTROL_SHIFT               (31 - 31)	/* PHY Control  << shift             */
+#define MIIMCON_PHY_STATUS_SHIFT                (31 - 31)	/* PHY Status   << shift             */
+
+/* UCC GETH MIIMIND (MII Management Indicator Register)
+ */
+#define MIIMIND_NOT_VALID                       0x00000004	/* Not valid                         */
+#define MIIMIND_SCAN                            0x00000002	/* Scan in progress                  */
+#define MIIMIND_BUSY                            0x00000001
+
+/* UCC GETH IFSTAT (Interface Status Register)
+ */
+#define IFSTAT_EXCESS_DEFER                     0x00000200	/* Excessive transmission defer      */
+
+/* UCC GETH MACSTNADDR1 (Station Address Part 1 Register)
+ */
+#define MACSTNADDR1_OCTET_6_SHIFT               (31 -  7)	/* Station address 6th octet << shift */
+#define MACSTNADDR1_OCTET_5_SHIFT               (31 - 15)	/* Station address 5th octet << shift */
+#define MACSTNADDR1_OCTET_4_SHIFT               (31 - 23)	/* Station address 4th octet << shift */
+#define MACSTNADDR1_OCTET_3_SHIFT               (31 - 31)	/* Station address 3rd octet << shift */
+
+/* UCC GETH MACSTNADDR2 (Station Address Part 2 Register)
+ */
+#define MACSTNADDR2_OCTET_2_SHIFT               (31 -  7)	/* Station address 2nd octet << shift */
+#define MACSTNADDR2_OCTET_1_SHIFT               (31 - 15)	/* Station address 1st octet << shift */
+
+/* UCC GETH UEMPR (Ethernet Mac Parameter Register)
+ */
+#define UEMPR_PAUSE_TIME_VALUE_SHIFT            (31 - 15)	/* Pause time value << shift         */
+#define UEMPR_EXTENDED_PAUSE_TIME_VALUE_SHIFT   (31 - 31)	/* Extended pause time value << shift */
+
+/* UCC GETH UTBIPAR (Ten Bit Interface Physical Address Register)
+ */
+#define UTBIPAR_PHY_ADDRESS_SHIFT               (31 - 31)	/* Phy address << shift              */
+#define UTBIPAR_PHY_ADDRESS_MASK                0x0000001f	/* Phy address mask                  */
+
+/* UCC GETH UESCR (Ethernet Statistics Control Register)
+ */
+#define UESCR_AUTOZ                             0x8000	/* Automatically zero addressed statistical counter values */
+#define UESCR_CLRCNT                            0x4000	/* Clear all statistics counters                           */
+#define UESCR_MAXCOV_SHIFT                      (15 -  7)	/* Max Coalescing Value << shift                           */
+#define UESCR_SCOV_SHIFT                        (15 - 15)	/* Status Coalescing Value << shift                        */
+
+/* UCC GETH UDSR (Data Synchronization Register)
+ */
+#define UDSR_MAGIC                              0x067E
+
+typedef struct ucc_geth_thread_data_tx {
+	u8 res0[104];
+} __attribute__ ((packed)) ucc_geth_thread_data_tx_t;
+
+typedef struct ucc_geth_thread_data_rx {
+	u8 res0[40];
+} __attribute__ ((packed)) ucc_geth_thread_data_rx_t;
+
+/* Send Queue Queue-Descriptor
+*/
+typedef struct ucc_geth_send_queue_qd {
+	u32 bd_ring_base;	/* pointer to BD ring base address     */
+	u8 res0[0x8];
+	u32 last_bd_completed_address;	/* initialize to last entry in BD ring */
+	u8 res1[0x30];
+} __attribute__ ((packed)) ucc_geth_send_queue_qd_t;
+
+typedef struct ucc_geth_send_queue_mem_region {
+	ucc_geth_send_queue_qd_t sqqd[NUM_TX_QUEUES];
+} __attribute__ ((packed)) ucc_geth_send_queue_mem_region_t;
+
+typedef struct ucc_geth_thread_tx_pram {
+	u8 res0[64];
+} __attribute__ ((packed)) ucc_geth_thread_tx_pram_t;
+
+typedef struct ucc_geth_thread_rx_pram {
+	u8 res0[128];
+} __attribute__ ((packed)) ucc_geth_thread_rx_pram_t;
+
+#define THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING        64
+#define THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8      64
+#define THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16     96
+
+typedef struct ucc_geth_scheduler {
+	u16 cpucount0;		/* CPU packet counter */
+	u16 cpucount1;		/* CPU packet counter */
+	u16 cecount0;		/* QE  packet counter */
+	u16 cecount1;		/* QE  packet counter */
+	u16 cpucount2;		/* CPU packet counter */
+	u16 cpucount3;		/* CPU packet counter */
+	u16 cecount2;		/* QE  packet counter */
+	u16 cecount3;		/* QE  packet counter */
+	u16 cpucount4;		/* CPU packet counter */
+	u16 cpucount5;		/* CPU packet counter */
+	u16 cecount4;		/* QE  packet counter */
+	u16 cecount5;		/* QE  packet counter */
+	u16 cpucount6;		/* CPU packet counter */
+	u16 cpucount7;		/* CPU packet counter */
+	u16 cecount6;		/* QE  packet counter */
+	u16 cecount7;		/* QE  packet counter */
+	u32 weightstatus[NUM_TX_QUEUES];	/* accumulated weight factor */
+	u32 rtsrshadow;		/* temporary variable handled by QE */
+	u32 time;		/* temporary variable handled by QE */
+	u32 ttl;		/* temporary variable handled by QE */
+	u32 mblinterval;	/* max burst length interval        */
+	u16 nortsrbytetime;	/* normalized value of byte time in tsr units    */
+	u8 fracsiz;		/* radix 2 log value of denom. of NorTSRByteTime */
+	u8 res0[1];
+	u8 strictpriorityq;	/* Strict Priority Mask register                 */
+	u8 txasap;		/* Transmit ASAP register                        */
+	u8 extrabw;		/* Extra BandWidth register                      */
+	u8 oldwfqmask;		/* temporary variable handled by QE              */
+	u8 weightfactor[NUM_TX_QUEUES];
+				      /**< weight factor for queues   */
+	u32 minw;		/* temporary variable handled by QE */
+	u8 res1[0x70 - 0x64];
+} __attribute__ ((packed)) ucc_geth_scheduler_t;
+
+typedef struct ucc_geth_tx_firmware_statistics_pram {
+	u32 sicoltx;		/* single collision */
+	u32 mulcoltx;		/* multiple collision */
+	u32 latecoltxfr;	/* late collision */
+	u32 frabortduecol;	/* frames aborted due to transmit collision */
+	u32 frlostinmactxer;	/* frames lost due to internal MAC error transmission that are not counted on any other counter */
+	u32 carriersenseertx;	/* carrier sense error */
+	u32 frtxok;		/* frames transmitted OK */
+	u32 txfrexcessivedefer;	/* frames with defferal time greater than specified threshold */
+	u32 txpkts256;		/* total packets (including bad) between 256  and 511       octets */
+	u32 txpkts512;		/* total packets (including bad) between 512  and 1023      octets */
+	u32 txpkts1024;		/* total packets (including bad) between 1024 and 1518      octets */
+	u32 txpktsjumbo;	/* total packets (including bad) between 1024 and MAXLength octets */
+} __attribute__ ((packed)) ucc_geth_tx_firmware_statistics_pram_t;
+
+typedef struct ucc_geth_rx_firmware_statistics_pram {
+	u32 frrxfcser;		/* frames with crc error */
+	u32 fraligner;		/* frames with alignment error */
+	u32 inrangelenrxer;	/* in range length error */
+	u32 outrangelenrxer;	/* out of range length error */
+	u32 frtoolong;		/* frame too long */
+	u32 runt;		/* runt */
+	u32 verylongevent;	/* very long event */
+	u32 symbolerror;	/* symbol error */
+	u32 dropbsy;		/* drop because of BD not ready */
+	u8 res0[0x8];
+	u32 mismatchdrop;	/* drop because of MAC filtering (e.g. address or type mismatch) */
+	u32 underpkts;		/* total frames less than 64 octets */
+	u32 pkts256;		/* total frames (including bad) between 256 and 511 octets */
+	u32 pkts512;		/* total frames (including bad) between 512 and 1023 octets */
+	u32 pkts1024;		/* total frames (including bad) between 1024 and 1518 octets */
+	u32 pktsjumbo;		/* total frames (including bad) between 1024 and MAXLength octets */
+	u32 frlossinmacer;	/* frames lost because of internal MAC error that is not counted in any other counter */
+	u32 pausefr;		/* pause frames */
+	u8 res1[0x4];
+	u32 removevlan;		/* total frames that had their VLAN tag removed  */
+	u32 replacevlan;	/* total frames that had their VLAN tag replaced */
+	u32 insertvlan;		/* total frames that had their VLAN tag inserted */
+} __attribute__ ((packed)) ucc_geth_rx_firmware_statistics_pram_t;
+
+typedef struct ucc_geth_rx_interrupt_coalescing_entry {
+	u32 interruptcoalescingmaxvalue;	/* interrupt coalescing max value */
+	u32 interruptcoalescingcounter;	/* interrupt coalescing counter, initialize to interruptcoalescingmaxvalue */
+} __attribute__ ((packed)) ucc_geth_rx_interrupt_coalescing_entry_t;
+
+typedef struct ucc_geth_rx_interrupt_coalescing_table {
+	ucc_geth_rx_interrupt_coalescing_entry_t coalescingentry[NUM_RX_QUEUES];
+									       /**< interrupt coalescing entry */
+} __attribute__ ((packed)) ucc_geth_rx_interrupt_coalescing_table_t;
+
+typedef struct ucc_geth_rx_prefetched_bds {
+	qe_bd_t bd[NUM_BDS_IN_PREFETCHED_BDS];	/* prefetched bd */
+} __attribute__ ((packed)) ucc_geth_rx_prefetched_bds_t;
+
+typedef struct ucc_geth_rx_bd_queues_entry {
+	u32 bdbaseptr;		/* BD base pointer          */
+	u32 bdptr;		/* BD pointer               */
+	u32 externalbdbaseptr;	/* external BD base pointer */
+	u32 externalbdptr;	/* external BD pointer      */
+} __attribute__ ((packed)) ucc_geth_rx_bd_queues_entry_t;
+
+typedef struct ucc_geth_tx_global_pram {
+	u16 temoder;
+	u8 res0[0x38 - 0x02];
+	u32 sqptr;		/* a base pointer to send queue memory region          */
+	u32 schedulerbasepointer;	/* a base pointer to scheduler memory region           */
+	u32 txrmonbaseptr;	/* base pointer to Tx RMON statistics counter */
+	u32 tstate;		/* tx internal state. High byte contains function code */
+	u8 iphoffset[TX_IP_OFFSET_ENTRY_MAX];
+	u32 vtagtable[0x8];	/* 8 4-byte VLAN tags */
+	u32 tqptr;		/* a base pointer to the Tx Queues Memory Region */
+	u8 res2[0x80 - 0x74];
+} __attribute__ ((packed)) ucc_geth_tx_global_pram_t;
+
+/* structure representing Extended Filtering Global Parameters in PRAM
+*/
+typedef struct ucc_geth_exf_global_pram {
+	u32 l2pcdptr;		/* individual address filter, high               */
+	u8 res0[0x10 - 0x04];
+} __attribute__ ((packed)) ucc_geth_exf_global_pram_t;
+
+typedef struct ucc_geth_rx_global_pram {
+	u32 remoder;		/* ethernet mode reg. */
+	u32 rqptr;		/* base pointer to the Rx Queues Memory Region */
+	u32 res0[0x1];
+	u8 res1[0x20 - 0xC];
+	u16 typeorlen;		/* cutoff point less than which, type/len field is considered length */
+	u8 res2[0x1];
+	u8 rxgstpack;		/* acknowledgement on GRACEFUL STOP RX command */
+	u32 rxrmonbaseptr;	/* base pointer to Rx RMON statistics counter */
+	u8 res3[0x30 - 0x28];
+	u32 intcoalescingptr;	/* Interrupt coalescing table pointer */
+	u8 res4[0x36 - 0x34];
+	u8 rstate;		/* rx internal state. High byte contains function code */
+	u8 res5[0x46 - 0x37];
+	u16 mrblr;		/* max receive buffer length reg. */
+	u32 rbdqptr;		/* base pointer to RxBD parameter table description */
+	u16 mflr;		/* max frame length reg. */
+	u16 minflr;		/* min frame length reg. */
+	u16 maxd1;		/* max dma1 length reg. */
+	u16 maxd2;		/* max dma2 length reg. */
+	u32 ecamptr;		/* external CAM address */
+	u32 l2qt;		/* VLAN priority mapping table. */
+	u32 l3qt[0x8];		/* IP   priority mapping table. */
+	u16 vlantype;		/* vlan type */
+	u16 vlantci;		/* default vlan tci */
+	u8 addressfiltering[64];	/* address filtering data structure */
+	u32 exfGlobalParam;	/* base address for extended filtering global parameters */
+	u8 res6[0x100 - 0xC4];	/* Initialize to zero */
+} __attribute__ ((packed)) ucc_geth_rx_global_pram_t;
+
+#define GRACEFUL_STOP_ACKNOWLEDGE_RX            0x01
+
+/* structure representing InitEnet command
+*/
+typedef struct ucc_geth_init_pram {
+	u8 resinit1;
+	u8 resinit2;
+	u8 resinit3;
+	u8 resinit4;
+	u16 resinit5;
+	u8 res1[0x1];
+	u8 largestexternallookupkeysize;
+	u32 rgftgfrxglobal;
+	u32 rxthread[ENET_INIT_PARAM_MAX_ENTRIES_RX];	/* rx threads */
+	u8 res2[0x38 - 0x30];
+	u32 txglobal;		/* tx global  */
+	u32 txthread[ENET_INIT_PARAM_MAX_ENTRIES_TX];	/* tx threads */
+	u8 res3[0x1];
+} __attribute__ ((packed)) ucc_geth_init_pram_t;
+
+#define ENET_INIT_PARAM_RGF_SHIFT               (32 - 4)
+#define ENET_INIT_PARAM_TGF_SHIFT               (32 - 8)
+
+#define ENET_INIT_PARAM_RISC_MASK               0x0000003f
+#define ENET_INIT_PARAM_PTR_MASK                0x00ffffc0
+#define ENET_INIT_PARAM_SNUM_MASK               0xff000000
+#define ENET_INIT_PARAM_SNUM_SHIFT              24
+
+#define ENET_INIT_PARAM_MAGIC_RES_INIT1         0x06
+#define ENET_INIT_PARAM_MAGIC_RES_INIT2         0x30
+#define ENET_INIT_PARAM_MAGIC_RES_INIT3         0xff
+#define ENET_INIT_PARAM_MAGIC_RES_INIT4         0x00
+#define ENET_INIT_PARAM_MAGIC_RES_INIT5         0x0400
+
+/* structure representing 82xx Address Filtering Enet Address in PRAM
+*/
+typedef struct ucc_geth_82xx_enet_address {
+	u8 res1[0x2];
+	u16 h;			/* address (MSB) */
+	u16 m;			/* address       */
+	u16 l;			/* address (LSB) */
+} __attribute__ ((packed)) ucc_geth_82xx_enet_address_t;
+
+/* structure representing 82xx Address Filtering PRAM
+*/
+typedef struct ucc_geth_82xx_address_filtering_pram {
+	u32 iaddr_h;		/* individual address filter, high               */
+	u32 iaddr_l;		/* individual address filter, low                */
+	u32 gaddr_h;		/* group address filter, high                    */
+	u32 gaddr_l;		/* group address filter, low                     */
+	ucc_geth_82xx_enet_address_t taddr;
+	ucc_geth_82xx_enet_address_t paddr[NUM_OF_PADDRS];
+	u8 res0[0x40 - 0x38];
+} __attribute__ ((packed)) ucc_geth_82xx_address_filtering_pram_t;
+
+/* GETH Tx firmware statistics structure, used when calling UCC_GETH_GetStatistics.
+*/
+typedef struct ucc_geth_tx_firmware_statistics {
+	u32 sicoltx;		/* single collision */
+	u32 mulcoltx;		/* multiple collision */
+	u32 latecoltxfr;	/* late collision */
+	u32 frabortduecol;	/* frames aborted due to transmit collision */
+	u32 frlostinmactxer;	/* frames lost due to internal MAC error transmission that are not counted on any other counter */
+	u32 carriersenseertx;	/* carrier sense error */
+	u32 frtxok;		/* frames transmitted OK */
+	u32 txfrexcessivedefer;	/* frames with defferal time greater than specified threshold */
+	u32 txpkts256;		/* total packets (including bad) between 256  and 511       octets */
+	u32 txpkts512;		/* total packets (including bad) between 512  and 1023      octets */
+	u32 txpkts1024;		/* total packets (including bad) between 1024 and 1518      octets */
+	u32 txpktsjumbo;	/* total packets (including bad) between 1024 and MAXLength octets */
+} __attribute__ ((packed)) ucc_geth_tx_firmware_statistics_t;
+
+/* GETH Rx firmware statistics structure, used when calling UCC_GETH_GetStatistics.
+*/
+typedef struct ucc_geth_rx_firmware_statistics {
+	u32 frrxfcser;		/* frames with crc error */
+	u32 fraligner;		/* frames with alignment error */
+	u32 inrangelenrxer;	/* in range length error */
+	u32 outrangelenrxer;	/* out of range length error */
+	u32 frtoolong;		/* frame too long */
+	u32 runt;		/* runt */
+	u32 verylongevent;	/* very long event */
+	u32 symbolerror;	/* symbol error */
+	u32 dropbsy;		/* drop because of BD not ready */
+	u8 res0[0x8];
+	u32 mismatchdrop;	/* drop because of MAC filtering (e.g. address or type mismatch) */
+	u32 underpkts;		/* total frames less than 64 octets */
+	u32 pkts256;		/* total frames (including bad) between 256 and 511 octets */
+	u32 pkts512;		/* total frames (including bad) between 512 and 1023 octets */
+	u32 pkts1024;		/* total frames (including bad) between 1024 and 1518 octets */
+	u32 pktsjumbo;		/* total frames (including bad) between 1024 and MAXLength octets */
+	u32 frlossinmacer;	/* frames lost because of internal MAC error that is not counted in any other counter */
+	u32 pausefr;		/* pause frames */
+	u8 res1[0x4];
+	u32 removevlan;		/* total frames that had their VLAN tag removed  */
+	u32 replacevlan;	/* total frames that had their VLAN tag replaced */
+	u32 insertvlan;		/* total frames that had their VLAN tag inserted */
+} __attribute__ ((packed)) ucc_geth_rx_firmware_statistics_t;
+
+/* GETH hardware statistics structure, used when calling UCC_GETH_GetStatistics.
+*/
+typedef struct ucc_geth_hardware_statistics {
+	u32 tx64;		/* Total number of frames (including bad frames) transmitted that were exactly of the minimal length (64 for un tagged, 68 for tagged, or with length exactly equal to the parameter MINLength */
+	u32 tx127;		/* Total number of frames (including bad frames) transmitted that were between MINLength (Including FCS length==4) and 127 octets */
+	u32 tx255;		/* Total number of frames (including bad frames) transmitted that were between 128 (Including FCS length==4) and 255 octets */
+	u32 rx64;		/* Total number of frames received including bad frames that were exactly of the mninimal length (64 bytes) */
+	u32 rx127;		/* Total number of frames (including bad frames) received that were between MINLength (Including FCS length==4) and 127 octets */
+	u32 rx255;		/* Total number of frames (including bad frames) received that were between 128 (Including FCS length==4) and 255 octets */
+	u32 txok;		/* Total number of octets residing in frames that where involved in succesfull transmission */
+	u16 txcf;		/* Total number of PAUSE control frames transmitted by this MAC */
+	u32 tmca;		/* Total number of frames that were transmitted succesfully with the group address bit set that are not broadcast frames */
+	u32 tbca;		/* Total number of frames transmitted succesfully that had destination address field equal to the broadcast address */
+	u32 rxfok;		/* Total number of frames received OK */
+	u32 rxbok;		/* Total number of octets received OK */
+	u32 rbyt;		/* Total number of octets received including octets in bad frames. Must be implemented in HW because it includes octets in frames that never even reach the UCC */
+	u32 rmca;		/* Total number of frames that were received succesfully with the group address bit set that are not broadcast frames */
+	u32 rbca;		/* Total number of frames received succesfully that had destination address equal to the broadcast address */
+} __attribute__ ((packed)) ucc_geth_hardware_statistics_t;
+
+/* UCC GETH Tx errors returned via TxConf callback
+*/
+#define TX_ERRORS_DEF      0x0200
+#define TX_ERRORS_EXDEF    0x0100
+#define TX_ERRORS_LC       0x0080
+#define TX_ERRORS_RL       0x0040
+#define TX_ERRORS_RC_MASK  0x003C
+#define TX_ERRORS_RC_SHIFT 2
+#define TX_ERRORS_UN       0x0002
+#define TX_ERRORS_CSL      0x0001
+
+/* UCC GETH Rx errors returned via RxStore callback
+*/
+#define RX_ERRORS_CMR      0x0200
+#define RX_ERRORS_M        0x0100
+#define RX_ERRORS_BC       0x0080
+#define RX_ERRORS_MC       0x0040
+
+/* Transmit BD. These are in addition to values defined in uccf.
+*/
+#define T_VID      0x003c0000	/* insert VLAN id index mask. */
+#define T_DEF      (((u32) TX_ERRORS_DEF     ) << 16)
+#define T_EXDEF    (((u32) TX_ERRORS_EXDEF   ) << 16)
+#define T_LC       (((u32) TX_ERRORS_LC      ) << 16)
+#define T_RL       (((u32) TX_ERRORS_RL      ) << 16)
+#define T_RC_MASK  (((u32) TX_ERRORS_RC_MASK ) << 16)
+#define T_UN       (((u32) TX_ERRORS_UN      ) << 16)
+#define T_CSL      (((u32) TX_ERRORS_CSL     ) << 16)
+#define T_ERRORS_REPORT  (T_DEF | T_EXDEF | T_LC | T_RL | T_RC_MASK | T_UN | T_CSL)	/* transmit errors to report */
+
+/* Receive BD. These are in addition to values defined in uccf.
+*/
+#define R_LG    0x00200000	/* Frame length violation.   */
+#define R_NO    0x00100000	/* Non-octet aligned frame.  */
+#define R_SH    0x00080000	/* Short frame.              */
+#define R_CR    0x00040000	/* CRC error.                */
+#define R_OV    0x00020000	/* Overrun.                  */
+#define R_IPCH  0x00010000	/* IP checksum check failed. */
+#define R_CMR   (((u32) RX_ERRORS_CMR  ) << 16)
+#define R_M     (((u32) RX_ERRORS_M    ) << 16)
+#define R_BC    (((u32) RX_ERRORS_BC   ) << 16)
+#define R_MC    (((u32) RX_ERRORS_MC   ) << 16)
+#define R_ERRORS_REPORT (R_CMR | R_M | R_BC | R_MC)	/* receive errors to report  */
+#define R_ERRORS_FATAL  (R_LG  | R_NO | R_SH | R_CR | R_OV | R_IPCH)	/* receive errors to discard */
+
+/* Alignments
+ */
+#define UCC_GETH_RX_GLOBAL_PRAM_ALIGNMENT                           256
+#define UCC_GETH_TX_GLOBAL_PRAM_ALIGNMENT                           128
+#define UCC_GETH_THREAD_RX_PRAM_ALIGNMENT                           128
+#define UCC_GETH_THREAD_TX_PRAM_ALIGNMENT                           64
+#define UCC_GETH_THREAD_DATA_ALIGNMENT                              256	/* spec gives values based on num of threads, but always using the maximum is easier */
+#define UCC_GETH_SEND_QUEUE_QUEUE_DESCRIPTOR_ALIGNMENT              32
+#define UCC_GETH_SCHEDULER_ALIGNMENT                                4	/* This is a guess */
+#define UCC_GETH_TX_STATISTICS_ALIGNMENT                            4	/* This is a guess */
+#define UCC_GETH_RX_STATISTICS_ALIGNMENT                            4	/* This is a guess */
+#define UCC_GETH_RX_INTERRUPT_COALESCING_ALIGNMENT                  4	/* This is a guess */
+#define UCC_GETH_RX_BD_QUEUES_ALIGNMENT                             8	/* This is a guess */
+#define UCC_GETH_RX_PREFETCHED_BDS_ALIGNMENT                        128	/* This is a guess */
+#define UCC_GETH_RX_EXTENDED_FILTERING_GLOBAL_PARAMETERS_ALIGNMENT  4	/* This is a guess */
+#define UCC_GETH_RX_BD_RING_ALIGNMENT                               32
+#define UCC_GETH_TX_BD_RING_ALIGNMENT                               32
+#define UCC_GETH_MRBLR_ALIGNMENT                                    128
+#define UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT                          4
+#define UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT                   32
+#define UCC_GETH_RX_DATA_BUF_ALIGNMENT                              64
+
+#define UCC_GETH_TAD_EF                         0x80
+#define UCC_GETH_TAD_V                          0x40
+#define UCC_GETH_TAD_REJ                        0x20
+#define UCC_GETH_TAD_VTAG_OP_RIGHT_SHIFT        2
+#define UCC_GETH_TAD_VTAG_OP_SHIFT              6
+#define UCC_GETH_TAD_V_NON_VTAG_OP              0x20
+#define UCC_GETH_TAD_RQOS_SHIFT                 0
+#define UCC_GETH_TAD_V_PRIORITY_SHIFT           5
+#define UCC_GETH_TAD_CFI                        0x10
+
+#define UCC_GETH_VLAN_PRIORITY_MAX              8
+#define UCC_GETH_IP_PRIORITY_MAX                64
+#define UCC_GETH_TX_VTAG_TABLE_ENTRY_MAX        8
+#define UCC_GETH_RX_BD_RING_SIZE_MIN            8
+#define UCC_GETH_TX_BD_RING_SIZE_MIN            2
+
+#define UCC_GETH_SIZE_OF_BD                     QE_SIZEOF_BD
+
+/* Driver definitions */
+#define TX_BD_RING_LEN                          0x10
+#define RX_BD_RING_LEN                          0x10
+#define UCC_GETH_DEV_WEIGHT                     TX_BD_RING_LEN
+
+#define TX_RING_MOD_MASK(size)                  (size-1)
+#define RX_RING_MOD_MASK(size)                  (size-1)
+
+#define ENET_NUM_OCTETS_PER_ADDRESS             6
+#define ENET_GROUP_ADDR                         0x01	/* Group address mask for ethernet addresses */
+
+#define TX_TIMEOUT                              (1*HZ)
+#define SKB_ALLOC_TIMEOUT                       100000
+#define PHY_INIT_TIMEOUT                        100000
+#define PHY_CHANGE_TIME                         2
+
+/* Fast Ethernet (10/100 Mbps) */
+#define UCC_GETH_URFS_INIT                      512	/* Rx virtual FIFO size */
+#define UCC_GETH_URFET_INIT                     256	/* 1/2 urfs */
+#define UCC_GETH_URFSET_INIT                    384	/* 3/4 urfs */
+#define UCC_GETH_UTFS_INIT                      512	/* Tx virtual FIFO size */
+#define UCC_GETH_UTFET_INIT                     256	/* 1/2 utfs */
+#define UCC_GETH_UTFTT_INIT                     128
+/* Gigabit Ethernet (1000 Mbps) */
+#define UCC_GETH_URFS_GIGA_INIT                 4096/*2048*/	/* Rx virtual FIFO size */
+#define UCC_GETH_URFET_GIGA_INIT                2048/*1024*/	/* 1/2 urfs */
+#define UCC_GETH_URFSET_GIGA_INIT               3072/*1536*/	/* 3/4 urfs */
+#define UCC_GETH_UTFS_GIGA_INIT                 8192/*2048*/	/* Tx virtual FIFO size */
+#define UCC_GETH_UTFET_GIGA_INIT                4096/*1024*/	/* 1/2 utfs */
+#define UCC_GETH_UTFTT_GIGA_INIT                0x400/*0x40*/	/*  */
+
+#define UCC_GETH_REMODER_INIT                   0	/* bits that must be set         */
+#define UCC_GETH_TEMODER_INIT                   0xC000	/* bits that must                */
+#define UCC_GETH_UPSMR_INIT                     (UPSMR_RES1)	/* Start value for this register */
+#define UCC_GETH_MACCFG1_INIT                   0
+#define UCC_GETH_MACCFG2_INIT                   (MACCFG2_RESERVED_1)
+#define UCC_GETH_MIIMCFG_MNGMNT_CLC_DIV_INIT    (MIIMCFG_MANAGEMENT_CLOCK_DIVIDE_BY_112)
+
+/* Ethernet speed
+*/
+typedef enum enet_speed {
+	ENET_SPEED_10BT,	/* 10 Base T */
+	ENET_SPEED_100BT,	/* 100 Base T */
+	ENET_SPEED_1000BT	/* 1000 Base T */
+} enet_speed_e;
+
+/* Ethernet Address Type.
+*/
+typedef enum enet_addr_type {
+	ENET_ADDR_TYPE_INDIVIDUAL,
+	ENET_ADDR_TYPE_GROUP,
+	ENET_ADDR_TYPE_BROADCAST
+} enet_addr_type_e;
+
+/* TBI / MII Set Register
+*/
+typedef enum enet_tbi_mii_reg {
+	ENET_TBI_MII_CR = 0x00,	/* Control                           (CR     ) */
+	ENET_TBI_MII_SR = 0x01,	/* Status                            (SR     ) */
+	ENET_TBI_MII_ANA = 0x04,	/* AN advertisement                  (ANA    ) */
+	ENET_TBI_MII_ANLPBPA = 0x05,	/* AN link partner base page ability (ANLPBPA) */
+	ENET_TBI_MII_ANEX = 0x06,	/* AN expansion                      (ANEX   ) */
+	ENET_TBI_MII_ANNPT = 0x07,	/* AN next page transmit             (ANNPT  ) */
+	ENET_TBI_MII_ANLPANP = 0x08,	/* AN link partner ability next page (ANLPANP) */
+	ENET_TBI_MII_EXST = 0x0F,	/* Extended status                   (EXST   ) */
+	ENET_TBI_MII_JD = 0x10,	/* Jitter diagnostics                (JD     ) */
+	ENET_TBI_MII_TBICON = 0x11	/* TBI control                       (TBICON ) */
+} enet_tbi_mii_reg_e;
+
+/* UCC GETH 82xx Ethernet Address Recognition Location
+*/
+typedef enum ucc_geth_enet_address_recognition_location {
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_STATION_ADDRESS,	/* station address                   */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_PADDR_FIRST,	/* additional station address paddr1 */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_PADDR2,	/* additional station address paddr2 */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_PADDR3,	/* additional station address paddr3 */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_PADDR_LAST,	/* additional station address paddr4 */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_GROUP_HASH,	/* group hash                        */
+	UCC_GETH_ENET_ADDRESS_RECOGNITION_LOCATION_INDIVIDUAL_HASH	/* individual hash                   */
+} ucc_geth_enet_address_recognition_location_e;
+
+/* UCC GETH vlan operation tagged
+*/
+typedef enum ucc_geth_vlan_operation_tagged {
+	UCC_GETH_VLAN_OPERATION_TAGGED_NOP = 0x0,	/* Tagged - nop                                    */
+	UCC_GETH_VLAN_OPERATION_TAGGED_REPLACE_VID_PORTION_OF_Q_TAG = 0x1,	/* Tagged - replace vid portion of q tag           */
+	UCC_GETH_VLAN_OPERATION_TAGGED_IF_VID0_REPLACE_VID_WITH_DEFAULT_VALUE = 0x2,	/* Tagged - if vid0 replace vid with default value */
+	UCC_GETH_VLAN_OPERATION_TAGGED_EXTRACT_Q_TAG_FROM_FRAME = 0x3	/* Tagged - extract q tag from frame               */
+} ucc_geth_vlan_operation_tagged_e;
+
+/* UCC GETH vlan operation non-tagged
+*/
+typedef enum ucc_geth_vlan_operation_non_tagged {
+	UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP = 0x0,	/* Non tagged - nop                                */
+	UCC_GETH_VLAN_OPERATION_NON_TAGGED_Q_TAG_INSERT = 0x1	/* Non tagged - q tag insert                       */
+} ucc_geth_vlan_operation_non_tagged_e;
+
+/* UCC GETH Rx Quality of Service Mode
+*/
+typedef enum ucc_geth_qos_mode {
+	UCC_GETH_QOS_MODE_DEFAULT = 0x0,	/* default queue                   */
+	UCC_GETH_QOS_MODE_QUEUE_NUM_FROM_L2_CRITERIA = 0x1,	/* queue determined by L2 criteria */
+	UCC_GETH_QOS_MODE_QUEUE_NUM_FROM_L3_CRITERIA = 0x2	/* queue determined by L3 criteria */
+} ucc_geth_qos_mode_e;
+
+/* UCC GETH Statistics Gathering Mode - These are bit flags, 'or' them together for combined functionality
+*/
+typedef enum ucc_geth_statistics_gathering_mode {
+	UCC_GETH_STATISTICS_GATHERING_MODE_NONE = 0x00000000,	/* No statistics gathering */
+	UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE = 0x00000001,	/* Enable hardware statistics gathering */
+	UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX = 0x00000004,	/* Enable firmware tx statistics gathering */
+	UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX = 0x00000008	/* Enable firmware rx statistics gathering */
+} ucc_geth_statistics_gathering_mode_e;
+
+/* UCC GETH Pad and CRC Mode - Note, Padding without CRC is not possible
+*/
+typedef enum ucc_geth_maccfg2_pad_and_crc_mode {
+	UCC_GETH_PAD_AND_CRC_MODE_NONE = MACCFG2_PAD_AND_CRC_MODE_NONE,	/* Neither Padding short frames nor CRC */
+	UCC_GETH_PAD_AND_CRC_MODE_CRC_ONLY = MACCFG2_PAD_AND_CRC_MODE_CRC_ONLY,	/* Append CRC only                      */
+	UCC_GETH_PAD_AND_CRC_MODE_PAD_AND_CRC =
+	    MACCFG2_PAD_AND_CRC_MODE_PAD_AND_CRC
+} ucc_geth_maccfg2_pad_and_crc_mode_e;
+
+/* UCC GETH upsmr Flow Control Mode
+*/
+typedef enum ucc_geth_flow_control_mode {
+	UPSMR_AUTOMATIC_FLOW_CONTROL_MODE_NONE = 0x00000000,	/* No automatic flow control                                    */
+	UPSMR_AUTOMATIC_FLOW_CONTROL_MODE_PAUSE_WHEN_EMERGENCY = 0x00004000	/* Send pause frame when RxFIFO reaches its emergency threshold */
+} ucc_geth_flow_control_mode_e;
+
+/* UCC GETH number of threads
+*/
+typedef enum ucc_geth_num_of_threads {
+	UCC_GETH_NUM_OF_THREADS_1 = 0x1,	/* 1 */
+	UCC_GETH_NUM_OF_THREADS_2 = 0x2,	/* 2 */
+	UCC_GETH_NUM_OF_THREADS_4 = 0x0,	/* 4 */
+	UCC_GETH_NUM_OF_THREADS_6 = 0x3,	/* 6 */
+	UCC_GETH_NUM_OF_THREADS_8 = 0x4	/* 8 */
+} ucc_geth_num_of_threads_e;
+
+/* UCC GETH number of station addresses
+*/
+typedef enum ucc_geth_num_of_station_addresses {
+	UCC_GETH_NUM_OF_STATION_ADDRESSES_1,	/* 1 */
+	UCC_GETH_NUM_OF_STATION_ADDRESSES_5	/* 5 */
+} ucc_geth_num_of_station_addresses_e;
+
+typedef u8 enet_addr_t[ENET_NUM_OCTETS_PER_ADDRESS];
+
+/* UCC GETH 82xx Ethernet Address Container
+*/
+typedef struct enet_addr_container {
+	enet_addr_t address;	/* ethernet address                              */
+	ucc_geth_enet_address_recognition_location_e location;	/* location in 82xx address recognition hardware */
+	struct list_head node;
+} enet_addr_container_t;
+
+#define ENET_ADDR_CONT_ENTRY(ptr) list_entry(ptr, enet_addr_container_t, node)
+
+/* UCC GETH Termination Action Descriptor (TAD) structure.
+*/
+typedef struct ucc_geth_tad_params {
+	int rx_non_dynamic_extended_features_mode;
+	int reject_frame;
+	ucc_geth_vlan_operation_tagged_e vtag_op;
+	ucc_geth_vlan_operation_non_tagged_e vnontag_op;
+	ucc_geth_qos_mode_e rqos;
+	u8 vpri;
+	u16 vid;
+} ucc_geth_tad_params_t;
+
+/* GETH protocol initialization structure
+*/
+typedef struct ucc_geth_info {
+	ucc_fast_info_t uf_info;
+	u8 numQueuesTx;
+	u8 numQueuesRx;
+	int ipCheckSumCheck;
+	int ipCheckSumGenerate;
+	int rxExtendedFiltering;
+	u32 extendedFilteringChainPointer;
+	u16 typeorlen;
+	int dynamicMaxFrameLength;
+	int dynamicMinFrameLength;
+	u8 nonBackToBackIfgPart1;
+	u8 nonBackToBackIfgPart2;
+	u8 miminumInterFrameGapEnforcement;
+	u8 backToBackInterFrameGap;
+	int ipAddressAlignment;
+	int lengthCheckRx;
+	u32 mblinterval;
+	u16 nortsrbytetime;
+	u8 fracsiz;
+	u8 strictpriorityq;
+	u8 txasap;
+	u8 extrabw;
+	int miiPreambleSupress;
+	u8 altBebTruncation;
+	int altBeb;
+	int backPressureNoBackoff;
+	int noBackoff;
+	int excessDefer;
+	u8 maxRetransmission;
+	u8 collisionWindow;
+	int pro;
+	int cap;
+	int rsh;
+	int rlpb;
+	int cam;
+	int bro;
+	int ecm;
+	int receiveFlowControl;
+	u8 maxGroupAddrInHash;
+	u8 maxIndAddrInHash;
+	u8 prel;
+	u16 maxFrameLength;
+	u16 minFrameLength;
+	u16 maxD1Length;
+	u16 maxD2Length;
+	u16 vlantype;
+	u16 vlantci;
+	u32 ecamptr;
+	u32 eventRegMask;
+	u16 pausePeriod;
+	u16 extensionField;
+	u8 phy_address;
+	u32 board_flags;
+	u32 phy_interrupt;
+	u8 weightfactor[NUM_TX_QUEUES];
+	u8 interruptcoalescingmaxvalue[NUM_RX_QUEUES];
+	u8 l2qt[UCC_GETH_VLAN_PRIORITY_MAX];
+	u8 l3qt[UCC_GETH_IP_PRIORITY_MAX];
+	u32 vtagtable[UCC_GETH_TX_VTAG_TABLE_ENTRY_MAX];
+	u8 iphoffset[TX_IP_OFFSET_ENTRY_MAX];
+	u16 bdRingLenTx[NUM_TX_QUEUES];
+	u16 bdRingLenRx[NUM_RX_QUEUES];
+	enet_interface_e enet_interface;
+	ucc_geth_num_of_station_addresses_e numStationAddresses;
+	 qe_fltr_largest_external_tbl_lookup_key_size_e
+	    largestexternallookupkeysize;
+	ucc_geth_statistics_gathering_mode_e statisticsMode;
+	ucc_geth_vlan_operation_tagged_e vlanOperationTagged;
+	ucc_geth_vlan_operation_non_tagged_e vlanOperationNonTagged;
+	ucc_geth_qos_mode_e rxQoSMode;
+	ucc_geth_flow_control_mode_e aufc;
+	ucc_geth_maccfg2_pad_and_crc_mode_e padAndCrc;
+	ucc_geth_num_of_threads_e numThreadsTx;
+	ucc_geth_num_of_threads_e numThreadsRx;
+	qe_risc_allocation_e riscTx;
+	qe_risc_allocation_e riscRx;
+} ucc_geth_info_t;
+
+/* structure representing UCC GETH
+*/
+typedef struct ucc_geth_private {
+	ucc_geth_info_t *ug_info;
+	ucc_fast_private_t *uccf;
+	struct net_device *dev;
+	struct net_device_stats stats;	/* linux network statistics */
+	ucc_geth_t *ug_regs;
+	ucc_geth_init_pram_t *p_init_enet_param_shadow;
+	ucc_geth_exf_global_pram_t *p_exf_glbl_param;
+	u32 exf_glbl_param_offset;
+	ucc_geth_rx_global_pram_t *p_rx_glbl_pram;
+	u32 rx_glbl_pram_offset;
+	ucc_geth_tx_global_pram_t *p_tx_glbl_pram;
+	u32 tx_glbl_pram_offset;
+	ucc_geth_send_queue_mem_region_t *p_send_q_mem_reg;
+	u32 send_q_mem_reg_offset;
+	ucc_geth_thread_data_tx_t *p_thread_data_tx;
+	u32 thread_dat_tx_offset;
+	ucc_geth_thread_data_rx_t *p_thread_data_rx;
+	u32 thread_dat_rx_offset;
+	ucc_geth_scheduler_t *p_scheduler;
+	u32 scheduler_offset;
+	ucc_geth_tx_firmware_statistics_pram_t *p_tx_fw_statistics_pram;
+	u32 tx_fw_statistics_pram_offset;
+	ucc_geth_rx_firmware_statistics_pram_t *p_rx_fw_statistics_pram;
+	u32 rx_fw_statistics_pram_offset;
+	ucc_geth_rx_interrupt_coalescing_table_t *p_rx_irq_coalescing_tbl;
+	u32 rx_irq_coalescing_tbl_offset;
+	ucc_geth_rx_bd_queues_entry_t *p_rx_bd_qs_tbl;
+	u32 rx_bd_qs_tbl_offset;
+	u8 *p_tx_bd_ring[NUM_TX_QUEUES];
+	u32 tx_bd_ring_offset[NUM_TX_QUEUES];
+	u8 *p_rx_bd_ring[NUM_RX_QUEUES];
+	u32 rx_bd_ring_offset[NUM_RX_QUEUES];
+	u8 *confBd[NUM_TX_QUEUES];
+	u8 *txBd[NUM_TX_QUEUES];
+	u8 *rxBd[NUM_RX_QUEUES];
+	int badFrame[NUM_RX_QUEUES];
+	u16 cpucount[NUM_TX_QUEUES];
+	volatile u16 *p_cpucount[NUM_TX_QUEUES];
+	int indAddrRegUsed[NUM_OF_PADDRS];
+	enet_addr_t paddr[NUM_OF_PADDRS];
+	u8 numGroupAddrInHash;
+	u8 numIndAddrInHash;
+	u8 numIndAddrInReg;
+	int rx_extended_features;
+	int rx_non_dynamic_extended_features;
+	struct list_head conf_skbs;
+	struct list_head group_hash_q;
+	struct list_head ind_hash_q;
+	u32 saved_uccm;
+	spinlock_t lock;
+	/* pointers to arrays of skbuffs for tx and rx */
+	struct sk_buff **tx_skbuff[NUM_TX_QUEUES];
+	struct sk_buff **rx_skbuff[NUM_RX_QUEUES];
+	/* indices pointing to the next free sbk in skb arrays */
+	u16 skb_curtx[NUM_TX_QUEUES];
+	u16 skb_currx[NUM_RX_QUEUES];
+	/* index of the first skb which hasn't been transmitted yet. */
+	u16 skb_dirtytx[NUM_TX_QUEUES];
+
+	struct work_struct tq;
+	struct timer_list phy_info_timer;
+	struct ugeth_mii_info *mii_info;
+	int oldspeed;
+	int oldduplex;
+	int oldlink;
+} ucc_geth_private_t;
+
+#endif				/* __UCC_GETH_H__ */
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth_phy.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth_phy.c
@@ -0,0 +1,806 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_geth_phy.c
+ *
+ * UCC GETH Driver -- PHY handling
+ * Driver for UEC on QE
+ * Based on 8260_io/fcc_enet.c
+ *
+ * Author: Shlomi Gridish
+ * Maintainer: Kumar Gala (kumar.gala@freescale.com)
+ *
+ * Copyright (c) 2002-2004 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include "ucc_geth.h"
+#include "ucc_geth_phy.h"
+
+#define ugphy_printk(level, format, arg...)  \
+        printk(level format "\n", ## arg)
+
+#define ugphy_dbg(format, arg...)            \
+        ugphy_printk(KERN_DEBUG, format , ## arg)
+#define ugphy_err(format, arg...)            \
+        ugphy_printk(KERN_ERR, format , ## arg)
+#define ugphy_info(format, arg...)           \
+        ugphy_printk(KERN_INFO, format , ## arg)
+#define ugphy_warn(format, arg...)           \
+        ugphy_printk(KERN_WARNING, format , ## arg)
+
+#ifdef UGETH_VERBOSE_DEBUG
+#define ugphy_vdbg ugphy_dbg
+#else
+#define ugphy_vdbg(fmt, args...) do { } while (0)
+#endif				/* UGETH_VERBOSE_DEBUG */
+
+static void config_genmii_advert(struct ugeth_mii_info *mii_info);
+static void genmii_setup_forced(struct ugeth_mii_info *mii_info);
+static void genmii_restart_aneg(struct ugeth_mii_info *mii_info);
+static int gbit_config_aneg(struct ugeth_mii_info *mii_info);
+static int genmii_config_aneg(struct ugeth_mii_info *mii_info);
+static int genmii_update_link(struct ugeth_mii_info *mii_info);
+static int genmii_read_status(struct ugeth_mii_info *mii_info);
+u16 phy_read(struct ugeth_mii_info *mii_info, u16 regnum);
+void phy_write(struct ugeth_mii_info *mii_info, u16 regnum, u16 val);
+
+/* Write value to the PHY for this device to the register at regnum, */
+/* waiting until the write is done before it returns.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+void write_phy_reg(struct net_device *dev, int mii_id, int regnum, int value)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	ucc_mii_mng_t *mii_regs;
+	enet_tbi_mii_reg_e mii_reg = (enet_tbi_mii_reg_e) regnum;
+	u32 tmp_reg;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irq(&ugeth->lock);
+
+	mii_regs = ugeth->mii_info->mii_regs;
+
+	/* Set this UCC to be the master of the MII managment */
+	ucc_set_qe_mux_mii_mng(ugeth->ug_info->uf_info.ucc_num);
+
+	/* Stop the MII management read cycle */
+	out_be32(&mii_regs->miimcom, 0);
+	/* Setting up the MII Mangement Address Register */
+	tmp_reg = ((u32) mii_id << MIIMADD_PHY_ADDRESS_SHIFT) | mii_reg;
+	out_be32(&mii_regs->miimadd, tmp_reg);
+
+	/* Setting up the MII Mangement Control Register with the value */
+	out_be32(&mii_regs->miimcon, (u32) value);
+
+	/* Wait till MII management write is complete */
+	while ((in_be32(&mii_regs->miimind)) & MIIMIND_BUSY)
+		cpu_relax();
+
+	spin_unlock_irq(&ugeth->lock);
+
+	udelay(10000);
+}
+
+/* Reads from register regnum in the PHY for device dev, */
+/* returning the value.  Clears miimcom first.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+int read_phy_reg(struct net_device *dev, int mii_id, int regnum)
+{
+	ucc_geth_private_t *ugeth = netdev_priv(dev);
+	ucc_mii_mng_t *mii_regs;
+	enet_tbi_mii_reg_e mii_reg = (enet_tbi_mii_reg_e) regnum;
+	u32 tmp_reg;
+	u16 value;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irq(&ugeth->lock);
+
+	mii_regs = ugeth->mii_info->mii_regs;
+
+	/* Setting up the MII Mangement Address Register */
+	tmp_reg = ((u32) mii_id << MIIMADD_PHY_ADDRESS_SHIFT) | mii_reg;
+	out_be32(&mii_regs->miimadd, tmp_reg);
+
+	/* Perform an MII management read cycle */
+	out_be32(&mii_regs->miimcom, MIIMCOM_READ_CYCLE);
+
+	/* Wait till MII management write is complete */
+	while ((in_be32(&mii_regs->miimind)) & MIIMIND_BUSY)
+		cpu_relax();
+
+	udelay(10000);
+
+	/* Read MII management status  */
+	value = (u16) in_be32(&mii_regs->miimstat);
+	out_be32(&mii_regs->miimcom, 0);
+	if (value == 0xffff)
+		ugphy_warn("read wrong value : mii_id %d,mii_reg %d, base %08x",
+			   mii_id, mii_reg, (u32) & (mii_regs->miimcfg));
+
+	spin_unlock_irq(&ugeth->lock);
+
+	return (value);
+}
+
+void mii_clear_phy_interrupt(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->phyinfo->ack_interrupt)
+		mii_info->phyinfo->ack_interrupt(mii_info);
+}
+
+void mii_configure_phy_interrupt(struct ugeth_mii_info *mii_info,
+				 u32 interrupts)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	mii_info->interrupts = interrupts;
+	if (mii_info->phyinfo->config_intr)
+		mii_info->phyinfo->config_intr(mii_info);
+}
+
+/* Writes MII_ADVERTISE with the appropriate values, after
+ * sanitizing advertise to make sure only supported features
+ * are advertised
+ */
+static void config_genmii_advert(struct ugeth_mii_info *mii_info)
+{
+	u32 advertise;
+	u16 adv;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Only allow advertising what this PHY supports */
+	mii_info->advertising &= mii_info->phyinfo->features;
+	advertise = mii_info->advertising;
+
+	/* Setup standard advertisement */
+	adv = phy_read(mii_info, MII_ADVERTISE);
+	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	if (advertise & ADVERTISED_10baseT_Half)
+		adv |= ADVERTISE_10HALF;
+	if (advertise & ADVERTISED_10baseT_Full)
+		adv |= ADVERTISE_10FULL;
+	if (advertise & ADVERTISED_100baseT_Half)
+		adv |= ADVERTISE_100HALF;
+	if (advertise & ADVERTISED_100baseT_Full)
+		adv |= ADVERTISE_100FULL;
+	phy_write(mii_info, MII_ADVERTISE, adv);
+}
+
+static void genmii_setup_forced(struct ugeth_mii_info *mii_info)
+{
+	u16 ctrl;
+	u32 features = mii_info->phyinfo->features;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	ctrl = phy_read(mii_info, MII_BMCR);
+
+	ctrl &=
+	    ~(BMCR_FULLDPLX | BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);
+	ctrl |= BMCR_RESET;
+
+	switch (mii_info->speed) {
+	case SPEED_1000:
+		if (features & (SUPPORTED_1000baseT_Half
+				| SUPPORTED_1000baseT_Full)) {
+			ctrl |= BMCR_SPEED1000;
+			break;
+		}
+		mii_info->speed = SPEED_100;
+	case SPEED_100:
+		if (features & (SUPPORTED_100baseT_Half
+				| SUPPORTED_100baseT_Full)) {
+			ctrl |= BMCR_SPEED100;
+			break;
+		}
+		mii_info->speed = SPEED_10;
+	case SPEED_10:
+		if (features & (SUPPORTED_10baseT_Half
+				| SUPPORTED_10baseT_Full))
+			break;
+	default:		/* Unsupported speed! */
+		ugphy_err("%s: Bad speed!", mii_info->dev->name);
+		break;
+	}
+
+	phy_write(mii_info, MII_BMCR, ctrl);
+}
+
+/* Enable and Restart Autonegotiation */
+static void genmii_restart_aneg(struct ugeth_mii_info *mii_info)
+{
+	u16 ctl;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	ctl = phy_read(mii_info, MII_BMCR);
+	ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	phy_write(mii_info, MII_BMCR, ctl);
+}
+
+static int gbit_config_aneg(struct ugeth_mii_info *mii_info)
+{
+	u16 adv;
+	u32 advertise;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->autoneg) {
+		/* Configure the ADVERTISE register */
+		config_genmii_advert(mii_info);
+		advertise = mii_info->advertising;
+
+		adv = phy_read(mii_info, MII_1000BASETCONTROL);
+		adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP |
+			 MII_1000BASETCONTROL_HALFDUPLEXCAP);
+		if (advertise & SUPPORTED_1000baseT_Half)
+			adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
+		if (advertise & SUPPORTED_1000baseT_Full)
+			adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
+		phy_write(mii_info, MII_1000BASETCONTROL, adv);
+
+		/* Start/Restart aneg */
+		genmii_restart_aneg(mii_info);
+	} else
+		genmii_setup_forced(mii_info);
+
+	return 0;
+}
+
+static int genmii_config_aneg(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->autoneg) {
+		config_genmii_advert(mii_info);
+		genmii_restart_aneg(mii_info);
+	} else
+		genmii_setup_forced(mii_info);
+
+	return 0;
+}
+
+static int genmii_update_link(struct ugeth_mii_info *mii_info)
+{
+	u16 status;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Do a fake read */
+	phy_read(mii_info, MII_BMSR);
+
+	/* Read link and autonegotiation status */
+	status = phy_read(mii_info, MII_BMSR);
+	if ((status & BMSR_LSTATUS) == 0)
+		mii_info->link = 0;
+	else
+		mii_info->link = 1;
+
+	/* If we are autonegotiating, and not done,
+	 * return an error */
+	if (mii_info->autoneg && !(status & BMSR_ANEGCOMPLETE))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int genmii_read_status(struct ugeth_mii_info *mii_info)
+{
+	u16 status;
+	int err;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Update the link, but return if there
+	 * was an error */
+	err = genmii_update_link(mii_info);
+	if (err)
+		return err;
+
+	if (mii_info->autoneg) {
+		status = phy_read(mii_info, MII_LPA);
+
+		if (status & (LPA_10FULL | LPA_100FULL))
+			mii_info->duplex = DUPLEX_FULL;
+		else
+			mii_info->duplex = DUPLEX_HALF;
+		if (status & (LPA_100FULL | LPA_100HALF))
+			mii_info->speed = SPEED_100;
+		else
+			mii_info->speed = SPEED_10;
+		mii_info->pause = 0;
+	}
+	/* On non-aneg, we assume what we put in BMCR is the speed,
+	 * though magic-aneg shouldn't prevent this case from occurring
+	 */
+
+	return 0;
+}
+
+static int marvell_init(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	phy_write(mii_info, 0x14, 0x0cd2);
+	phy_write(mii_info, MII_BMCR,
+		  phy_read(mii_info, MII_BMCR) | BMCR_RESET);
+	msleep(4000);
+
+	return 0;
+}
+
+static int marvell_config_aneg(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* The Marvell PHY has an errata which requires
+	 * that certain registers get written in order
+	 * to restart autonegotiation */
+	phy_write(mii_info, MII_BMCR, BMCR_RESET);
+
+	phy_write(mii_info, 0x1d, 0x1f);
+	phy_write(mii_info, 0x1e, 0x200c);
+	phy_write(mii_info, 0x1d, 0x5);
+	phy_write(mii_info, 0x1e, 0);
+	phy_write(mii_info, 0x1e, 0x100);
+
+	gbit_config_aneg(mii_info);
+
+	return 0;
+}
+
+static int marvell_read_status(struct ugeth_mii_info *mii_info)
+{
+	u16 status;
+	int err;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Update the link, but return if there
+	 * was an error */
+	err = genmii_update_link(mii_info);
+	if (err)
+		return err;
+
+	/* If the link is up, read the speed and duplex */
+	/* If we aren't autonegotiating, assume speeds
+	 * are as set */
+	if (mii_info->autoneg && mii_info->link) {
+		int speed;
+		status = phy_read(mii_info, MII_M1011_PHY_SPEC_STATUS);
+
+#if 0
+		/* If speed and duplex aren't resolved,
+		 * return an error.  Isn't this handled
+		 * by checking aneg?
+		 */
+		if ((status & MII_M1011_PHY_SPEC_STATUS_RESOLVED) == 0)
+			return -EAGAIN;
+#endif
+
+		/* Get the duplexity */
+		if (status & MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX)
+			mii_info->duplex = DUPLEX_FULL;
+		else
+			mii_info->duplex = DUPLEX_HALF;
+
+		/* Get the speed */
+		speed = status & MII_M1011_PHY_SPEC_STATUS_SPD_MASK;
+		switch (speed) {
+		case MII_M1011_PHY_SPEC_STATUS_1000:
+			mii_info->speed = SPEED_1000;
+			break;
+		case MII_M1011_PHY_SPEC_STATUS_100:
+			mii_info->speed = SPEED_100;
+			break;
+		default:
+			mii_info->speed = SPEED_10;
+			break;
+		}
+		mii_info->pause = 0;
+	}
+
+	return 0;
+}
+
+static int marvell_ack_interrupt(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Clear the interrupts by reading the reg */
+	phy_read(mii_info, MII_M1011_IEVENT);
+
+	return 0;
+}
+
+static int marvell_config_intr(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
+		phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_INIT);
+	else
+		phy_write(mii_info, MII_M1011_IMASK, MII_M1011_IMASK_CLEAR);
+
+	return 0;
+}
+
+static int cis820x_init(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	phy_write(mii_info, MII_CIS8201_AUX_CONSTAT,
+		  MII_CIS8201_AUXCONSTAT_INIT);
+	phy_write(mii_info, MII_CIS8201_EXT_CON1, MII_CIS8201_EXTCON1_INIT);
+
+	return 0;
+}
+
+static int cis820x_read_status(struct ugeth_mii_info *mii_info)
+{
+	u16 status;
+	int err;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Update the link, but return if there
+	 * was an error */
+	err = genmii_update_link(mii_info);
+	if (err)
+		return err;
+
+	/* If the link is up, read the speed and duplex */
+	/* If we aren't autonegotiating, assume speeds
+	 * are as set */
+	if (mii_info->autoneg && mii_info->link) {
+		int speed;
+
+		status = phy_read(mii_info, MII_CIS8201_AUX_CONSTAT);
+		if (status & MII_CIS8201_AUXCONSTAT_DUPLEX)
+			mii_info->duplex = DUPLEX_FULL;
+		else
+			mii_info->duplex = DUPLEX_HALF;
+
+		speed = status & MII_CIS8201_AUXCONSTAT_SPEED;
+
+		switch (speed) {
+		case MII_CIS8201_AUXCONSTAT_GBIT:
+			mii_info->speed = SPEED_1000;
+			break;
+		case MII_CIS8201_AUXCONSTAT_100:
+			mii_info->speed = SPEED_100;
+			break;
+		default:
+			mii_info->speed = SPEED_10;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int cis820x_ack_interrupt(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	phy_read(mii_info, MII_CIS8201_ISTAT);
+
+	return 0;
+}
+
+static int cis820x_config_intr(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
+		phy_write(mii_info, MII_CIS8201_IMASK, MII_CIS8201_IMASK_MASK);
+	else
+		phy_write(mii_info, MII_CIS8201_IMASK, 0);
+
+	return 0;
+}
+
+#define DM9161_DELAY 10
+
+static int dm9161_read_status(struct ugeth_mii_info *mii_info)
+{
+	u16 status;
+	int err;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Update the link, but return if there
+	 * was an error */
+	err = genmii_update_link(mii_info);
+	if (err)
+		return err;
+
+	/* If the link is up, read the speed and duplex */
+	/* If we aren't autonegotiating, assume speeds
+	 * are as set */
+	if (mii_info->autoneg && mii_info->link) {
+		status = phy_read(mii_info, MII_DM9161_SCSR);
+		if (status & (MII_DM9161_SCSR_100F | MII_DM9161_SCSR_100H))
+			mii_info->speed = SPEED_100;
+		else
+			mii_info->speed = SPEED_10;
+
+		if (status & (MII_DM9161_SCSR_100F | MII_DM9161_SCSR_10F))
+			mii_info->duplex = DUPLEX_FULL;
+		else
+			mii_info->duplex = DUPLEX_HALF;
+	}
+
+	return 0;
+}
+
+static int dm9161_config_aneg(struct ugeth_mii_info *mii_info)
+{
+	struct dm9161_private *priv = mii_info->priv;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (0 == priv->resetdone)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static void dm9161_timer(unsigned long data)
+{
+	struct ugeth_mii_info *mii_info = (struct ugeth_mii_info *)data;
+	struct dm9161_private *priv = mii_info->priv;
+	u16 status = phy_read(mii_info, MII_BMSR);
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (status & BMSR_ANEGCOMPLETE) {
+		priv->resetdone = 1;
+	} else
+		mod_timer(&priv->timer, jiffies + DM9161_DELAY * HZ);
+}
+
+static int dm9161_init(struct ugeth_mii_info *mii_info)
+{
+	struct dm9161_private *priv;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Allocate the private data structure */
+	priv = kmalloc(sizeof(struct dm9161_private), GFP_KERNEL);
+
+	if (NULL == priv)
+		return -ENOMEM;
+
+	mii_info->priv = priv;
+
+	/* Reset is not done yet */
+	priv->resetdone = 0;
+
+	/* Isolate the PHY */
+//    phy_write(mii_info, MII_BMCR, BMCR_ISOLATE);
+
+	/* Do not bypass the scrambler/descrambler */
+//    phy_write(mii_info, MII_DM9161_SCR, MII_DM9161_SCR_INIT);
+
+	/* Clear 10BTCSR to default */
+//    phy_write(mii_info, MII_DM9161_10BTCSR, MII_DM9161_10BTCSR_INIT);
+
+	phy_write(mii_info, MII_BMCR,
+		  phy_read(mii_info, MII_BMCR) | BMCR_RESET);
+
+	phy_write(mii_info, MII_BMCR,
+		  phy_read(mii_info, MII_BMCR) & ~BMCR_ISOLATE);
+
+	config_genmii_advert(mii_info);
+	/* Start/Restart aneg */
+	genmii_config_aneg(mii_info);
+
+//    phy_write(mii_info, MII_BMCR, phy_read(mii_info, MII_BMCR) | BMCR_RESET);
+
+	/* Start a timer for DM9161_DELAY seconds to wait
+	 * for the PHY to be ready */
+	init_timer(&priv->timer);
+	priv->timer.function = &dm9161_timer;
+	priv->timer.data = (unsigned long)mii_info;
+	mod_timer(&priv->timer, jiffies + DM9161_DELAY * HZ);
+
+	return 0;
+}
+
+static void dm9161_close(struct ugeth_mii_info *mii_info)
+{
+	struct dm9161_private *priv = mii_info->priv;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	del_timer_sync(&priv->timer);
+	kfree(priv);
+}
+
+static int dm9161_ack_interrupt(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Clear the interrupts by reading the reg */
+	phy_read(mii_info, MII_DM9161_INTR);
+
+	return 0;
+}
+
+static int dm9161_config_intr(struct ugeth_mii_info *mii_info)
+{
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	if (mii_info->interrupts == MII_INTERRUPT_ENABLED)
+		phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_INIT);
+	else
+		phy_write(mii_info, MII_DM9161_INTR, MII_DM9161_INTR_STOP);
+
+	return 0;
+}
+
+/* Cicada 820x */
+static struct phy_info phy_info_cis820x = {
+	.phy_id = 0x000fc440,
+	.name = "Cicada Cis8204",
+	.phy_id_mask = 0x000fffc0,
+	.features = MII_GBIT_FEATURES,
+	.init = &cis820x_init,
+	.config_aneg = &gbit_config_aneg,
+	.read_status = &cis820x_read_status,
+	.ack_interrupt = &cis820x_ack_interrupt,
+	.config_intr = &cis820x_config_intr,
+};
+
+static struct phy_info phy_info_dm9161 = {
+	.phy_id = 0x0181b880,
+	.phy_id_mask = 0x0ffffff0,
+	.name = "Davicom DM9161E",
+	.init = dm9161_init,
+	.config_aneg = dm9161_config_aneg,
+	.read_status = dm9161_read_status,
+	.close = dm9161_close,
+};
+
+static struct phy_info phy_info_dm9161a = {
+	.phy_id = 0x0181b8a0,
+	.phy_id_mask = 0x0ffffff0,
+	.name = "Davicom DM9161A",
+	.features = MII_BASIC_FEATURES,
+	.init = dm9161_init,
+	.config_aneg = dm9161_config_aneg,
+	.read_status = dm9161_read_status,
+	.ack_interrupt = dm9161_ack_interrupt,
+	.config_intr = dm9161_config_intr,
+	.close = dm9161_close,
+};
+
+static struct phy_info phy_info_marvell = {
+	.phy_id = 0x01410c00,
+	.phy_id_mask = 0xffffff00,
+	.name = "Marvell 88E11x1",
+	.features = MII_GBIT_FEATURES,
+	.init = &marvell_init,
+	.config_aneg = &marvell_config_aneg,
+	.read_status = &marvell_read_status,
+	.ack_interrupt = &marvell_ack_interrupt,
+	.config_intr = &marvell_config_intr,
+};
+
+static struct phy_info phy_info_genmii = {
+	.phy_id = 0x00000000,
+	.phy_id_mask = 0x00000000,
+	.name = "Generic MII",
+	.features = MII_BASIC_FEATURES,
+	.config_aneg = genmii_config_aneg,
+	.read_status = genmii_read_status,
+};
+
+static struct phy_info *phy_info[] = {
+	&phy_info_cis820x,
+	&phy_info_marvell,
+	&phy_info_dm9161,
+	&phy_info_dm9161a,
+	&phy_info_genmii,
+	NULL
+};
+
+u16 phy_read(struct ugeth_mii_info *mii_info, u16 regnum)
+{
+	u16 retval;
+	unsigned long flags;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irqsave(&mii_info->mdio_lock, flags);
+	retval = mii_info->mdio_read(mii_info->dev, mii_info->mii_id, regnum);
+	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
+
+	return retval;
+}
+
+void phy_write(struct ugeth_mii_info *mii_info, u16 regnum, u16 val)
+{
+	unsigned long flags;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	spin_lock_irqsave(&mii_info->mdio_lock, flags);
+	mii_info->mdio_write(mii_info->dev, mii_info->mii_id, regnum, val);
+	spin_unlock_irqrestore(&mii_info->mdio_lock, flags);
+}
+
+/* Use the PHY ID registers to determine what type of PHY is attached
+ * to device dev.  return a struct phy_info structure describing that PHY
+ */
+struct phy_info *get_phy_info(struct ugeth_mii_info *mii_info)
+{
+	u16 phy_reg;
+	u32 phy_ID;
+	int i;
+	struct phy_info *theInfo = NULL;
+	struct net_device *dev = mii_info->dev;
+
+	ugphy_vdbg("%s: IN", __FUNCTION__);
+
+	/* Grab the bits from PHYIR1, and put them in the upper half */
+	phy_reg = phy_read(mii_info, MII_PHYSID1);
+	phy_ID = (phy_reg & 0xffff) << 16;
+
+	/* Grab the bits from PHYIR2, and put them in the lower half */
+	phy_reg = phy_read(mii_info, MII_PHYSID2);
+	phy_ID |= (phy_reg & 0xffff);
+
+	/* loop through all the known PHY types, and find one that */
+	/* matches the ID we read from the PHY. */
+	for (i = 0; phy_info[i]; i++)
+		if (phy_info[i]->phy_id == (phy_ID & phy_info[i]->phy_id_mask)) {
+			theInfo = phy_info[i];
+			break;
+		}
+
+	/* This shouldn't happen, as we have generic PHY support */
+	if (theInfo == NULL) {
+		ugphy_info("%s: PHY id %x is not supported!", dev->name,
+			   phy_ID);
+		return NULL;
+	} else {
+		ugphy_info("%s: PHY is %s (%x)", dev->name, theInfo->name,
+			   phy_ID);
+	}
+
+	return theInfo;
+}
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth_phy.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_geth_phy.h
@@ -0,0 +1,217 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_geth_phy.h
+ *
+ * UCC GETH Driver -- PHY handling
+ * Driver for UEC on QE
+ * Based on 8260_io/fcc_enet.c
+ *
+ * Author: Shlomi Gridish
+ * Maintainer: Kumar Gala (kumar.gala@freescale.com)
+ *
+ * Copyright (c) 2002-2005 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef __UCC_GETH_PHY_H__
+#define __UCC_GETH_PHY_H__
+
+#define MII_end ((u32)-2)
+#define MII_read ((u32)-1)
+
+#define MIIMIND_BUSY            0x00000001
+#define MIIMIND_NOTVALID        0x00000004
+
+#define UGETH_AN_TIMEOUT        2000
+
+/* 1000BT control (Marvell & BCM54xx at least) */
+#define MII_1000BASETCONTROL                  0x09
+#define MII_1000BASETCONTROL_FULLDUPLEXCAP    0x0200
+#define MII_1000BASETCONTROL_HALFDUPLEXCAP    0x0100
+
+/* Cicada Extended Control Register 1 */
+#define MII_CIS8201_EXT_CON1        0x17
+#define MII_CIS8201_EXTCON1_INIT    0x0000
+
+/* Cicada Interrupt Mask Register */
+#define MII_CIS8201_IMASK           0x19
+#define MII_CIS8201_IMASK_IEN       0x8000
+#define MII_CIS8201_IMASK_SPEED     0x4000
+#define MII_CIS8201_IMASK_LINK      0x2000
+#define MII_CIS8201_IMASK_DUPLEX    0x1000
+#define MII_CIS8201_IMASK_MASK      0xf000
+
+/* Cicada Interrupt Status Register */
+#define MII_CIS8201_ISTAT           0x1a
+#define MII_CIS8201_ISTAT_STATUS    0x8000
+#define MII_CIS8201_ISTAT_SPEED     0x4000
+#define MII_CIS8201_ISTAT_LINK      0x2000
+#define MII_CIS8201_ISTAT_DUPLEX    0x1000
+
+/* Cicada Auxiliary Control/Status Register */
+#define MII_CIS8201_AUX_CONSTAT        0x1c
+#define MII_CIS8201_AUXCONSTAT_INIT    0x0004
+#define MII_CIS8201_AUXCONSTAT_DUPLEX  0x0020
+#define MII_CIS8201_AUXCONSTAT_SPEED   0x0018
+#define MII_CIS8201_AUXCONSTAT_GBIT    0x0010
+#define MII_CIS8201_AUXCONSTAT_100     0x0008
+
+/* 88E1011 PHY Status Register */
+#define MII_M1011_PHY_SPEC_STATUS               0x11
+#define MII_M1011_PHY_SPEC_STATUS_1000          0x8000
+#define MII_M1011_PHY_SPEC_STATUS_100           0x4000
+#define MII_M1011_PHY_SPEC_STATUS_SPD_MASK      0xc000
+#define MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX    0x2000
+#define MII_M1011_PHY_SPEC_STATUS_RESOLVED      0x0800
+#define MII_M1011_PHY_SPEC_STATUS_LINK          0x0400
+
+#define MII_M1011_IEVENT                0x13
+#define MII_M1011_IEVENT_CLEAR          0x0000
+
+#define MII_M1011_IMASK                 0x12
+#define MII_M1011_IMASK_INIT            0x6400
+#define MII_M1011_IMASK_CLEAR           0x0000
+
+#define MII_DM9161_SCR                  0x10
+#define MII_DM9161_SCR_INIT             0x0610
+
+/* DM9161 Specified Configuration and Status Register */
+#define MII_DM9161_SCSR                 0x11
+#define MII_DM9161_SCSR_100F            0x8000
+#define MII_DM9161_SCSR_100H            0x4000
+#define MII_DM9161_SCSR_10F             0x2000
+#define MII_DM9161_SCSR_10H             0x1000
+
+/* DM9161 Interrupt Register */
+#define MII_DM9161_INTR                 0x15
+#define MII_DM9161_INTR_PEND            0x8000
+#define MII_DM9161_INTR_DPLX_MASK       0x0800
+#define MII_DM9161_INTR_SPD_MASK        0x0400
+#define MII_DM9161_INTR_LINK_MASK       0x0200
+#define MII_DM9161_INTR_MASK            0x0100
+#define MII_DM9161_INTR_DPLX_CHANGE     0x0010
+#define MII_DM9161_INTR_SPD_CHANGE      0x0008
+#define MII_DM9161_INTR_LINK_CHANGE     0x0004
+#define MII_DM9161_INTR_INIT            0x0000
+#define MII_DM9161_INTR_STOP    \
+(MII_DM9161_INTR_DPLX_MASK | MII_DM9161_INTR_SPD_MASK \
+ | MII_DM9161_INTR_LINK_MASK | MII_DM9161_INTR_MASK)
+
+/* DM9161 10BT Configuration/Status */
+#define MII_DM9161_10BTCSR              0x12
+#define MII_DM9161_10BTCSR_INIT         0x7800
+
+#define MII_BASIC_FEATURES    (SUPPORTED_10baseT_Half | \
+                 SUPPORTED_10baseT_Full | \
+                 SUPPORTED_100baseT_Half | \
+                 SUPPORTED_100baseT_Full | \
+                 SUPPORTED_Autoneg | \
+                 SUPPORTED_TP | \
+                 SUPPORTED_MII)
+
+#define MII_GBIT_FEATURES    (MII_BASIC_FEATURES | \
+                 SUPPORTED_1000baseT_Half | \
+                 SUPPORTED_1000baseT_Full)
+
+#define MII_READ_COMMAND                0x00000001
+
+#define MII_INTERRUPT_DISABLED          0x0
+#define MII_INTERRUPT_ENABLED           0x1
+/* Taken from mii_if_info and sungem_phy.h */
+struct ugeth_mii_info {
+	/* Information about the PHY type */
+	/* And management functions */
+	struct phy_info *phyinfo;
+
+	ucc_mii_mng_t *mii_regs;
+
+	/* forced speed & duplex (no autoneg)
+	 * partner speed & duplex & pause (autoneg)
+	 */
+	int speed;
+	int duplex;
+	int pause;
+
+	/* The most recently read link state */
+	int link;
+
+	/* Enabled Interrupts */
+	u32 interrupts;
+
+	u32 advertising;
+	int autoneg;
+	int mii_id;
+
+	/* private data pointer */
+	/* For use by PHYs to maintain extra state */
+	void *priv;
+
+	/* Provided by host chip */
+	struct net_device *dev;
+
+	/* A lock to ensure that only one thing can read/write
+	 * the MDIO bus at a time */
+	spinlock_t mdio_lock;
+
+	/* Provided by ethernet driver */
+	int (*mdio_read) (struct net_device * dev, int mii_id, int reg);
+	void (*mdio_write) (struct net_device * dev, int mii_id, int reg,
+			    int val);
+};
+
+/* struct phy_info: a structure which defines attributes for a PHY
+ *
+ * id will contain a number which represents the PHY.  During
+ * startup, the driver will poll the PHY to find out what its
+ * UID--as defined by registers 2 and 3--is.  The 32-bit result
+ * gotten from the PHY will be ANDed with phy_id_mask to
+ * discard any bits which may change based on revision numbers
+ * unimportant to functionality
+ *
+ * There are 6 commands which take a ugeth_mii_info structure.
+ * Each PHY must declare config_aneg, and read_status.
+ */
+struct phy_info {
+	u32 phy_id;
+	char *name;
+	unsigned int phy_id_mask;
+	u32 features;
+
+	/* Called to initialize the PHY */
+	int (*init) (struct ugeth_mii_info * mii_info);
+
+	/* Called to suspend the PHY for power */
+	int (*suspend) (struct ugeth_mii_info * mii_info);
+
+	/* Reconfigures autonegotiation (or disables it) */
+	int (*config_aneg) (struct ugeth_mii_info * mii_info);
+
+	/* Determines the negotiated speed and duplex */
+	int (*read_status) (struct ugeth_mii_info * mii_info);
+
+	/* Clears any pending interrupts */
+	int (*ack_interrupt) (struct ugeth_mii_info * mii_info);
+
+	/* Enables or disables interrupts */
+	int (*config_intr) (struct ugeth_mii_info * mii_info);
+
+	/* Clears up any memory if needed */
+	void (*close) (struct ugeth_mii_info * mii_info);
+};
+
+struct phy_info *get_phy_info(struct ugeth_mii_info *mii_info);
+void write_phy_reg(struct net_device *dev, int mii_id, int regnum, int value);
+int read_phy_reg(struct net_device *dev, int mii_id, int regnum);
+void mii_clear_phy_interrupt(struct ugeth_mii_info *mii_info);
+void mii_configure_phy_interrupt(struct ugeth_mii_info *mii_info,
+				 u32 interrupts);
+
+struct dm9161_private {
+	struct timer_list timer;
+	int resetdone;
+};
+
+#endif				/* __UCC_GETH_PHY_H__ */
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc.h
@@ -0,0 +1,79 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc.h
+ *
+ * Internal header file for UCC unit routines.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __UCC_H__
+#define __UCC_H__
+
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#define STATISTICS
+
+/* Slow or fast type for UCCs.
+*/
+typedef enum ucc_speed_type {
+	UCC_SPEED_TYPE_FAST, UCC_SPEED_TYPE_SLOW
+} ucc_speed_type_e;
+
+/* Initial UCCs Parameter RAM address relative to: MEM_MAP_BASE (IMMR).
+*/
+typedef enum ucc_pram_initial_offset {
+	UCC_PRAM_OFFSET_UCC1 = 0x8400, UCC_PRAM_OFFSET_UCC2 =
+	    0x8500, UCC_PRAM_OFFSET_UCC3 = 0x8600, UCC_PRAM_OFFSET_UCC4 =
+	    0x9000, UCC_PRAM_OFFSET_UCC5 = 0x8000, UCC_PRAM_OFFSET_UCC6 =
+	    0x8100, UCC_PRAM_OFFSET_UCC7 = 0x8200, UCC_PRAM_OFFSET_UCC8 = 0x8300
+} ucc_pram_initial_offset_e;
+
+/* ucc_set_type
+ * Sets UCC to slow or fast mode.
+ *
+ * @Param         ucc_num  - (In) number of UCC  (0-7).
+ * @Param         regs     - (In) pointer to registers base for the UCC.
+ * @Param         speed    - (In) slow or fast mode for UCC.
+ */
+int ucc_set_type(unsigned int ucc_num, struct ucc_common *regs,
+		 enum ucc_speed_type speed);
+
+/* ucc_init_guemr
+ * Init the Guemr register.
+ *
+ * @Param         regs - (In) pointer to registers base for the UCC.
+ */
+int ucc_init_guemr(struct ucc_common *regs);
+
+int ucc_set_qe_mux_mii_mng(unsigned int ucc_num);
+
+int ucc_set_qe_mux_rxtx(unsigned int ucc_num, qe_clock_e clock,
+			comm_dir_e mode);
+
+int ucc_mux_set_grant_tsa_bkpt(unsigned int ucc_num, int set, u32 mask);
+
+/* QE MUX clock routing for UCC
+*/
+static inline int ucc_set_qe_mux_grant(unsigned int ucc_num, int set)
+{
+	return ucc_mux_set_grant_tsa_bkpt(ucc_num, set, QE_CMXUCR_GRANT);
+}
+
+static inline int ucc_set_qe_mux_tsa(unsigned int ucc_num, int set)
+{
+	return ucc_mux_set_grant_tsa_bkpt(ucc_num, set, QE_CMXUCR_TSA);
+}
+
+static inline int ucc_set_qe_mux_bkpt(unsigned int ucc_num, int set)
+{
+	return ucc_mux_set_grant_tsa_bkpt(ucc_num, set, QE_CMXUCR_BKPT);
+}
+
+#endif				/* __UCC_H__ */
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_slow.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_slow.c
@@ -0,0 +1,403 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_slow.c
+ *
+ * QE UCC Slow API Set - UCC Slow specific routines implementations.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+#include "ucc_slow.h"
+
+#define uccs_printk(level, format, arg...)  \
+        printk(level format "\n", ## arg)
+
+#define uccs_dbg(format, arg...)            \
+        uccs_printk(KERN_DEBUG , format , ## arg)
+#define uccs_err(format, arg...)            \
+        uccs_printk(KERN_ERR , format , ## arg)
+#define uccs_info(format, arg...)           \
+        uccs_printk(KERN_INFO , format , ## arg)
+#define uccs_warn(format, arg...)           \
+        uccs_printk(KERN_WARNING , format , ## arg)
+
+#ifdef UCCS_VERBOSE_DEBUG
+#define uccs_vdbg uccs_dbg
+#else
+#define uccs_vdbg(fmt, args...) do { } while (0)
+#endif				/* UCCS_VERBOSE_DEBUG */
+
+u32 ucc_slow_get_qe_cr_subblock(int uccs_num)
+{
+	switch (uccs_num) {
+	case (0):
+		return (QE_CR_SUBBLOCK_UCCSLOW1);
+	case (1):
+		return (QE_CR_SUBBLOCK_UCCSLOW2);
+	case (2):
+		return (QE_CR_SUBBLOCK_UCCSLOW3);
+	case (3):
+		return (QE_CR_SUBBLOCK_UCCSLOW4);
+	case (4):
+		return (QE_CR_SUBBLOCK_UCCSLOW5);
+	case (5):
+		return (QE_CR_SUBBLOCK_UCCSLOW6);
+	case (6):
+		return (QE_CR_SUBBLOCK_UCCSLOW7);
+	case (7):
+		return (QE_CR_SUBBLOCK_UCCSLOW8);
+	default:
+		return QE_CR_SUBBLOCK_INVALID;
+	}
+}
+
+void ucc_slow_poll_transmitter_now(ucc_slow_private_t * uccs)
+{
+	out_be16(&uccs->us_regs->utodr, UCC_SLOW_TOD);
+}
+
+void ucc_slow_graceful_stop_tx(ucc_slow_private_t * uccs)
+{
+	ucc_slow_info_t *us_info = uccs->us_info;
+	u32 id;
+
+	id = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);
+	qe_issue_cmd(QE_GRACEFUL_STOP_TX, id, (u8) QE_CR_PROTOCOL_UNSPECIFIED,
+		     0);
+}
+
+void ucc_slow_stop_tx(ucc_slow_private_t * uccs)
+{
+	ucc_slow_info_t *us_info = uccs->us_info;
+	u32 id;
+
+	id = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);
+	qe_issue_cmd(QE_STOP_TX, id, (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+}
+
+void ucc_slow_restart_tx(ucc_slow_private_t * uccs)
+{
+	ucc_slow_info_t *us_info = uccs->us_info;
+	u32 id;
+
+	id = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);
+	qe_issue_cmd(QE_RESTART_TX, id, (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+}
+
+void ucc_slow_enable(ucc_slow_private_t * uccs, comm_dir_e mode)
+{
+	ucc_slow_t *us_regs;
+	u32 gumr_l;
+
+	us_regs = uccs->us_regs;
+
+	/* Enable reception and/or transmission on this UCC. */
+	gumr_l = in_be32(&us_regs->gumr_l);
+	if (mode & COMM_DIR_TX) {
+		gumr_l |= UCC_SLOW_GUMR_L_ENT;
+		uccs->enabled_tx = 1;
+	}
+	if (mode & COMM_DIR_RX) {
+		gumr_l |= UCC_SLOW_GUMR_L_ENR;
+		uccs->enabled_rx = 1;
+	}
+	out_be32(&us_regs->gumr_l, gumr_l);
+}
+
+void ucc_slow_disable(ucc_slow_private_t * uccs, comm_dir_e mode)
+{
+	ucc_slow_t *us_regs;
+	u32 gumr_l;
+
+	us_regs = uccs->us_regs;
+
+	/* Disable reception and/or transmission on this UCC. */
+	gumr_l = in_be32(&us_regs->gumr_l);
+	if (mode & COMM_DIR_TX) {
+		gumr_l &= ~UCC_SLOW_GUMR_L_ENT;
+		uccs->enabled_tx = 0;
+	}
+	if (mode & COMM_DIR_RX) {
+		gumr_l &= ~UCC_SLOW_GUMR_L_ENR;
+		uccs->enabled_rx = 0;
+	}
+	out_be32(&us_regs->gumr_l, gumr_l);
+}
+
+int ucc_slow_init(ucc_slow_info_t * us_info, ucc_slow_private_t ** uccs_ret)
+{
+	u32 i;
+	ucc_slow_t *us_regs;
+	u32 gumr;
+	u8 function_code = 0;
+	u8 *bd;
+	ucc_slow_private_t *uccs;
+	u32 id;
+	u32 command;
+	int ret;
+
+	uccs_vdbg("%s: IN", __FUNCTION__);
+
+	if (!us_info)
+		return -EINVAL;
+
+	/* check if the UCC port number is in range. */
+	if (us_info->ucc_num > UCC_MAX_NUM) {
+		uccs_err("ucc_slow_init: Illegal UCC number!");
+		return -EINVAL;
+	}
+
+	/* Set mrblr */
+	/* Check that 'max_rx_buf_length' is properly aligned (4), unless rfw is 1,  */
+	/* meaning that QE accepts one byte at a time, unlike normal case when QE    */
+	/* accepts 32 bits at a time.                                                */
+	if ((!us_info->rfw)
+	    && (us_info->max_rx_buf_length & (UCC_SLOW_MRBLR_ALIGNMENT - 1))) {
+		uccs_err("max_rx_buf_length not aligned.");
+		return -EINVAL;
+	}
+
+	uccs =
+	    (ucc_slow_private_t *) kmalloc(sizeof(ucc_slow_private_t),
+					   GFP_KERNEL);
+	if (!uccs) {
+		uccs_err
+		    ("ucc_slow_init: No memory for UCC slow data structure!");
+		return -ENOMEM;
+	}
+	memset(uccs, 0, sizeof(ucc_slow_private_t));
+
+	/* Fill slow UCC structure */
+	uccs->us_info = us_info;
+	uccs->saved_uccm = 0;
+	uccs->p_rx_frame = 0;
+	uccs->us_regs = us_info->us_regs;
+	us_regs = uccs->us_regs;
+	uccs->p_ucce = (u16 *) & (us_regs->ucce);
+	uccs->p_uccm = (u16 *) & (us_regs->uccm);
+#ifdef STATISTICS
+	uccs->rx_frames = 0;
+	uccs->tx_frames = 0;
+	uccs->rx_discarded = 0;
+#endif				/* STATISTICS */
+
+	/* Get PRAM base */
+	uccs->us_pram_offset =
+	    qe_muram_alloc(UCC_SLOW_PRAM_SIZE, ALIGNMENT_OF_UCC_SLOW_PRAM);
+	if (IS_MURAM_ERR(uccs->us_pram_offset)) {
+		uccs_err
+		    ("ucc_slow_init: Can not allocate MURAM memory for Slow UCC.");
+		ucc_slow_free(uccs);
+		return -ENOMEM;
+	}
+	id = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);
+	qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, id, QE_CR_PROTOCOL_UNSPECIFIED,
+		     (u32) uccs->us_pram_offset);
+
+	uccs->us_pram = qe_muram_addr(uccs->us_pram_offset);
+
+	/* Init Guemr register */
+	if ((ret = ucc_init_guemr((ucc_common_t *) (us_info->us_regs)))) {
+		uccs_err("ucc_slow_init: Could not init the guemr register.");
+		ucc_slow_free(uccs);
+		return ret;
+	}
+
+	/* Set UCC to slow type */
+	if ((ret = ucc_set_type(us_info->ucc_num,
+				(ucc_common_t *) (us_info->us_regs),
+				UCC_SPEED_TYPE_SLOW))) {
+		uccs_err("ucc_slow_init: Could not init the guemr register.");
+		ucc_slow_free(uccs);
+		return ret;
+	}
+
+	out_be16(&uccs->us_pram->mrblr, us_info->max_rx_buf_length);
+
+	INIT_LIST_HEAD(&uccs->confQ);
+
+	/* Allocate BDs. */
+	uccs->rx_base_offset =
+	    qe_muram_alloc(us_info->rx_bd_ring_len * UCC_SLOW_SIZE_OF_BD,
+			   QE_ALIGNMENT_OF_BD);
+	if (IS_MURAM_ERR(uccs->rx_base_offset)) {
+		uccs_err("ucc_slow_init: No memory for Rx BD's.");
+		uccs->rx_base_offset = 0;
+		ucc_slow_free(uccs);
+		return -ENOMEM;
+	}
+
+	uccs->tx_base_offset =
+	    qe_muram_alloc(us_info->tx_bd_ring_len * UCC_SLOW_SIZE_OF_BD,
+			   QE_ALIGNMENT_OF_BD);
+	if (IS_MURAM_ERR(uccs->tx_base_offset)) {
+		uccs_err("ucc_slow_init: No memory for Tx BD's.");
+		uccs->tx_base_offset = 0;
+		ucc_slow_free(uccs);
+		return -ENOMEM;
+	}
+
+	/* Init Tx bds */
+	bd = uccs->confBd = uccs->tx_bd = qe_muram_addr(uccs->tx_base_offset);
+	for (i = 0; i < us_info->tx_bd_ring_len; i++) {
+		BD_BUFFER_CLEAR(bd);
+		BD_STATUS_AND_LENGTH_SET(bd, 0);
+		bd += QE_SIZEOF_BD;
+	}
+	bd -= QE_SIZEOF_BD;
+	BD_STATUS_AND_LENGTH_SET(bd, T_W);	/* for last BD set Wrap bit */
+
+	/* Init Rx bds */
+	bd = uccs->rx_bd = qe_muram_addr(uccs->rx_base_offset);
+	for (i = 0; i < us_info->rx_bd_ring_len; i++) {
+		BD_STATUS_AND_LENGTH_SET(bd, 0);
+		BD_BUFFER_CLEAR(bd);
+		bd += QE_SIZEOF_BD;
+	}
+	bd -= QE_SIZEOF_BD;
+	BD_STATUS_AND_LENGTH_SET(bd, R_W);	/* for last BD set Wrap bit */
+
+	/* Set GUMR (For more details see the hardware spec.). */
+	/* gumr_h */
+	gumr = 0;
+	gumr |= us_info->tcrc;
+	if (us_info->cdp)
+		gumr |= UCC_SLOW_GUMR_H_CDP;
+	if (us_info->ctsp)
+		gumr |= UCC_SLOW_GUMR_H_CTSP;
+	if (us_info->cds)
+		gumr |= UCC_SLOW_GUMR_H_CDS;
+	if (us_info->ctss)
+		gumr |= UCC_SLOW_GUMR_H_CTSS;
+	if (us_info->tfl)
+		gumr |= UCC_SLOW_GUMR_H_TFL;
+	if (us_info->rfw)
+		gumr |= UCC_SLOW_GUMR_H_RFW;
+	if (us_info->txsy)
+		gumr |= UCC_SLOW_GUMR_H_TXSY;
+	if (us_info->rtsm)
+		gumr |= UCC_SLOW_GUMR_H_RTSM;
+	out_be32(&us_regs->gumr_h, gumr);
+
+	/* gumr_l */
+	gumr = 0;
+	if (us_info->tci)
+		gumr |= UCC_SLOW_GUMR_L_TCI;
+	if (us_info->rinv)
+		gumr |= UCC_SLOW_GUMR_L_RINV;
+	if (us_info->tinv)
+		gumr |= UCC_SLOW_GUMR_L_TINV;
+	if (us_info->tend)
+		gumr |= UCC_SLOW_GUMR_L_TEND;
+	gumr |= us_info->tdcr;
+	gumr |= us_info->rdcr;
+	gumr |= us_info->tenc;
+	gumr |= us_info->renc;
+	gumr |= us_info->diag;
+	gumr |= us_info->mode;
+	out_be32(&us_regs->gumr_l, gumr);
+
+	/* Function code registers */
+	/* function_code has initial value 0 */
+
+	/* if the data is in cachable memory, the 'global' */
+	/* in the function code should be set.             */
+	function_code |= us_info->data_mem_part;
+	function_code |= QE_BMR_BYTE_ORDER_BO_MOT;	/* Required for QE */
+	uccs->us_pram->tfcr = function_code;
+	uccs->us_pram->rfcr = function_code;
+
+	/* rbase, tbase are offsets from MURAM base */
+	out_be16(&uccs->us_pram->rbase, uccs->us_pram_offset);
+	out_be16(&uccs->us_pram->tbase, uccs->us_pram_offset);
+
+	/* Mux clocking */
+	/* Grant Support */
+	ucc_set_qe_mux_grant(us_info->ucc_num, us_info->grant_support);
+	/* Breakpoint Support */
+	ucc_set_qe_mux_bkpt(us_info->ucc_num, us_info->brkpt_support);
+	/* Set Tsa or NMSI mode. */
+	ucc_set_qe_mux_tsa(us_info->ucc_num, us_info->tsa);
+	/* If NMSI (not Tsa), set Tx and Rx clock. */
+	if (!us_info->tsa) {
+		/* Rx clock routing */
+		if (ucc_set_qe_mux_rxtx
+		    (us_info->ucc_num, us_info->rx_clock, COMM_DIR_RX)) {
+			uccs_err
+			    ("ucc_slow_init: Illegal value for parameter 'RxClock'.");
+			ucc_slow_free(uccs);
+			return -EINVAL;
+		}
+		/* Tx clock routing */
+		if (ucc_set_qe_mux_rxtx
+		    (us_info->ucc_num, us_info->tx_clock, COMM_DIR_TX)) {
+			uccs_err
+			    ("ucc_slow_init: Illegal value for parameter 'TxClock'.");
+			ucc_slow_free(uccs);
+			return -EINVAL;
+		}
+	}
+
+	/*
+	 * INTERRUPTS
+	 */
+	/* Set interrupt mask register at UCC level. */
+	out_be16(&us_regs->uccm, us_info->uccm_mask);
+
+	/* First, clear anything pending at UCC level, */
+	/* otherwise, old garbage may come through     */
+	/* as soon as the dam is opened.               */
+
+	/* Writing '1' clears */
+	out_be16(&us_regs->ucce, 0xffff);
+
+	/* Issue QE Init command */
+	if (us_info->init_tx && us_info->init_rx)
+		command = QE_INIT_TX_RX;
+	else if (us_info->init_tx)
+		command = QE_INIT_TX;
+	else
+		command = QE_INIT_RX;	/* We know at least one is TRUE */
+	id = ucc_slow_get_qe_cr_subblock(us_info->ucc_num);
+	qe_issue_cmd(command, id, (u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
+
+	*uccs_ret = uccs;
+	return 0;
+}
+
+void ucc_slow_free(ucc_slow_private_t * uccs)
+{
+	if (!uccs)
+		return;
+
+	if (uccs->rx_base_offset)
+		qe_muram_free(uccs->rx_base_offset);
+
+	if (uccs->tx_base_offset)
+		qe_muram_free(uccs->tx_base_offset);
+
+	if (uccs->us_pram) {
+		qe_muram_free(uccs->us_pram_offset);
+		uccs->us_pram = NULL;
+	}
+
+	kfree(uccs);
+}
Index: linux-2.6.10/arch/ppc/qe_io/ucc/ucc_slow.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/qe_io/ucc/ucc_slow.h
@@ -0,0 +1,275 @@
+/*
+ * arch/ppc/qe_io/ucc/ucc_slow.h
+ *
+ * Internal header file for UCC SLOW unit routines.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __UCC_SLOW_H__
+#define __UCC_SLOW_H__
+
+#include <linux/kernel.h>
+
+#include <asm/immap_qe.h>
+#include <asm/qe.h>
+
+#include "ucc.h"
+
+#define UCC_SLOW_SIZE_OF_BD QE_SIZEOF_BD
+
+/* transmit BD's status.
+*/
+#define T_R     0x80000000	/* ready bit                                       */
+#define T_PAD   0x40000000	/* add pads to short frames                        */
+#define T_W     0x20000000	/* wrap bit                                        */
+#define T_I     0x10000000	/* interrupt on completion                         */
+#define T_L     0x08000000	/* last                                            */
+
+#define T_A     0x04000000	/* Address - the data transmitted as address chars */
+#define T_TC    0x04000000	/* transmit CRC                                    */
+#define T_CM    0x02000000	/* continuous mode                                 */
+#define T_DEF   0x02000000	/* collision on previous attempt to transmit.      */
+#define T_P     0x01000000	/* Preamble - send Preamble sequence before data   */
+#define T_HB    0x01000000	/* heartbeat.                                      */
+#define T_NS    0x00800000	/* No Stop                                         */
+#define T_LC    0x00800000	/* late collision.                                 */
+#define T_RL    0x00400000	/* retransmission limit.                           */
+#define T_UN    0x00020000	/* underrun                                        */
+#define T_CT    0x00010000	/* CTS lost                                        */
+#define T_CSL   0x00010000	/* carrier sense lost.                             */
+#define T_RC    0x003c0000	/* retry count.                                    */
+
+/* Receive BD's status.
+*/
+#define R_E     0x80000000	/* buffer empty                                    */
+#define R_W     0x20000000	/* wrap bit                                        */
+#define R_I     0x10000000	/* interrupt on reception                          */
+#define R_L     0x08000000	/* last                                            */
+#define R_C     0x08000000	/* the last byte in this buffer is a cntl char     */
+#define R_F     0x04000000	/* first                                           */
+#define R_A     0x04000000	/* the first byte in this buffer is address byte   */
+#define R_CM    0x02000000	/* continuous mode                                 */
+#define R_ID    0x01000000	/* buffer close on reception of idles              */
+#define R_M     0x01000000	/* Frame received because of promiscuous mode.     */
+#define R_AM    0x00800000	/* Address match                                   */
+#define R_DE    0x00800000	/* Address match                                   */
+#define R_LG    0x00200000	/* Break received                                  */
+#define R_BR    0x00200000	/* Frame length violation                          */
+#define R_NO    0x00100000	/* Rx Non Octet Aligned Packet                     */
+#define R_FR    0x00100000	/* Framing Error (no stop bit) character received  */
+#define R_PR    0x00080000	/* Parity Error character received                 */
+#define R_AB    0x00080000	/* Frame Aborted                                   */
+#define R_SH    0x00080000	/* frame is too short.                             */
+#define R_CR    0x00040000	/* CRC Error                                       */
+#define R_OV    0x00020000	/* Overrun                                         */
+#define R_CD    0x00010000	/* CD lost                                         */
+#define R_CL    0x00010000	/* this frame is closed because of a collision     */
+
+/* Rx Data buffer must be 4 bytes aligned in most cases.*/
+#define UCC_SLOW_RX_ALIGN             4
+#define UCC_SLOW_MRBLR_ALIGNMENT      4
+
+/*
+*/
+#define UCC_SLOW_PRAM_SIZE            0x100
+#define ALIGNMENT_OF_UCC_SLOW_PRAM    64
+
+/* UCC Slow Channel Protocol Mode
+*/
+typedef enum ucc_slow_channel_protocol_mode {
+	UCC_SLOW_CHANNEL_PROTOCOL_MODE_QMC = 0x00000002,	/* QMC    */
+	UCC_SLOW_CHANNEL_PROTOCOL_MODE_UART = 0x00000004,	/* UART   */
+	UCC_SLOW_CHANNEL_PROTOCOL_MODE_BISYNC = 0x00000008	/* BISYNC */
+} ucc_slow_channel_protocol_mode_e;
+
+/* UCC Slow Transparent Transmit CRC (TCRC)
+*/
+typedef enum ucc_slow_transparent_tcrc {
+	UCC_SLOW_TRANSPARENT_TCRC_CCITT_CRC16 = 0x00000000,	/* 16-bit CCITT CRC (HDLC). (X16 + X12 + X5 + 1) */
+	UCC_SLOW_TRANSPARENT_TCRC_CRC16 = 0x00004000,	/* CRC16 (BISYNC). (X16 + X15 + X2 + 1) */
+	UCC_SLOW_TRANSPARENT_TCRC_CCITT_CRC32 = 0x00008000	/* 32-bit CCITT CRC (Ethernet and HDLC). */
+} ucc_slow_transparent_tcrc_e;
+
+/* UCC Slow oversampling rate for transmitter (TDCR)
+*/
+typedef enum ucc_slow_tx_oversampling_rate {
+	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_1 = 0x00000000,	/* 1x  clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_8 = 0x00010000,	/* 8x  clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_16 = 0x00020000,	/* 16x clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_TX_TDCR_32 = 0x00030000	/* 32x clock mode */
+} ucc_slow_tx_oversampling_rate_e;
+
+/* UCC Slow Oversampling rate for receiver (RDCR)
+*/
+typedef enum ucc_slow_rx_oversampling_rate {
+	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_1 = 0x00000000,	/* 1x  clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_8 = 0x00004000,	/* 8x  clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_16 = 0x00008000,	/* 16x clock mode */
+	UCC_SLOW_OVERSAMPLING_RATE_RX_RDCR_32 = 0x0000c000	/* 32x clock mode */
+} ucc_slow_rx_oversampling_rate_e;
+
+/* UCC Slow Transmitter encoding method (TENC)
+*/
+typedef enum ucc_slow_tx_encoding_method {
+	UCC_SLOW_TRANSMITTER_ENCODING_METHOD_TENC_NRZ = 0x00000000,	/* nrz  */
+	UCC_SLOW_TRANSMITTER_ENCODING_METHOD_TENC_NRZI = 0x00000100	/* nrzi */
+} ucc_slow_tx_encoding_method_e;
+
+/* UCC Slow Receiver decoding method (RENC)
+*/
+typedef enum ucc_slow_rx_decoding_method {
+	UCC_SLOW_RECEIVER_DECODING_METHOD_RENC_NRZ = 0x00000000,	/* nrz  */
+	UCC_SLOW_RECEIVER_DECODING_METHOD_RENC_NRZI = 0x00000800	/* nrzi */
+} ucc_slow_rx_decoding_method_e;
+
+/* UCC Slow Diagnostic mode (DIAG)
+*/
+typedef enum ucc_slow_diag_mode {
+	UCC_SLOW_DIAG_MODE_NORMAL = 0x00000000,	/* normal             */
+	UCC_SLOW_DIAG_MODE_LOOPBACK = 0x00000040,	/* loop back          */
+	UCC_SLOW_DIAG_MODE_ECHO = 0x00000080,	/* echo               */
+	UCC_SLOW_DIAG_MODE_LOOPBACK_ECHO = 0x000000c0	/* loop back and echo */
+} ucc_slow_diag_mode_e;
+
+typedef struct ucc_slow_info {
+	uint ucc_num;
+	qe_clock_e rx_clock;
+	qe_clock_e tx_clock;
+	ucc_slow_t *us_regs;
+	int irq;
+	u16 uccm_mask;
+	int data_mem_part;
+	int init_tx;
+	int init_rx;
+	u32 tx_bd_ring_len;
+	u32 rx_bd_ring_len;
+	int rx_interrupts;
+	int brkpt_support;
+	int grant_support;
+	int tsa;
+	int cdp;
+	int cds;
+	int ctsp;
+	int ctss;
+	int rinv;
+	int tinv;
+	int rtsm;
+	int rfw;
+	int tci;
+	int tend;
+	int tfl;
+	int txsy;
+	u16 max_rx_buf_length;
+	ucc_slow_transparent_tcrc_e tcrc;
+	ucc_slow_channel_protocol_mode_e mode;
+	ucc_slow_diag_mode_e diag;
+	ucc_slow_tx_oversampling_rate_e tdcr;
+	ucc_slow_rx_oversampling_rate_e rdcr;
+	ucc_slow_tx_encoding_method_e tenc;
+	ucc_slow_rx_decoding_method_e renc;
+} ucc_slow_info_t;
+
+typedef struct ucc_slow_private {
+	ucc_slow_info_t *us_info;
+	ucc_slow_t *us_regs;	/* a pointer to memory map of UCC regs.                                                */
+	ucc_slow_pram_t *us_pram;	/* a pointer to the parameter RAM.                                                     */
+	uint us_pram_offset;
+	int enabled_tx;		/* Whether channel is enabled for Tx (ENT)                                             */
+	int enabled_rx;		/* Whether channel is enabled for Rx (ENR)                                             */
+	int stopped_tx;		/* Whether channel has been stopped for Tx (STOP_TX, etc.)                             */
+	int stopped_rx;		/* Whether channel has been stopped for Rx                                             */
+	struct list_head confQ;	/* frames passed to chip waiting for tx                                                */
+	u32 first_tx_bd_mask;	/* mask is used in Tx routine to save status and length for first BD in a frame.       */
+	uint tx_base_offset;	/* first BD in Tx BD table offset (In MURAM)                                           */
+	uint rx_base_offset;	/* first BD in Rx BD table offset (In MURAM)                                           */
+	u8 *confBd;		/* next BD for confirm after Tx                                                        */
+	u8 *tx_bd;		/* next BD for new Tx request                                                          */
+	u8 *rx_bd;		/* next BD to collect after  Rx                                                        */
+	void *p_rx_frame;	/* accumulating receive frame                                                          */
+	u16 *p_ucce;		/* a pointer to the event register in memory.                                          */
+	u16 *p_uccm;		/* a pointer to the mask register in memory.                                           */
+	u16 saved_uccm;		/* a saved mask for the RX Interrupt bits.                                             */
+#ifdef STATISTICS
+	u32 tx_frames;		/* Transmitted frames counters.                                                        */
+	u32 rx_frames;		/* Received frames counters (only frames passed to application).                       */
+	u32 rx_discarded;	/* Discarded frames counters (frames that were discarded by the driver due to errors). */
+#endif				/* STATISTICS */
+} ucc_slow_private_t;
+
+/* ucc_slow_init
+ * Initializes Slow UCC according to provided parameters.
+ *
+ * @Param         us_info  - (In) pointer to the slow UCC info structure.
+ * @Param         uccs_ret - (Out) pointer to the slow UCC structure.
+ */
+int ucc_slow_init(ucc_slow_info_t * us_info, ucc_slow_private_t ** uccs_ret);
+
+/* ucc_slow_free
+ * Frees all resources for slow UCC.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ */
+void ucc_slow_free(ucc_slow_private_t * uccs);
+
+/* ucc_slow_enable
+ * Enables a fast UCC port.
+ * This routine enables Tx and/or Rx through the General UCC Mode Register.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ * @Param         mode - (In) TX, RX, or both.
+ */
+void ucc_slow_enable(ucc_slow_private_t * uccs, comm_dir_e mode);
+
+/* ucc_slow_disable
+ * Disables a fast UCC port.
+ * This routine disables Tx and/or Rx through the General UCC Mode Register.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ * @Param         mode - (In) TX, RX, or both.
+ */
+void ucc_slow_disable(ucc_slow_private_t * uccs, comm_dir_e mode);
+
+/* ucc_slow_poll_transmitter_now
+ * Immediately forces a poll of the transmitter for data to be sent.
+ * Typically, the hardware performs a periodic poll for data that the
+ * transmit routine has set up to be transmitted. In cases where
+ * this polling cycle is not soon enough, this optional routine can
+ * be invoked to force a poll right away, instead. Proper use for
+ * each transmission for which this functionality is desired is to
+ * call the transmit routine and then this routine right after.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ */
+void ucc_slow_poll_transmitter_now(ucc_slow_private_t * uccs);
+
+/* ucc_slow_graceful_stop_tx
+ * Smoothly stops transmission on a specified slow UCC.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ */
+void ucc_slow_graceful_stop_tx(ucc_slow_private_t * uccs);
+
+/* ucc_slow_stop_tx
+ * Stops transmission on a specified slow UCC.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ */
+void ucc_slow_stop_tx(ucc_slow_private_t * uccs);
+
+/* ucc_slow_restart_x
+ * Restarts transmitting on a specified slow UCC.
+ *
+ * @Param         uccs - (In) pointer to the slow UCC structure.
+ */
+void ucc_slow_restart_x(ucc_slow_private_t * uccs);
+
+u32 ucc_slow_get_qe_cr_subblock(int uccs_num);
+
+#endif				/* __UCC_SLOW_H__ */
Index: linux-2.6.10/arch/ppc/syslib/ipic.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ipic.c
+++ linux-2.6.10/arch/ppc/syslib/ipic.c
@@ -492,6 +492,18 @@ void __init ipic_init(phys_addr_t phys_a
 			senses_count, primary_ipic->regs);
 }
 
+void ipic_force_irq(unsigned int irq)
+{
+	struct ipic *ipic = ipic_from_irq(irq);
+	unsigned int src = irq - ipic->irq_offset;
+	u32 temp;
+
+	temp = ipic_read(ipic->regs, ipic_info[src].force);
+	temp |= (1 << (31 - ipic_info[src].bit));
+	ipic_write(ipic->regs, ipic_info[src].force, temp);
+}
+
+
 int ipic_set_priority(unsigned int irq, unsigned int priority)
 {
 	struct ipic *ipic = ipic_from_irq(irq);
Index: linux-2.6.10/arch/ppc/syslib/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/Makefile
+++ linux-2.6.10/arch/ppc/syslib/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_83xx)		+= ipic.o ppc83xx_se
 ifeq ($(CONFIG_83xx),y)
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o
 endif
+obj-$(CONFIG_QE)		+= qe_ic.o
 obj-$(CONFIG_MPC8548_CDS)	+= todc_time.o
 obj-$(CONFIG_MPC8555_CDS)	+= todc_time.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc52xx_setup.o mpc52xx_pic.o
Index: linux-2.6.10/arch/ppc/syslib/qe_ic.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/qe_ic.c
@@ -0,0 +1,475 @@
+/*
+ * arch/ppc/syslib/qe_ic.c
+ *
+ * QE IC routines implementations.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/qe_ic.h>
+
+#include "qe_ic.h"
+
+static struct qe_ic_private p_qe_ic;
+static struct qe_ic_private *primary_qe_ic;
+
+static struct qe_ic_info qe_ic_info[] = {
+	[1] = {
+	       .mask = 0x00008000,
+	       .qimr = 1,
+	       .pri_code = 0},
+	[2] = {
+	       .mask = 0x00004000,
+	       .qimr = 1,
+	       .pri_code = 1},
+	[3] = {
+	       .mask = 0x00002000,
+	       .qimr = 1,
+	       .pri_code = 2},
+	[10] = {
+		.mask = 0x00000040,
+		.qimr = 1,
+		.pri_code = 1},
+	[11] = {
+		.mask = 0x00000020,
+		.qimr = 1,
+		.pri_code = 2},
+	[12] = {
+		.mask = 0x00000010,
+		.qimr = 1,
+		.pri_code = 3},
+	[13] = {
+		.mask = 0x00000008,
+		.qimr = 1,
+		.pri_code = 4},
+	[14] = {
+		.mask = 0x00000004,
+		.qimr = 1,
+		.pri_code = 5},
+	[15] = {
+		.mask = 0x00000002,
+		.qimr = 1,
+		.pri_code = 6},
+	[20] = {
+		.mask = 0x10000000,
+		.qimr = 0,
+		.pri_code = 3},
+	[25] = {
+		.mask = 0x00800000,
+		.qimr = 0,
+		.pri_code = 0},
+	[26] = {
+		.mask = 0x00400000,
+		.qimr = 0,
+		.pri_code = 1},
+	[27] = {
+		.mask = 0x00200000,
+		.qimr = 0,
+		.pri_code = 2},
+	[28] = {
+		.mask = 0x00100000,
+		.qimr = 0,
+		.pri_code = 3},
+	[32] = {
+		.mask = 0x80000000,
+		.qimr = 1,
+		.pri_code = 0},
+	[33] = {
+		.mask = 0x40000000,
+		.qimr = 1,
+		.pri_code = 1},
+	[34] = {
+		.mask = 0x20000000,
+		.qimr = 1,
+		.pri_code = 2},
+	[35] = {
+		.mask = 0x10000000,
+		.qimr = 1,
+		.pri_code = 3},
+	[36] = {
+		.mask = 0x08000000,
+		.qimr = 1,
+		.pri_code = 4},
+	[40] = {
+		.mask = 0x00800000,
+		.qimr = 1,
+		.pri_code = 0},
+	[41] = {
+		.mask = 0x00400000,
+		.qimr = 1,
+		.pri_code = 1},
+	[42] = {
+		.mask = 0x00200000,
+		.qimr = 1,
+		.pri_code = 2},
+	[43] = {
+		.mask = 0x00100000,
+		.qimr = 1,
+		.pri_code = 3},
+};
+
+struct hw_interrupt_type qe_ic = {
+	.typename = " QE IC  ",
+	.enable = qe_ic_enable_irq,
+	.disable = qe_ic_disable_irq,
+	.ack = qe_ic_disable_irq_and_ack,
+	.end = qe_ic_end_irq,
+};
+
+static int qe_ic_get_low_irq(struct pt_regs *regs)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	int irq = -1;
+
+	/* get the low byte of SIVEC to get the interrupt source vector. */
+	irq = (in_be32(&p_qe_ic->regs->qivec) >> 24) >> 2;
+
+	if (irq == 0)		/* 0 --> no irq is pending */
+		return -1;
+
+	return irq + p_qe_ic->irq_offset;
+}
+
+static int qe_ic_get_high_irq(struct pt_regs *regs)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	int irq = -1;
+
+	/* get the high byte of SIVEC to get the interrupt source vector. */
+	irq = (in_be32(&p_qe_ic->regs->qhivec) >> 24) >> 2;
+
+	if (irq == 0)		/* 0 --> no irq is pending */
+		return -1;
+
+	return irq + p_qe_ic->irq_offset;
+}
+
+static irqreturn_t qe_ic_cascade_low(int irq, void *dev_id,
+				     struct pt_regs *regs)
+{
+	while ((irq = qe_ic_get_low_irq(regs)) >= 0)
+		__do_IRQ(irq, regs);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t qe_ic_cascade_high(int irq, void *dev_id,
+				      struct pt_regs *regs)
+{
+	while ((irq = qe_ic_get_high_irq(regs)) >= 0)
+		__do_IRQ(irq, regs);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction qe_ic_low_irqaction = {
+	.handler = qe_ic_cascade_low,
+	.flags = SA_INTERRUPT,
+	.mask = CPU_MASK_NONE,
+	.name = "qe_ic_cascade_low",
+};
+
+static struct irqaction qe_ic_high_irqaction = {
+	.handler = qe_ic_cascade_high,
+	.flags = SA_INTERRUPT,
+	.mask = CPU_MASK_NONE,
+	.name = "qe_ic_cascade_high",
+};
+
+int qe_ic_init(phys_addr_t phys_addr,
+	       unsigned int flags, unsigned int irq_offset)
+{
+	struct qe_ic_map *regs;
+	u8 grp, pri, shift = 0;
+	u32 tmp_qicr = 0, tmp_qricr = 0, tmp_qicnr = 0, tmp_mask;
+	int i, high_hctive = 0;
+	const u32 high_signal = 2;
+
+	primary_qe_ic = &p_qe_ic;
+	memset(primary_qe_ic, 0, sizeof(struct qe_ic_private));
+
+	/* initialize QE interrupt controller registers */
+	primary_qe_ic->regs = regs =
+	    (struct qe_ic_map *)ioremap(phys_addr, QE_IC_SIZE);
+	primary_qe_ic->irq_offset = irq_offset;
+
+	/* default priority scheme is grouped. If spread mode is    */
+	/* required, configure sicr accordingly.                    */
+	if (flags & QE_IC_SPREADMODE_GRP_W)
+		tmp_qicr |= QICR_GWCC;
+	if (flags & QE_IC_SPREADMODE_GRP_X)
+		tmp_qicr |= QICR_GXCC;
+	if (flags & QE_IC_SPREADMODE_GRP_Y)
+		tmp_qicr |= QICR_GYCC;
+	if (flags & QE_IC_SPREADMODE_GRP_Z)
+		tmp_qicr |= QICR_GZCC;
+	if (flags & QE_IC_SPREADMODE_GRP_RISCA)
+		tmp_qicr |= QICR_GRTA;
+	if (flags & QE_IC_SPREADMODE_GRP_RISCB)
+		tmp_qicr |= QICR_GRTB;
+
+	/* choose destination signal for highest priority interrupt */
+	if (flags & QE_IC_HIGH_SIGNAL) {
+		tmp_qicr |= (high_signal << QICR_HPIT_SHIFT);
+		high_hctive = 1;
+	}
+
+	out_be32(&regs->qicr, tmp_qicr);
+
+	tmp_mask = (1 << QE_IC_GRP_W_DEST_SIGNAL_SHIFT);
+	/* choose destination signal for highest priority interrupt in each group */
+	for (grp = 0; grp < NUM_OF_QE_IC_GROUPS; grp++) {
+		/* the first 2 priorities in each group have a choice of destination signal */
+		for (pri = 0; pri <= 1; pri++) {
+			if (flags & ((tmp_mask << (grp << 1)) << pri)) {
+				/* indicate whether QE High signal is required */
+				if (!high_hctive)
+					high_hctive = 1;
+
+				/* The location of the bits relevant to priority 0 in the   */
+				/* registers is always 2 bits left comparing to priority 1. */
+				if (pri == 0)
+					shift = 2;
+
+				switch (grp) {
+				case (QE_IC_GRP_W):
+					shift += QICNR_WCC1T_SHIFT;
+					tmp_qicnr |= high_signal << shift;
+					break;
+				case (QE_IC_GRP_X):
+					shift += QICNR_XCC1T_SHIFT;
+					tmp_qicnr |= high_signal << shift;
+					break;
+				case (QE_IC_GRP_Y):
+					shift += QICNR_YCC1T_SHIFT;
+					tmp_qicnr |= high_signal << shift;
+					break;
+				case (QE_IC_GRP_Z):
+					shift += QICNR_ZCC1T_SHIFT;
+					tmp_qicnr |= high_signal << shift;
+					break;
+				case (QE_IC_GRP_RISCA):
+					shift += QRICR_RTA1T_SHIFT;
+					tmp_qricr |= high_signal << shift;
+					break;
+				case (QE_IC_GRP_RISCB):
+					shift += QRICR_RTB1T_SHIFT;
+					tmp_qricr |= high_signal << shift;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	if (tmp_qicnr)
+		out_be32(&regs->qicnr, tmp_qicnr);
+	if (tmp_qricr)
+		out_be32(&regs->qricr, tmp_qricr);
+
+	for (i = primary_qe_ic->irq_offset;
+	     i < (NR_QE_IC_INTS + primary_qe_ic->irq_offset); i++) {
+		irq_desc[i].handler = &qe_ic;
+		irq_desc[i].status = IRQ_LEVEL;
+	}
+
+	/* register QE_IC interrupt controller in the a higher hirarchy controller */
+	setup_irq(IRQ_QE_LOW, &qe_ic_low_irqaction);
+
+	if (high_hctive)
+		/* register QE_IC high interrupt source in the higher hirarchy controller */
+		setup_irq(IRQ_QE_HIGH, &qe_ic_high_irqaction);
+
+	printk("QE IC (%d IRQ sources) at %p\n", NR_QE_IC_INTS,
+	       primary_qe_ic->regs);
+	return 0;
+}
+
+void qe_ic_free(void)
+{
+}
+
+void qe_ic_enable_irq(unsigned int irq)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	unsigned int src = irq - p_qe_ic->irq_offset;
+	u32 qimr;
+
+	if (qe_ic_info[src].qimr) {
+		qimr = in_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qimr);
+		out_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qimr,
+			 qimr | (qe_ic_info[src].mask));
+	} else {
+		qimr = in_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qrimr);
+		out_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qrimr,
+			 qimr | (qe_ic_info[src].mask));
+	}
+}
+
+void qe_ic_disable_irq(unsigned int irq)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	unsigned int src = irq - p_qe_ic->irq_offset;
+	u32 qimr;
+
+	if (qe_ic_info[src].qimr) {
+		qimr = in_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qimr);
+		out_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qimr,
+			 qimr & ~(qe_ic_info[src].mask));
+	} else {
+		qimr = in_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qrimr);
+		out_be32(&((struct qe_ic_private *)p_qe_ic)->regs->qrimr,
+			 qimr & ~(qe_ic_info[src].mask));
+	}
+}
+
+void qe_ic_disable_irq_and_ack(unsigned int irq)
+{
+	qe_ic_disable_irq(irq);
+}
+
+void qe_ic_end_irq(unsigned int irq)
+{
+
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))
+	    && irq_desc[irq].action)
+		qe_ic_enable_irq(irq);
+}
+
+void qe_ic_modify_highest_priority(unsigned int irq)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	unsigned int src = irq - p_qe_ic->irq_offset;
+	u32 tmp_qicr = 0;
+
+	tmp_qicr = in_be32(&p_qe_ic->regs->qicr);
+	out_be32(&p_qe_ic->regs->qicr, (u32) (tmp_qicr | ((u8) src << 24)));
+}
+
+void qe_ic_modify_priority(enum qe_ic_grp_id grp,
+			   unsigned int pri0,
+			   unsigned int pri1,
+			   unsigned int pri2,
+			   unsigned int pri3,
+			   unsigned int pri4,
+			   unsigned int pri5,
+			   unsigned int pri6, unsigned int pri7)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+	volatile u32 *p_qip = 0;
+	u32 tmp_qip = 0;
+	u8 tmp_array[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+	signed char code_array[8], i = 0, j = 0;
+
+	code_array[0] = (signed char)(pri0 ? qe_ic_info[pri0].pri_code : -1);
+	code_array[1] = (signed char)(pri1 ? qe_ic_info[pri1].pri_code : -1);
+	code_array[2] = (signed char)(pri2 ? qe_ic_info[pri2].pri_code : -1);
+	code_array[3] = (signed char)(pri3 ? qe_ic_info[pri3].pri_code : -1);
+	code_array[4] = (signed char)(pri4 ? qe_ic_info[pri4].pri_code : -1);
+	code_array[5] = (signed char)(pri5 ? qe_ic_info[pri5].pri_code : -1);
+	code_array[6] = (signed char)(pri6 ? qe_ic_info[pri6].pri_code : -1);
+	code_array[7] = (signed char)(pri7 ? qe_ic_info[pri7].pri_code : -1);
+
+	for (i = 0; i < 8; i++) {
+		if (code_array[i] == -1)
+			break;
+		tmp_array[code_array[i]] = 1;
+	}
+
+	for (; i < 8; i++) {
+		while (tmp_array[j] && j < 8)
+			j++;
+		code_array[i] = j;
+		tmp_array[j] = 1;
+	}
+
+	tmp_qip = (u32) (code_array[0] << QIPCC_SHIFT_PRI0 |
+			 code_array[1] << QIPCC_SHIFT_PRI1 |
+			 code_array[2] << QIPCC_SHIFT_PRI2 |
+			 code_array[3] << QIPCC_SHIFT_PRI3 |
+			 code_array[4] << QIPCC_SHIFT_PRI4 |
+			 code_array[5] << QIPCC_SHIFT_PRI5 |
+			 code_array[6] << QIPCC_SHIFT_PRI6 |
+			 code_array[7] << QIPCC_SHIFT_PRI7);
+
+	switch (grp) {
+	case (QE_IC_GRP_W):
+		p_qip = &(p_qe_ic->regs->qipwcc);
+		break;
+	case (QE_IC_GRP_X):
+		p_qip = &(p_qe_ic->regs->qipxcc);
+		break;
+	case (QE_IC_GRP_Y):
+		p_qip = &(p_qe_ic->regs->qipycc);
+		break;
+	case (QE_IC_GRP_Z):
+		p_qip = &(p_qe_ic->regs->qipzcc);
+		break;
+	case (QE_IC_GRP_RISCA):
+		p_qip = &(p_qe_ic->regs->qiprta);
+		break;
+	case (QE_IC_GRP_RISCB):
+		p_qip = &(p_qe_ic->regs->qiprtb);
+		break;
+	default:
+		break;
+	}
+
+	out_be32(p_qip, tmp_qip);
+}
+
+void qe_ic_dump_regs(void)
+{
+	struct qe_ic_private *p_qe_ic = primary_qe_ic;
+
+	printk(KERN_INFO "QE IC registars:\n");
+	printk(KERN_INFO "Base address: 0x%08x\n", (u32) p_qe_ic->regs);
+	printk(KERN_INFO "qicr  : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qicr, in_be32(&p_qe_ic->regs->qicr));
+	printk(KERN_INFO "qivec : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qivec, in_be32(&p_qe_ic->regs->qivec));
+	printk(KERN_INFO "qripnr: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qripnr, in_be32(&p_qe_ic->regs->qripnr));
+	printk(KERN_INFO "qipnr : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qipnr, in_be32(&p_qe_ic->regs->qipnr));
+	printk(KERN_INFO "qipxcc: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qipxcc, in_be32(&p_qe_ic->regs->qipxcc));
+	printk(KERN_INFO "qipycc: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qipycc, in_be32(&p_qe_ic->regs->qipycc));
+	printk(KERN_INFO "qipwcc: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qipwcc, in_be32(&p_qe_ic->regs->qipwcc));
+	printk(KERN_INFO "qipzcc: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qipzcc, in_be32(&p_qe_ic->regs->qipzcc));
+	printk(KERN_INFO "qimr  : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qimr, in_be32(&p_qe_ic->regs->qimr));
+	printk(KERN_INFO "qrimr : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qrimr, in_be32(&p_qe_ic->regs->qrimr));
+	printk(KERN_INFO "qicnr : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qicnr, in_be32(&p_qe_ic->regs->qicnr));
+	printk(KERN_INFO "qiprta: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qiprta, in_be32(&p_qe_ic->regs->qiprta));
+	printk(KERN_INFO "qiprtb: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qiprtb, in_be32(&p_qe_ic->regs->qiprtb));
+	printk(KERN_INFO "qricr : addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qricr, in_be32(&p_qe_ic->regs->qricr));
+	printk(KERN_INFO "qhivec: addr - 0x%08x, val - 0x%08x\n",
+	       (u32) & p_qe_ic->regs->qhivec, in_be32(&p_qe_ic->regs->qhivec));
+}
Index: linux-2.6.10/arch/ppc/syslib/qe_ic.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/qe_ic.h
@@ -0,0 +1,79 @@
+/*
+ * arch/ppc/syslib/qe_ic.h
+ *
+ * QE IC private definitions and structure.
+ *
+ * Author: Shlomi Gridish <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __QE_IC_H__
+#define __QE_IC_H__
+
+typedef struct qe_ic_map {
+	volatile u32 qicr;
+	volatile u32 qivec;
+	volatile u32 qripnr;
+	volatile u32 qipnr;
+	volatile u32 qipxcc;
+	volatile u32 qipycc;
+	volatile u32 qipwcc;
+	volatile u32 qipzcc;
+	volatile u32 qimr;
+	volatile u32 qrimr;
+	volatile u32 qicnr;
+	volatile u8 res0[0x4];
+	volatile u32 qiprta;
+	volatile u32 qiprtb;
+	volatile u8 res1[0x4];
+	volatile u32 qricr;
+	volatile u8 res2[0x20];
+	volatile u32 qhivec;
+	volatile u8 res3[0x1C];
+} __attribute__ ((packed)) qe_ic_map_t;
+
+#define QE_IC_SIZE sizeof(struct qe_ic_map)
+
+/* Interrupt priority registers */
+#define QIPCC_SHIFT_PRI0        29
+#define QIPCC_SHIFT_PRI1        26
+#define QIPCC_SHIFT_PRI2        23
+#define QIPCC_SHIFT_PRI3        20
+#define QIPCC_SHIFT_PRI4        13
+#define QIPCC_SHIFT_PRI5        10
+#define QIPCC_SHIFT_PRI6        7
+#define QIPCC_SHIFT_PRI7        4
+
+/* QICR priority modes */
+#define QICR_GWCC               0x00040000
+#define QICR_GXCC               0x00020000
+#define QICR_GYCC               0x00010000
+#define QICR_GZCC               0x00080000
+#define QICR_GRTA               0x00200000
+#define QICR_GRTB               0x00400000
+#define QICR_HPIT_SHIFT         8
+
+/* QICNR */
+#define QICNR_WCC1T_SHIFT       20
+#define QICNR_ZCC1T_SHIFT       28
+#define QICNR_YCC1T_SHIFT       12
+#define QICNR_XCC1T_SHIFT       4
+
+/* QRICR */
+#define QRICR_RTA1T_SHIFT       20
+#define QRICR_RTB1T_SHIFT       28
+
+struct qe_ic_private {
+	struct qe_ic_map *regs;
+	unsigned int irq_offset;
+} qe_ic_private_t;
+
+extern struct hw_interrupt_type qe_ic;
+extern int qe_ic_get_irq(struct pt_regs *regs);
+
+#endif				/* __QE_IC_H__ */
Index: linux-2.6.10/include/asm-ppc/immap_qe.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-ppc/immap_qe.h
@@ -0,0 +1,480 @@
+/*
+ * include/asm-ppc/immap_qe.h
+ *
+ * QUICC Engine (QE) Internal Memory Map.
+ * The Internal Memory Map for devices with QE on them. This
+ * is the superset of all QE devices (8360, etc.).
+ *
+ * Author: Shlomi Gridih <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifdef __KERNEL__
+#ifndef __IMMAP_QE_H__
+#define __IMMAP_QE_H__
+
+#include <linux/kernel.h>
+
+/* QE I-RAM
+*/
+typedef struct qe_iram {
+	u32 iadd;		/* I-RAM Address Register */
+	u32 idata;		/* I-RAM Data Register    */
+	u8 res0[0x78];
+} __attribute__ ((packed)) qe_iram_t;
+
+/* QE Interrupt Controller
+*/
+typedef struct qe_ic {
+	u32 qicr;
+	u32 qivec;
+	u32 qripnr;
+	u32 qipnr;
+	u32 qipxcc;
+	u32 qipycc;
+	u32 qipwcc;
+	u32 qipzcc;
+	u32 qimr;
+	u32 qrimr;
+	u32 qicnr;
+	u8 res0[0x4];
+	u32 qiprta;
+	u32 qiprtb;
+	u8 res1[0x4];
+	u32 qricr;
+	u8 res2[0x20];
+	u32 qhivec;
+	u8 res3[0x1C];
+} __attribute__ ((packed)) qe_ic_t;
+
+/* Communications Processor
+*/
+typedef struct cp_qe {
+	u32 cecr;		/* QE command register */
+	u32 ceccr;		/* QE controller configuration register */
+	u32 cecdr;		/* QE command data register */
+	u8 res0[0xA];
+	u16 ceter;		/* QE timer event register */
+	u8 res1[0x2];
+	u16 cetmr;		/* QE timers mask register */
+	u32 cetscr;		/* QE time-stamp timer control register */
+	u32 cetsr1;		/* QE time-stamp register 1 */
+	u32 cetsr2;		/* QE time-stamp register 2 */
+	u8 res2[0x8];
+	u32 cevter;		/* QE virtual tasks event register */
+	u32 cevtmr;		/* QE virtual tasks mask register */
+	u16 cercr;		/* QE RAM control register */
+	u8 res3[0x2];
+	u8 res4[0x24];
+	u16 ceexe1;		/* QE external request 1 event register */
+	u8 res5[0x2];
+	u16 ceexm1;		/* QE external request 1 mask register */
+	u8 res6[0x2];
+	u16 ceexe2;		/* QE external request 2 event register */
+	u8 res7[0x2];
+	u16 ceexm2;		/* QE external request 2 mask register */
+	u8 res8[0x2];
+	u16 ceexe3;		/* QE external request 3 event register */
+	u8 res9[0x2];
+	u16 ceexm3;		/* QE external request 3 mask register */
+	u8 res10[0x2];
+	u16 ceexe4;		/* QE external request 4 event register */
+	u8 res11[0x2];
+	u16 ceexm4;		/* QE external request 4 mask register */
+	u8 res12[0x2];
+	u8 res13[0x280];
+} __attribute__ ((packed)) cp_qe_t;
+
+#define UCC_COUNT	8
+#define UCC_MAX_NUM	(UCC_COUNT-1)
+
+/* QE Multiplexer
+*/
+typedef struct qe_mux {
+	u32 cmxgcr;		/* CMX general clock route register    */
+	u32 cmxsi1cr_l;		/* CMX SI1 clock route low register    */
+	u32 cmxsi1cr_h;		/* CMX SI1 clock route high register   */
+	u32 cmxsi1syr;		/* CMX SI1 SYNC route register         */
+	u32 cmxucrx[UCC_COUNT / 2];	/* CMX UCC clock route registers       */
+	u32 cmxupcr;		/* CMX UPC clock route register        */
+	u8 res0[0x1C];
+} __attribute__ ((packed)) qe_mux_t;
+
+/* QE Timers
+*/
+typedef struct qe_timers {
+	u8 gtcfr1;		/* Timer 1 and Timer 2 global configuration register */
+	u8 res0[0x3];
+	u8 gtcfr2;		/* Timer 3 and timer 4 global configuration register */
+	u8 res1[0xB];
+	u16 gtmdr1;		/* Timer 1 mode register */
+	u16 gtmdr2;		/* Timer 2 mode register */
+	u16 gtrfr1;		/* Timer 1 reference register */
+	u16 gtrfr2;		/* Timer 2 reference register */
+	u16 gtcpr1;		/* Timer 1 capture register */
+	u16 gtcpr2;		/* Timer 2 capture register */
+	u16 gtcnr1;		/* Timer 1 counter */
+	u16 gtcnr2;		/* Timer 2 counter */
+	u16 gtmdr3;		/* Timer 3 mode register */
+	u16 gtmdr4;		/* Timer 4 mode register */
+	u16 gtrfr3;		/* Timer 3 reference register */
+	u16 gtrfr4;		/* Timer 4 reference register */
+	u16 gtcpr3;		/* Timer 3 capture register */
+	u16 gtcpr4;		/* Timer 4 capture register */
+	u16 gtcnr3;		/* Timer 3 counter */
+	u16 gtcnr4;		/* Timer 4 counter */
+	u16 gtevr1;		/* Timer 1 event register */
+	u16 gtevr2;		/* Timer 2 event register */
+	u16 gtevr3;		/* Timer 3 event register */
+	u16 gtevr4;		/* Timer 4 event register */
+	u16 gtps;		/* Timer 1 prescale register */
+	u8 res2[0x46];
+} __attribute__ ((packed)) qe_timers_t;
+
+/* BRG
+*/
+typedef struct qe_brg {
+	u32 brgc1;		/* BRG1 configuration register  */
+	u32 brgc2;		/* BRG2 configuration register  */
+	u32 brgc3;		/* BRG3 configuration register  */
+	u32 brgc4;		/* BRG4 configuration register  */
+	u32 brgc5;		/* BRG5 configuration register  */
+	u32 brgc6;		/* BRG6 configuration register  */
+	u32 brgc7;		/* BRG7 configuration register  */
+	u32 brgc8;		/* BRG8 configuration register  */
+	u32 brgc9;		/* BRG9 configuration register  */
+	u32 brgc10;		/* BRG10 configuration register */
+	u32 brgc11;		/* BRG11 configuration register */
+	u32 brgc12;		/* BRG12 configuration register */
+	u32 brgc13;		/* BRG13 configuration register */
+	u32 brgc14;		/* BRG14 configuration register */
+	u32 brgc15;		/* BRG15 configuration register */
+	u32 brgc16;		/* BRG16 configuration register */
+	u8 res0[0x40];
+} __attribute__ ((packed)) qe_brg_t;
+
+/* SPI
+*/
+typedef struct spi {
+	u8 res0[0x20];
+	u32 spmode;		/* SPI mode register */
+	u8 res1[0x2];
+	u8 spie;		/* SPI event register */
+	u8 res2[0x1];
+	u8 res3[0x2];
+	u8 spim;		/* SPI mask register */
+	u8 res4[0x1];
+	u8 res5[0x1];
+	u8 spcom;		/* SPI command register  */
+	u8 res6[0x2];
+	u32 spitd;		/* SPI transmit data register (cpu mode) */
+	u32 spird;		/* SPI receive data register (cpu mode) */
+	u8 res7[0x8];
+} __attribute__ ((packed)) spi_t;
+
+/* SI
+*/
+typedef struct si1 {
+	u16 siamr1;		/* SI1 TDMA mode register */
+	u16 sibmr1;		/* SI1 TDMB mode register */
+	u16 sicmr1;		/* SI1 TDMC mode register */
+	u16 sidmr1;		/* SI1 TDMD mode register */
+	u8 siglmr1_h;		/* SI1 global mode register high */
+	u8 res0[0x1];
+	u8 sicmdr1_h;		/* SI1 command register high */
+	u8 res2[0x1];
+	u8 sistr1_h;		/* SI1 status register high */
+	u8 res3[0x1];
+	u16 sirsr1_h;		/* SI1 RAM shadow address register high */
+	u8 sitarc1;		/* SI1 RAM counter Tx TDMA */
+	u8 sitbrc1;		/* SI1 RAM counter Tx TDMB */
+	u8 sitcrc1;		/* SI1 RAM counter Tx TDMC */
+	u8 sitdrc1;		/* SI1 RAM counter Tx TDMD */
+	u8 sirarc1;		/* SI1 RAM counter Rx TDMA */
+	u8 sirbrc1;		/* SI1 RAM counter Rx TDMB */
+	u8 sircrc1;		/* SI1 RAM counter Rx TDMC */
+	u8 sirdrc1;		/* SI1 RAM counter Rx TDMD */
+	u8 res4[0x8];
+	u16 siemr1;		/* SI1 TDME mode register 16 bits */
+	u16 sifmr1;		/* SI1 TDMF mode register 16 bits */
+	u16 sigmr1;		/* SI1 TDMG mode register 16 bits */
+	u16 sihmr1;		/* SI1 TDMH mode register 16 bits */
+	u8 siglmg1_l;		/* SI1 global mode register low 8 bits */
+	u8 res5[0x1];
+	u8 sicmdr1_l;		/* SI1 command register low 8 bits */
+	u8 res6[0x1];
+	u8 sistr1_l;		/* SI1 status register low 8 bits */
+	u8 res7[0x1];
+	u16 sirsr1_l;		/* SI1 RAM shadow address register low 16 bits */
+	u8 siterc1;		/* SI1 RAM counter Tx TDME 8 bits */
+	u8 sitfrc1;		/* SI1 RAM counter Tx TDMF 8 bits */
+	u8 sitgrc1;		/* SI1 RAM counter Tx TDMG 8 bits */
+	u8 sithrc1;		/* SI1 RAM counter Tx TDMH 8 bits */
+	u8 sirerc1;		/* SI1 RAM counter Rx TDME 8 bits */
+	u8 sirfrc1;		/* SI1 RAM counter Rx TDMF 8 bits */
+	u8 sirgrc1;		/* SI1 RAM counter Rx TDMG 8 bits */
+	u8 sirhrc1;		/* SI1 RAM counter Rx TDMH 8 bits */
+	u8 res8[0x8];
+	u32 siml1;		/* SI1 multiframe limit register */
+	u8 siedm1;		/* SI1 extended diagnostic mode register */
+	u8 res9[0xBB];
+} __attribute__ ((packed)) si1_t;
+
+/* SI Routing Tables
+*/
+typedef struct sir {
+	u8 tx[0x400];
+	u8 rx[0x400];
+	u8 res0[0x800];
+} __attribute__ ((packed)) sir_t;
+
+/* USB Controller.
+*/
+typedef struct usb_ctlr {
+	u8 usb_usmod;
+	u8 usb_usadr;
+	u8 usb_uscom;
+	u8 res1[1];
+	u16 usb_usep1;
+	u16 usb_usep2;
+	u16 usb_usep3;
+	u16 usb_usep4;
+	u8 res2[4];
+	u16 usb_usber;
+	u8 res3[2];
+	u16 usb_usbmr;
+	u8 res4[1];
+	u8 usb_usbs;
+	u16 usb_ussft;
+	u8 res5[2];
+	u16 usb_usfrn;
+	u8 res6[0x22];
+} __attribute__ ((packed)) usb_t;
+
+/* MCC
+*/
+typedef struct mcc {
+	u32 mcce;		/* MCC event register */
+	u32 mccm;		/* MCC mask register */
+	u32 mccf;		/* MCC configuration register */
+	u32 merl;		/* MCC emergency request level register */
+	u8 res0[0xF0];
+} __attribute__ ((packed)) mcc_t;
+
+/* QE UCC Slow
+*/
+typedef struct ucc_slow {
+	u32 gumr_l;		/* UCCx general mode register (low) */
+	u32 gumr_h;		/* UCCx general mode register (high) */
+	u16 upsmr;		/* UCCx protocol-specific mode register */
+	u8 res0[0x2];
+	u16 utodr;		/* UCCx transmit on demand register */
+	u16 udsr;		/* UCCx data synchronization register */
+	u16 ucce;		/* UCCx event register */
+	u8 res1[0x2];
+	u16 uccm;		/* UCCx mask register */
+	u8 res2[0x1];
+	u8 uccs;		/* UCCx status register */
+	u8 res3[0x24];
+	u16 utpt;
+	u8 guemr;		/* UCC general extended mode register */
+	u8 res4[0x200 - 0x091];
+} __attribute__ ((packed)) ucc_slow_t;
+
+/* QE UCC Fast
+*/
+typedef struct ucc_fast {
+	u32 gumr;		/* UCCx general mode register */
+	u32 upsmr;		/* UCCx protocol-specific mode register  */
+	u16 utodr;		/* UCCx transmit on demand register  */
+	u8 res0[0x2];
+	u16 udsr;		/* UCCx data synchronization register  */
+	u8 res1[0x2];
+	u32 ucce;		/* UCCx event register */
+	u32 uccm;		/* UCCx mask register.  */
+	u8 uccs;		/* UCCx status register */
+	u8 res2[0x7];
+	u32 urfb;		/* UCC receive FIFO base */
+	u16 urfs;		/* UCC receive FIFO size */
+	u8 res3[0x2];
+	u16 urfet;		/* UCC receive FIFO emergency threshold */
+	u16 urfset;		/* UCC receive FIFO special emergency threshold */
+	u32 utfb;		/* UCC transmit FIFO base */
+	u16 utfs;		/* UCC transmit FIFO size */
+	u8 res4[0x2];
+	u16 utfet;		/* UCC transmit FIFO emergency threshold */
+	u8 res5[0x2];
+	u16 utftt;		/* UCC transmit FIFO transmit threshold */
+	u8 res6[0x2];
+	u16 utpt;		/* UCC transmit polling timer */
+	u8 res7[0x2];
+	u32 urtry;		/* UCC retry counter register */
+	u8 res8[0x4C];
+	u8 guemr;		/* UCC general extended mode register */
+	u8 res9[0x100 - 0x091];
+//      u8  res9[0x200-0x100];
+} __attribute__ ((packed)) ucc_fast_t;
+
+/* QE UCC
+*/
+typedef struct ucc_common {
+	u8 res1[0x90];
+	u8 guemr;
+	u8 res2[0x200 - 0x091];
+} __attribute__ ((packed)) ucc_common_t;
+
+typedef struct ucc {
+	union {
+		ucc_slow_t slow;
+		ucc_fast_t fast;
+		ucc_common_t common;
+	};
+} __attribute__ ((packed)) ucc_t;
+
+/* MultiPHY UTOPIA POS Controllers (UPC)
+*/
+typedef struct upc {
+	u32 upgcr;		/* UTOPIA/POS general configuration register  */
+	u32 uplpa;		/* UTOPIA/POS last PHY address */
+	u32 uphec;		/* ATM HEC register */
+	u32 upuc;		/* UTOPIA/POS UCC configuration */
+	u32 updc1;		/* UTOPIA/POS device 1 configuration */
+	u32 updc2;		/* UTOPIA/POS device 2 configuration  */
+	u32 updc3;		/* UTOPIA/POS device 3 configuration */
+	u32 updc4;		/* UTOPIA/POS device 4 configuration  */
+	u32 upstpa;		/* UTOPIA/POS STPA threshold  */
+	u8 res0[0xC];
+	u32 updrs1_h;		/* UTOPIA/POS device 1 rate select  */
+	u32 updrs1_l;		/* UTOPIA/POS device 1 rate select  */
+	u32 updrs2_h;		/* UTOPIA/POS device 2 rate select  */
+	u32 updrs2_l;		/* UTOPIA/POS device 2 rate select */
+	u32 updrs3_h;		/* UTOPIA/POS device 3 rate select */
+	u32 updrs3_l;		/* UTOPIA/POS device 3 rate select */
+	u32 updrs4_h;		/* UTOPIA/POS device 4 rate select */
+	u32 updrs4_l;		/* UTOPIA/POS device 4 rate select */
+	u32 updrp1;		/* UTOPIA/POS device 1 receive priority low  */
+	u32 updrp2;		/* UTOPIA/POS device 2 receive priority low  */
+	u32 updrp3;		/* UTOPIA/POS device 3 receive priority low  */
+	u32 updrp4;		/* UTOPIA/POS device 4 receive priority low  */
+	u32 upde1;		/* UTOPIA/POS device 1 event */
+	u32 upde2;		/* UTOPIA/POS device 2 event */
+	u32 upde3;		/* UTOPIA/POS device 3 event */
+	u32 upde4;		/* UTOPIA/POS device 4 event */
+	u16 uprp1;
+	u16 uprp2;
+	u16 uprp3;
+	u16 uprp4;
+	u8 res1[0x8];
+	u16 uptirr1_0;		/* Device 1 transmit internal rate 0 */
+	u16 uptirr1_1;		/* Device 1 transmit internal rate 1 */
+	u16 uptirr1_2;		/* Device 1 transmit internal rate 2 */
+	u16 uptirr1_3;		/* Device 1 transmit internal rate 3 */
+	u16 uptirr2_0;		/* Device 2 transmit internal rate 0 */
+	u16 uptirr2_1;		/* Device 2 transmit internal rate 1 */
+	u16 uptirr2_2;		/* Device 2 transmit internal rate 2 */
+	u16 uptirr2_3;		/* Device 2 transmit internal rate 3 */
+	u16 uptirr3_0;		/* Device 3 transmit internal rate 0 */
+	u16 uptirr3_1;		/* Device 3 transmit internal rate 1 */
+	u16 uptirr3_2;		/* Device 3 transmit internal rate 2 */
+	u16 uptirr3_3;		/* Device 3 transmit internal rate 3 */
+	u16 uptirr4_0;		/* Device 4 transmit internal rate 0 */
+	u16 uptirr4_1;		/* Device 4 transmit internal rate 1 */
+	u16 uptirr4_2;		/* Device 4 transmit internal rate 2 */
+	u16 uptirr4_3;		/* Device 4 transmit internal rate 3 */
+	u32 uper1;		/* Device 1 port enable register */
+	u32 uper2;		/* Device 2 port enable register */
+	u32 uper3;		/* Device 3 port enable register */
+	u32 uper4;		/* Device 4 port enable register */
+	u8 res2[0x150];
+} __attribute__ ((packed)) upc_t;
+
+/* SDMA
+*/
+typedef struct sdma {
+	u32 sdsr;		/* Serial DMA status register */
+	u32 sdmr;		/* Serial DMA mode register */
+	u32 sdtr1;		/* SDMA system bus threshold register */
+	u32 sdtr2;		/* SDMA secondary bus threshold register */
+	u32 sdhy1;		/* SDMA system bus hysteresis register */
+	u32 sdhy2;		/* SDMA secondary bus hysteresis register */
+	u32 sdta1;		/* SDMA system bus address register */
+	u32 sdta2;		/* SDMA secondary bus address register */
+	u32 sdtm1;		/* SDMA system bus MSNUM register */
+	u32 sdtm2;		/* SDMA secondary bus MSNUM register */
+	u8 res0[0x10];
+	u32 sdaqr;		/* SDMA address bus qualify register */
+	u32 sdaqmr;		/* SDMA address bus qualify mask register */
+	u8 res1[0x4];
+	u32 sdebcr;		/* SDMA CAM entries base register */
+	u8 res2[0x38];
+} __attribute__ ((packed)) sdma_t;
+
+/* Debug Space
+*/
+typedef struct dbg {
+	u32 bpdcr;		/* Breakpoint debug command register */
+	u32 bpdsr;		/* Breakpoint debug status register */
+	u32 bpdmr;		/* Breakpoint debug mask register */
+	u32 bprmrr0;		/* Breakpoint request mode risc register 0 */
+	u32 bprmrr1;		/* Breakpoint request mode risc register 1 */
+	u8 res0[0x8];
+	u32 bprmtr0;		/* Breakpoint request mode trb register 0 */
+	u32 bprmtr1;		/* Breakpoint request mode trb register 1 */
+	u8 res1[0x8];
+	u32 bprmir;		/* Breakpoint request mode immediate register */
+	u32 bprmsr;		/* Breakpoint request mode serial register */
+	u32 bpemr;		/* Breakpoint exit mode register */
+	u8 res2[0x48];
+} __attribute__ ((packed)) dbg_t;
+
+/* RISC Special Registers (Trap and Breakpoint)
+*/
+typedef struct rsp {
+	u8 fixme[0x100];
+} __attribute__ ((packed)) rsp_t;
+
+typedef struct qe_immap {
+	qe_iram_t iram;		/* I-RAM */
+	qe_ic_t ic;		/* Interrupt Controller */
+	cp_qe_t cp;		/* Communications Processor */
+	qe_mux_t qmx;		/* QE Multiplexer */
+	qe_timers_t qet;	/* QE Timers */
+	spi_t spi[0x2];		/* spi  */
+	mcc_t mcc;		/* mcc */
+	qe_brg_t brg;		/* brg */
+	usb_t usb;		/* USB */
+	si1_t si1;		/* SI */
+	u8 res11[0x800];
+	sir_t sir;		/* SI Routing Tables  */
+	ucc_t ucc1;		/* ucc1 */
+	ucc_t ucc3;		/* ucc3 */
+	ucc_t ucc5;		/* ucc5 */
+	ucc_t ucc7;		/* ucc7 */
+	u8 res12[0x600];
+	upc_t upc1;		/* MultiPHY UTOPIA POS Controller 1 */
+	ucc_t ucc2;		/* ucc2 */
+	ucc_t ucc4;		/* ucc4 */
+	ucc_t ucc6;		/* ucc6 */
+	ucc_t ucc8;		/* ucc8 */
+	u8 res13[0x600];
+	upc_t upc2;		/* MultiPHY UTOPIA POS Controller 2 */
+	sdma_t sdma;		/* SDMA */
+	dbg_t dbg;		/* Debug Space */
+	rsp_t rsp[0x2];		/* RISC Special Registers (Trap and Breakpoint) */
+	u8 res14[0x300];
+	u8 res15[0x3A00];
+	u8 res16[0x8000];	/* 0x108000 -  0x110000 */
+	u8 muram[0xC000];	/* 0x110000 -  0x11C000 Multi-user RAM */
+	u8 res17[0x24000];	/* 0x11C000 -  0x140000 */
+	u8 res18[0xC0000];	/* 0x140000 -  0x200000 */
+} __attribute__ ((packed)) qe_map_t;
+
+extern qe_map_t *qe_immr;
+
+#endif				/* __IMMAP_QE_H__ */
+#endif				/* __KERNEL__ */
Index: linux-2.6.10/include/asm-ppc/ipic.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ipic.h
+++ linux-2.6.10/include/asm-ppc/ipic.h
@@ -72,6 +72,7 @@ enum ipic_mcp_irq {
 extern void ipic_init(phys_addr_t phys_addr, unsigned int flags,
 		unsigned int irq_offset,
 		unsigned char *senses, unsigned int senses_count);
+extern void ipic_force_irq(unsigned int irq);
 extern int ipic_set_priority(unsigned int irq, unsigned int priority);
 extern void ipic_set_highest_priority(unsigned int irq);
 extern void ipic_set_default_priority(void);
Index: linux-2.6.10/include/asm-ppc/irq.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/irq.h
+++ linux-2.6.10/include/asm-ppc/irq.h
@@ -180,7 +180,15 @@ static __inline__ int irq_canonicalize(i
 	return irq;
 }
 
-#define	NR_IRQS	(NR_IPIC_INTS)
+#ifdef CONFIG_QE
+#define QE_IRQ_OFFSET   MPC83xx_QE_IRQ_OFFSET
+#define NR_QE_IC_INTS   MPC83xx_NR_QE_IC_INTS
+#define IRQ_QE_HIGH     MPC83xx_IRQ_QE_HIGH
+#define IRQ_QE_LOW      MPC83xx_IRQ_QE_LOW
+#define	NR_IRQS (NR_IPIC_INTS + NR_QE_IC_INTS)
+#else
+#define	NR_IRQS (NR_IPIC_INTS)
+#endif /* CONFIG_QE */
 
 #elif defined(CONFIG_85xx)
 /* Now include the board configuration specific associations.
Index: linux-2.6.10/include/asm-ppc/mpc83xx.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/mpc83xx.h
+++ linux-2.6.10/include/asm-ppc/mpc83xx.h
@@ -19,12 +19,18 @@
 
 #include <linux/config.h>
 #include <asm/mmu.h>
+#ifdef CONFIG_QE
+#include <asm/qe.h>
+#endif /* CONFIG_QE */
 
 #ifdef CONFIG_83xx
 
 #ifdef CONFIG_MPC834x_SYS
 #include <platforms/83xx/mpc834x_sys.h>
 #endif
+#ifdef CONFIG_MPC8360E_PB
+#include <platforms/83xx/mpc8360e_pb.h>
+#endif
 
 #define _IO_BASE        isa_io_base
 #define _ISA_MEM_BASE   isa_mem_base
@@ -62,6 +68,10 @@ extern unsigned char __res[];
 #define MPC83xx_IRQ_EXT5	(21 + MPC83xx_IPIC_IRQ_OFFSET)
 #define MPC83xx_IRQ_EXT6	(22 + MPC83xx_IPIC_IRQ_OFFSET)
 #define MPC83xx_IRQ_EXT7	(23 + MPC83xx_IPIC_IRQ_OFFSET)
+#ifdef CONFIG_QE
+#define MPC83xx_IRQ_QE_HIGH             (32 + MPC83xx_IPIC_IRQ_OFFSET)
+#define MPC83xx_IRQ_QE_LOW              (33 + MPC83xx_IPIC_IRQ_OFFSET)
+#endif /* CONFIG_QE */
 #define MPC83xx_IRQ_TSEC1_TX	(32 + MPC83xx_IPIC_IRQ_OFFSET)
 #define MPC83xx_IRQ_TSEC1_RX	(33 + MPC83xx_IPIC_IRQ_OFFSET)
 #define MPC83xx_IRQ_TSEC1_ERROR	(34 + MPC83xx_IPIC_IRQ_OFFSET)
@@ -93,6 +103,46 @@ extern unsigned char __res[];
 #define MPC83xx_IRQ_GTM1	(90 + MPC83xx_IPIC_IRQ_OFFSET)
 #define MPC83xx_IRQ_GTM5	(91 + MPC83xx_IPIC_IRQ_OFFSET)
 
+#define MPC83xx_PCI1_LOWER_IO	0x00000000
+#define MPC83xx_PCI1_UPPER_IO	0x00ffffff
+#define MPC83xx_PCI1_LOWER_MEM	0x80000000
+#define MPC83xx_PCI1_UPPER_MEM	0x9fffffff
+#define MPC83xx_PCI1_IO_BASE	0xe2000000
+#define MPC83xx_PCI1_MEM_OFFSET	0x00000000
+#define MPC83xx_PCI1_IO_SIZE	0x01000000
+
+#define MPC83xx_PCI2_LOWER_IO	0x00000000
+#define MPC83xx_PCI2_UPPER_IO	0x00ffffff
+#define MPC83xx_PCI2_LOWER_MEM	0xa0000000
+#define MPC83xx_PCI2_UPPER_MEM	0xbfffffff
+#define MPC83xx_PCI2_IO_BASE	0xe3000000
+#define MPC83xx_PCI2_MEM_OFFSET	0x00000000
+#define MPC83xx_PCI2_IO_SIZE	0x01000000
+
+/* Internal IRQs on MPC83xx QE IC */
+/* Not all of these exist on all MPC83xx QE implementations */
+
+#ifndef MPC83xx_QE_IRQ_OFFSET
+#define MPC83xx_QE_IRQ_OFFSET	NR_IPIC_INTS
+#endif /* MPC83xx_QE_IRQ_OFFSET */
+
+#define MPC83xx_NR_QE_IC_INTS 64
+
+#define MPC83xx_QE_IRQ_UCC1             (32 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC2             (33 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC3             (34 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC4             (35 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC5             (40 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC6             (41 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC7             (42 + MPC83xx_QE_IRQ_OFFSET)
+#define MPC83xx_QE_IRQ_UCC8             (43 + MPC83xx_QE_IRQ_OFFSET)
+
+#ifdef CONFIG_QE
+#define MPC83xx_IMMRBAR_SIZE    (2*1024*1024)
+#else
+#define MPC83xx_IMMRBAR_SIZE    (1024*1024)
+#endif /* CONFIG_QE */
+
 #define MPC83xx_CCSRBAR_SIZE	(1024*1024)
 
 /* system priority and configuration register */
@@ -138,9 +188,33 @@ enum ppc_sys_devices {
 	MPC83xx_USB2_DR,
 	MPC83xx_USB2_MPH,
 	MPC83xx_MDIO,
+	MPC83xx_QE_UCC1,
+	MPC83xx_QE_UCC2,
+	MPC83xx_QE_UCC3,
+	MPC83xx_QE_UCC4,
+	MPC83xx_QE_UCC5,
+	MPC83xx_QE_UCC6,
+	MPC83xx_QE_UCC7,
+	MPC83xx_QE_UCC8,
 	NUM_PPC_SYS_DEVS,
 };
 
+static inline unsigned long immrbar_virt_to_phys(volatile void * address)
+{
+    if ( ((uint)address >= VIRT_IMMRBAR) &&
+         ((uint)address < (VIRT_IMMRBAR + MPC83xx_IMMRBAR_SIZE)) )
+        return (unsigned long)(address - VIRT_IMMRBAR + immrbar);
+    return (unsigned long)address;
+}
+
+static inline void * immrbar_phys_to_virt(unsigned long address)
+{
+    if ( (address >= immrbar) &&
+         (address < (immrbar + MPC83xx_IMMRBAR_SIZE)) )
+        return (void *)(address - immrbar + VIRT_IMMRBAR);
+    return (void *)address;
+}
+
 #endif /* CONFIG_83xx */
 #endif /* __ASM_MPC83xx_H__ */
 #endif /* __KERNEL__ */
Index: linux-2.6.10/include/asm-ppc/ppcboot.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ppcboot.h
+++ linux-2.6.10/include/asm-ppc/ppcboot.h
@@ -57,6 +57,10 @@ typedef struct bd_info {
 	unsigned long	bi_sccfreq;	/* SCC_CLK Freq, in MHz */
 	unsigned long	bi_vco;		/* VCO Out from PLL, in MHz */
 #endif
+#if defined(CONFIG_QE)
+        unsigned long   bi_qefreq;      /* QE_CLK Freq, in MHz */
+        unsigned long   bi_brgfreq;     /* BRG_CLK Freq, in MHz */
+#endif
 #if defined(CONFIG_PPC_MPC52xx)
 	unsigned long   bi_ipbfreq;     /* IPB Bus Freq, in MHz */
 	unsigned long   bi_pcifreq;     /* PCI Bus Freq, in MHz */
Index: linux-2.6.10/include/asm-ppc/qe.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-ppc/qe.h
@@ -0,0 +1,472 @@
+/*
+ * include/asm-ppc/qe.h
+ *
+ * QUICC Engine (QE) external definitions and structure.
+ *
+ * Author: Shlomi Gridih <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifdef __KERNEL__
+#ifndef __QE_H__
+#define __QE_H__
+
+#include <asm/immap_qe.h>
+
+/* Multi User RAM addresses.
+ */
+#define QE_MURAM_DATAONLY_BASE	((uint)0x0)
+#define QE_MURAM_NOSPACE		((uint)0x7fffffff)
+#define QE_MURAM_DATAONLY_SIZE	((uint)(48 * 1024) - QE_MURAM_DATAONLY_BASE)
+
+static inline long IS_MURAM_ERR(const uint offset)
+{
+	return (uint) offset > (uint) - 1000L;
+}
+
+#define QE_NUM_OF_SNUM  28
+#define QE_NUM_OF_BRGS  16
+#define QE_NUM_OF_PORTS 1024
+
+/* Memory partitions
+*/
+#define MEM_PART_SYSTEM     0
+#define MEM_PART_SECONDARY  1
+#define MEM_PART_MURAM      2
+
+/* Export the base address of the communication processor registers
+ * and dual port ram.
+ */
+int qe_issue_cmd(uint cmd, uint device, u8 mcn_protocol, u32 cmd_input);
+void qe_setbrg(uint brg, uint rate);
+int qe_get_snum(void);
+void qe_put_snum(u8 snum);
+uint qe_muram_alloc(uint size, uint align);
+int qe_muram_free(uint offset);
+uint qe_muram_alloc_fixed(uint offset, uint size);
+void qe_muram_dump(void);
+void *qe_muram_addr(uint offset);
+/* Buffer descriptors.
+*/
+typedef struct qe_bd {
+	u16 status;
+	u16 length;
+	u32 buf;
+} __attribute__ ((packed)) qe_bd_t;
+
+#define QE_SIZEOF_BD       sizeof(qe_bd_t)
+
+#define BD_STATUS_MASK                      0xffff0000
+#define BD_LENGTH_MASK                      0x0000ffff
+
+#define BD_BUFFER_ARG(bd)                   ((qe_bd_t *)bd)->buf
+#define BD_BUFFER_CLEAR(bd)                 out_be32(&(BD_BUFFER_ARG(bd)), 0);
+#define BD_BUFFER(bd)                       in_be32(&(BD_BUFFER_ARG(bd)))
+#define BD_STATUS_AND_LENGTH_SET(bd, val)   out_be32((u32*)bd, val)
+#define BD_STATUS_AND_LENGTH(bd)            in_be32((u32*)bd)
+#define BD_BUFFER_SET(bd, buffer)           out_be32(&(BD_BUFFER_ARG(bd)), (u32)(buffer))
+/* Macro for retrieving the following BD.
+   example:
+   next = BD_GET_NEXT( currBd, bdStatus, bdBase, SIZEOF_MY_BD, T_W ) */
+#define BD_GET_NEXT( curr_bd, bd_status, bd_base, bd_len, last_bd ) \
+        ( (!((bd_status) & (last_bd))) ? ((curr_bd)+(bd_len)) : (bd_base) )
+
+/* Alignments
+*/
+#define QE_INTR_TABLE_ALIGN                16	/* ??? */
+#define QE_ALIGNMENT_OF_BD                 8
+#define QE_ALIGNMENT_OF_PRAM               64
+
+/* RISC allocation
+*/
+typedef enum qe_risc_allocation {
+	QE_RISC_ALLOCATION_RISC1 = 1,	/* RISC 1 */
+	QE_RISC_ALLOCATION_RISC2 = 2,	/* RISC 2 */
+	QE_RISC_ALLOCATION_RISC1_AND_RISC2 = 3	/* Dynamically choose RISC 1 or RISC 2 */
+} qe_risc_allocation_e;
+
+/* QE extended filtering Table Lookup Key Size
+*/
+typedef enum qe_fltr_tbl_lookup_key_size {
+	QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES = 0x3f,	/* LookupKey parsed by the Generate LookupKey CMD is truncated to 8  bytes */
+	QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES = 0x5f,	/* LookupKey parsed by the Generate LookupKey CMD is truncated to 16 bytes */
+} qe_fltr_tbl_lookup_key_size_e;
+
+/* QE FLTR extended filtering Largest External Table Lookup Key Size
+*/
+typedef enum qe_fltr_largest_external_tbl_lookup_key_size_ {
+	QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE = 0x0,	/* not used */
+	QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_8_BYTES = QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES,	/* 8  bytes */
+	QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_16_BYTES = QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES	/* 16 bytes */
+} qe_fltr_largest_external_tbl_lookup_key_size_e;
+
+/* structure representing QE parameter RAM
+*/
+typedef struct qe_timer_tables {
+	u16 tm_base;		/* QE timer table base adr */
+	u16 tm_ptr;		/* QE timer table pointer  */
+	u16 r_tmr;		/* QE timer mode register  */
+	u16 r_tmv;		/* QE timer valid register */
+	u32 tm_cmd;		/* QE timer cmd register   */
+	u32 tm_cnt;		/* QE timer internal cnt   */
+} __attribute__ ((packed)) qe_timer_tables_t;
+
+#define QE_FLTR_TAD_SIZE                8
+
+/* QE extended filtering Termination Action Descriptor (TAD)
+*/
+typedef struct qe_fltr_tad {
+	u8 serialized[QE_FLTR_TAD_SIZE];
+} __attribute__ ((packed)) qe_fltr_tad_t;
+
+/* Communication Direction.
+*/
+typedef enum comm_dir {
+	COMM_DIR_NONE = 0,
+	COMM_DIR_RX = 1,
+	COMM_DIR_TX = 2,
+	COMM_DIR_RX_AND_TX = 3
+} comm_dir_e;
+
+/* Clocks and GRG's
+*/
+typedef enum qe_clock {
+	QE_CLK_NONE = 0, QE_BRG1	/* Baud Rate Generator  1 */
+	    , QE_BRG2		/* Baud Rate Generator  2 */
+	    , QE_BRG3		/* Baud Rate Generator  3 */
+	    , QE_BRG4		/* Baud Rate Generator  4 */
+	    , QE_BRG5		/* Baud Rate Generator  5 */
+	    , QE_BRG6		/* Baud Rate Generator  6 */
+	    , QE_BRG7		/* Baud Rate Generator  7 */
+	    , QE_BRG8		/* Baud Rate Generator  8 */
+	    , QE_BRG9		/* Baud Rate Generator  9 */
+	    , QE_BRG10		/* Baud Rate Generator 10 */
+	    , QE_BRG11		/* Baud Rate Generator 11 */
+	    , QE_BRG12		/* Baud Rate Generator 12 */
+	    , QE_BRG13		/* Baud Rate Generator 13 */
+	    , QE_BRG14		/* Baud Rate Generator 14 */
+	    , QE_BRG15		/* Baud Rate Generator 15 */
+	    , QE_BRG16		/* Baud Rate Generator 16 */
+	    , QE_CLK1		/* Clock  1               */
+	    , QE_CLK2		/* Clock  2               */
+	    , QE_CLK3		/* Clock  3               */
+	    , QE_CLK4		/* Clock  4               */
+	    , QE_CLK5		/* Clock  5               */
+	    , QE_CLK6		/* Clock  6               */
+	    , QE_CLK7		/* Clock  7               */
+	    , QE_CLK8		/* Clock  8               */
+	    , QE_CLK9		/* Clock  9               */
+	    , QE_CLK10		/* Clock 10               */
+	    , QE_CLK11		/* Clock 11               */
+	    , QE_CLK12		/* Clock 12               */
+	    , QE_CLK13		/* Clock 13               */
+	    , QE_CLK14		/* Clock 14               */
+	    , QE_CLK15		/* Clock 15               */
+	    , QE_CLK16		/* Clock 16               */
+	    , QE_CLK17		/* Clock 17               */
+	    , QE_CLK18		/* Clock 18               */
+	    , QE_CLK19		/* Clock 19               */
+	    , QE_CLK20		/* Clock 20               */
+	    , QE_CLK21		/* Clock 21               */
+	    , QE_CLK22		/* Clock 22               */
+	    , QE_CLK23		/* Clock 23               */
+	    , QE_CLK24		/* Clock 24               */
+	, QE_CLK_DUMMY
+} qe_clock_e;
+
+/* QE CMXUCR Registers.
+ * There are two UCCs represented in each of the four CMXUCR registers.
+ * These values are for the UCC in the LSBs
+ */
+#define QE_CMXUCR_MII_ENET_MNG              0x00007000
+#define QE_CMXUCR_MII_ENET_MNG_SHIFT        12
+#define QE_CMXUCR_GRANT                     0x00008000
+#define QE_CMXUCR_TSA                       0x00004000
+#define QE_CMXUCR_BKPT                      0x00000100
+#define QE_CMXUCR_TX_CLK_SRC_MASK           0x0000000F
+
+/* QE CMXGCR Registers.
+*/
+#define QE_CMXGCR_MII_ENET_MNG              0x00007000
+#define QE_CMXGCR_MII_ENET_MNG_SHIFT        12
+#define QE_CMXGCR_USBCS                     0x0000000f
+
+/* QE CECR Commands.
+*/
+#define QE_CR_FLG                   0x00010000
+#define QE_RESET                    0x80000000
+#define QE_INIT_TX_RX               0x00000000
+#define QE_INIT_RX                  0x00000001
+#define QE_INIT_TX                  0x00000002
+#define QE_ENTER_HUNT_MODE          0x00000003
+#define QE_STOP_TX                  0x00000004
+#define QE_GRACEFUL_STOP_TX         0x00000005
+#define QE_RESTART_TX               0x00000006
+#define QE_CLOSE_RX_BD              0x00000007
+#define QE_SWITCH_COMMAND           0x00000007
+#define QE_SET_GROUP_ADDRESS        0x00000008
+#define QE_START_IDMA               0x00000009
+#define QE_MCC_STOP_RX              0x00000009
+#define QE_ATM_TRANSMIT             0x0000000a
+#define QE_HPAC_CLEAR_ALL           0x0000000b
+#define QE_GRACEFUL_STOP_RX         0x0000001a
+#define QE_RESTART_RX               0x0000001b
+#define QE_HPAC_SET_PRIORITY        0x0000010b
+#define QE_HPAC_STOP_TX             0x0000020b
+#define QE_HPAC_STOP_RX             0x0000030b
+#define QE_HPAC_GRACEFUL_STOP_TX    0x0000040b
+#define QE_HPAC_GRACEFUL_STOP_RX    0x0000050b
+#define QE_HPAC_START_TX            0x0000060b
+#define QE_HPAC_START_RX            0x0000070b
+#define QE_USB_STOP_TX              0x0000000a
+#define QE_USB_RESTART_TX           0x0000000b
+#define QE_QMC_STOP_TX              0x0000000c
+#define QE_QMC_STOP_RX              0x0000000d
+#define QE_SS7_SU_FIL_RESET         0x0000000e
+/* jonathbr added from here down for 83xx */
+#define QE_RESET_BCS                0x0000000a
+#define QE_MCC_INIT_TX_RX_16        0x00000003
+#define QE_MCC_STOP_TX              0x00000004
+#define QE_MCC_INIT_TX_1            0x00000005
+#define QE_MCC_INIT_RX_1            0x00000006
+#define QE_MCC_RESET                0x00000007
+#define QE_SET_TIMER                0x00000008
+#define QE_RANDOM_NUMBER            0x0000000c
+#define QE_ATM_MULTI_THREAD_INIT    0x00000011
+#define QE_ASSIGN_PAGE              0x00000012
+#define QE_ADD_REMOVE_HASH_ENTRY    0x00000013
+#define QE_START_FLOW_CONTROL       0x00000014
+#define QE_STOP_FLOW_CONTROL        0x00000015
+#define QE_ASSIGN_PAGE_TO_DEVICE    0x00000016
+
+#define QE_ASSIGN_RISC		    0x00000010
+#define QE_CR_MCN_NORMAL_SHIFT      6
+#define QE_CR_MCN_USB_SHIFT         4
+#define QE_CR_MCN_RISC_ASSIGN_SHIFT 8
+#define QE_CR_SNUM_SHIFT            17
+
+/* QE CECR Sub Block - sub block of QE command.
+*/
+#define QE_CR_SUBBLOCK_INVALID      0x00000000
+#define QE_CR_SUBBLOCK_USB          0x03200000
+#define QE_CR_SUBBLOCK_UCCFAST1     0x02000000
+#define QE_CR_SUBBLOCK_UCCFAST2     0x02200000
+#define QE_CR_SUBBLOCK_UCCFAST3     0x02400000
+#define QE_CR_SUBBLOCK_UCCFAST4     0x02600000
+#define QE_CR_SUBBLOCK_UCCFAST5     0x02800000
+#define QE_CR_SUBBLOCK_UCCFAST6     0x02a00000
+#define QE_CR_SUBBLOCK_UCCFAST7     0x02c00000
+#define QE_CR_SUBBLOCK_UCCFAST8     0x02e00000
+#define QE_CR_SUBBLOCK_UCCSLOW1     0x00000000
+#define QE_CR_SUBBLOCK_UCCSLOW2     0x00200000
+#define QE_CR_SUBBLOCK_UCCSLOW3     0x00400000
+#define QE_CR_SUBBLOCK_UCCSLOW4     0x00600000
+#define QE_CR_SUBBLOCK_UCCSLOW5     0x00800000
+#define QE_CR_SUBBLOCK_UCCSLOW6     0x00a00000
+#define QE_CR_SUBBLOCK_UCCSLOW7     0x00c00000
+#define QE_CR_SUBBLOCK_UCCSLOW8     0x00e00000
+#define QE_CR_SUBBLOCK_MCC1         0x03800000
+#define QE_CR_SUBBLOCK_MCC2         0x03a00000
+#define QE_CR_SUBBLOCK_MCC3         0x03000000
+#define QE_CR_SUBBLOCK_IDMA1        0x02800000
+#define QE_CR_SUBBLOCK_IDMA2        0x02a00000
+#define QE_CR_SUBBLOCK_IDMA3        0x02c00000
+#define QE_CR_SUBBLOCK_IDMA4        0x02e00000
+#define QE_CR_SUBBLOCK_HPAC         0x01e00000
+#define QE_CR_SUBBLOCK_SPI1         0x01400000
+#define QE_CR_SUBBLOCK_SPI2         0x01600000
+#define QE_CR_SUBBLOCK_RAND         0x01c00000
+#define QE_CR_SUBBLOCK_TIMER        0x01e00000
+#define QE_CR_SUBBLOCK_GENERAL      0x03c00000
+
+/* QE CECR Protocol - For non-MCC, specifies mode for QE CECR command.
+*/
+#define QE_CR_PROTOCOL_UNSPECIFIED       0x00	/* For all other protocols */
+#define QE_CR_PROTOCOL_HDLC_TRANSPARENT  0x00
+#define QE_CR_PROTOCOL_ATM_POS           0x0A
+#define QE_CR_PROTOCOL_ETHERNET          0x0C
+#define QE_CR_PROTOCOL_L2_SWITCH         0x0D
+
+/* BMR byte order
+*/
+#define QE_BMR_BYTE_ORDER_BO_PPC  0x08	/* powerpc little endian */
+#define QE_BMR_BYTE_ORDER_BO_MOT  0x10	/* motorola big endian   */
+#define QE_BMR_BYTE_ORDER_BO_MAX  0x18
+
+/* BRG configuration register
+*/
+#define QE_BRGC_ENABLE          0x00010000
+#define QE_BRGC_DIVISOR_SHIFT   1
+#define QE_BRGC_DIVISOR_MAX     0xFFF
+#define QE_BRGC_DIV16           1
+/* QE Timers registers */
+#define QE_GTCFR1_PCAS      0x80
+#define QE_GTCFR1_STP2      0x20
+#define QE_GTCFR1_RST2      0x10
+#define QE_GTCFR1_GM2       0x08
+#define QE_GTCFR1_GM1       0x04
+#define QE_GTCFR1_STP1      0x02
+#define QE_GTCFR1_RST1      0x01
+
+/* SDMA registers */
+#define QE_SDSR_BER1            0x02000000
+#define QE_SDSR_BER2            0x01000000
+
+#define QE_SDMR_GLB_1_MSK       0x80000000
+#define QE_SDMR_ADR_SEL         0x20000000
+#define QE_SDMR_BER1_MSK        0x02000000
+#define QE_SDMR_BER2_MSK        0x01000000
+#define QE_SDMR_EB1_MSK         0x00800000
+#define QE_SDMR_ER1_MSK         0x00080000
+#define QE_SDMR_ER2_MSK         0x00040000
+#define QE_SDMR_CEN_MASK        0x0000E000
+#define QE_SDMR_SBER_1          0x00000200
+#define QE_SDMR_SBER_2          0x00000200
+#define QE_SDMR_EB1_PR_MASK     0x000000C0
+#define QE_SDMR_ER1_PR          0x00000008
+
+#define QE_SDMR_CEN_SHIFT       13
+#define QE_SDMR_EB1_PR_SHIFT    6
+
+#define QE_SDTM_MSNUM_SHIFT     24
+
+#define QE_SDEBCR_BA_MASK       0x01FFFFFF
+
+/* UPC
+*/
+#define UPGCR_PROTOCOL      0x80000000	/* protocol ul2 or pl2 */
+#define UPGCR_TMS           0x40000000	/* Transmit master/slave mode */
+#define UPGCR_RMS           0x20000000	/* Receive master/slave mode */
+#define UPGCR_ADDR          0x10000000	/* Master MPHY Addr multiplexing */
+#define UPGCR_DIAG          0x01000000	/* Diagnostic mode */
+
+/* UCC
+*/
+#define UCC_GUEMR_MODE_MASK_RX  0x02
+#define UCC_GUEMR_MODE_MASK_TX  0x01
+#define UCC_GUEMR_MODE_FAST_RX  0x02
+#define UCC_GUEMR_MODE_FAST_TX  0x01
+#define UCC_GUEMR_MODE_SLOW_RX  0x00
+#define UCC_GUEMR_MODE_SLOW_TX  0x00
+#define UCC_GUEMR_SET_RESERVED3 0x10	/* Bit 3 in the guemr is reserved but must be set 1 */
+
+/* structure representing UCC SLOW parameter RAM
+*/
+typedef struct ucc_slow_pram {
+	u16 rbase;		/* RX BD base address       */
+	u16 tbase;		/* TX BD base address       */
+	u8 rfcr;		/* Rx function code         */
+	u8 tfcr;		/* Tx function code         */
+	u16 mrblr;		/* Rx buffer length         */
+	u32 rstate;		/* Rx internal state        */
+	u32 rptr;		/* Rx internal data pointer */
+	u16 rbptr;		/* rb BD Pointer            */
+	u16 rcount;		/* Rx internal byte count   */
+	u32 rtemp;		/* Rx temp                  */
+	u32 tstate;		/* Tx internal state        */
+	u32 tptr;		/* Tx internal data pointer */
+	u16 tbptr;		/* Tx BD pointer            */
+	u16 tcount;		/* Tx byte count            */
+	u32 ttemp;		/* Tx temp                  */
+	u32 rcrc;		/* temp receive CRC         */
+	u32 tcrc;		/* temp transmit CRC        */
+} __attribute__ ((packed)) ucc_slow_pram_t;
+
+/* General UCC SLOW Mode Register (GUMRH & GUMRL)
+*/
+#define UCC_SLOW_GUMR_H_CRC16         0x00004000
+#define UCC_SLOW_GUMR_H_CRC16CCITT    0x00000000
+#define UCC_SLOW_GUMR_H_CRC32CCITT    0x00008000
+#define UCC_SLOW_GUMR_H_REVD          0x00002000
+#define UCC_SLOW_GUMR_H_TRX           0x00001000
+#define UCC_SLOW_GUMR_H_TTX           0x00000800
+#define UCC_SLOW_GUMR_H_CDP           0x00000400
+#define UCC_SLOW_GUMR_H_CTSP          0x00000200
+#define UCC_SLOW_GUMR_H_CDS           0x00000100
+#define UCC_SLOW_GUMR_H_CTSS          0x00000080
+#define UCC_SLOW_GUMR_H_TFL           0x00000040
+#define UCC_SLOW_GUMR_H_RFW           0x00000020
+#define UCC_SLOW_GUMR_H_TXSY          0x00000010
+#define UCC_SLOW_GUMR_H_4SYNC         0x00000004
+#define UCC_SLOW_GUMR_H_8SYNC         0x00000008
+#define UCC_SLOW_GUMR_H_16SYNC        0x0000000c
+#define UCC_SLOW_GUMR_H_RTSM          0x00000002
+#define UCC_SLOW_GUMR_H_RSYN          0x00000001
+
+#define UCC_SLOW_GUMR_L_TCI           0x10000000
+#define UCC_SLOW_GUMR_L_RINV          0x02000000
+#define UCC_SLOW_GUMR_L_TINV          0x01000000
+#define UCC_SLOW_GUMR_L_TEND          0x00020000
+#define UCC_SLOW_GUMR_L_ENR           0x00000020
+#define UCC_SLOW_GUMR_L_ENT           0x00000010
+
+/* General UCC FAST Mode Register
+*/
+#define UCC_FAST_GUMR_TCI             0x20000000
+#define UCC_FAST_GUMR_TRX             0x10000000
+#define UCC_FAST_GUMR_TTX             0x08000000
+#define UCC_FAST_GUMR_CDP             0x04000000
+#define UCC_FAST_GUMR_CTSP            0x02000000
+#define UCC_FAST_GUMR_CDS             0x01000000
+#define UCC_FAST_GUMR_CTSS            0x00800000
+#define UCC_FAST_GUMR_TXSY            0x00020000
+#define UCC_FAST_GUMR_RSYN            0x00010000
+#define UCC_FAST_GUMR_RTSM            0x00002000
+#define UCC_FAST_GUMR_REVD            0x00000400
+#define UCC_FAST_GUMR_ENR             0x00000020
+#define UCC_FAST_GUMR_ENT             0x00000010
+
+/* Slow UCC Event Register (UCCE)
+*/
+#define UCC_SLOW_UCCE_GLR       0x1000
+#define UCC_SLOW_UCCE_GLT       0x0800
+#define UCC_SLOW_UCCE_DCC       0x0400
+#define UCC_SLOW_UCCE_FLG       0x0200
+#define UCC_SLOW_UCCE_AB        0x0200
+#define UCC_SLOW_UCCE_IDLE      0x0100
+#define UCC_SLOW_UCCE_GRA       0x0080
+#define UCC_SLOW_UCCE_TXE       0x0010
+#define UCC_SLOW_UCCE_RXF       0x0008
+#define UCC_SLOW_UCCE_CCR       0x0008
+#define UCC_SLOW_UCCE_RCH       0x0008
+#define UCC_SLOW_UCCE_BSY       0x0004
+#define UCC_SLOW_UCCE_TXB       0x0002
+#define UCC_SLOW_UCCE_TX        0x0002
+#define UCC_SLOW_UCCE_RX        0x0001
+#define UCC_SLOW_UCCE_GOV       0x0001
+#define UCC_SLOW_UCCE_GUN       0x0002
+#define UCC_SLOW_UCCE_GINT      0x0004
+#define UCC_SLOW_UCCE_IQOV      0x0008
+
+#define UCC_SLOW_UCCE_HDLC_SET  (UCC_SLOW_UCCE_TXE|UCC_SLOW_UCCE_BSY|UCC_SLOW_UCCE_GRA|UCC_SLOW_UCCE_TXB|UCC_SLOW_UCCE_RXF|UCC_SLOW_UCCE_DCC|UCC_SLOW_UCCE_GLT|UCC_SLOW_UCCE_GLR)
+#define UCC_SLOW_UCCE_ENET_SET  (UCC_SLOW_UCCE_TXE|UCC_SLOW_UCCE_BSY|UCC_SLOW_UCCE_GRA|UCC_SLOW_UCCE_TXB|UCC_SLOW_UCCE_RXF)
+#define UCC_SLOW_UCCE_TRANS_SET (UCC_SLOW_UCCE_TXE|UCC_SLOW_UCCE_BSY|UCC_SLOW_UCCE_GRA|UCC_SLOW_UCCE_TX |UCC_SLOW_UCCE_RX |UCC_SLOW_UCCE_DCC|UCC_SLOW_UCCE_GLT|UCC_SLOW_UCCE_GLR)
+#define UCC_SLOW_UCCE_UART_SET  (UCC_SLOW_UCCE_BSY|UCC_SLOW_UCCE_GRA|UCC_SLOW_UCCE_TXB|UCC_SLOW_UCCE_TX |UCC_SLOW_UCCE_RX |UCC_SLOW_UCCE_GLT|UCC_SLOW_UCCE_GLR)
+#define UCC_SLOW_UCCE_QMC_SET   (UCC_SLOW_UCCE_IQOV|UCC_SLOW_UCCE_GINT|UCC_SLOW_UCCE_GUN|UCC_SLOW_UCCE_GOV)
+
+#define UCC_SLOW_UCCE_OTHER     (UCC_SLOW_UCCE_TXE|UCC_SLOW_UCCE_BSY|UCC_SLOW_UCCE_GRA|UCC_SLOW_UCCE_DCC|UCC_SLOW_UCCE_GLT|UCC_SLOW_UCCE_GLR)
+
+#define UCC_SLOW_INTR_TX        UCC_SLOW_UCCE_TXB
+#define UCC_SLOW_INTR_RX        (UCC_SLOW_UCCE_RXF | UCC_SLOW_UCCE_RX)
+#define UCC_SLOW_INTR           (UCC_SLOW_INTR_TX  | UCC_SLOW_INTR_RX)
+
+/* Transmit On Demand (UTORD)
+*/
+#define UCC_SLOW_TOD            0x8000
+#define UCC_FAST_TOD            0x8000
+
+/* Function code masks.
+*/
+#define FC_GBL                             0x20
+#define FC_DTB_LCL                         0x02
+#define UCC_FAST_FUNCTION_CODE_GBL         0x20
+#define UCC_FAST_FUNCTION_CODE_DTB_LCL     0x02
+#define UCC_FAST_FUNCTION_CODE_BDB_LCL     0x01
+
+#endif				/* __QE_H__ */
+#endif				/* __KERNEL__ */
Index: linux-2.6.10/include/asm-ppc/qe_ic.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-ppc/qe_ic.h
@@ -0,0 +1,126 @@
+/*
+ * include/asm-ppc/qe_ic.h
+ *
+ * QE IC external definitions and structure.
+ *
+ * Author: Shlomi Gridih <gridish@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifdef __KERNEL__
+#ifndef __ASM_QE_IC_H__
+#define __ASM_QE_IC_H__
+
+#include <linux/irq.h>
+
+#define _IO_BASE        isa_io_base
+#define _ISA_MEM_BASE   isa_mem_base
+#ifdef CONFIG_PCI
+#define PCI_DRAM_OFFSET pci_dram_offset
+#else
+#define PCI_DRAM_OFFSET 0
+#endif
+
+#define NUM_OF_QE_IC_GROUPS    6
+
+/* Flags when we init the QE IC */
+#define QE_IC_SPREADMODE_GRP_W                   0x00000001
+#define QE_IC_SPREADMODE_GRP_X                   0x00000002
+#define QE_IC_SPREADMODE_GRP_Y                   0x00000004
+#define QE_IC_SPREADMODE_GRP_Z                   0x00000008
+#define QE_IC_SPREADMODE_GRP_RISCA               0x00000010
+#define QE_IC_SPREADMODE_GRP_RISCB               0x00000020
+
+#define QE_IC_LOW_SIGNAL                         0x00000100
+#define QE_IC_HIGH_SIGNAL                        0x00000200
+
+#define QE_IC_GRP_W_PRI0_DEST_SIGNAL_HIGH        0x00001000
+#define QE_IC_GRP_W_PRI1_DEST_SIGNAL_HIGH        0x00002000
+#define QE_IC_GRP_X_PRI0_DEST_SIGNAL_HIGH        0x00004000
+#define QE_IC_GRP_X_PRI1_DEST_SIGNAL_HIGH        0x00008000
+#define QE_IC_GRP_Y_PRI0_DEST_SIGNAL_HIGH        0x00010000
+#define QE_IC_GRP_Y_PRI1_DEST_SIGNAL_HIGH        0x00020000
+#define QE_IC_GRP_Z_PRI0_DEST_SIGNAL_HIGH        0x00040000
+#define QE_IC_GRP_Z_PRI1_DEST_SIGNAL_HIGH        0x00080000
+#define QE_IC_GRP_RISCA_PRI0_DEST_SIGNAL_HIGH    0x00100000
+#define QE_IC_GRP_RISCA_PRI1_DEST_SIGNAL_HIGH    0x00200000
+#define QE_IC_GRP_RISCB_PRI0_DEST_SIGNAL_HIGH    0x00400000
+#define QE_IC_GRP_RISCB_PRI1_DEST_SIGNAL_HIGH    0x00800000
+#define QE_IC_GRP_W_DEST_SIGNAL_SHIFT            (12)
+
+/*
+ * QE interrupt sources groups
+ */
+enum qe_ic_grp_id {
+	QE_IC_GRP_W = 0,	/* QE interrupt controller group W      */
+	QE_IC_GRP_X,		/* QE interrupt controller group X      */
+	QE_IC_GRP_Y,		/* QE interrupt controller group Y      */
+	QE_IC_GRP_Z,		/* QE interrupt controller group Z      */
+	QE_IC_GRP_RISCA,	/* QE interrupt controller RISC group A */
+	QE_IC_GRP_RISCB		/* QE interrupt controller RISC group B */
+};
+
+/*
+ * QE interrupt controller internal structure
+ */
+struct qe_ic_info {
+	u32 mask;		/* locaion of this source at the QIMR register.    */
+	int qimr;		/* TRUE is this source is mappd to QIMR,           */
+	/* otherwise - QRIMR (risc).                       */
+	u8 pri_code;		/* for grouped interrupts sources - the interrupt  */
+	/* code as appears at the group priority register. */
+};
+
+/*********************************************/
+/******   QE IC API routines             *****/
+/*********************************************/
+int qe_ic_init(phys_addr_t phys_addr,
+	       unsigned int flags, unsigned int irq_offset);
+void qe_ic_free(void);
+void qe_ic_enable_irq(unsigned int qeIntrSrc);
+void qe_ic_disable_irq(unsigned int qeIntrSrc);
+void qe_ic_disable_irq_and_ack(unsigned int irq);
+void qe_ic_end_irq(unsigned int irq);
+
+/* qe_ic_modify_highest_priority
+ * Optional, used to change default. This routine defines a single interrupt
+ * source to be highest priority. It may be called at any stage, thus enabling
+ * dynamic change of the highest priority interrupt.
+ * In default, Highest priority is XCC1 highest priority interrupt source.
+ *
+ * @Param    irq (In) -  Interrupt source Id.
+ */
+void qe_ic_modify_highest_priority(unsigned int irq);
+
+/* qe_ic_modify_priority
+ * Optional, used to change default. May be called at run time to manipulate
+ * priorities. This routine is called to reorganize a specific group.
+ *
+ * @Param    qeIcGroupId (In)         - One of:
+ *                                          e_QE_IC_GRP_W
+ *                                          e_QE_IC_GRP_X
+ *                                          e_QE_IC_GRP_Y
+ *                                          e_QE_IC_GRP_Z
+ *                                          e_QE_IC_GRP_RISCA
+ *                                          e_QE_IC_GRP_RISCB
+ * @Param    pri0, pr1,..., pri7 (In) - A list of interrupt sources (of type
+ *                                      unsigned int) in order of priority. The
+ *                                      list must include all and only sources
+ *                                      of the specified group.
+ */
+void qe_ic_modify_priority(enum qe_ic_grp_id qeIcGroupId,
+			   unsigned int pri0,
+			   unsigned int pri1,
+			   unsigned int pri2,
+			   unsigned int pri3,
+			   unsigned int pri4,
+			   unsigned int pri5,
+			   unsigned int pri6, unsigned int pri7);
+
+#endif				/* __ASM_QE_IC_H__ */
+#endif				/* __KERNEL__ */
Index: linux-2.6.10/include/linux/fsl_devices.h
===================================================================
--- linux-2.6.10.orig/include/linux/fsl_devices.h
+++ linux-2.6.10/include/linux/fsl_devices.h
@@ -111,5 +111,43 @@ struct fsl_usb2_platform_data {
 #define FSL_USB2_PORT0_ENABLED	0x00000001
 #define FSL_USB2_PORT1_ENABLED	0x00000002
 
+/* Ethernet interface (phy management and speed)
+*/
+typedef enum enet_interface {
+	ENET_10_MII,       /* 10 Base T,   MII interface */
+	ENET_10_RMII,      /* 10 Base T,  RMII interface */
+	ENET_10_RGMII,     /* 10 Base T, RGMII interface */
+	ENET_100_MII,      /* 100 Base T,   MII interface */
+	ENET_100_RMII,     /* 100 Base T,  RMII interface */
+	ENET_100_RGMII,    /* 100 Base T, RGMII interface */
+	ENET_1000_GMII,    /* 1000 Base T,  GMII interface */
+	ENET_1000_RGMII,   /* 1000 Base T, RGMII interface */
+	ENET_1000_TBI,     /* 1000 Base T,   TBI interface */
+	ENET_1000_RTBI     /* 1000 Base T,  RTBI interface */
+} enet_interface_e;
+
+struct ucc_geth_platform_data {
+	/* device specific information */
+	u32					device_flags;
+	u32					phy_reg_addr;
+
+	/* board specific information */
+	u32					board_flags;
+	u8					rx_clock;
+	u8					tx_clock;
+	u32					phy_id;
+	enet_interface_e	phy_interface;
+	u32					phy_interrupt;
+	u8					mac_addr[6];
+};
+
+/* Flags related to UCC Gigabit Ethernet device features */
+#define FSL_UGETH_DEV_HAS_GIGABIT	0x00000001
+#define FSL_UGETH_DEV_HAS_COALESCE	0x00000002
+#define FSL_UGETH_DEV_HAS_RMON		0x00000004
+
+/* Flags in ucc_geth_platform_data */
+#define FSL_UGETH_BRD_HAS_PHY_INTR	0x00000001	/* if not set use a timer */
+
 #endif				/* _FSL_DEVICE_H_ */
 #endif				/* __KERNEL__ */
Index: linux-2.6.10/arch/ppc/platforms/83xx/mpc834x_sys.h
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/83xx/mpc834x_sys.h
+++ linux-2.6.10/arch/ppc/platforms/83xx/mpc834x_sys.h
@@ -42,20 +42,4 @@
 #define PIRQC	MPC83xx_IRQ_EXT6
 #define PIRQD	MPC83xx_IRQ_EXT7
 
-#define MPC83xx_PCI1_LOWER_IO	0x00000000
-#define MPC83xx_PCI1_UPPER_IO	0x00ffffff
-#define MPC83xx_PCI1_LOWER_MEM	0x80000000
-#define MPC83xx_PCI1_UPPER_MEM	0x9fffffff
-#define MPC83xx_PCI1_IO_BASE	0xe2000000
-#define MPC83xx_PCI1_MEM_OFFSET	0x00000000
-#define MPC83xx_PCI1_IO_SIZE	0x01000000
-
-#define MPC83xx_PCI2_LOWER_IO	0x00000000
-#define MPC83xx_PCI2_UPPER_IO	0x00ffffff
-#define MPC83xx_PCI2_LOWER_MEM	0xa0000000
-#define MPC83xx_PCI2_UPPER_MEM	0xbfffffff
-#define MPC83xx_PCI2_IO_BASE	0xe3000000
-#define MPC83xx_PCI2_MEM_OFFSET	0x00000000
-#define MPC83xx_PCI2_IO_SIZE	0x01000000
-
 #endif                /* __MACH_MPC83XX_SYS_H__ */
Index: linux-2.6.10/arch/ppc/syslib/mpc83xx_sys.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/mpc83xx_sys.c
+++ linux-2.6.10/arch/ppc/syslib/mpc83xx_sys.c
@@ -92,6 +92,18 @@ struct ppc_sys_spec ppc_sys_specs[] = {
 			MPC83xx_USB2_DR, MPC83xx_MDIO
 		},
 	},
+	{
+		.ppc_sys_name	= "8360E",
+		.mask		= 0xFFFF0000,
+		.value		= 0x80480000,
+		.num_devices	= 6,
+		.device_list	= (enum ppc_sys_devices[])
+		{
+			MPC83xx_QE_UCC1,MPC83xx_QE_UCC2,MPC83xx_QE_UCC3,
+			MPC83xx_IIC1, MPC83xx_IIC2, MPC83xx_DUART,
+
+		},
+	},
 	{	/* default match */
 		.ppc_sys_name	= "",
 		.mask 		= 0x00000000,
Index: linux-2.6.10/arch/ppc/syslib/mpc83xx_devices.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/mpc83xx_devices.c
+++ linux-2.6.10/arch/ppc/syslib/mpc83xx_devices.c
@@ -77,6 +77,16 @@ static struct plat_serial8250_port seria
 	{ },
 };
 
+static struct ucc_geth_platform_data mpc83xx_ugeth1_pdata = {
+	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT,
+	.phy_reg_addr = 0x2000,
+};
+
+static struct ucc_geth_platform_data mpc83xx_ugeth2_pdata = {
+	.device_flags = FSL_UGETH_DEV_HAS_GIGABIT,
+	.phy_reg_addr = 0x3000,
+};
+
 struct platform_device ppc_sys_platform_devices[] = {
 	[MPC83xx_TSEC1] = {
 		.name = "fsl-gianfar",
@@ -238,6 +248,57 @@ struct platform_device ppc_sys_platform_
 			},
 		},
 	},
+	[MPC83xx_QE_UCC1] = {
+		.name = "fsl-ucc-geth",
+		.id     = 0,
+		.dev.platform_data = &mpc83xx_ugeth1_pdata,
+		.num_resources   = 2,
+		.resource = (struct resource[]) {
+			{
+				.start  = 0x12000,
+				.end    = 0x121ff,
+				.flags  = IORESOURCE_MEM,
+			},
+			{
+				.name   = "ucc1-irq",
+				.start  = MPC83xx_QE_IRQ_UCC1,
+				.end    = MPC83xx_QE_IRQ_UCC1,
+				.flags  = IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC83xx_QE_UCC2] = {
+		.name = "fsl-ucc-geth",
+		.id	= 1,
+		.dev.platform_data = &mpc83xx_ugeth2_pdata,
+		.num_resources	 = 2,
+		.resource = (struct resource[]) {
+			{
+				.start	= 0x13000,
+				.end	= 0x131ff,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.name	= "ucc2-irq",
+				.start	= MPC83xx_QE_IRQ_UCC2,
+				.end	= MPC83xx_QE_IRQ_UCC2,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC83xx_QE_UCC3] = {
+		.name = "fsl-ucc-atm",
+		.id = 0,
+		.num_resources = 1,
+		.resource = (struct resource[]) {
+			{
+				.name	= "ucc3-irq",
+				.start	= MPC83xx_QE_IRQ_UCC3,
+				.end	= MPC83xx_QE_IRQ_UCC3,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
 	[MPC83xx_MDIO] = {
 		.name = "fsl-gianfar_mdio",
 		.id = 0,
Index: linux-2.6.10/arch/ppc/syslib/ppc83xx_pci.h
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ppc83xx_pci.h
+++ linux-2.6.10/arch/ppc/syslib/ppc83xx_pci.h
@@ -19,6 +19,37 @@
 #ifndef __PPC_SYSLIB_PPC83XX_PCI_H
 #define __PPC_SYSLIB_PPC83XX_PCI_H
 
+typedef struct law {
+	u32	bar; /* LBIU local access window base address register */
+	u32 	ar;  /* LBIU local access window attribute register */
+} law_t;
+
+#define	LAWBAR_BAR	0xFFFFF000 /* Identifies the 20 most-significant address bits of the base of local access window n. The specified base address should be aligned to the window size, as defined by LBLAWARn[SIZE]. */
+#define	LAWBAR_RES	~(LAWBAR_BAR)
+#define	LAWAR_EN	0x80000000 /* 0 The local bus local access window n is disabled. 1 The local bus local access window n is enabled and other LBLAWAR0 and LBLAWBAR0 fields combine to identify an address range for this window. */
+#define	LAWAR_SIZE	0x0000003F /* Identifies the size of the window from the starting address. Window size is 2^(SIZE+1) bytes. 000000001010Reserved. Window is undefined. */
+#define	LAWAR_SIZE_4K	0x0000000B
+#define	LAWAR_SIZE_8K	0x0000000C
+#define	LAWAR_SIZE_16K	0x0000000D
+#define	LAWAR_SIZE_32K	0x0000000E
+#define	LAWAR_SIZE_64K	0x0000000F
+#define	LAWAR_SIZE_128K	0x00000010
+#define	LAWAR_SIZE_256K	0x00000011
+#define	LAWAR_SIZE_512K	0x00000012
+#define	LAWAR_SIZE_1M	0x00000013
+#define	LAWAR_SIZE_2M	0x00000014
+#define	LAWAR_SIZE_4M	0x00000015
+#define	LAWAR_SIZE_8M	0x00000016
+#define	LAWAR_SIZE_16M	0x00000017
+#define	LAWAR_SIZE_32M	0x00000018
+#define	LAWAR_SIZE_64M	0x00000019
+#define	LAWAR_SIZE_128M	0x0000001A
+#define	LAWAR_SIZE_256M	0x0000001B
+#define	LAWAR_SIZE_512M	0x0000001C
+#define	LAWAR_SIZE_1G	0x0000001D
+#define	LAWAR_SIZE_2G	0x0000001E
+#define	LAWAR_RES	~(LAWAR_EN|LAWAR_SIZE)
+
 typedef struct immr_clk {
 	u32 spmr; /* system PLL mode Register  */
 	u32 occr; /* output clock control Register  */
Index: linux-2.6.10/arch/ppc/syslib/ppc83xx_setup.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ppc83xx_setup.c
+++ linux-2.6.10/arch/ppc/syslib/ppc83xx_setup.c
@@ -318,14 +318,15 @@ mpc83xx_setup_hose(void)
 {
 	u32 val32;
 	volatile immr_clk_t * clk;
+        volatile law_t * pci_law;
 	struct pci_controller * hose1;
 #ifdef CONFIG_MPC83xx_PCI2
 	struct pci_controller * hose2;
 #endif
 	bd_t * binfo = (bd_t *)__res;
 
-	clk = ioremap(binfo->bi_immr_base + 0xA00,
-			sizeof(immr_clk_t));
+	clk = ioremap(binfo->bi_immr_base + 0xA00, sizeof(immr_clk_t));
+        pci_law = ioremap(binfo->bi_immr_base + 0x60, sizeof(law_t));
 
 	/*
 	 * Configure PCI controller and PCI_CLK_OUTPUT both in 66M mode
@@ -337,6 +338,16 @@ mpc83xx_setup_hose(void)
 
 	iounmap(clk);
 
+        /*
+         * Configure PCI Local Access Windows
+         */
+        pci_law[0].bar = MPC83xx_PCI1_LOWER_MEM & LAWBAR_BAR;
+        pci_law[0].ar = LAWAR_EN | LAWAR_SIZE_1G;
+        pci_law[1].bar = MPC83xx_PCI1_IO_BASE & LAWBAR_BAR;
+        pci_law[1].ar = LAWAR_EN | LAWAR_SIZE_32M;
+
+	iounmap(pci_law);
+
 	hose1 = pcibios_alloc_controller();
 	if(!hose1)
 		return;
Index: linux-2.6.10/mvl_patches/pro-0976.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0976.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(976);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

