#! /usr/bin/env bash
# Patch: -pro_arm_davinci_video_dm6467
# Date: Mon Jan 21 23:07:39 2008
# Source: Texas Instruments, Inc.
# MR: 26251
# Type: Enhancements
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
#  Video support for DM6467.
# 

PATCHNUM=1696
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments, Inc.
MR: 26251
Type: Enhancements
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:
 Video support for DM6467.

Index: linux-2.6.10/drivers/media/video/davinci/adv7343.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/adv7343.c
@@ -0,0 +1,2416 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* adv7343.c */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <media/davinci/adv7343.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <media/davinci/vid_encoder_if.h>
+
+unsigned char reg0 = 0x20;	/* MODE_REG0 */
+unsigned char reg1 = 0x00;	/* MODE_SELECT_REG */
+unsigned char reg2 = ADV7343_SD_MODE_REG2_DEFAULT;	/* SD_MODE_REG2 */
+unsigned char reg6 = 0x00;	/* HD_MODE_REG6 */
+unsigned char reg80 = ADV7343_SD_MODE_REG1_DEFAULT;	/* SD_MODE_REG1 */
+
+unsigned char reg3 = 0x0C;	/* SD_MODE_REG6 */
+unsigned char reg4 = 0x00;	/* SD_SCALE_LSB */
+unsigned char reg5 = 0x04;	/* SD_MODE_REG7 */
+unsigned char reg7 = 0xE8;	/* HD_MODE_REG4 */
+unsigned char reg9 = 0x01;	/* HD_MODE_REG2 */
+unsigned char reg10 = 0x3C;	/* HD_MODE_REG1 */
+unsigned char reg11 = 0x80;	/* Power Mode register */
+unsigned char reg12 = 0x10;	/* SD_CGMS_WSS */
+unsigned char reg13 = 0x10;	/* SD_MODE_REG3 */
+
+static int adv7343_initialize(struct vid_encoder_device *enc, int flag);
+static int adv7343_deinitialize(struct vid_encoder_device *enc);
+
+static int adv7343_setstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc);
+static int adv7343_getstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc);
+
+static int adv7343_setoutput(char *output, struct vid_encoder_device *enc);
+static int adv7343_getoutput(char *output, struct vid_encoder_device *enc);
+static int adv7343_enumoutput(int index,
+			      char *output, struct vid_encoder_device *enc);
+
+static int adv7343_set_params(void *params, struct vid_encoder_device *enc);
+static int adv7343_get_params(void *params, struct vid_encoder_device *enc);
+
+static int adv7343_setcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char val,
+			      struct vid_encoder_device *enc);
+static int adv7343_getcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char *val,
+			      struct vid_encoder_device *enc);
+
+static int adv7343_set_sdparams(struct adv7343_sd_params *, void *enc);
+static int adv7343_set_hdparams(struct adv7343_hd_params *, void *enc);
+static int adv7343_set_dnrparams(struct adv7343_dnr_params *, void *enc);
+static int adv7343_set_ssafparams(struct adv7343_ssaf_params *, void *enc);
+static int adv7343_set_filterparams(struct adv7343_filter_params *, void *enc);
+static int adv7343_set_rgbmatrix(struct adv7343_rgb_matrix *, void *enc);
+static int adv7343_set_gammaparams(struct adv7343_gamma_params *params,
+				   enum adv7343_params_type type, void *enc);
+
+static int adv7343_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int adv7343_write_vbi_data(struct vid_enc_sliced_vbi_data *data,
+				  struct vid_encoder_device *enc);
+static int adv7343_set_vbi_services(struct vid_enc_sliced_vbi_service
+				    *services, struct vid_encoder_device *enc);
+static int adv7343_get_sliced_cap(struct vid_enc_sliced_vbi_service
+				  *service, struct vid_encoder_device *enc);
+
+/* i2c function prototypes */
+static int adv7343_i2c_attach_client(struct i2c_client *,
+				     struct i2c_driver *,
+				     struct i2c_adapter *, int);
+static int adv7343_i2c_detach_client(struct i2c_client *);
+static int adv7343_i2c_probe_adapter(struct i2c_adapter *);
+static int adv7343_i2c_init(void);
+static void adv7343_i2c_cleanup(void);
+
+static int adv7343_start_display(struct vid_encoder_device *);
+static int adv7343_stop_display(struct vid_encoder_device *);
+
+/* following function is used to set ths7303 */
+static int ths7303_setvalue(struct vid_enc_mode_info *mode_info);
+
+static struct adv7343_control_info
+    adv7343_controls[ADV7343_COMPOSITE_NO_CONTROLS] = {
+	{
+	 .register_address = ADV7343_DAC1_OUTPUT_LEVEL,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_GAIN,
+	 .minimum = 0,
+	 .maximum = 255},
+	{
+	 .register_address = ADV7343_SD_BRIGHTNESS_WSS,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_BRIGHTNESS,
+	 .minimum = 0,
+	 .maximum = 127},
+	{
+	 .register_address = ADV7343_SD_HUE_REG,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_HUE,
+	 .minimum = 0,
+	 .maximum = 255}
+};
+
+static struct vid_enc_mode_info
+    adv7343_composite_standards[ADV7343_COMPOSITE_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0}
+};
+
+static struct vid_enc_mode_info
+    adv7343_component_standards[ADV7343_COMPONENT_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_720P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {60000, 1000},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {30, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {50, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_480P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {60, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_576P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {50, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_24,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {24, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+};
+
+struct adv7343_std_info adv7343_composite_std_info[ADV7343_COMPOSITE_NUM_STD] = {
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_NTSC, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_PAL_BDGHI, 0x8C, 0xCB, 0x8D, 0x8A, 0x8E, 0x09, 0x8F, 0x2A}
+};
+
+struct adv7343_std_info adv7343_component_std_info[ADV7343_COMPONENT_NUM_STD] = {
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_25 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_30 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_50 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080I << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080I_25fps << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_525P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_625P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_NTSC, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_PAL_BDGHI, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_24 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_25 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_30 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21}
+};
+
+static struct adv7343_config adv7343_configuration[ADV7343_NUM_CHANNELS] = {
+	{
+	 .no_of_outputs = ADV7343_MAX_NO_OUTPUTS,
+	 .output[0] = {
+		       .output_type = ADV7343_COMPOSITE_ID,
+		       .output_name = VID_ENC_OUTPUT_COMPOSITE,
+		       .no_of_standard = ADV7343_COMPOSITE_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_composite_standards,
+		       .def_std = &adv7343_composite_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_composite_std_info,
+		       .no_of_controls = ADV7343_COMPOSITE_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_COMPOSITE_POWER_VALUE},
+	 .output[1] = {
+		       .output_type = ADV7343_COMPONENT_ID,
+		       .output_name = VID_ENC_OUTPUT_COMPONENT,
+		       .no_of_standard = ADV7343_COMPONENT_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_component_standards,
+		       .def_std = &adv7343_component_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_component_std_info,
+		       .no_of_controls = ADV7343_COMPONENT_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_COMPONENT_POWER_VALUE},
+	 .output[2] = {
+		       .output_type = ADV7343_SVIDEO_ID,
+		       .output_name = VID_ENC_OUTPUT_SVIDEO,
+		       .no_of_standard = ADV7343_SVIDEO_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_composite_standards,
+		       .def_std = &adv7343_composite_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_composite_std_info,
+		       .no_of_controls = ADV7343_SVIDEO_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_SVIDEO_POWER_VALUE},
+	 .services_set = VID_ENC_SLICED_VBI_WSS_PAL |
+	 VID_ENC_SLICED_VBI_CGMS_NTSC | VID_ENC_SLICED_VBI_CC_NTSC,
+	 .num_services = 0}
+};
+
+static struct adv7343_service_data_reg
+    adv7343_services_regs[ADV7343_VBI_NUM_SERVICES] = {
+	{
+	 .service_set = VID_ENC_SLICED_VBI_CC_NTSC,
+	 .field = {
+		   {
+		    .addr = {ADV7343_SD_CLOSE_CAPTION_ODD0,
+			     ADV7343_SD_CLOSE_CAPTION_ODD1}
+		    },
+		   {
+		    .addr = {ADV7343_SD_CLOSE_CAPTION_EVEN0,
+			     ADV7343_SD_CLOSE_CAPTION_EVEN1}
+		    }
+		   },
+	 .bytestowrite = 2},
+	{
+	 .service_set = VID_ENC_SLICED_VBI_WSS_PAL,
+	 .field = {
+		   {
+		    .addr = {ADV7343_SD_CGMS_WSS2,
+			     ADV7343_SD_CGMS_WSS1}
+		    },
+		   {
+		    .addr = {ADV7343_SD_CGMS_WSS2,
+			     ADV7343_SD_CGMS_WSS1}
+		    }
+		   },
+	 .bytestowrite = 2}
+};
+
+static struct adv7343_service_reg adv7343_sliced_reg[ADV7343_VBI_NUM_SERVICES] = {
+
+	{
+	 .service = VID_ENC_SLICED_VBI_WSS_PAL,
+	 .reg = ADV7343_SD_CGMS_WSS0,
+	 .reg_val = &reg12,
+	 .enable_val = SD_WSS_EN,
+	 .disable_val = SD_WSS_DI,
+	 .std = &adv7343_composite_standards[1]},
+	{
+	 .service = VID_ENC_SLICED_VBI_CC_NTSC,
+	 .reg = ADV7343_SD_MODE_REG3,
+	 .reg_val = &reg13,
+	 .enable_val = SD_CLOSE_CAPTION_BOTH,
+	 .disable_val = SD_CLOSE_CAPTION_DI,
+	 .std = &adv7343_composite_standards[0]},
+	{
+	 .service = VID_ENC_SLICED_VBI_CGMS_NTSC,
+	 .reg = ADV7343_SD_CGMS_WSS0,
+	 .reg_val = &reg12,
+	 .enable_val = SD_CGMS_EN,
+	 .disable_val = SD_CGMS_DI,
+	 .std = &adv7343_composite_standards[0]}
+};
+
+static struct adv7343_channel adv7343_channel_info[ADV7343_NUM_CHANNELS] = {
+	{
+	 .current_output = ADV7343_COMPOSITE_ID,
+	 .mode_info = &adv7343_composite_standards[0],
+	 .i2c_dev = {
+		     .i2c_addr = (0x54 >> 1),
+		     .i2c_registration = 0},
+	 .enc_device = NULL}
+};
+
+/* Global variables */
+static struct device *adv7343_i2c_dev[ADV7343_NUM_CHANNELS];
+
+/* Global structures variables */
+static struct vid_enc_param_ops params_ops = {
+	.setparams = adv7343_set_params,
+	.getparams = adv7343_get_params
+};
+
+static struct vid_enc_control_ops controls_ops = {
+	.setcontrol = adv7343_setcontrol,
+	.getcontrol = adv7343_getcontrol
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = ADV7343_MAX_NO_OUTPUTS,
+	.enumoutput = adv7343_enumoutput,
+	.setoutput = adv7343_setoutput,
+	.getoutput = adv7343_getoutput
+};
+
+static struct vid_enc_mode_ops standards_ops = {
+	.setmode = adv7343_setstd,
+	.getmode = adv7343_getstd,
+};
+
+static struct vid_encoder_device adv7343_dev[ADV7343_NUM_CHANNELS] = {
+	{
+	 .name = "ADV7343",
+	 .channel_id = 0,
+	 .capabilities = 0,
+	 .initialize = adv7343_initialize,
+	 .mode_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .output_ops = &outputs_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = adv7343_deinitialize,
+	 .misc_ops = NULL,
+	 .write_vbi_data = adv7343_write_vbi_data,
+	 .enable_vbi = NULL,
+	 .enable_hbi = NULL,
+	 .set_vbi_services = adv7343_set_vbi_services,
+	 .get_sliced_cap = adv7343_get_sliced_cap,
+	 .start_display = adv7343_start_display,
+	 .stop_display = adv7343_stop_display}
+};
+
+/* This function is called by the vpif driver to initialize ADV7343 driver.
+ * It initializes all registers of adv7343 with the default values
+ */
+static int adv7343_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+	if (adv7343_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk(KERN_ERR "adv7343 driver is already initialized..\n");
+		return err;
+	}
+
+	/* Register ADV7343 I2C client */
+	err = i2c_add_driver(&adv7343_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register ADV7343 I2C client.\n");
+		return -EINVAL;
+	}
+	adv7343_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	adv7343_channel_info[ch_id].enc_device = enc;
+	if (VID_ENC_I2C_BIND_FLAG == flag) {
+		return err;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 driver registered\n");
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SOFT_RESET,
+				     ADV7343_SOFT_RESET_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_POWER_MODE_REG,
+				     ADV7343_POWER_MODE_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_MODE_SELECT_REG,
+				     ADV7343_MODE_SELECT_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_MODE_REG0,
+				     ADV7343_MODE_REG0_DEFAULT);
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_DAC1_OUTPUT_LEVEL,
+				     ADV7343_DAC1_OUTPUT_LEVEL_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_DAC2_OUTPUT_LEVEL,
+				     ADV7343_DAC2_OUTPUT_LEVEL_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG1,
+				     ADV7343_HD_MODE_REG1_DEFAULT);
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG2,
+				     ADV7343_HD_MODE_REG2_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG3,
+				     ADV7343_HD_MODE_REG3_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG4,
+				     ADV7343_HD_MODE_REG4_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG5,
+				     ADV7343_HD_MODE_REG5_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG6,
+				     ADV7343_HD_MODE_REG6_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG7,
+				     ADV7343_HD_MODE_REG7_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG1,
+				     ADV7343_SD_MODE_REG1_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG2,
+				     ADV7343_SD_MODE_REG2_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG3,
+				     ADV7343_SD_MODE_REG3_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG4,
+				     ADV7343_SD_MODE_REG4_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG5,
+				     ADV7343_SD_MODE_REG5_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG6,
+				     ADV7343_SD_MODE_REG6_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG7,
+				     ADV7343_SD_MODE_REG7_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG8,
+				     ADV7343_SD_MODE_REG8_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_TIMING_REG0,
+				     ADV7343_SD_TIMING_REG0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_TIMING_REG0,
+				     ADV7343_SD_TIMING_REG0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_HUE_REG,
+				     ADV7343_SD_HUE_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_CGMS_WSS0,
+				     ADV7343_SD_CGMS_WSS0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_BRIGHTNESS_WSS,
+				     ADV7343_SD_BRIGHTNESS_WSS_DEFAULT);
+
+	if (err < 0) {
+		err = -EINVAL;
+		adv7343_deinitialize(enc);
+		return err;
+	} else {
+		adv7343_channel_info[ch_id].current_output = 0;
+		adv7343_channel_info[ch_id].mode_info =
+		    &adv7343_composite_standards[0];
+		/* Configure for default video standard */
+		/* call set standard */
+		err |=
+		    adv7343_setoutput(adv7343_configuration[ch_id].
+				      output[0].output_name, enc);
+		err |=
+		    adv7343_setstd(adv7343_configuration[ch_id].output[0].
+				   def_std, enc);
+		if (err < 0) {
+			err = -EINVAL;
+			adv7343_deinitialize(enc);
+			return err;
+		}
+	}
+	adv7343_channel_info[ch_id].i2c_dev.i2c_registration |= 2;
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_initialize>\n");
+	return err;
+}
+
+static int adv7343_deinitialize(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+			deinitialization called\n");
+
+	if (adv7343_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&adv7343_channel_info[ch_id].i2c_dev.driver);
+		adv7343_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		adv7343_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		adv7343_channel_info[ch_id].enc_device = NULL;
+	}
+	return 0;
+}
+
+int adv7343_start_display(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+		start display called\n");
+
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+int adv7343_stop_display(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+			start display called\n");
+
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static int adv7343_set_vbi_services(struct vid_enc_sliced_vbi_service
+				    *services, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	unsigned char val1 = 0;
+	int i;
+	u8 num_services = 0;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_vbi_services\n");
+
+	if (NULL == services) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	if ((services->service_set |
+	     adv7343_configuration[ch_id].services_set) !=
+	    adv7343_configuration[ch_id].services_set) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid service\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < ADV7343_VBI_NUM_SERVICES; i++) {
+		if ((services->service_set & adv7343_sliced_reg[i].service)
+		    && (0 !=
+			strcmp(adv7343_sliced_reg[i].std->name,
+			       adv7343_channel_info[ch_id].mode_info->name))) {
+			dev_err(adv7343_i2c_dev[ch_id],
+				"Standard doesn't " "support this service\n");
+			return -EINVAL;
+		}
+		val1 = *adv7343_sliced_reg[i].reg_val;
+
+		if (services->service_set & adv7343_sliced_reg[i].service) {
+			val1 |= adv7343_sliced_reg[i].enable_val;
+			num_services++;
+		} else {
+			val1 &= adv7343_sliced_reg[i].disable_val;
+		}
+
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  adv7343_sliced_reg[i].reg, val1);
+		*adv7343_sliced_reg[i].reg_val = val1;
+	}
+	adv7343_configuration[ch_id].num_services = num_services;
+	adv7343_channel_info[ch_id].services_set = services->service_set;
+	return (err < 0) ? err : num_services;
+}
+
+/* This function is used to write the vbi data to the encoder device */
+static int adv7343_write_vbi_data(struct vid_enc_sliced_vbi_data *data,
+				  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0, j, k;
+	unsigned char val1 = 0, val2;
+	u8 num_services;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "adv7343_write_vbi_data:NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of adv7343_write_vbi_data..\n");
+	if (NULL == data) {
+		dev_err(adv7343_i2c_dev[ch_id], "adv7343_write_vbi_data:"
+			"NULL pointer.\n");
+		return -EINVAL;
+	}
+	num_services = adv7343_configuration[ch_id].num_services;
+	for (i = 0; i < num_services; i++) {
+		if (0 == data[i].service_id)
+			continue;
+		if ((data[i].service_id | adv7343_channel_info[ch_id].
+		     services_set) !=
+		    adv7343_channel_info[ch_id].services_set) {
+			printk(KERN_ERR "%d Service Id = %x\n", i,
+			       data[i].service_id);
+			dev_err(adv7343_i2c_dev[ch_id], "Invalid Service\n");
+			return -EINVAL;
+		}
+		for (j = 0; j < ADV7343_VBI_NUM_SERVICES; j++) {
+			if (!(adv7343_services_regs[j].service_set &
+			      data[i].service_id))
+				if (data[i].service_id !=
+				    VID_ENC_SLICED_VBI_CGMS_NTSC)
+					continue;
+			if (data[i].service_id & VID_ENC_SLICED_VBI_CGMS_NTSC) {
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS2,
+				     data[i].data[0]);
+
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS1,
+				     data[i].data[1]);
+
+				val1 = *adv7343_sliced_reg[2].reg_val;
+				val2 = data[i].data[2] & 0x0F;
+				val1 |= val2;
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS0, val1);
+				if (err < 0) {
+					dev_err(adv7343_i2c_dev[ch_id],
+						"adv7343_write_vbi_data failed\n");
+					return err;
+				}
+			} else {
+
+				for (k = 0; k <
+				     adv7343_services_regs[j].bytestowrite;
+				     k++) {
+					err |=
+					    adv7343_i2c_write_reg
+					    (&adv7343_channel_info[ch_id].
+					     i2c_dev.client,
+					     adv7343_services_regs[j].
+					     field[data[i].field].addr[k],
+					     data[i].data[0 + k]);
+					if (err < 0) {
+						dev_err(adv7343_i2c_dev
+							[ch_id],
+							"adv7343_write_vbi_data"
+							"failed\n");
+						return err;
+					}
+				}
+			}
+		}
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_write_vbi_data>\n");
+	return err;
+}
+
+/* This function is used to set the value of the control like brightness,
+   hue */
+static int adv7343_setcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char val, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int value;
+	int output_idx;
+	int ch_id, i = 0;
+	struct adv7343_control_info *control = NULL;
+	int no_of_controls;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_setcontrol>\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	value = val;
+	if ((strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_PAL) == 0)) {
+		no_of_controls = 3;
+	} else {
+		no_of_controls
+		    = adv7343_configuration[ch_id].output[output_idx].
+		    no_of_controls;
+	}
+
+	for (i = 0; i < no_of_controls; i++) {
+		control = &adv7343_configuration[ch_id].output[output_idx].
+		    controls[i];
+		if (control->id == ctrl) {
+			break;
+		}
+	}
+	if (i == no_of_controls) {
+		return -EINVAL;
+	}
+	if ((control->minimum > value)
+	    || (control->maximum < value)) {
+		return -EINVAL;
+	}
+	if (VID_ENC_CTRL_GAIN == ctrl) {
+		if ((value > POSITIVE_GAIN_MAX)
+		    && (value < NEGATIVE_GAIN_MIN)) {
+			return -EINVAL;
+		} else {
+			err |= adv7343_i2c_write_reg(&adv7343_channel_info
+						     [ch_id].i2c_dev.
+						     client,
+						     ADV7343_DAC2_OUTPUT_LEVEL,
+						     value);
+		}
+	}
+
+	err = adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				    client, control->register_address, value);
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"ADV7343 set control fails...\n");
+		return err;
+	}
+	control->value = value;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setcontrol>\n");
+	return err;
+}
+
+/* This function is used to get the value of the control */
+static int adv7343_getcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char *val,
+			      struct vid_encoder_device *enc)
+{
+	int err = 0, i;
+	int ch_id;
+	struct adv7343_control_info *control = NULL;
+	int output_idx;
+	int no_of_controls;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Starting getctrl of adv7343...\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	/* check for null pointer */
+	if (val == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	if ((strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_PAL) == 0)) {
+		no_of_controls = 3;
+	} else {
+		no_of_controls
+		    = adv7343_configuration[ch_id].output[output_idx].
+		    no_of_controls;
+	}
+
+	for (i = 0; i < no_of_controls; i++) {
+		control =
+		    &adv7343_configuration[ch_id].output[output_idx].
+		    controls[i];
+		if (control->id == ctrl) {
+			break;
+		}
+	}
+	if (i == no_of_controls) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	*val = control->value;
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"ADV7343 get control fails...\n");
+		return err;
+	}
+	if (VID_ENC_CTRL_BRIGHTNESS == ctrl) {
+		(*val) &= SD_BRIGHTNESS_MASK;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_getcontrol>\n");
+	return err;
+}
+
+/* following function is used to set ths7303 */
+static int ths7303_setvalue(struct vid_enc_mode_info *mode)
+{
+	int err = 0;
+	u8 val[2];
+	u8 val1;
+	u16 ths7303_i2c_addr = 0x2C;
+
+	if (NULL == mode) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((strcmp(mode->name, VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(mode->name, VID_ENC_STD_PAL) == 0))
+		val1 = 0x02;
+	else if ((strcmp(mode->name, VID_ENC_STD_480P_60) == 0) ||
+		 (strcmp(mode->name, VID_ENC_STD_576P_50) == 0))
+		val1 = 0x4A;
+	else
+		val1 = 0x92;
+
+	val[0] = 0x01;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	val[0] = 0x02;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	val[0] = 0x03;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	if (err) {
+		printk(KERN_ERR "ths7303\n");
+	}
+	mdelay(100);
+	return err;
+}
+
+static int adv7343_setstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct vid_enc_mode_info *standard;
+	int output_idx;
+	unsigned char val1, val2;
+	u8 reg, val;
+	struct vid_enc_sliced_vbi_service services;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of adv7343_setstd..\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	if (mode_info == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < adv7343_configuration[ch_id].output[output_idx].
+	     no_of_standard; i++) {
+		standard =
+		    &adv7343_configuration[ch_id].output[output_idx].
+		    standard[i];
+		if (strcmp(standard->name, mode_info->name) == 0) {
+			break;
+		}
+	}
+	if (i == adv7343_configuration[ch_id].output[output_idx].no_of_standard) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	/* Read Mode Select Register */
+	val1 = reg1;
+
+	val2 = *(adv7343_configuration[ch_id].
+		 output[output_idx].std_info[i].value);
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	val2 &=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    standard_val2;
+	val2 |=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    standard_val3;
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client,
+				  adv7343_configuration[ch_id].
+				  output[output_idx].std_info[i].
+				  set_std_register, val2);
+	*(adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	  value) = val2;
+
+	val1 &= (~((u8) INPUT_MODE_MASK));
+
+	val1 |=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    outputmode_val1;
+
+	/* Write val1 to Mode select register */
+
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_MODE_SELECT_REG, val1);
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	reg1 = val1;
+
+	/* Store the standard in global object of adv7343 */
+	adv7343_channel_info[ch_id].mode_info =
+	    &adv7343_configuration[ch_id].output[output_idx].standard[i];
+	ths7303_setvalue(adv7343_channel_info[ch_id].mode_info);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc0_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc0_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG0,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc0_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc1_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc1_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG1,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc1_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc2_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc2_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG2,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc2_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc3_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc3_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG3,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc3_val);
+	val1 = reg80;
+	if (0 == strcmp(mode_info->name, VID_ENC_STD_NTSC)) {
+		val1 &= 0x03;
+	} else if (0 == strcmp(mode_info->name, VID_ENC_STD_PAL)) {
+		val1 |= 0x04;
+	}
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG1, val1);
+	reg80 = val1;
+
+	/* disable all VBI sliced vbi services */
+	services.service_set = 0;
+	err |= adv7343_set_vbi_services(&services, enc);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setstd>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected standard.*/
+static int adv7343_getstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Starting getstd function.\n");
+
+	if (mode_info == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Read the video standard */
+	memcpy(mode_info, adv7343_channel_info[ch_id].mode_info,
+	       sizeof(struct vid_enc_mode_info));
+	dev_dbg(adv7343_i2c_dev[ch_id], "End of getstd function.\n");
+	return err;
+}
+
+static int adv7343_get_sliced_cap(struct vid_enc_sliced_vbi_service
+				  *service, struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc || NULL == service) {
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+
+	service->service_set = adv7343_configuration[ch_id].services_set;
+	return 0;
+}
+static int adv7343_enumoutput(int index, char *output,
+			      struct vid_encoder_device *enc)
+{
+	int err = 0, ch_id;
+	if (NULL == enc || NULL == output) {
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	if (index >= adv7343_configuration[ch_id].no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		adv7343_configuration[ch_id].output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	return err;
+}
+
+/* Following function is used to set output format in ADV7343 device. The index
+   of the output format is  passed as the argument to this function. */
+static int adv7343_setoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id, i;
+	int index;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of set output function.\n");
+
+	/* check for null pointer */
+	if (output == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < adv7343_configuration[ch_id].no_of_outputs; i++) {
+		if (0 == strcmp(output,
+				adv7343_configuration[ch_id].output[i].
+				output_name))
+			break;
+	}
+	if (i == adv7343_configuration[ch_id].no_of_outputs)
+		return -EINVAL;
+	index = i;
+	/* Enable Appropriate DAC */
+	val1 = reg11;
+	val1 &= 0x03;
+	val1 |= adv7343_configuration[ch_id].output[index].power_val;
+	err = adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				    client, ADV7343_POWER_MODE_REG, val1);
+	reg11 = val1;
+	/* Enable YUV output mode in Mode Register 0 */
+
+	/* Read Mode register 0 */
+	val1 = reg0;
+
+	/* Enable YUV output */
+	val1 |= YUV_OUTPUT_SELECT;
+
+	/* write Mode register 0 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_MODE_REG0, val1);
+	reg0 = val1;
+
+	/* Read SD MODE REGISTER 2 */
+	val2 = reg2;
+
+	/* configure SD DAC Output 2 and SD DAC Output 1 bit to zero */
+	val2 &= (SD_DAC_1_DI & SD_DAC_2_DI);
+
+	/* write SD MODE REGISTER 2 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG2, val2);
+	if (err < 0) {
+		return err;
+	}
+	reg2 = val2;
+
+	/* Read HD MODE REGISTER 6 */
+	val2 = reg6;
+
+	/* configure ED/HD Color DAC Swap and ED/HD RGB Input Enable bit to
+	 * zero */
+	val2 &= (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);
+
+	/* write HD MODE REGISTER 6 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_HD_MODE_REG6, val2);
+	if (err < 0) {
+		return err;
+	}
+	reg6 = val2;
+
+	adv7343_channel_info[ch_id].current_output = index;
+
+	/* set default standard */
+	adv7343_channel_info[ch_id].mode_info
+	    = adv7343_configuration[ch_id].output[index].def_std;
+	err |= adv7343_setstd(adv7343_channel_info[ch_id].mode_info, enc);
+	if (err < 0) {
+		return err;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get index of the output currently selected.*/
+static int adv7343_getoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int index;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of get output function.\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = adv7343_channel_info[ch_id].current_output;
+	strncpy(output, adv7343_configuration[ch_id].output[index].
+		output_name, VID_ENC_NAME_MAX_CHARS);
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_getoutput>\n");
+	return err;
+}
+
+/* This function is used to set parameters depending on the type */
+static int adv7343_set_params(void *p, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	adv7343_params params;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_params>\n");
+	/* Check for null value */
+	if (!(adv7343_params *) p) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&params, (adv7343_params *) p, sizeof(params))) {
+		return -EFAULT;
+	}
+
+	if (ADV7343_SDPARAMS == params.type) {
+		/* If parameter type is SD parameters, call
+		 * adv7343_set_sdparams function to set SD parameters */
+		err = adv7343_set_sdparams(&(params.params.sd), enc);
+	} else if (ADV7343_HDPARAMS == params.type) {
+		/* If parameter type is HD parameters, call
+		 * adv7343_set_hdparams function to set HD parameters */
+		err = adv7343_set_hdparams(&(params.params.hd), enc);
+	} else {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_params:invalid type of parameter\n");
+		return -EINVAL;
+	}
+	adv7343_channel_info[ch_id].params = params;
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_params>\n");
+	return err;
+}
+
+/* This function is used to get parameters depending on the type */
+static int adv7343_get_params(void *p, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	adv7343_params *params = (adv7343_params *) p;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_get_params>\n");
+	/* Check for null value */
+	if (!params) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_get_params:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_to_user(params, &(adv7343_channel_info[ch_id].params),
+			 sizeof(*params))) {
+		return -EFAULT;
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_get_params>\n");
+	return err;
+}
+
+/* This function is used to set SD parameters */
+static int adv7343_set_sdparams(struct adv7343_sd_params *sd, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2, val3;
+	int ch_id;
+	struct i2c_client *ch_client;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_sdparams>\n");
+	/* Check for null value */
+	if (!sd) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(sd->active_step_edge_scale))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:invalid value of"
+			" active_step_edge_scale\n");
+		return -EINVAL;
+	}
+	if (!(ADV7343_VALID_FEATURE_VAL(sd->scale.en_scale))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:invalid value of"
+			" scale.en_scale\n");
+		return -EINVAL;
+	}
+	/* Set Luma and chroma filter in SD Mode register 0 */
+	val1 = reg80;
+
+	/* Set PbPr color difference filter in SD Mode register 1 */
+	val3 = reg2;
+
+	val1 &= (~(SD_LUMA_FLTR_MASK << SD_LUMA_FLTR_SHIFT));
+	val1 |= ((sd->luma_filter & SD_LUMA_FLTR_MASK) << SD_LUMA_FLTR_SHIFT);
+
+	if (sd->chroma_filter != ADV7343_CHROMA_SSAF) {
+		val1 &= (~(SD_CHROMA_FLTR_MASK << SD_CHROMA_FLTR_SHIFT));
+		val1 |= ((sd->chroma_filter & SD_CHROMA_FLTR_MASK) <<
+			 SD_CHROMA_FLTR_SHIFT);
+		val3 &= SD_PBPR_SSAF_DI;
+	} else {
+		val3 |= SD_PBPR_SSAF_EN;
+	}
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG1, val1);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG2, val3);
+	reg80 = val1;
+	reg2 = val3;
+
+	/* Call adv7343_set_ssafparams to set ssaf parameters */
+	err = adv7343_set_ssafparams(&sd->ssaf, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_dnrparams to set dnr parameters */
+	err = adv7343_set_dnrparams(&sd->dnr, enc);
+	if (err < 0)
+		return err;
+
+	/* Set scalling parameters in ADV7343 SD Y,U,V Scale registers and
+	 * enable it on SD Mode register 4 */
+	val3 = reg3;
+	if (sd->scale.en_scale == ADV7343_ENABLE) {
+		/* Enable scaling in ADV7343 register */
+		val3 |= SD_PBPR_SCALE_EN;
+		val3 |= SD_Y_SCALE_EN;
+
+		val1 = 0;
+
+		sd->scale.y_scale &= SD_YPBPR_SCALE_MASK;
+		sd->scale.pb_scale &= SD_YPBPR_SCALE_MASK;
+		sd->scale.pr_scale &= SD_YPBPR_SCALE_MASK;
+
+		/* Write pr scale value in ADV Register */
+		val2 = (u8) ((sd->scale.pr_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 = (sd->scale.pr_scale & SD_YPBPR_SCALE_LMASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_CR_SCALE, val2);
+
+		/* Write pb scale value in ADV Register */
+		val2 = (u8) ((sd->scale.pb_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 <<= SD_YPBPR_SCALE_SHIFT;
+		val1 |= (sd->scale.pb_scale & SD_YPBPR_SCALE_LMASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_CB_SCALE, val2);
+
+		/* Write y scale value in ADV Register */
+		val2 = (u8) ((sd->scale.y_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 <<= SD_YPBPR_SCALE_SHIFT;
+		val1 |= sd->scale.y_scale & SD_YPBPR_SCALE_LMASK;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_Y_SCALE, val2);
+
+		val2 = reg4;
+		val2 |= val1;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_SCALE_LSB, val2);
+		reg4 = val2;
+	} else {
+		/* Disable scaling in ADV7343 register */
+		val3 &= SD_PBPR_SCALE_DI;
+		val3 &= SD_Y_SCALE_DI;
+	}
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG6, val3);
+	reg3 = val3;
+
+	/* Enable active and step edge control in SD Mode register 1 if it is
+	   enabled in sd */
+	val1 = reg2;
+	if (sd->active_step_edge_scale == ADV7343_ENABLE) {
+		val1 |= SD_ACTIVE_EDGE_EN;
+	} else {
+		val1 &= SD_ACTIVE_EDGE_DI;
+	}
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG2, val1);
+	reg2 = val1;
+
+	/* Call adv7343_set_gammaparams to set gamma correction parameters */
+	err = adv7343_set_gammaparams(&sd->gamma, ADV7343_SDPARAMS, enc);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_sdparams>\n");
+	return err;
+}
+
+/* This function is used to set Gamma Correction parameters */
+static int adv7343_set_gammaparams(struct adv7343_gamma_params *params,
+				   enum adv7343_params_type type, void *enc)
+{
+	int err = 0, i;
+	unsigned char val1, reg = 0;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_gammaparams>\n");
+	/* Check for null value */
+	if (!params) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(params->en_gamma))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:invalid value"
+			" of en_gamma\n");
+		return -EINVAL;
+	}
+	/* Check for invalid curve */
+	if ((ADV7343_ENABLE == params->en_gamma)
+	    && (!(ADV7343_VALID_GAMMA_CURVE(params->curve)))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:invalid curve type\n");
+		return -EINVAL;
+	}
+
+	/* Write the gamma coefficient in */
+	if (ADV7343_SDPARAMS == type) {
+		val1 = reg5;
+	} else {
+		val1 = reg6;
+	}
+
+	/* If gamm enabled, enable gamma correction in SD Mode Register 5
+	 * or HD Mode register 6 */
+	if (params->en_gamma == ADV7343_ENABLE) {
+		if (ADV7343_SDPARAMS == type) {
+			val1 |= SD_GAMMA_EN;
+			/* Select gamm curve in the same register */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (val1 |= SD_GAMMA_CURVE_B)
+			    : (val1 &= SD_GAMMA_CURVE_A);
+
+			/* Select base register for gamma coefficients as per
+			 * the curve selected */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (reg = ADV7343_SD_GAMMA_B0)
+			    : (reg = ADV7343_SD_GAMMA_A0);
+
+		} else {
+			val1 |= HD_GAMMA_EN;
+
+			/* Select gamm curve in the same register */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (val1 |= HD_GAMMA_CURVE_B)
+			    : (val1 &= HD_GAMMA_CURVE_A);
+
+			/* Select base register for gamma coefficients as per
+			 * the curve selected */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (reg = ADV7343_HD_GAMMA_B0)
+			    : (reg = ADV7343_HD_GAMMA_A0);
+		}
+		/* Write the gamma coefficient in */
+		for (i = reg; i < reg + ADV7343_MAX_GAMMA_COEFFS; i++) {
+			err |=
+			    adv7343_i2c_write_reg(&adv7343_channel_info
+						  [ch_id].i2c_dev.client,
+						  i, params->coeff[i - reg]);
+		}
+	} else {
+		/* Disable the gamma curve */
+		if (ADV7343_SDPARAMS == type) {
+			val1 &= SD_GAMMA_DI;
+		} else {
+			val1 &= HD_GAMMA_DI;
+		}
+	}
+
+	/* Write the value to the register */
+	if (ADV7343_SDPARAMS == type) {
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_MODE_REG7, val1);
+		reg5 = val1;
+	} else {
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_gammaparams>\n");
+	return err;
+}
+
+/* This function is used to set HD parameters */
+static int adv7343_set_hdparams(struct adv7343_hd_params *hd, void *enc)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_hdparams>\n");
+	if (!hd) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!ADV7343_VALID_FEATURE_VAL(hd->sinc_filter)) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:invalid value"
+			" of sinc filter\n");
+		return -EINVAL;
+	}
+	if (!ADV7343_VALID_FEATURE_VAL(hd->ssaf_filter)) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:invalid value"
+			" of ssaf filter\n");
+		return -EINVAL;
+	}
+
+	/* Set the HD filters in HD Mode register 4 */
+	val = reg7;
+
+	if (hd->sinc_filter == ADV7343_ENABLE) {
+		val |= HD_SYNC_FLTR_EN;
+	} else {
+		val &= HD_SYNC_FLTR_DI;
+	}
+
+	if (hd->ssaf_filter == ADV7343_ENABLE) {
+		val |= HD_CHROMA_SSAF_EN;
+	} else {
+		val &= HD_CHROMA_SSAF_DI;
+	}
+
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_HD_MODE_REG4, val);
+	reg7 = val;
+
+	/* Call adv7343_set_rgbparams function to set RGB params */
+	err = adv7343_set_rgbmatrix(&hd->rgb, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_filterparams function to set filter params */
+	err = adv7343_set_filterparams(&hd->filt_params, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_gammaparams function to set gamma correction
+	   parameters */
+	err = adv7343_set_gammaparams(&hd->gamma, ADV7343_HDPARAMS, enc);
+	if (err < 0)
+		return err;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_hdparams>\n");
+	return err;
+}
+
+/* This function is used to set DNR parameters */
+static int adv7343_set_dnrparams(struct adv7343_dnr_params *dnr, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_dnrparams>\n");
+	/* Check for null value */
+	if (!dnr) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(dnr->en_dnr))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid value" " of en_dnr\n");
+		return -EINVAL;
+	}
+	/* If DNR is disabled, disable it in ADV registers */
+
+	/* Read SD Mode Register 5 to enable/disable DNR */
+	val1 = reg5;
+
+	if (dnr->en_dnr == ADV7343_DISABLE) {
+
+		/* Disable DNR in SD Mode register 5 */
+		val1 &= SD_DNR_DI;
+
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_MODE_REG7, val1);
+		reg5 = val1;
+		return err;
+	}
+
+	/* Check for invalid values */
+	if (dnr->data_gain > SD_DNR_GAIN_MAX
+	    || dnr->border_gain > SD_DNR_GAIN_MAX
+	    || dnr->threshold > SD_DNR_THRESHOLD_MAX) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:gain is out of bound\n");
+		return -EINVAL;
+	}
+	if (ADV7343_DNR_BLOCK_16 != dnr->block_size &&
+	    ADV7343_DNR_BLOCK_8 != dnr->block_size) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid block size\n");
+		return -EINVAL;
+	}
+	if (ADV7343_BORDER_AREA_4 != dnr->area &&
+	    ADV7343_BORDER_AREA_4 != dnr->area) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid border area\n");
+		return -EINVAL;
+	}
+	if (ADV7343_MODE_DNR_SHARPNESS != dnr->mode &&
+	    ADV7343_MODE_DNR != dnr->mode) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid mode\n");
+		return -EINVAL;
+	}
+
+	/* Enable DNR in SD Mode register 5 */
+	val1 |= SD_DNR_EN;
+
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG7, val1);
+	reg5 = val1;
+
+	/* Write value of Data and Border gain in DNR 0 Register */
+	val1 = (dnr->data_gain & SD_DNR_DATA_GAIN_MASK);
+	val1 <<= SD_DNR_DATA_GAIN_SHIFT;
+	val1 |= (dnr->border_gain & SD_DNR_BORDER_GAIN_MASK);
+
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR0, val1);
+
+	val1 = dnr->threshold & SD_DNR_THRESHOLD_MASK;
+	if (ADV7343_DNR_BLOCK_16 == dnr->block_size) {
+		val1 |= SD_BLOCK_SIZE_16x16;
+	} else {
+		val1 &= SD_BLOCK_SIZE_8x8;
+	}
+
+	if (ADV7343_BORDER_AREA_4 == dnr->area) {
+		val1 |= SD_BORDER_AREA_4PIXELS;
+	} else {
+		val1 &= SD_BORDER_AREA_2PIXELS;
+	}
+
+	/* Write the value of border size, block size and threshold in DNR 1
+	   Register */
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR1, val1);
+
+	val1 = dnr->filt_select;
+
+	if (ADV7343_MODE_DNR_SHARPNESS == dnr->mode) {
+		val1 |= SD_DNR_SHARPNESS_MODE;
+	} else {
+		val1 &= SD_DNR_MODE;
+	}
+
+	val2 = (dnr->block_offset & SD_DNR_BLOCK_OFFSET_MASK);
+	val2 <<= SD_DNR_BLOCK_OFFSET_SHIFT;
+	val1 |= val2;
+	/* Write the value of block offset and DNR mode in DNR 2 register */
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR2, val1);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_dnrparams>\n");
+	return err;
+}
+
+/* This function is used to set SSAF filter parameters */
+static int adv7343_set_ssafparams(struct adv7343_ssaf_params *ssaf, void *enc)
+{
+	int err = 0;
+	unsigned char val1;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_ssafparams>\n");
+
+	/* Check for null value */
+	if (!ssaf) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_ssafparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(ssaf->en_gain))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_ssafparams:invalid value" " of en_gain\n");
+		return -EINVAL;
+	}
+
+	/* Read SD Mode register 4 */
+	val1 = reg3;
+
+	/* If ssaf gain is enabled */
+	if (ssaf->en_gain == ADV7343_ENABLE) {
+		/* If gain value is out of bound return error */
+		if (ssaf->gain > SD_LUMA_SSAF_GAIN_MAX) {
+			dev_err(adv7343_i2c_dev[ch_id],
+				"adv7343_set_ssafparams:Invalid"
+				" value of gain\n");
+			return -EINVAL;
+		}
+
+		/* Enable SSAF Gain in SD Mode Register 4 */
+		val1 |= SD_LUMA_SSAF_GAIN_EN;
+
+		/* Write value of gain in SD LUMA SSAF register */
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_LUMA_SSAF, ssaf->gain);
+	} else {
+		/* Disable ssaf gain */
+		/* Disable SSAF Gain in SD Mode Register 4 */
+		val1 &= SD_LUMA_SSAF_GAIN_DI;
+	}
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_MODE_REG6, val1);
+	reg3 = val1;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_ssafparams>\n");
+	return err;
+}
+
+/* This function is used to set filter parameters for HD */
+static int adv7343_set_filterparams(struct adv7343_filter_params *filt,
+				    void *enc)
+{
+	int err = 0;
+	unsigned char val1;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_filterparams>\n");
+
+	/* Check for null value */
+	if (!filt) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(filt->en_filter))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:invalid value of "
+			"en_filter\n");
+		return -EINVAL;
+	}
+	/* If filter is not enabled, return */
+	if (filt->en_filter == ADV7343_DISABLE) {
+		/* Disable both sharpness and adaptive filters */
+		val1 = reg9;
+
+		val1 &= HD_SHARPNESS_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		val1 = reg6;
+
+		val1 &= HD_ADPT_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_filterparams L\n");
+		return 0;
+	}
+
+	/* Switch on the value of mode */
+	switch (filt->mode) {
+		/* If the case is for mode sharpness */
+	case ADV7343_FILTER_MODE_SHARPNESS:
+		/* Read HD Mode Register 2 to enable sharpness filter */
+		val1 = reg9;
+		val1 |= HD_SHARPNESS_FLTR_EN;
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		/* Disable adaptive filter in HD Mode Register 2 */
+		val1 = reg6;
+
+		val1 &= HD_ADPT_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 *  gain register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     filt->sharpness);
+		break;
+
+		/* If the case is for mode A */
+	case ADV7343_FILTER_MODE_A:
+		/* enable sharpness filter in HD Mode Register 2 */
+		val1 = reg9;
+
+		val1 |= HD_SHARPNESS_FLTR_EN;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+		/* Enable adaptive filter and mode A in HD Mode
+		 * Register 6 */
+		val1 = reg6;
+
+		val1 |= HD_ADPT_FLTR_EN;
+		val1 &= HD_ADPT_FLTR_MODEA;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 *  gain register */
+		val1 = (filt->sharpness & HD_SHARPNESS_FLTR_B_MASK)
+		    << HD_SHARPNESS_FLTR_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     val1);
+		filt->sharpness = val1;
+
+		/* Write the value of thresholds in HD thresholds
+		 * register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDA,
+					     filt->threshold_a);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDB,
+					     filt->threshold_b);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDC,
+					     filt->threshold_c);
+		filt->gain1_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain2_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain3_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+
+		/* Write value of filter gains in HD Gains registers */
+		val1 = (filt->gain1_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN1, val1);
+
+		val1 = (filt->gain2_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN2, val1);
+
+		val1 = (filt->gain3_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN3, val1);
+
+		break;
+
+		/* If the case is for mode B */
+	case ADV7343_FILTER_MODE_B:
+		/* enable sharpness filter in HD Mode Register 2 */
+		val1 = reg9;
+
+		val1 |= HD_SHARPNESS_FLTR_EN;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		/* Enable adaptive filter and mode B in HD Mode
+		 * Register 6 */
+		val1 = reg6;
+		val1 |= HD_ADPT_FLTR_EN;
+		val1 |= HD_ADPT_FLTR_MODEB;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 * gain register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     filt->sharpness);
+		filt->gain1_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain2_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain3_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain1_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+		filt->gain2_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+		filt->gain3_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+
+		/* Write the value of thresholds in HD thresholds
+		 * register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDA,
+					     filt->threshold_a);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDB,
+					     filt->threshold_b);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDC,
+					     filt->threshold_c);
+
+		/* Write value of filter gains in HD Gains registers */
+		val1 = (filt->gain1_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain1_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN1, val1);
+
+		val1 = (filt->gain2_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain2_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN2, val1);
+
+		val1 = (filt->gain3_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain3_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN3, val1);
+		break;
+
+	default:
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:invalid Mode\n");
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_filterparams>\n");
+	return err;
+}
+
+/* This function is used to set RGB matrix coeffiecients */
+static int adv7343_set_rgbmatrix(struct adv7343_rgb_matrix *rgb, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_rgbmatrix>\n");
+
+	/* Check for null value */
+	if (!rgb) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_rgbmatrix:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(rgb->en_rgb_matrix))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_rgbmatrix:invalid value of "
+			"en_rgb_matrix\n");
+		return -EINVAL;
+	}
+	/* Disable RGB matrix in Mode Register 0 */
+	val1 = reg0;
+
+	/* If rgb matrix is not enabled, return */
+	if (rgb->en_rgb_matrix == ADV7343_DISABLE) {
+		val1 &= CSC_MATRIX_DI;
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_MODE_REG0, val1);
+		reg0 = val1;
+		dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_rgbmatrix L\n");
+		return err;
+	}
+
+	/* Enable RGB matrix in Mode Register 0 */
+	val1 |= CSC_MATRIX_EN;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_MODE_REG0, val1);
+	reg0 = val1;
+
+	rgb->gy &= CSC_MATRIX_MASK;
+	rgb->gu &= CSC_MATRIX_MASK;
+	rgb->gv &= CSC_MATRIX_MASK;
+	rgb->bu &= CSC_MATRIX_MASK;
+	rgb->rv &= CSC_MATRIX_MASK;
+
+	/* Write the value GY in RGB matrix 2 register */
+	val1 = (rgb->gy & CSC_LSB_MASK);
+	val2 = (u8) (rgb->gy >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX0, val1);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX2, val2);
+
+	/* Write the value GU in RGB matrix 3 register */
+	val1 = (rgb->gu & CSC_LSB_MASK);
+	val2 = (rgb->gu >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX3, val2);
+
+	/* Write the value GR in RGB matrix 4 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->gv & CSC_LSB_MASK);
+	val2 = (rgb->gv >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX4, val2);
+
+	/* Write the value BU in RGB matrix 5 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->bu & CSC_LSB_MASK);
+	val2 = rgb->bu >> CSC_SHIFT;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX5, val2);
+
+	/* Write the value RV in RGB matrix 6 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->rv & CSC_LSB_MASK);
+	val2 = rgb->rv >> CSC_SHIFT;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX6, val2);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX1, val1);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_rgbmatrix>\n");
+	return err;
+}
+
+/*This function is used to write value into register using i2c client. */
+static int adv7343_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		dev_dbg(adv7343_i2c_dev[0], "adv7343 i2c WRITE start \n");
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(adv7343_i2c_dev[0], "adv7343 i2c WRITE end \n");
+
+	return ((err < 0) ? err : 0);
+}
+
+/* This function is used to attach i2c client */
+static int adv7343_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* This function is used to detach i2c client */
+static int adv7343_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+static int adv7343_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	adv7343_i2c_dev[0] = &(adap->dev);
+	dev_dbg(adv7343_i2c_dev[0], "ADV7343 i2c probe adapter called...\n");
+	/* Attach the client */
+	err = adv7343_i2c_attach_client(&adv7343_channel_info[0].i2c_dev.
+					client,
+					&adv7343_channel_info[0].i2c_dev.
+					driver, adap,
+					adv7343_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(adv7343_i2c_dev[0], "ADV7343 i2c probe adapter ends...\n");
+	return err;
+
+}
+
+/* This function used to initialize the i2c driver */
+static int adv7343_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j;
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+
+	char strings[ADV7343_NUM_CHANNELS][80] = {
+		"ADV7343 encoder I2C driver"
+	};
+
+	for (i = 0; i < ADV7343_NUM_CHANNELS; i++) {
+		driver = &adv7343_channel_info[i].i2c_dev.driver;
+		driver->owner = THIS_MODULE;
+		strlcpy(driver->name, strings[i], sizeof(strings[i]));
+		driver->id = I2C_DRIVERID_EXP0;
+		driver->flags = I2C_DF_NOTIFY;
+		if (0 == i) {
+			driver->attach_adapter = adv7343_i2c_probe_adapter;
+		}
+
+		driver->detach_client = adv7343_i2c_detach_client;
+		err |= vid_enc_register_encoder(&adv7343_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vid_enc_unregister_encoder(&adv7343_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* Function used to cleanup i2c driver */
+static void adv7343_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < ADV7343_NUM_CHANNELS; i++) {
+		if (vid_enc_unregister_encoder(&adv7343_dev[i]) < 0)
+			return;
+		if (adv7343_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&adv7343_channel_info[i].i2c_dev.driver);
+			adv7343_channel_info[i].i2c_dev.client.adapter = NULL;
+			adv7343_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+	}
+}
+
+module_init(adv7343_i2c_init);
+module_exit(adv7343_i2c_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/davincihd_capture.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davincihd_capture.c
@@ -0,0 +1,3044 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davincihd_vpfe.c */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <media/davinci/davincihd_capture.h>
+#include <media/davinci/vpif.h>
+#include <asm/arch/video_hdevm.h>
+
+static u32 device_type = -1;
+static u32 channel0_numbuffers = 3;
+static u32 channel1_numbuffers = 3;
+static u32 channel0_bufsize = 1920 * 1080 * 2;
+static u32 channel1_bufsize = 720 * 576 * 2;
+module_param(device_type, uint, S_IRUGO);
+module_param(channel0_numbuffers, uint, S_IRUGO);
+module_param(channel1_numbuffers, uint, S_IRUGO);
+module_param(channel0_bufsize, uint, S_IRUGO);
+module_param(channel1_bufsize, uint, S_IRUGO);
+
+static struct vpif_config_params config_params = {
+	.min_numbuffers = 3,
+	.numbuffers[0] = 3,
+	.numbuffers[1] = 3,
+	.min_bufsize[0] = 720 * 480 * 2,
+	.min_bufsize[1] = 720 * 480 * 2,
+	.channel_bufsize[0] = 1920 * 1080 * 2,
+	.channel_bufsize[1] = 720 * 576 * 2,
+	.default_device[0] = 0,
+	.default_device[1] = 0,
+	.max_device_type = 1,
+	.device_type = -1
+};
+
+static int vpif_nr[] = { 0, 1 };
+
+/* global variables */
+static struct vpif_device vpif_obj = { {NULL} };
+static struct workqueue_struct *vbi_workqueue;
+static struct work_struct vbi_work[VPIF_CAPTURE_NUM_CHANNELS];
+
+static struct device *vpif_dev = NULL;
+
+static struct v4l2_capability vpif_videocap = {
+	.driver = "vpif capture",
+	.card = "DaVinciHD EVM",
+	.bus_info = "Platform",
+	.version = VPIF_CAPTURE_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+	    V4L2_CAP_VBI_CAPTURE | V4L2_CAP_HBI_CAPTURE
+};
+
+static struct v4l2_vbi_format vpif_raw_vbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_VBI_START_FIELD0,
+		   VPIF_NTSC_VBI_START_FIELD1},
+	 .count = {VPIF_NTSC_VBI_COUNT_FIELD0,
+		   VPIF_NTSC_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_VBI_START_FIELD0,
+		   VPIF_PAL_VBI_START_FIELD1},
+	 .count = {VPIF_PAL_VBI_COUNT_FIELD0,
+		   VPIF_PAL_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct v4l2_vbi_format vpif_raw_hbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_HBI_START_FIELD0,
+		   VPIF_NTSC_HBI_START_FIELD1},
+	 .count = {VPIF_NTSC_HBI_COUNT_FIELD0,
+		   VPIF_NTSC_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_HBI_START_FIELD0,
+		   VPIF_PAL_HBI_START_FIELD1},
+	 .count = {VPIF_PAL_HBI_COUNT_FIELD0,
+		   VPIF_PAL_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct vpif_service_line vbi_service_lines[] = {
+	{V4L2_SLICED_CGMS_525, {20, 283}},
+	{V4L2_SLICED_CAPTION_525, {21, 284}},
+	{V4L2_SLICED_WSS_625, {23, 0}},
+};
+
+static void vbi_work_handler(unsigned long data)
+{
+	struct channel_obj *channel = (struct channel_obj *)data;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	unsigned long addr = (unsigned long)common->curFrm->boff;
+
+	if (ISNULL(dec->read_vbi_data)) {
+		dev_err(vpif_dev, "tasklet handler : no read_vbi_data\n");
+		return;
+	}
+	addr = (unsigned long)phys_to_virt(addr);
+	down(&common->lock);
+	if (channel->field_id == 1) {
+		addr += sizeof(struct v4l2_sliced_vbi_data) *
+		    (channel->vbi.num_services);
+	}
+	dec->read_vbi_data((void *)addr, (void *)dec);
+	up(&common->lock);
+}
+
+/* vpif_alloc_buffer : Allocate memory for buffers
+ */
+static inline unsigned long vpif_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/* vpif_free_buffer :  Free memory for buffers
+ */
+static inline void vpif_free_buffer(unsigned long addr, unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*  vpif_uservirt_to_phys : This inline function is used to 
+ *  convert user space virtual address to physical address.
+ */
+static inline u32 vpif_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *)virtp);
+	} else if ((vma = find_vma(mm, virtp)) && (vma->vm_flags & VM_IO) &&
+		   (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated, 
+		   mmaped-to-usermode addresses */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp = __pa(page_address(&pages[0]) +
+				     (virtp & ~PAGE_MASK));
+		} else {
+			dev_err(vpif_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+	return physp;
+}
+
+/* buffer_prepare :  This is the callback function called from 
+ * videobuf_qbuf() function the buffer is prepared and user space 
+ * virtual address is converted into  physical address
+ */
+static int vpif_buffer_prepare(struct videobuf_queue *q,
+			       struct videobuf_buffer *vb,
+			       enum v4l2_field field)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	unsigned long addr;
+	int i, j, prevline = 0, num_services;
+	struct v4l2_sliced_vbi_data *vbidata;
+
+	dev_dbg(vpif_dev, "<vpif_buffer_prepare>\n");
+
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = common->width;
+		vb->height = common->height;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		if (0 == vb->baddr) {
+			dev_err(vpif_dev, "buffer address is 0\n");
+			return -EINVAL;
+		}
+		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	addr = vb->boff;
+	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != q->type)) {
+		if (!ISALIGNED((addr + common->ytop_off)) ||
+		    !ISALIGNED((addr + common->ybtm_off)) ||
+		    !ISALIGNED((addr + common->ctop_off)) ||
+		    !ISALIGNED((addr + common->cbtm_off))) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == q->type) {
+		num_services = channel->vbi.num_services;
+		vbidata = (struct v4l2_sliced_vbi_data *)phys_to_virt(vb->boff);
+		prevline = 0;
+		for (i = 0; i < num_services * 2; i++) {
+			if (0 == vbidata->id)
+				continue;
+			if (!(vbidata->id & common->fmt.fmt.sliced.service_set)) {
+				dev_err(vpif_dev, "Invalid services id\n");
+				return -EINVAL;
+			}
+			if ((vbidata->field != 0) && (vbidata->field != 1)) {
+				dev_err(vpif_dev, "Invalid field value\n");
+				return -EINVAL;
+			}
+			for (j = 0; j < VPIF_SLICED_MAX_SERVICES; j++) {
+				if (!(vbidata->id &
+				      vbi_service_lines[j].service_id))
+					continue;
+				if ((vbidata->field == 0) && (vbidata->line !=
+							      vbi_service_lines
+							      [j].
+							      service_line[0]))
+				{
+					dev_err(vpif_dev,
+						"Invalid field 0 line number\n");
+					return -EINVAL;
+				}
+				if ((vbidata->field == 1) && (vbidata->line !=
+							      vbi_service_lines
+							      [j].
+							      service_line[1]))
+				{
+					dev_err(vpif_dev,
+						"Invalid field 1 line number\n");
+					return -EINVAL;
+				}
+			}
+			if (prevline > vbidata->line) {
+				dev_err(vpif_dev, "line numbers are not in \
+						increasing order\n");
+				return -EINVAL;
+			}
+			prevline = vbidata->line;
+			vbidata++;
+		}
+	}
+
+	dev_dbg(vpif_dev, "</vpif_buffer_prepare>\n");
+	return 0;
+}
+
+/*  vpif_buffer_config : This function is responsible to 
+ *  responsible for buffer's  physical address
+ */
+static void vpif_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	int i;
+	dev_dbg(vpif_dev, "<vpif_buffer_config>\n");
+
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer config\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((u32 *) common->fbuffers[i]);
+		dev_dbg(vpif_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_config>\n");
+}
+
+/* vpif_buffer_setup : This function allocates memory for
+ * the buffers
+ */
+static int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			     unsigned int *size)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	int i, startindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_setup>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer setup\n");
+		return 0;
+	}
+
+	/* Calculate the size of the buffer */
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE == q->type) {
+		/* Calculate the size of the buffer */
+		*size = config_params.channel_bufsize[channel->channel_id];
+		startindex = config_params.numbuffers[channel->channel_id];
+
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == q->type) {
+		/* Get the size of the buffer */
+		*size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		*size = ((common->fmt.fmt.vbi.count[0]) +
+			 (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	for (i = startindex; i < *count; i++) {
+		/* Allocate memory for the buffers */
+		common->fbuffers[i] = (u8 *) vpif_alloc_buffer(*size);
+		if (!common->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = common->numbuffers = i;
+	dev_dbg(vpif_dev, "</vpif_buffer_setup>\n");
+	return 0;
+}
+
+/* vpif_buffer_queue : This function adds the buffer to DMA queue
+ */
+static void vpif_buffer_queue(struct videobuf_queue *q,
+			      struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	dev_dbg(vpif_dev, "<vpif_buffer_queue>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpif_dev, "</vpif_buffer_queue>\n");
+}
+
+/* vpif_buffer_release : This function is called from the videobuf
+ * layer to free memory allocated to  the buffers
+ */
+static void vpif_buffer_release(struct videobuf_queue *q,
+				struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	unsigned int buf_size = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_release>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	vb->state = STATE_NEEDS_INIT;
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer release\n");
+		return;
+	}
+	/* Calculate the size of the buffer */
+	buf_size = config_params.channel_bufsize[channel->channel_id];
+
+	dev_dbg(vpif_dev, "</vpif_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = vpif_buffer_setup,
+	.buf_prepare = vpif_buffer_prepare,
+	.buf_queue = vpif_buffer_queue,
+	.buf_release = vpif_buffer_release,
+	.buf_config = vpif_buffer_config,
+};
+
+static u8 channel_first_int[VPIF_NUMBER_OF_OBJECTS][2] = { {1, 1},
+{1, 1}, {1, 1}
+};
+
+/* vpif_channel_isr :It changes status of the captured buffer,
+ * takes next buffer from the queue  and sets its address in VPIF
+ * registers
+ */
+static irqreturn_t vpif_channel_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct timeval timevalue;
+	int fid = -1, i;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	int channel_id = 0;
+	struct vpif_device *dev = &vpif_obj;
+	unsigned long addr = 0;
+	enum v4l2_field field;
+	dev_dbg(vpif_dev, "<vpif_channel_isr>\n");
+
+	channel_id = *(int *)(dev_id);
+	channel = dev->dev[channel_id];
+	vid_ch = &(channel->video);
+	do_gettimeofday(&timevalue);
+	field = channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;
+
+	for (i = 0; i < VPIF_NUMBER_OF_OBJECTS; i++) {
+		common = &(channel->common[i]);
+		/* If streaming is started in this channel */
+		if (0 == common->started)
+			continue;
+
+		/* Check the field format */
+		if (1 == vid_ch->std_info.frame_format) {
+			if (list_empty(&common->dma_queue))
+				continue;
+			/* Progressive mode */
+			if (!channel_first_int[i][channel_id]) {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				common->curFrm->ts = timevalue;
+				common->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				common->curFrm = common->nextFrm;
+			}
+			channel_first_int[i][channel_id] = 0;
+			/* Get the next buffer from buffer queue */
+			common->nextFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&common->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			common->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+			addr = common->nextFrm->boff;
+			if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+			    == common->fmt.type) {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+			} else {
+				common->set_addr(addr + common->ytop_off,
+						 addr + common->ybtm_off,
+						 addr + common->ctop_off,
+						 addr + common->cbtm_off);
+			}
+			channel_first_int[i][channel_id] = 0;
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (channel_first_int[i][channel_id]) {
+				channel_first_int[i][channel_id] = 0;
+				continue;
+			}
+			if (0 == i) {
+				channel->field_id ^= 1;
+				/* Get field id from VPIF registers */
+				fid = vpif_channel_getfid(channel->channel_id);
+				/* If field id does not match with stored
+				   field id */
+				if (fid != channel->field_id) {
+					/* Make them in sync */
+					if (0 == fid) {
+						channel->field_id = fid;
+					}
+					return IRQ_HANDLED;
+				}
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (common->curFrm == common->nextFrm) {
+					continue;
+				}
+				/* one frame is captured If next frame is
+				 * available, release curFrm and move on*/
+				/* Copy frame capture time */
+				common->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				common->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				common->curFrm = common->nextFrm;
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				}
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&common->dma_queue)
+				    || (common->curFrm != common->nextFrm)) {
+					continue;
+				}
+
+				/* one field is captured, configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				common->nextFrm = list_entry(common->
+							     dma_queue.
+							     next, struct
+							     videobuf_buffer,
+							     queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&common->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				common->nextFrm->state = STATE_ACTIVE;
+				addr = common->nextFrm->boff;
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				} else {
+					common->set_addr(addr +
+							 common->ytop_off,
+							 addr +
+							 common->ybtm_off,
+							 addr +
+							 common->ctop_off,
+							 addr +
+							 common->cbtm_off);
+				}
+			}
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_channel_isr>\n");
+	return IRQ_HANDLED;
+}
+
+static void vpif_get_std_info(struct channel_obj *ch)
+{
+	struct decoder_device *dec = ch->decoder[ch->current_decoder];
+	struct video_obj *vid_ch = &(ch->video);
+	struct v4l2_standard standard;
+	int index = 0, ret;
+
+	vid_ch->std_info.channel_id = ch->channel_id;
+
+	/* Get standard name from the decoder by enumerating standards */
+	do {
+		standard.index = index;
+
+		ret = dec->std_ops->enumstd(&standard, dec);
+		if (standard.id & vid_ch->std) {
+			strncpy(vid_ch->std_info.name, standard.name,
+				sizeof(vid_ch->std_info.name));
+			strncpy(ch->vpifparams.video_params.name,
+				standard.name, sizeof(vid_ch->std_info.name));
+			break;
+		}
+		index++;
+	} while (ret >= 0);
+
+	/* Get standard information from VPIF layer */
+	ret = vpif_get_mode_info(&vid_ch->std_info);
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.width =
+	    ch->common[VPIF_VIDEO_INDEX].width = vid_ch->std_info.activepixels;
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.height =
+	    ch->common[VPIF_VIDEO_INDEX].height = vid_ch->std_info.activelines;
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.bytesperline =
+	    vid_ch->std_info.activepixels;
+	ch->vpifparams.video_params.hpitch = vid_ch->std_info.activepixels;
+	ch->vpifparams.video_params.storage_mode =
+	    vid_ch->std_info.frame_format;
+}
+
+/* vpif_calculate_offsets : This function calculates buffers offset
+ *  for Y and C in the top and bottom field
+ */
+static void vpif_calculate_offsets(struct channel_obj *channel)
+{
+	unsigned int hpitch, vpitch, sizeimage;
+	struct video_obj *vid_ch = &(channel->video);
+	struct vpif_params *vpifparams = &channel->vpifparams;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	enum v4l2_field field = common->fmt.fmt.pix.field;
+
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets>\n");
+
+	if (V4L2_FIELD_ANY == field) {
+		if (vid_ch->std_info.frame_format)
+			vid_ch->buf_field = V4L2_FIELD_NONE;
+		else
+			vid_ch->buf_field = V4L2_FIELD_INTERLACED;
+	} else {
+		vid_ch->buf_field = common->fmt.fmt.pix.field;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = common->fmt.fmt.pix.sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+	hpitch = common->fmt.fmt.pix.bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = hpitch;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = sizeimage / 2 + hpitch;
+	} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = sizeimage / 4;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = common->ctop_off + sizeimage / 4;
+	} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ybtm_off = 0;
+		common->ytop_off = sizeimage / 4;
+		common->cbtm_off = sizeimage / 2;
+		common->ctop_off = common->cbtm_off + sizeimage / 4;
+	}
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		vpifparams->video_params.storage_mode = 1;
+	} else {
+		vpifparams->video_params.storage_mode = 0;
+	}
+
+	if (1 == vid_ch->std_info.frame_format) {
+		vpifparams->video_params.hpitch =
+		    common->fmt.fmt.pix.bytesperline;
+	} else {
+		if ((field == V4L2_FIELD_ANY)
+		    || (field == V4L2_FIELD_INTERLACED))
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline * 2;
+		else
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline;
+	}
+
+	strncpy(channel->vpifparams.video_params.name, vid_ch->std_info.name,
+		sizeof(channel->vpifparams.video_params.name));
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets>\n");
+}
+
+static void vpif_calculate_offsets_vbi(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets_vbi>\n");
+	common->ytop_off = 0;
+	common->ctop_off = 0;
+	common->ybtm_off = (common->fmt.fmt.vbi.count[0]) *
+	    (common->fmt.fmt.vbi.samples_per_line);
+	common->cbtm_off = 0;
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets_vbi>\n");
+}
+
+static void vpif_config_format(struct channel_obj *channel)
+{
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	common->fmt.fmt.pix.field = V4L2_FIELD_ANY;
+
+	if (config_params.numbuffers[channel->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+
+	common->fmt.fmt.pix.sizeimage
+	    = config_params.channel_bufsize[channel->channel_id];
+
+	if (dec->if_type & INTERFACE_TYPE_RAW)
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	else
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+	common->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	channel->common[VPIF_VBI_INDEX].fmt.type =
+	    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;
+	channel->common[VPIF_VBI_INDEX].fmt.fmt.sliced.service_set = 0;
+	channel->common[VPIF_VBI_INDEX].memory = V4L2_MEMORY_MMAP;
+	channel->common[VPIF_HBI_INDEX].fmt.type = V4L2_BUF_TYPE_HBI_CAPTURE;
+	channel->common[VPIF_HBI_INDEX].memory = V4L2_MEMORY_MMAP;
+}
+
+static void vpif_config_std(struct channel_obj *channel)
+{
+	int ret;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	/* Detect the standard from the devide */
+	ret = dec->std_ops->getstd(&vid_ch->std, dec);
+	if (ret)
+		return;
+
+	vpif_get_std_info(channel);
+
+	/* Reset the pitch */
+	common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+
+	/* Change the pixel format as per the new decoder */
+	if (dec->if_type & INTERFACE_TYPE_RAW)
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	else
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+}
+
+static int vpif_check_format(struct channel_obj *channel,
+			     struct v4l2_pix_format *pixfmt)
+{
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 sizeimage, hpitch, vpitch;
+	enum v4l2_field field = pixfmt->field;
+
+	if ((dec->if_type & INTERFACE_TYPE_RAW)
+	    && (pixfmt->pixelformat != V4L2_PIX_FMT_SBGGR8)) {
+		dev_err(vpif_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (!(VPIF_VALID_FIELD(field))) {
+		dev_err(vpif_dev, "invalid field format\n");
+		return -EINVAL;
+	}
+	if (pixfmt->bytesperline <= 0) {
+		dev_err(vpif_dev, "invalid pitch\n");
+		return -EINVAL;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = pixfmt->sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+	hpitch = pixfmt->bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+	/* Check for valid value of pitch */
+	if ((hpitch < vid_ch->std_info.activepixels) ||
+	    (vpitch < vid_ch->std_info.activelines)) {
+		dev_err(vpif_dev, "Invalid pitch\n");
+		return -EINVAL;
+	}
+	/* Check for 8 byte alignment */
+	if (!(ISALIGNED(hpitch))) {
+		dev_err(vpif_dev, "invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = common->fmt.fmt.pix.width;
+	pixfmt->height = common->fmt.fmt.pix.height;
+	return 0;
+}
+
+static int vpif_convert_index(struct channel_obj *channel, int *index,
+			      int *dec_index)
+{
+	int i, suminput = 0;
+	struct decoder_device *dec;
+	*dec_index = 0;
+	for (i = 0; i < channel->numdecoders; i++) {
+		dec = channel->decoder[i];
+		suminput += dec->input_ops->count;
+		if ((*index) < suminput) {
+			*dec_index = i;
+			suminput -= dec->input_ops->count;
+			break;
+		}
+	}
+	*index -= suminput;
+	if (i == channel->numdecoders)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void vpif_config_addr(struct channel_obj *channel, int muxmode,
+			     enum v4l2_buf_type buftype)
+{
+	struct common_obj *common;
+	int buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+			      == buftype) ? VPIF_VIDEO_INDEX : VPIF_VBI_INDEX;
+	common = &(channel->common[buf_type_index]);
+	if (VPIF_CHANNEL1_VIDEO == channel->channel_id) {
+		if (0 == buf_type_index)
+			common->set_addr = ch1_set_videobuf_addr;
+		else if (1 == buf_type_index)
+			common->set_addr = ch1_set_vbi_addr;
+		else
+			common->set_addr = ch1_set_hbi_addr;
+	} else {
+		if (0 == buf_type_index) {
+			if (2 == muxmode) {
+				common->set_addr =
+				    ch0_set_videobuf_addr_yc_nmux;
+			} else {
+				common->set_addr = ch0_set_videobuf_addr;
+			}
+		} else if (1 == buf_type_index) {
+			common->set_addr = ch0_set_vbi_addr;
+		} else {
+			common->set_addr = ch0_set_hbi_addr;
+		}
+	}
+}
+
+static int vpif_try_raw_format(struct channel_obj *channel,
+			       struct v4l2_vbi_format *fmt, u8 index)
+{
+	struct video_obj *vid_ch = &(channel->video);
+	struct v4l2_vbi_format *raw_vbi;
+	if (V4L2_STD_525_60 == vid_ch->std) {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[0]) :
+		    &(vpif_raw_hbi_formats[0]);
+	} else {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[1]) :
+		    &(vpif_raw_hbi_formats[1]);
+	}
+
+	if ((fmt->sampling_rate != raw_vbi->sampling_rate) ||
+	    (fmt->samples_per_line != raw_vbi->samples_per_line) ||
+	    (fmt->start[0] != raw_vbi->start[0]) ||
+	    (fmt->count[0] != raw_vbi->count[0]) ||
+	    (fmt->start[1] != raw_vbi->start[1]) ||
+	    (fmt->count[1] != raw_vbi->count[1]) ||
+	    (fmt->flags != raw_vbi->flags)) {
+		dev_err(vpif_dev, "invalid parameters\n");
+		*fmt = *raw_vbi;
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*  vpfe_doioctl : This function will provide different V4L2 commands.
+ * This function can be used to configure driver or get status of
+ * driver as per command passed  by application
+ */
+static int vpif_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct vpif_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct video_obj *vid_ch = &(channel->video);
+	unsigned int index = 0, i = 0;
+	unsigned long addr, flags;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+
+	if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_G_INPUT:
+		case VIDIOC_S_STD:
+		case VIDIOC_S_INPUT:
+		case VIDIOC_S_FMT:
+		case VIDIOC_REQBUFS:
+		case VPIF_S_VPIF_PARAMS:
+		case VPIF_CMD_S_DECODER_PARAMS:
+			if (!fh->initialized) {
+				dev_dbg(vpif_dev, "channel busy\n");
+				return -EBUSY;
+			}
+		}
+	}
+	/* Check for the priority */
+	if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_STD:
+		case VIDIOC_S_INPUT:
+		case VIDIOC_S_FMT:
+			ret = v4l2_prio_check(&channel->prio, &fh->prio);
+			if (0 != ret)
+				return ret;
+			fh->initialized = 1;
+			break;
+		}
+	}
+
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(vpif_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCAP\n");
+			memset(cap, 0, sizeof(*cap));
+			if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+			    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+				*cap = vpif_videocap;
+				cap->capabilities |= dec->capabilities;
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for enumerating inputs */
+	case VIDIOC_ENUMINPUT:
+		{
+			int index, index1;
+			struct v4l2_input *input = (struct v4l2_input *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUMINPUT\n");
+
+			index = index1 = input->index;
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel, &index, &i);
+			if (ret)
+				break;
+			input->index = index;
+			/* Call enuminput of the new decoder */
+			ret = channel->decoder[i]->input_ops->
+			    enuminput(input, channel->decoder[i]);
+			input->index = index1;
+			break;
+		}
+
+		/* If the case is for getting input */
+	case VIDIOC_G_INPUT:
+		{
+			int i, j;
+			int temp_input_idx = 0;
+			struct decoder_device *cur_dec;
+			int sumindex = 0;
+			int found = 0;
+			int result_input_idx = -1;
+			int first_input_idx = -1;
+			int default_mt9t001_decoder = 0;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct video_obj *vid_ch = &(channel->video);
+
+			dev_dbg(vpif_dev, "VIDIOC_G_INPUT\n");
+			down_interruptible(&common->lock);
+
+			if (0 == strcmp(channel->
+					decoder[channel->default_decoder]->name,
+					"MT9T001")) {
+				default_mt9t001_decoder = 1;
+			}
+			if (0 != strcmp(dec->name, "MT9T001")) {
+				/* De-Initialize the current decoder */
+				dec->deinitialize(dec);
+			}
+			for (i = 0; i < channel->numdecoders; i++) {
+				cur_dec = channel->decoder[i];
+				if (ISNULL(cur_dec->input_ops)
+				    || ISNULL(cur_dec->input_ops->getinput)
+				    || ISNULL(cur_dec->deinitialize)
+				    || ISNULL(cur_dec->initialize)) {
+					sumindex += cur_dec->input_ops->count;
+					continue;
+				}
+				if (0 != strcmp(cur_dec->name, "MT9T001")) {
+					cur_dec->initialize(cur_dec,
+							    DECODER_I2C_BIND_FLAG);
+				}
+				if ((0 == strcmp(cur_dec->name, "MT9T001")) &&
+				    (!default_mt9t001_decoder)) {
+					sumindex += cur_dec->input_ops->count;
+					continue;
+				}
+
+				/* for decoder, call getinput for each index */
+				for (j = 0; j < cur_dec->input_ops->count; j++) {
+					if (0 != strcmp(cur_dec->name,
+							"MT9T001")) {
+						ret =
+						    cur_dec->input_ops->
+						    getinput(&j, cur_dec);
+					} else {
+						ret = 0;
+					}
+					if (ret)
+						continue;
+					if (0 == found) {
+						first_input_idx = sumindex + j;
+						found = 1;
+					}
+					if (temp_input_idx == vid_ch->input_idx) {
+						result_input_idx = sumindex + j;
+						vid_ch->input_idx++;
+						found = 2;
+						break;
+					}
+					temp_input_idx++;
+				}
+				if (0 != strcmp(cur_dec->name, "MT9T001")) {
+					cur_dec->deinitialize(cur_dec);
+				}
+				if (2 == found)
+					break;
+				sumindex += cur_dec->input_ops->count;
+			}
+			if (0 == found) {
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			if (1 == found) {
+				vid_ch->input_idx = 1;
+				result_input_idx = first_input_idx;
+			}
+			*(int *)arg = result_input_idx;
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel,
+						 &result_input_idx, &i);
+			if (ret) {
+				up(&common->lock);
+				break;
+			}
+			/* Initialize the new decoder */
+			dec = channel->decoder[i];
+			channel->current_decoder = i;
+			if (0 != strcmp(dec->name, "MT9T001")) {
+				dec->initialize(dec, DECODER_I2C_BIND_FLAG);
+			}
+			/* Set the standard in the decoder */
+			ret = dec->input_ops->setinput(&result_input_idx, dec);
+			vpif_config_std(channel);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for setting input */
+	case VIDIOC_S_INPUT:
+		{
+			int index = *(int *)arg;
+			int index1 = index;
+			int default_mt9t001_decoder = 0;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VIDIOC_S_INPUT\n");
+			/* If streaming is started return device busy
+			 * error */
+			down_interruptible(&common->lock);
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is on\n");
+				ret = -EBUSY;
+				up(&common->lock);
+				break;
+			}
+			if (0 == strcmp(channel->
+					decoder[channel->default_decoder]->name,
+					"MT9T001")) {
+				default_mt9t001_decoder = 1;
+			}
+
+			if (ISNULL(dec->input_ops)
+			    || ISNULL(dec->input_ops->setinput) ||
+			    ISNULL(dec->deinitialize)
+			    || ISNULL(dec->initialize)) {
+				dev_err(vpif_dev, "vpif_doioctl:No setinput\n");
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel, &index, &i);
+
+			if (ret) {
+				up(&common->lock);
+				break;
+			}
+			dec = channel->decoder[channel->current_decoder];
+			/* if default is not mt9t001 and request comes 
+			 * to set
+			 * it, raise an error */
+			if ((0 == strcmp(channel->decoder[i]->name, "MT9T001"))
+			    && (!default_mt9t001_decoder)) {
+				up(&common->lock);
+				return -EINVAL;
+			}
+			channel->current_decoder = i;
+			/* Deinitialize the previous decoder */
+			dec->deinitialize(dec);
+
+			/* Initialize the new decoder */
+			dec = channel->decoder[i];
+			dec->initialize(dec, DECODER_FULL_INIT_FLAG);
+
+			/* Set the standard in the decoder */
+			ret = dec->input_ops->setinput(&index, dec);
+			*(int *)arg = index1;
+			vpif_config_std(channel);
+			up(&common->lock);
+
+			break;
+		}
+		/* If the case is for enumerating standards */
+	case VIDIOC_ENUMSTD:
+		{
+			struct v4l2_standard *std = (struct v4l2_standard *)arg;
+			struct video_obj *vid_ch = &(channel->video);
+			int index = std->index, dec_idx;
+			dev_dbg(vpif_dev, "VIDIOC_ENUMSTD\n");
+			/* Call enumstd function of decoder device */
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->enumstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No enumstd\n");
+				return -EINVAL;
+			}
+			if (index >= vid_ch->count_std) {
+				dev_err(vpif_dev, "Invalid index\n");
+				return -EINVAL;
+			}
+			dec_idx = vid_ch->std_tbl[index].dec_idx;
+			dec = channel->decoder[dec_idx];
+			std->index = vid_ch->std_tbl[index].std_idx;
+			ret = dec->std_ops->enumstd(std, dec);
+			std->index = index;
+			break;
+		}
+
+		/* If the case is for querying standards */
+	case VIDIOC_QUERYSTD:
+		{
+			v4l2_std_id *std = (v4l2_std_id *) arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct video_obj *vid_ch = &(channel->video);
+			dev_dbg(vpif_dev, "VIDIOC_QUERYSTD\n");
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->querystd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No querystd\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			/* Call querystd function of decoder device */
+			ret = dec->std_ops->querystd(std, dec);
+
+			if (!ret) {
+				/* Get the information about 
+				 * the standard from the decoder */
+				vid_ch->std = *std;
+				vpif_get_std_info(channel);
+			}
+
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting standard */
+	case VIDIOC_G_STD:
+		{
+			v4l2_std_id *std = (v4l2_std_id *) arg;
+			dev_dbg(vpif_dev, "VIDIOC_G_STD\n");
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->getstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No getstd\n");
+				return -EINVAL;
+			}
+			/* Call getstd function of decoder device */
+			ret = dec->std_ops->getstd(std, dec);
+			break;
+		}
+
+		/* If the case is for setting standard */
+	case VIDIOC_S_STD:
+		{
+			v4l2_std_id std = *(v4l2_std_id *) arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VIDIOC_S_STD\n");
+
+			/* If streaming is started, return device
+			   busy error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				return -EBUSY;
+			}
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->setstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No setstd\n");
+				return -EINVAL;
+			}
+			/* Call decoder driver function to set the
+			   standard */
+			down_interruptible(&common->lock);
+			ret = dec->std_ops->setstd(&std, dec);
+
+			/* If it returns error, return error */
+			if (ret < 0) {
+				up(&common->lock);
+				return ret;
+			}
+			/* Get the information about the standard from
+			 * the decoder */
+			vid_ch->std = std;
+			vpif_get_std_info(channel);
+
+			if ((vid_ch->std_info.activelines *
+			     vid_ch->std_info.activepixels * 2)
+			    > config_params.channel_bufsize[channel->
+							    channel_id]) {
+				dev_err(vpif_dev,
+					"invalid std for this size\n");
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			up(&common->lock);
+			break;
+		}
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUM_FMT\n");
+			if (fmt->index != 0) {
+				dev_err(vpif_dev, "Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			if (dec->if_type & INTERFACE_TYPE_RAW) {
+				fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+				strcpy(fmt->description,
+				       "Raw Mode -Bayer Pattern GrRBGb");
+				fmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
+			} else {
+				fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+				strcpy(fmt->description,
+				       "YCbCr4:2:2 YC Planar");
+				fmt->pixelformat = V4L2_PIX_FMT_YUV422UVP;
+			}
+			break;
+		}
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_G_FMT\n");
+
+			if (common->fmt.type != fmt->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If buffer type is not video output */
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fmt->type) {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					return -EINVAL;
+				}
+			}
+			/* Fill in the information about
+			 * format */
+			down_interruptible(&(common->lock));
+			*fmt = common->fmt;
+			up(&(common->lock));
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			u8 index;
+			dev_dbg(vpif_dev, "VIDIOC_S_FMT\n");
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			/* If streaming is started, return error */
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+
+				if (ret) {
+					return ret;
+				}
+
+				/* store the pixel format in the channel
+				 * object */
+				common->fmt.fmt.pix = *pixfmt;
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev, "standard \
+						 doesn't support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == fmt->type) {
+					if (ISNULL(dec->fmt_ops) ||
+					    ISNULL(dec->fmt_ops->setformat)) {
+						dev_err(vpif_dev,
+							"vpif_doioctl:\
+							No setformat \
+								\n");
+						return -EINVAL;
+					}
+					ret = dec->fmt_ops->setformat(fmt, dec);
+					if (ret >= 0) {
+						common->width =
+						    fmt->fmt.sliced.io_size;
+						common->height = 1;
+						channel->vbi.num_services = ret;
+					}
+				} else if ((V4L2_BUF_TYPE_VBI_CAPTURE
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_CAPTURE
+					    == fmt->type)) {
+					index = (V4L2_BUF_TYPE_VBI_CAPTURE ==
+						 fmt->type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret = vpif_try_raw_format
+					    (channel, &(fmt->fmt.vbi), index);
+					if (ret) {
+						return ret;
+					}
+					ret = dec->fmt_ops->setformat(fmt, dec);
+					if (ret) {
+						return ret;
+					}
+					common->width =
+					    fmt->fmt.vbi.samples_per_line;
+					common->height =
+					    fmt->fmt.vbi.count[0] +
+					    fmt->fmt.vbi.count[1];
+				} else {
+					dev_err(vpif_dev, "invalid \
+							type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+
+			/* store the pixel format in the channel
+			 * object */
+			down_interruptible(&common->lock);
+			common->fmt = *fmt;
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_format *fmt;
+			u8 index;
+			dev_dbg(vpif_dev, "VIDIOC_TRY_FMT\n");
+			fmt = (struct v4l2_format *)arg;
+
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+				if (ret) {
+					*pixfmt = common->fmt.fmt.pix;
+					pixfmt->sizeimage =
+					    pixfmt->width * pixfmt->height * 2;
+				}
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev, "standard doesn't \
+							support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == fmt->type) {
+					if (ISNULL(dec->fmt_ops)
+					    || ISNULL(dec->fmt_ops->tryformat)) {
+						dev_err(vpif_dev,
+							"vpif_doioctl:\
+							No tryformat\
+							\n");
+						return -EINVAL;
+					}
+					ret = dec->fmt_ops->tryformat(fmt, dec);
+				} else if ((V4L2_BUF_TYPE_VBI_CAPTURE
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_CAPTURE
+					    == fmt->type)) {
+					index = (V4L2_BUF_TYPE_VBI_CAPTURE ==
+						 fmt->type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret = vpif_try_raw_format
+					    (channel, &(fmt->fmt.vbi), index);
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			break;
+		}
+
+		/* If the case is for querying controls */
+	case VIDIOC_QUERYCTRL:
+		{
+			struct v4l2_queryctrl *queryctrl =
+			    (struct v4l2_queryctrl *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->queryctrl)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No queryctrl\n");
+				return -EINVAL;
+			}
+			/* Call queryctrl function of decoder device */
+			ret = dec->ctrl_ops->queryctrl(queryctrl, dec);
+			break;
+		}
+
+		/* If the case is for getting controls value */
+	case VIDIOC_G_CTRL:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct v4l2_control *ctrl = (struct v4l2_control *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_G_CTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->getcontrol)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No getcontrol\n");
+				return -EINVAL;
+			}
+			/* Call getcontrol function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->ctrl_ops->getcontrol(ctrl, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting controls value */
+	case VIDIOC_S_CTRL:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct v4l2_control *ctrl = (struct v4l2_control *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_S_CTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->setcontrol)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No setcontrol\n");
+				return -EINVAL;
+			}
+			/* Call setcontrol function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->ctrl_ops->setcontrol(ctrl, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting decoder parameters */
+	case VPIF_CMD_G_DECODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_G_DECODER_PARAMS\n");
+			if (ISNULL(dec->params_ops)
+			    || ISNULL(dec->params_ops->getparams)) {
+				dev_err(vpif_dev, "vpif_doioctl:No \
+							getdeviceparams\n");
+				return -EINVAL;
+			}
+			/* Call getparams function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->getparams((void *)arg, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for setting decoder parameters */
+	case VPIF_CMD_S_DECODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_S_DECODER_PARAMS\n");
+			/* If channel is already started, return
+			 * error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				return -EBUSY;
+			}
+			if (ISNULL(dec->params_ops)
+			    || ISNULL(dec->params_ops->setparams)) {
+				dev_err(vpif_dev, "vpif_doioctl:No \
+							setdeviceparams\n");
+				return -EINVAL;
+			}
+			/* Call getparams function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->setparams((void *)arg, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_requestbuffers *reqbuf;
+			enum v4l2_field field;
+			int buf_type_index;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_REQBUFS\n");
+			if ((V4L2_BUF_TYPE_VIDEO_CAPTURE != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_VBI_CAPTURE != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != reqbuf->type)
+			    && (V4L2_BUF_TYPE_HBI_CAPTURE != reqbuf->type))
+				return -EINVAL;
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+					  == reqbuf->type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE == reqbuf->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			if (common->fmt.type != reqbuf->type) {
+				ret = -EINVAL;
+				break;
+			}
+			if ((V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == reqbuf->type)
+			    && (V4L2_MEMORY_MMAP != reqbuf->memory)) {
+				ret = -EINVAL;
+				break;
+			}
+
+			/* If io users of the channel is not zero,
+			   return error */
+			if (0 != common->io_usrs) {
+				ret = -EBUSY;
+				break;
+			}
+
+			down_interruptible(&common->lock);
+			if ((common->fmt.fmt.pix.field != V4L2_FIELD_ANY) &&
+			    (V4L2_BUF_TYPE_VIDEO_CAPTURE == reqbuf->type))
+				field = common->fmt.fmt.pix.field;
+			else
+				field = V4L2_FIELD_INTERLACED;
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&common->buffer_queue,
+					    &video_qops, NULL,
+					    &common->irqlock,
+					    reqbuf->type,
+					    field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&common->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed[buf_type_index] = 1;
+			/* Increment io usrs member of channel object
+			   to 1 */
+			common->io_usrs = 1;
+			/* Store type of memory requested in channel
+			 * object */
+			common->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&common->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&common->buffer_queue, reqbuf);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			struct videobuf_buffer *buf1;
+			int buf_type_index;
+			dev_dbg(vpif_dev, "VIDIOC_QBUF\n");
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+					  == (tbuf.type)) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+
+			if (!(list_empty(&common->dma_queue)) ||
+			    (common->curFrm != common->nextFrm) ||
+			    !(common->started) ||
+			    (common->started && (0 == channel->field_id))) {
+				ret = videobuf_qbuf
+				    (&common->buffer_queue,
+				     (struct v4l2_buffer *)
+				     arg);
+				break;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != common->fmt.type) {
+				ret = videobuf_qbuf
+				    (&common->buffer_queue,
+				     (struct v4l2_buffer *)
+				     arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 * in VPIF registers */
+			down(&common->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = common->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(vpif_dev, "invalid buffer" " type\n");
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				dev_err(vpif_dev, "invalid state\n");
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					up(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					up(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					vpif_buffer_release(&common->
+							    buffer_queue, buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    vpif_buffer_prepare(&common->buffer_queue,
+						buf1, common->buffer_queue.
+						field);
+			if (ret < 0) {
+				local_irq_restore(flags);
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			common->nextFrm = buf1;
+			common->set_addr((addr + common->ytop_off),
+					 (addr + common->ybtm_off),
+					 (addr + common->ctop_off),
+					 (addr + common->cbtm_off));
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(common->buffer_queue.stream));
+			up(&common->buffer_queue.lock);
+			break;
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			struct common_obj *common = NULL;
+			int buf_type_index = 0;
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			struct common_obj *common = NULL;
+			u8 buf_type_index = 0;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYBUF\n");
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+			if (((struct v4l2_buffer *)arg)->memory !=
+			    V4L2_MEMORY_MMAP) {
+				return -EINVAL;
+			}
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&common->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			struct common_obj *common = NULL;
+			struct video_obj *vid_ch = NULL;
+			struct channel_obj *oth_ch
+			    = vpif_obj.dev[!channel->channel_id];
+			struct vpif_params *vpif;
+			enum v4l2_buf_type buftype
+			    = *(enum v4l2_buf_type *)(arg);
+			int buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					      buftype) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMON\n");
+			common = &(channel->common[buf_type_index]);
+			vid_ch = &(channel->video);
+			vpif = &channel->vpifparams;
+			/* If file handle is not allowed IO,
+			 * return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EBUSY;
+				break;
+			}
+			if ((channel->channel_id == VPIF_CHANNEL0_VIDEO
+			     && oth_ch->common[VPIF_VIDEO_INDEX].started &&
+			     vid_ch->std_info.ycmux_mode == 0)
+			    || ((channel->channel_id == VPIF_CHANNEL1_VIDEO)
+				&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].
+				    started))) {
+				dev_err(vpif_dev, "other channel is using\n");
+				ret = -EBUSY;
+				break;
+			}
+			if (VPIF_VIDEO_INDEX == buf_type_index) {
+				ret = vpif_check_format(channel,
+							&common->fmt.fmt.pix);
+				if (ret)
+					return ret;
+			} else {
+				if (!channel->common[VPIF_VIDEO_INDEX].started)
+					return -EINVAL;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&common->buffer_queue);
+			if (ret) {
+				dev_err(vpif_dev, "videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&common->lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&common->dma_queue)) {
+				dev_err(vpif_dev, "buffer queue is empty\n");
+				ret = -EIO;
+				up(&common->lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			common->nextFrm = common->curFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&common->curFrm->queue);
+			/* Mark state of the current frame to active */
+			common->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+			channel->field_id = 0;
+			common->started = 1;
+
+			addr = common->curFrm->boff;
+
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) {
+				/* Calculate the offset for Y and C data
+				   in the buffer */
+				vpif_calculate_offsets(channel);
+
+				if ((vid_ch->std_info.frame_format &&
+				     ((common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_NONE) &&
+				      (common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_ANY))) ||
+				    (!vid_ch->std_info.frame_format &&
+				     (common->fmt.fmt.pix.field ==
+				      V4L2_FIELD_NONE))) {
+					dev_err(vpif_dev, "conflict in field \
+							format and std \
+							format\n");
+					up(&common->lock);
+					return -EINVAL;
+				}
+				/* if single channel is needed */
+				if (vid_ch->std_info.ycmux_mode == 1) {
+					ret = set_vid_in_mode_for_tvp5147();
+				} else {
+					ret = set_vid_in_mode_for_tvp7002();
+				}
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set vid in bit\n");
+					up(&common->lock);
+					return ret;
+				}
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret =
+				    vpif_set_video_params(vpif,
+							  channel->channel_id);
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set video params\n");
+					up(&common->lock);
+					return ret;
+				}
+				common->started = ret;
+				vpif_config_addr(channel, ret, buftype);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+
+				/* Set interrupt for both the fields in
+				   VPIF Register enable channel in
+				   VPIF register */
+				if ((VPIF_CHANNEL0_VIDEO
+				     == channel->channel_id)) {
+					channel0_intr_assert();
+					channel0_intr_enable(1);
+					enable_channel0(1);
+				}
+				if ((VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				    || (common->started == 2)) {
+					channel1_intr_assert();
+					channel1_intr_enable(1);
+					enable_channel1(1);
+				}
+				channel_first_int[VPIF_VIDEO_INDEX]
+				    [channel->channel_id] = 1;
+			} else if (V4L2_BUF_TYPE_VBI_CAPTURE == buftype ||
+				   V4L2_BUF_TYPE_HBI_CAPTURE == buftype) {
+				u8 index = 0;
+				/* Calculate the offset for vbi data
+				   in the buffer */
+				if (V4L2_BUF_TYPE_VBI_CAPTURE == buftype)
+					index = VPIF_VBI_INDEX;
+				else
+					index = VPIF_HBI_INDEX;
+
+				vpif_calculate_offsets_vbi(channel, index);
+
+				vpif_config_addr(channel, 0, buftype);
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				enable_raw_feature(channel->channel_id, index);
+				channel_first_int[index]
+				    [channel->channel_id] = 1;
+			} else {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+				channel_first_int[VPIF_VBI_INDEX]
+				    [channel->channel_id] = 1;
+			}
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			struct common_obj *common = NULL;
+			int buf_type_index;
+			enum v4l2_buf_type buftype
+			    = *(enum v4l2_buf_type *)(arg);
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  buftype) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMOFF\n");
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) {
+				/* disable channel */
+				if (VPIF_CHANNEL0_VIDEO == channel->channel_id) {
+					enable_channel0(0);
+					channel0_intr_enable(0);
+				} else {
+					enable_channel1(0);
+					channel1_intr_enable(0);
+				}
+			} else if (buftype == V4L2_BUF_TYPE_VBI_CAPTURE) {
+				disable_raw_feature(channel->channel_id,
+						    VPIF_VBI_INDEX);
+			} else if (buftype == V4L2_BUF_TYPE_HBI_CAPTURE) {
+				disable_raw_feature(channel->channel_id,
+						    VPIF_HBI_INDEX);
+			}
+			common->started = 0;
+			up(&common->lock);
+			ret = videobuf_streamoff(&common->buffer_queue);
+			break;
+		}
+
+		/* If the case is for setting VPIF parameters */
+	case VPIF_S_VPIF_PARAMS:
+		{
+			struct video_obj *vid_ch = NULL;
+			struct common_obj *common = NULL;
+			struct vpif_params *params = (struct vpif_params *)arg;
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			vid_ch = &(channel->video);
+			dev_dbg(vpif_dev, "VPIF_S_VPIF_PARAMS\n");
+			/* If streaming is not started, return error */
+			if (common->started) {
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			channel->vpifparams = *params;
+			strncpy(channel->video.std_info.name,
+				params->video_params.name,
+				sizeof(channel->video.std_info.name));
+			common->fmt.fmt.pix.bytesperline =
+			    params->video_params.hpitch;
+			ret = vpif_get_mode_info(&vid_ch->std_info);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting VPIF Parameters */
+	case VPIF_G_VPIF_PARAMS:
+		{
+			struct vpif_params *params = (struct vpif_params *)arg;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VPIF_G_VPIF_PARAMS\n");
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			down_interruptible(&common->lock);
+			memcpy(params, &channel->vpifparams, sizeof(*params));
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting TVP5146 parameters */
+	case VPFE_CMD_CONFIG_TVP5146:
+		{
+			dev_err(vpif_dev, "Device is not supported\n");
+			return -ENODEV;
+			break;
+		}
+
+		/* If the case is for setting mt9t001 parameters */
+	case VPFE_S_MT9T001_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				return -EINVAL;
+			if (0 != strcmp(dec->name, "MT9T001"))
+				return -ENODEV;
+			if (ISNULL(dec->params_ops->setparams)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No setparams\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->setparams((void *)arg, dec);
+			up(&common->lock);
+		}
+		break;
+
+		/* If the case is for setting mt9t001 parameters */
+	case VPFE_G_MT9T001_PARAMS:
+		{
+			struct common_obj *common;
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			if (VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				return -EINVAL;
+			if (0 != strcmp(dec->name, "MT9T001"))
+				return -ENODEV;
+			if (ISNULL(dec->params_ops->getparams)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No getparams\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->getparams((void *)arg, dec);
+			up(&common->lock);
+		}
+		break;
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			ret = v4l2_prio_change(&channel->prio, &fh->prio, *p);
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			*p = v4l2_prio_max(&channel->prio);
+			break;
+		}
+		/* If the case is for getting sliced vbi capabilites */
+	case VIDIOC_G_SLICED_VBI_CAP:
+		{
+			if (ISNULL(dec->get_sliced_vbi_cap)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No get sliced vbi cap\n");
+				return -EINVAL;
+			}
+			/* Call get sliced capability function 
+			   of encoder device */
+			dec->get_sliced_vbi_cap
+			    ((struct v4l2_sliced_vbi_cap *)arg, dec);
+			break;
+		}
+		/* If the case if for getting cropping parameters */
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *crop = (struct v4l2_cropcap *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != crop->type)
+				return -EINVAL;
+			crop->bounds.left = crop->bounds.top = 0;
+			crop->defrect.left = crop->defrect.top = 0;
+			crop->defrect.height = crop->bounds.height =
+			    common->height;
+			crop->defrect.width = crop->bounds.width =
+			    common->width;
+			break;
+		}
+	default:
+		dev_err(vpif_dev, "Invalid command\n");
+
+		return -EINVAL;
+	}
+
+	dev_dbg(vpif_dev, "End of vpif_doioctl\n");
+	return ret;
+}
+
+/* vpfe_ioctl : Calls vpif_doioctl function
+ */
+static int vpif_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	char sbuf[128];
+	void *mbuf = NULL;
+	void *parg = NULL;
+
+	dev_dbg(vpif_dev, "Start of vpif ioctl\n");
+	if (ISDECODERCMD(cmd)) {
+		ret = vpif_doioctl(inode, file, cmd, arg);
+		if (ret == -ENOIOCTLCMD)
+			ret = -EINVAL;
+		goto out;
+	}
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		parg = NULL;
+		break;
+	case _IOC_READ:
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		ret = -EFAULT;
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(parg, (void __user *)arg,
+					   _IOC_SIZE(cmd)))
+				goto out;
+		break;
+	}
+
+	/* call driver */
+	ret = vpif_doioctl(inode, file, cmd, (unsigned long)parg);
+	if (ret == -ENOIOCTLCMD)
+		ret = -EINVAL;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			ret = -EFAULT;
+		break;
+	}
+out:
+	if (mbuf)
+		kfree(mbuf);
+
+	dev_dbg(vpif_dev, "End of vpif ioctl\n");
+	return ret;
+}
+
+/*  vpfe_mmap : It is used to map kernel space buffers
+ *  into user spaces
+ */
+static int vpif_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	int err = 0, i, found = 0;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	dev_dbg(vpif_dev, "Start of vpif mmap\n");
+	for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+		if (common->buffer_queue.bufs[i]->boff == offset)
+			found = 1;
+	}
+	if (0 == found) {
+		common = &(channel->common[VPIF_HBI_INDEX]);
+		for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+			if (common->buffer_queue.bufs[i]->boff == offset)
+				found = 1;
+		}
+	}
+	if (0 == found)
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+	dev_dbg(vpif_dev, "End of vpif mmap\n");
+	return err;
+}
+
+/* vpif_poll: It is used for select/poll system call
+ */
+static unsigned int vpif_poll(struct file *filep, poll_table * wait)
+{
+	int err = 0;
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	dev_dbg(vpif_dev, "<vpif_poll>");
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	common = &(channel->common[VPIF_VBI_INDEX]);
+	if (common->started)
+		err |= videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	dev_dbg(vpif_dev, "</vpif_poll>");
+	return err;
+}
+
+/* vpif_open : It creates object of file handle structure and
+ * stores it in private_data  member of filepointer
+ */
+static int vpif_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0;
+	struct channel_obj *channel = NULL;
+	struct decoder_device *dec = NULL;
+	struct video_obj *vid_ch = NULL;
+	struct common_obj *common = NULL;
+	struct vpif_fh *fh = NULL;
+	u8 name[20];
+
+	dev_dbg(vpif_dev, "<vpif open>\n");
+
+	/* Check for valid minor number */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		vid_ch = &(channel->video);
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+		if (minor == channel->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(vpif_dev, "device not found\n");
+		return -ENODEV;
+	}
+	channel->current_decoder = 0;
+	/* Select the decoder as per the device_type argument */
+	if (config_params.device_type >= 0) {
+		if (config_params.device_type == 0)
+			strncpy(name, "TVP5147", sizeof(name));
+		else
+			strncpy(name, "MT9T001", sizeof(name));
+		for (i = 0; i < channel->numdecoders; i++) {
+			if (0 == strncmp(channel->decoder[i]->name, name,
+					 sizeof(name))) {
+				channel->current_decoder = i;
+				break;
+			}
+		}
+	}
+	channel->default_decoder = channel->current_decoder;
+	vid_ch->input_idx = 0;
+	/* Check if decoder registered for default device */
+	dec = channel->decoder[channel->current_decoder];
+	if (ISNULL(dec)) {
+		dev_err(vpif_dev, "No decoder registered\n");
+		return -ENXIO;
+	}
+	if (ISNULL(dec->std_ops) || ISNULL(dec->std_ops->getstd)) {
+		dev_err(vpif_dev, "No standard functions in decoder\n");
+		return -EINVAL;
+	}
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpif_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(vpif_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = channel;
+	fh->initialized = 0;
+	/* If decoder is not initialized. initialize it */
+	if (!channel->initialized) {
+		fh->initialized = 1;
+		/* Initialize decoder by calling initialize function */
+		dec->initialize(dec, DECODER_FULL_INIT_FLAG);
+		channel->initialized = 1;
+		/* Increment usage counter */
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+
+		/* Get the default standard and info about standard */
+		dec->std_ops->getstd(&vid_ch->std, dec);
+		vpif_get_std_info(channel);
+		common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+		/* Configure the default format information */
+		vpif_config_format(channel);
+	}
+	/* Increment channel usrs counter */
+	channel->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed[VPIF_VIDEO_INDEX] =
+	    fh->io_allowed[VPIF_VBI_INDEX] = fh->io_allowed[VPIF_HBI_INDEX] = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&channel->prio, &fh->prio);
+
+	dev_dbg(vpif_dev, "</vpif_open>\n");
+	return 0;
+}
+
+static void vpif_free_vbibuffers(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = NULL;
+	u32 bufsize, i;
+	common = &(channel->common[index]);
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == common->buffer_queue.type)
+		bufsize = VPIF_SLICED_BUF_SIZE;
+	else {
+		/* Calculate the size of the buffer */
+		bufsize = ((common->fmt.fmt.vbi.count[0]) +
+			   (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+	for (i = 0; i < common->numbuffers; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+	}
+	common->numbuffers = 0;
+}
+static void vpif_free_allbuffers(struct channel_obj *channel)
+{
+	int i;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 start = config_params.numbuffers[channel->channel_id];
+	u32 end = common->numbuffers;
+	u32 bufsize = config_params.channel_bufsize[channel->channel_id];
+	for (i = start; i < end; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+}
+
+/* vpif_release : This function deletes buffer queue, frees the
+ * buffers and the vpfe file  handle
+ */
+static int vpif_release(struct inode *inode, struct file *filep)
+{
+	struct common_obj *common = NULL;
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	int i;
+
+	dev_dbg(vpif_dev, "<vpif_release>\n");
+	common = &(channel->common[VPIF_VIDEO_INDEX]);
+	/* If this is doing IO and other channels are not closed */
+	if ((channel->usrs != 1) && fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		dev_err(vpif_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on channel object */
+	down_interruptible(&common->lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		common->io_usrs = 0;
+		/* Disable channel/vbi as per its device type and channel id */
+		if (VPIF_CHANNEL0_VIDEO == channel->channel_id) {
+			enable_channel0(0);
+			channel0_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL1_VIDEO == channel->channel_id) ||
+		    (2 == common->started)) {
+			enable_channel1(0);
+			channel1_intr_enable(0);
+		}
+		common->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&common->buffer_queue);
+		vpif_free_allbuffers(channel);
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+	}
+	/* unlock semaphore on channel object */
+	up(&common->lock);
+
+	for (i = VPIF_VBI_INDEX; i <= VPIF_HBI_INDEX; i++) {
+		common = &(channel->common[i]);
+		/* If this is doing IO and other channels are not closed */
+		if ((channel->usrs != 1) && fh->io_allowed[i]) {
+			dev_err(vpif_dev, "Close other instances\n");
+			return -EAGAIN;
+		}
+		/* Get the lock on channel object */
+		down_interruptible(&common->lock);
+
+		/* if this instance is doing IO */
+		if (fh->io_allowed[i]) {
+			/* Reset io_usrs member of channel object */
+			common->io_usrs = 0;
+			/* Disable channel/vbi as per its device type and 
+			   channel id */
+			disable_raw_feature(channel->channel_id, i);
+			common->started = 0;
+			/* Free buffers allocated */
+			videobuf_queue_cancel(&common->buffer_queue);
+			vpif_free_vbibuffers(channel, i);
+			common->numbuffers = 0;
+		}
+		/* unlock semaphore on channel object */
+		up(&common->lock);
+	}
+
+	/* Decrement channel usrs counter */
+	channel->usrs--;
+	/* Close the priority */
+	v4l2_prio_close(&channel->prio, &fh->prio);
+	/* If this file handle has initialize decoder device, reset it */
+	if (fh->initialized) {
+		dec->deinitialize(dec);
+		channel->initialized = 0;
+	}
+	filep->private_data = NULL;
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+
+	dev_dbg(vpif_dev, "</vpif_release>\n");
+	return 0;
+}
+
+static void vpif_platform_release(struct device
+				  *device)
+{
+	/* This is called when the reference count goes to zero. */
+}
+
+static struct file_operations vpif_fops = {
+	.owner = THIS_MODULE,
+	.open = vpif_open,
+	.release = vpif_release,
+	.ioctl = vpif_ioctl,
+	.mmap = vpif_mmap,
+	.poll = vpif_poll
+};
+static struct video_device vpif_video_template = {
+	.name = "vpif",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &vpif_fops,.minor = -1,
+};
+
+/* vpif_probe : This function creates device entries by register
+ * itself to the V4L2 driver and initializes fields of each
+ * channel objects */
+static __init int vpif_probe(struct device *device)
+{
+	struct common_obj *common = NULL;
+	int i, j = 0, k, err = 0, index = 0;
+	struct video_device *vfd = NULL;
+	struct channel_obj *channel = NULL;
+	struct video_obj *vid_ch = NULL;
+	vpif_dev = device;
+
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Allocate memory for video device */
+		vfd = video_device_alloc();
+		if (ISNULL(vfd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release(vpif_obj.dev[j]->
+						     video_dev);
+			}
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vfd = vpif_video_template;
+		vfd->dev = device;
+		vfd->release = video_device_release;
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "DaVinciHD_VPIFCapture_DRIVER_V%d.%d.%d",
+			 (VPIF_CAPTURE_VERSION_CODE >> 16) & 0xff,
+			 (VPIF_CAPTURE_VERSION_CODE >> 8) & 0xff,
+			 (VPIF_CAPTURE_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		channel->video_dev = vfd;
+	}
+
+	for (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {
+		channel = vpif_obj.dev[j];
+		channel->usrs = 0;
+		for (k = VPIF_VIDEO_INDEX; k <= VPIF_HBI_INDEX; k++) {
+			common = &(channel->common[k]);
+			common->io_usrs = 0;
+			common->started = 0;
+			common->irqlock = SPIN_LOCK_UNLOCKED;
+			init_MUTEX(&common->lock);
+			common->numbuffers = 0;
+			common->set_addr = NULL;
+			common->ytop_off = common->ybtm_off = 0;
+			common->ctop_off = common->cbtm_off = 0;
+			common->curFrm = common->nextFrm = NULL;
+			memset(&common->fmt, 0, sizeof(struct v4l2_format));
+		}
+		channel->video.std = 0;
+		channel->initialized = 0;
+		channel->channel_id = j;
+
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+		vid_ch = &(channel->video);
+		/* Initialize field of the channel objects */
+		channel->usrs = common->io_usrs = vid_ch->std = 0;
+		common->started = channel->initialized = 0;
+		channel->channel_id = j;
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+
+		channel->numdecoders = 0;
+		channel->current_decoder = 0;
+		for (index = 0; index < VPIF_CAPTURE_NUM_DECODERS; index++) {
+			channel->decoder[index] = NULL;
+		}
+
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+		/* Initialize prio member of channel object */
+		v4l2_prio_init(&channel->prio);
+
+		/* Set the tasklet handler in the tasklet struct */
+		channel->vbi.vbi_tasklet.func = vbi_work_handler;
+		/* Set Timer counter */
+		channel->vbi.timer_counter = VPIF_TIMER_COUNT;
+		/* Initialize the work structure */
+		INIT_WORK(&vbi_work[channel->channel_id],
+			  (void (*)(void *))vbi_work_handler, (void *)channel);
+		/* register video device */
+		dev_dbg(vpif_dev, "trying to register vpif device.\n");
+		dev_dbg(vpif_dev, "channel=%x,channel->video_dev=%x\n",
+			(int)channel, (int)&channel->video_dev);
+		channel->common[VPIF_VIDEO_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		channel->common[VPIF_VBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;
+		channel->common[VPIF_HBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_HBI_CAPTURE;
+		err = video_register_device(channel->video_dev,
+					    VFL_TYPE_GRABBER, vpif_nr[j]);
+		if (err)
+			goto probe_out;
+	}
+	return 0;
+
+probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[k];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		/* Release video device */
+		video_device_release(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_probe>\n");
+	return err;
+}
+
+/*  vpif_remove : It un-register channels from V4L2 driver
+ */
+static int vpif_remove(struct device *device)
+{
+	int i;
+	struct channel_obj *channel;
+	dev_dbg(vpif_dev, "<vpif_remove>\n");
+	/* un-register device */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_remove>\n");
+	return 0;
+}
+
+static struct device_driver vpif_driver = {
+	.name = "vpif capture",
+	.bus = &platform_bus_type,
+	.probe = vpif_probe,
+	.remove = vpif_remove,
+};
+static struct platform_device _vpif_device = {
+	.name = "vpif capture",
+	.id = 1,
+	.dev = {
+		.release = vpif_platform_release,
+		}
+};
+
+/* vpif_init : This function registers device and driver to
+ * the kernel, requests irq handler and allocates memory
+ * for channel objects
+ */
+static __init int vpif_init(void)
+{
+	int free_irq_no_index;
+	int err = 0, i, j;
+	int free_channel_objects_index;
+	int free_buffer_channel_index;
+	int free_buffer_index;
+	u8 *addr;
+	u32 size;
+
+	/* Default number of buffers should be 3 */
+	if ((channel0_numbuffers > 0) &&
+	    (channel0_numbuffers < config_params.min_numbuffers))
+		channel0_numbuffers = config_params.min_numbuffers;
+	if ((channel1_numbuffers > 0) &&
+	    (channel1_numbuffers < config_params.min_numbuffers))
+		channel1_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (channel0_bufsize < config_params.min_bufsize[VPIF_CHANNEL0_VIDEO])
+		channel0_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL0_VIDEO];
+	if (channel1_bufsize < config_params.min_bufsize[VPIF_CHANNEL1_VIDEO])
+		channel1_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL1_VIDEO];
+
+	config_params.numbuffers[VPIF_CHANNEL0_VIDEO] = channel0_numbuffers;
+	config_params.numbuffers[VPIF_CHANNEL1_VIDEO] = channel1_numbuffers;
+	if (channel0_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL0_VIDEO]
+		    = channel0_bufsize;
+	}
+	if (channel1_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL1_VIDEO]
+		    = channel1_bufsize;
+	}
+
+	/* Check the correct value of device_type */
+	if ((device_type > config_params.max_device_type) || (device_type < 0)) {
+		config_params.device_type = 0;
+	} else {
+		config_params.device_type = device_type;
+	}
+	/* Allocate memory for six channel objects */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		vpif_obj.dev[i] =
+		    kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!vpif_obj.dev[i]) {
+			free_channel_objects_index = i;
+			goto vpif_init_free_channel_objects;
+			err = -ENOMEM;
+		}
+	}
+	free_channel_objects_index = VPIF_CAPTURE_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		size = config_params.channel_bufsize[i];
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (u8 *) vpif_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_channel_index = i;
+				free_buffer_index = j;
+				err = -ENOMEM;
+				goto vpif_init_free_buffers;
+			}
+			vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].fbuffers[j] =
+			    addr;
+		}
+	}
+	free_buffer_channel_index = VPIF_CAPTURE_NUM_CHANNELS;
+	free_buffer_index = config_params.numbuffers[i - 1];
+
+	/* Create the workqueue */
+	vbi_workqueue = create_singlethread_workqueue("vbi");
+	if (!vbi_workqueue) {
+		err = -ENOMEM;
+		goto vpif_init_free_buffers;
+	}
+
+	/* Register driver to the kernel */
+	err = driver_register(&vpif_driver);
+	if (0 != err) {
+		goto vpif_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_vpif_device);
+	if (0 != err) {
+		goto vpif_init_unregister_vpif_driver;
+	}
+	for (j = 0; j < VPIF_CAPTURE_NUM_CHANNELS; j++) {
+		err =
+		    request_irq(vpif_get_irq_number(j),
+				vpif_channel_isr, SA_INTERRUPT,
+				"DaVinciHD_Capture",
+				(void *)(&(vpif_obj.dev[j]->channel_id)));
+		if (0 != err) {
+			if (j == 0) {
+				goto vpif_init_unregister_vpif_device;
+			} else {
+				free_irq_no_index = j;
+				goto vpif_init_free_irq;
+			}
+		}
+	}
+	free_irq_no_index = VPIF_CAPTURE_NUM_CHANNELS;
+
+	/* Set the pinmux settings */
+	set_vpif_pinmux();
+
+	return 0;
+
+vpif_init_free_irq:
+	for (j = 0; j < free_irq_no_index; j++) {
+		free_irq(vpif_get_irq_number(j),
+			 (void *)(&(vpif_obj.dev[j]->channel_id)));
+	}
+vpif_init_unregister_vpif_device:
+	platform_device_unregister(&_vpif_device);
+
+vpif_init_unregister_vpif_driver:
+	driver_unregister(&vpif_driver);
+
+vpif_init_free_buffers:
+	for (i = 0; i < free_buffer_channel_index; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j];
+			if (addr) {
+				vpif_free_buffer((unsigned long)addr,
+						 config_params.
+						 channel_bufsize[i]
+				    );
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = NULL;
+			}
+		}
+	}
+	for (j = 0; j < free_buffer_index; j++) {
+		addr =
+		    vpif_obj.dev[free_buffer_channel_index]->
+		    common[VPIF_VIDEO_INDEX].fbuffers[j];
+		if (addr) {
+			vpif_free_buffer((unsigned long)addr,
+					 config_params.channel_bufsize[i]);
+			vpif_obj.dev[free_buffer_channel_index]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j]
+			    = NULL;
+		}
+	}
+
+vpif_init_free_channel_objects:
+	for (j = 0; j < free_channel_objects_index; j++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[j]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* vpif_cleanup : This function un-registers device and driver
+ * to the kernel, frees requested irq handler and de-allocates memory
+ * allocated for channel objects.
+ */
+static void vpif_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		free_irq(vpif_get_irq_number(i),
+			 (void *)(&(vpif_obj.dev[i]->channel_id)));
+	}
+	/* Flush and destroy the workqueue */
+	flush_workqueue(vbi_workqueue);
+	destroy_workqueue(vbi_workqueue);
+
+	platform_device_unregister(&_vpif_device);
+	driver_unregister(&vpif_driver);
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (u32) vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = NULL;
+			}
+		}
+	}
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[i]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+}
+
+/* vpif_enum_std : Function to enumerate all the standards in 
+ * all the registered decoders
+ */
+static int vpif_enum_std(struct channel_obj *channel)
+{
+	int i, j, index;
+	struct video_obj *vid_ch = NULL;
+	struct v4l2_standard standard;
+	struct decoder_device *dec;
+	v4l2_std_id all_std = 0;
+	int ret = 0;
+	vid_ch = &(channel->video);
+	vid_ch->count_std = 0;
+
+	/* For all the registered encoders */
+	for (i = 0; i < channel->numdecoders; i++) {
+		dec = channel->decoder[i];
+		/* Do the enumstd */
+		for (j = 0; j < dec->std_ops->count; j++) {
+			standard.index = j;
+			ret = dec->std_ops->enumstd(&standard, dec);
+			if (ret)
+				return ret;
+
+			/* If the standard is already added, 
+			 * do not add it to the table */
+			if (all_std & standard.id)
+				continue;
+			/* Store the standard information in the table */
+			index = vid_ch->count_std;
+			vid_ch->std_tbl[index].dec_idx = i;
+			vid_ch->std_tbl[index].std_idx = j;
+			vid_ch->std_tbl[index].std = standard.id;
+			vid_ch->count_std++;
+			all_std |= standard.id;
+		}
+	}
+	return 0;
+}
+
+/* vpif_register_decoder : This function will be called by the decoder
+ * driver to register its functionalities to vpif driver
+ */
+int vpif_register_decoder(struct decoder_device
+			  *decoder)
+{
+	struct channel_obj *channel = vpif_obj.dev[decoder->channel_id];
+	int err = -EINVAL;
+
+	dev_dbg(vpif_dev, "<vpif_register_decoder>\n");
+	if (ISNULL(channel)) {
+		return err;
+	}
+	if (channel->numdecoders < VPIF_CAPTURE_NUM_DECODERS) {
+		channel->decoder[channel->numdecoders++] = decoder;
+		err = vpif_enum_std(channel);
+		return err;
+	}
+	dev_dbg(vpif_dev, "</vpif_register_decoder>\n");
+	return err;
+}
+
+/* vpif_unregister_decoder : This function will be called by the decoder
+ * driver to un-register its functionalities to vpif driver
+ */
+int vpif_unregister_decoder(struct decoder_device
+			    *decoder)
+{
+	int i, j = 0, err = 0;
+	struct channel_obj *channel = vpif_obj.dev[decoder->channel_id];
+	dev_dbg(vpif_dev, "<vpif_unregister_decoder>\n");
+
+	for (i = 0; i < channel->numdecoders; i++) {
+		if (decoder == channel->decoder[i]) {
+			if (channel->decoder[channel->current_decoder] ==
+			    decoder && channel->initialized)
+				return -EBUSY;
+			channel->decoder[i] = NULL;
+			for (j = i; j < channel->numdecoders - 1; j++)
+				channel->decoder[j] = channel->decoder[j + 1];
+			channel->numdecoders--;
+			err = vpif_enum_std(channel);
+			break;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_unregister_decoder>\n");
+	return err;
+}
+
+EXPORT_SYMBOL(vpif_register_decoder);
+EXPORT_SYMBOL(vpif_unregister_decoder);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(vpif_init);
+module_exit(vpif_cleanup);
Index: linux-2.6.10/drivers/media/video/davinci/davincihd_display.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davincihd_display.c
@@ -0,0 +1,2547 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davincihd_display.c */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <media/davinci/davincihd_display.h>
+#include <media/davinci/vpif.h>
+#include <asm/arch/video_hdevm.h>
+
+#include <asm/arch/i2c-client.h>
+
+#include <media/davinci/davinci_enc.h>
+
+static u32 channel2_numbuffers = 3;
+static u32 channel3_numbuffers = 3;
+static u32 channel2_bufsize = 1920 * 1080 * 2;
+static u32 channel3_bufsize = 720 * 576 * 2;
+
+module_param(channel2_numbuffers, uint, S_IRUGO);
+module_param(channel3_numbuffers, uint, S_IRUGO);
+module_param(channel2_bufsize, uint, S_IRUGO);
+module_param(channel3_bufsize, uint, S_IRUGO);
+
+static struct vpif_config_params config_params = {
+	.min_numbuffers = 3,
+	.numbuffers[0] = 3,
+	.numbuffers[1] = 3,
+	.min_bufsize[0] = 720 * 480 * 2,
+	.min_bufsize[1] = 720 * 480 * 2,
+	.channel_bufsize[0] = 1920 * 1080 * 2,
+	.channel_bufsize[1] = 720 * 576 * 2,
+};
+
+static int vpif_nr[] = { 2, 3, };
+
+/* global variables */
+static struct vpif_device vpif_obj = { {NULL} };
+static struct workqueue_struct *vbi_workqueue;
+static struct work_struct vbi_work[VPIF_DISPLAY_NUM_CHANNELS];
+
+static struct device *vpif_dev = NULL;
+
+static struct v4l2_capability vpif_videocap = {
+	.driver = "vpif display",
+	.card = "DaVinciHD EVM",
+	.bus_info = "Platform",
+	.version = VPIF_DISPLAY_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING |
+	    V4L2_CAP_VBI_OUTPUT | V4L2_CAP_HBI_OUTPUT |
+	    V4L2_CAP_SLICED_VBI_OUTPUT
+};
+
+static struct v4l2_vbi_format vpif_raw_vbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_VBI_START_FIELD0,
+		   VPIF_NTSC_VBI_START_FIELD1},
+	 .count = {VPIF_NTSC_VBI_COUNT_FIELD0,
+		   VPIF_NTSC_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_VBI_START_FIELD0,
+		   VPIF_PAL_VBI_START_FIELD1},
+	 .count = {VPIF_PAL_VBI_COUNT_FIELD0,
+		   VPIF_PAL_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+static struct v4l2_vbi_format vpif_raw_hbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_HBI_START_FIELD0,
+		   VPIF_NTSC_HBI_START_FIELD1},
+	 .count = {VPIF_NTSC_HBI_COUNT_FIELD0,
+		   VPIF_NTSC_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_HBI_START_FIELD0,
+		   VPIF_PAL_HBI_START_FIELD1},
+	 .count = {VPIF_PAL_HBI_COUNT_FIELD0,
+		   VPIF_PAL_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct vpif_service_line vbi_service_lines[] = {
+	{V4L2_SLICED_CGMS_525, {20, 283}, VID_ENC_SLICED_VBI_CGMS_NTSC, 3},
+	{V4L2_SLICED_CAPTION_525, {21, 284}, VID_ENC_SLICED_VBI_CC_NTSC,
+	 2},
+	{V4L2_SLICED_WSS_625, {23, 0}, VID_ENC_SLICED_VBI_WSS_PAL, 2},
+};
+
+static void vbi_work_handler(unsigned long data1)
+{
+	int i, j;
+	struct channel_obj *channel = (struct channel_obj *)data1;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	struct v4l2_sliced_vbi_data *addr = (struct v4l2_sliced_vbi_data *)
+	    common->curFrm->boff;
+	struct vid_enc_sliced_vbi_data data[2];
+	addr = (struct v4l2_sliced_vbi_data *)
+	    phys_to_virt((unsigned long)addr);
+	down(&common->lock);
+	if (channel->field_id == 1)
+		addr += channel->vbi.num_services;
+	for (i = 0; i < channel->vbi.num_services; i++) {
+		data[i].service_id = 0;
+		data[i].field = 0;
+		for (j = 0; j < 3; j++) {
+			if ((addr + i)->id & vbi_service_lines[j].service_id) {
+				data[i].service_id =
+				    vbi_service_lines[j].enc_service_id;
+				data[i].field = addr->field;
+				memcpy(data[i].data, (addr + i)->data,
+				       vbi_service_lines[j].bytestowrite);
+			}
+		}
+	}
+	davinci_enc_write_sliced_vbi_data(channel->channel_id, data);
+	up(&common->lock);
+}
+
+/*
+ * vpif_alloc_buffer: Allocate memory for buffers */
+static inline unsigned long vpif_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/*
+ *vpif_free_buffer : Free memory for buffers */
+static inline void vpif_free_buffer(unsigned long addr, unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*
+ * vpif_uservirt_to_phys: This inline function is used to convert user
+ * space virtual address to physical address.
+ */
+static inline u32 vpif_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *)virtp);
+	} else if ((vma = find_vma(mm, virtp)) && (vma->vm_flags & VM_IO)
+		   && (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated,
+		   mmaped-to-usermode addresses */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp = __pa(page_address(&pages[0]) +
+				     (virtp & ~PAGE_MASK));
+		} else {
+			dev_err(vpif_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+
+	return physp;
+}
+
+/*
+ * buffer_prepare: This is the callback function called from videobuf_qbuf()
+ * function the buffer is prepared and user space virtual address is converted
+* into physical address */
+static int vpif_buffer_prepare(struct videobuf_queue *q,
+			       struct videobuf_buffer *vb,
+			       enum v4l2_field field)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	unsigned long addr;
+	int i, j, prevline = 0, num_services;
+	struct v4l2_sliced_vbi_data *vbidata;
+	struct common_obj *common = NULL;
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	dev_dbg(vpif_dev, "<vpif_buffer_prepare>\n");
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = common->width;
+		vb->height = common->height;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		if (0 == vb->baddr) {
+			dev_err(vpif_dev, "buffer_address is 0\n");
+			return -EINVAL;
+		}
+		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	addr = vb->boff;
+	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {
+		if (!ISALIGNED((addr + common->ytop_off)) ||
+		    !ISALIGNED((addr + common->ybtm_off)) ||
+		    !ISALIGNED((addr + common->ctop_off)) ||
+		    !ISALIGNED((addr + common->cbtm_off))) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		num_services = channel->vbi.num_services;
+		vbidata = (struct v4l2_sliced_vbi_data *)phys_to_virt(vb->boff);
+		prevline = 0;
+		for (i = 0; i < num_services * 2; i++) {
+			if (0 == vbidata->id)
+				continue;
+			if (!(vbidata->id & common->fmt.fmt.sliced.service_set)) {
+				dev_err(vpif_dev, "Invalid service\n");
+				return -EINVAL;
+			}
+			if (vbidata->field != 0 && vbidata->field != 1) {
+				dev_err(vpif_dev, "Invalid field\n");
+				return -EINVAL;
+			}
+			for (j = 0; j < VPIF_SLICED_MAX_SERVICES; j++) {
+				if (!(vbidata->id &
+				      vbi_service_lines[j].service_id))
+					continue;
+				if ((vbidata->field == 0)
+				    && (vbidata->line !=
+					vbi_service_lines[j].service_line[0])) {
+					dev_err(vpif_dev,
+						"Invalid field0line\n");
+					return -EINVAL;
+				}
+				if ((vbidata->field == 1)
+				    && (vbidata->line !=
+					vbi_service_lines[j].service_line[1])) {
+					dev_err(vpif_dev,
+						"Invalid field0line\n");
+					return -EINVAL;
+				}
+			}
+			if (prevline > vbidata->line) {
+				dev_err(vpif_dev,
+					"Lines are not in increasing order\n");
+				return -EINVAL;
+			}
+			prevline = vbidata->line;
+			vbidata++;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_prepare>\n");
+	return 0;
+}
+
+/*
+ * vpif_buffer_config: This function is responsible to responsible for
+ * buffer's physical address */
+static void vpif_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int i;
+	dev_dbg(vpif_dev, "<vpif_buffer_config>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer config\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((void *)common->fbuffers[i]);
+		dev_dbg(vpif_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_config>\n");
+}
+
+/*
+ * vpif_buffer_setup: This function allocates memory for the buffers */
+static int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			     unsigned int *size)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int i;
+	int startindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_setup>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer setup\n");
+		return 0;
+	}
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == q->type) {
+		/* Calculate the size of the buffer */
+		*size = config_params.channel_bufsize[channel->channel_id];
+		startindex = config_params.numbuffers[channel->channel_id];
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		/* Get the size of the buffer */
+		*size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		*size = ((common->fmt.fmt.vbi.count[0]) +
+			 (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	for (i = startindex; i < *count; i++) {
+		/* Allocate memory for the buffers */
+		common->fbuffers[i] = (u8 *) vpif_alloc_buffer(*size);
+		if (!common->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = common->numbuffers = i;
+	dev_dbg(vpif_dev, "</vpif_buffer_setup>\n");
+	return 0;
+}
+
+/*
+ * vpif_buffer_queue: This function adds the buffer to DMA queue  */
+static void vpif_buffer_queue(struct videobuf_queue *q,
+			      struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	dev_dbg(vpif_dev, "<vpif_buffer_queue>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpif_dev, "</vpif_buffer_queue>\n");
+}
+
+/*
+ * vpif_buffer_release: This function is called from the videobuf layer to
+ * free memory allocated to the buffers */
+static void vpif_buffer_release(struct videobuf_queue *q,
+				struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	unsigned int buf_size = 0;
+	int endindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_release>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	vb->state = STATE_NEEDS_INIT;
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer release\n");
+		return;
+	}
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == q->type) {
+		/* Calculate the size of the buffer */
+		buf_size = config_params.channel_bufsize[channel->channel_id];
+		endindex = config_params.numbuffers[channel->channel_id];
+
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		/* Get the size of the buffer */
+		buf_size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		buf_size = ((common->fmt.fmt.vbi.count[0]) +
+			    (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	dev_dbg(vpif_dev, "</vpif_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = vpif_buffer_setup,
+	.buf_prepare = vpif_buffer_prepare,
+	.buf_queue = vpif_buffer_queue,
+	.buf_release = vpif_buffer_release,
+	.buf_config = vpif_buffer_config,
+};
+
+static u8 channel_first_int[VPIF_NUMOBJECTS][2] = { {1, 1}, {1, 1}, {1, 1} };
+
+/* vpif_channel_isr: It changes status of the displayed buffer, takes next
+ * buffer from the queue and sets its address in VPIF registers */
+static irqreturn_t vpif_channel_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct timeval timevalue;
+	int fid = -1, i;
+	struct vpif_device *dev = &vpif_obj;
+	int channel_id = 0;
+	unsigned long addr = 0;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	enum v4l2_field field;
+	dev_dbg(vpif_dev, "<vpif_channel_isr>\n");
+
+	channel_id = *(int *)(dev_id);
+	channel = dev->dev[channel_id];
+	vid_ch = &(channel->video);
+
+	do_gettimeofday(&timevalue);
+	field = channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;
+	for (i = 0; i < VPIF_NUMOBJECTS; i++) {
+		common = &(channel->common[i]);
+		/* If streaming is started in this channel */
+		if (0 == common->started)
+			continue;
+
+		/* Check the field format */
+		if (1 == vid_ch->std_info.frame_format) {
+			if (list_empty(&common->dma_queue))
+				continue;
+			/* Progressive mode */
+			if (!channel_first_int[i][channel_id]) {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				common->curFrm->ts = timevalue;
+				common->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				common->curFrm = common->nextFrm;
+			}
+			channel_first_int[i][channel_id] = 0;
+
+			/* Get the next buffer from buffer queue */
+			common->nextFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&common->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			common->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+
+			addr = common->nextFrm->boff;
+
+			if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == common->fmt.type) {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+			} else {
+				common->set_addr(addr + common->ytop_off,
+						 addr + common->ybtm_off,
+						 addr + common->ctop_off,
+						 addr + common->cbtm_off);
+			}
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (channel_first_int[i][channel_id]) {
+				channel_first_int[i][channel_id] = 0;
+				continue;
+			}
+			if (0 == i) {
+				channel->field_id ^= 1;
+				/* Get field id from VPIF registers */
+				fid =
+				    vpif_channel_getfid(channel->
+							channel_id + 2);
+				/* If field id does not match with stored
+				   field id */
+				if (fid != channel->field_id) {
+					/* Make them in sync */
+					if (0 == fid) {
+						channel->field_id = fid;
+					}
+					return IRQ_HANDLED;
+				}
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (common->curFrm == common->nextFrm) {
+					continue;
+				}
+				/* one frame is displayed If next frame is
+				 *  available, release curFrm and move on*/
+
+				/* Copy frame display time */
+				common->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				common->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				common->curFrm = common->nextFrm;
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				}
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&common->dma_queue)
+				    || (common->curFrm != common->nextFrm)) {
+					continue;
+				}
+
+				/* one field is displayed configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				common->nextFrm = list_entry(common->
+							     dma_queue.
+							     next, struct
+							     videobuf_buffer,
+							     queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&common->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				common->nextFrm->state = STATE_ACTIVE;
+				addr = common->nextFrm->boff;
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				} else {
+					common->set_addr(addr +
+							 common->ytop_off,
+							 addr +
+							 common->ybtm_off,
+							 addr +
+							 common->ctop_off,
+							 addr +
+							 common->cbtm_off);
+				}
+
+			}
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_channel_isr>\n");
+	return IRQ_HANDLED;
+}
+
+static void vpif_get_std_info(struct channel_obj *ch)
+{
+	struct video_obj *vid_ch = &(ch->video);
+	struct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);
+	int ret;
+
+	vid_ch->std_info.channel_id = ch->channel_id + 2;
+
+	/* Get standard name from the encoder by enumerating standards */
+	strncpy(vid_ch->std_info.name, vid_ch->mode_info.name,
+		sizeof(vid_ch->std_info.name));
+
+	/* Get standard information from VPIF layer */
+	ret = vpif_get_mode_info(&vid_ch->std_info);
+	common->fmt.fmt.pix.width = vid_ch->std_info.activepixels;
+	common->fmt.fmt.pix.height = vid_ch->std_info.activelines;
+
+	/* Set height and width paramateres */
+	ch->common[VPIF_VIDEO_INDEX].height = vid_ch->std_info.activelines;
+	ch->common[VPIF_VIDEO_INDEX].width = vid_ch->std_info.activepixels;
+}
+
+/*
+ * vpif_calculate_offsets: This function calculates buffers offset for Y and C
+ * in the top and bottom field */
+static void vpif_calculate_offsets(struct channel_obj *channel)
+{
+	unsigned int hpitch, vpitch, sizeimage;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	struct video_obj *vid_ch = &(channel->video);
+	struct vpif_params *vpifparams = &channel->vpifparams;
+	enum v4l2_field field = common->fmt.fmt.pix.field;
+
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets>\n");
+
+	if (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {
+		if (vid_ch->std_info.frame_format)
+			vid_ch->buf_field = V4L2_FIELD_NONE;
+		else
+			vid_ch->buf_field = V4L2_FIELD_INTERLACED;
+	} else {
+		vid_ch->buf_field = common->fmt.fmt.pix.field;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = common->fmt.fmt.pix.sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+
+	hpitch = common->fmt.fmt.pix.bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = hpitch;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = sizeimage / 2 + hpitch;
+	} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = sizeimage / 4;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = common->ctop_off + sizeimage / 4;
+	} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ybtm_off = 0;
+		common->ytop_off = sizeimage / 4;
+		common->cbtm_off = sizeimage / 2;
+		common->ctop_off = common->cbtm_off + sizeimage / 4;
+	}
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		vpifparams->video_params.storage_mode = 1;
+	} else {
+		vpifparams->video_params.storage_mode = 0;
+	}
+
+	if (vid_ch->std_info.frame_format == 1) {
+		vpifparams->video_params.hpitch =
+		    common->fmt.fmt.pix.bytesperline;
+	} else {
+		if ((field == V4L2_FIELD_ANY)
+		    || (field == V4L2_FIELD_INTERLACED))
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline * 2;
+		else
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline;
+	}
+	strncpy(channel->vpifparams.video_params.name,
+		vid_ch->std_info.name,
+		sizeof(channel->vpifparams.video_params.name));
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets>\n");
+}
+
+static void vpif_calculate_offsets_vbi(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets_vbi>\n");
+
+	common->ytop_off = 0;
+	common->ctop_off = 0;
+	common->ybtm_off = (common->fmt.fmt.vbi.count[0]) *
+	    (common->fmt.fmt.vbi.samples_per_line);
+	common->cbtm_off = 0;
+
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets_vbi>\n");
+}
+static void vpif_config_format(struct channel_obj *channel)
+{
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	common->fmt.fmt.pix.field = V4L2_FIELD_ANY;
+
+	if (config_params.numbuffers[channel->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+
+	common->fmt.fmt.pix.sizeimage
+	    = config_params.channel_bufsize[channel->channel_id];
+
+	common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+	common->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	channel->common[VPIF_VBI_INDEX].fmt.type =
+	    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;
+	channel->common[VPIF_VBI_INDEX].fmt.fmt.sliced.service_set = 0;
+	channel->common[VPIF_VBI_INDEX].memory = V4L2_MEMORY_MMAP;
+
+	channel->common[VPIF_HBI_INDEX].fmt.type = V4L2_BUF_TYPE_HBI_OUTPUT;
+	channel->common[VPIF_HBI_INDEX].memory = V4L2_MEMORY_MMAP;
+}
+
+static int vpif_check_format(struct channel_obj *channel,
+			     struct v4l2_pix_format *pixfmt)
+{
+	u32 sizeimage, hpitch, vpitch;
+	enum v4l2_field field = pixfmt->field;
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	dev_dbg(vpif_dev, "<vpif_check_format>\n");
+
+	if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422UVP) {
+		dev_err(vpif_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (!(VPIF_VALID_FIELD(field))) {
+		dev_err(vpif_dev, "invalid field format\n");
+		return -EINVAL;
+	}
+	if (pixfmt->bytesperline <= 0) {
+		dev_err(vpif_dev, "invalid pitch\n");
+		return -EINVAL;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = pixfmt->sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+
+	davinci_enc_get_mode(channel->channel_id, &channel->video.mode_info);
+	vpif_get_std_info(channel);
+
+	hpitch = pixfmt->bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	/* Check for valid value of pitch */
+	if ((hpitch < vid_ch->std_info.activepixels) ||
+	    (vpitch < vid_ch->std_info.activelines)) {
+		dev_err(vpif_dev, "Invalid pitch\n");
+		return -EINVAL;
+	}
+	/* Check for 8 byte alignment */
+	if (!(ISALIGNED(hpitch))) {
+		dev_err(vpif_dev, "invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = common->fmt.fmt.pix.width;
+	pixfmt->height = common->fmt.fmt.pix.height;
+
+	dev_dbg(vpif_dev, "</vpif_check_format>\n");
+	return 0;
+}
+
+static void vpif_config_addr(struct channel_obj *channel, int muxmode)
+{
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	dev_dbg(vpif_dev, "<vpif_config_addr>");
+	if (VPIF_CHANNEL3_VIDEO == channel->channel_id) {
+		common->set_addr = ch3_set_videobuf_addr;
+	} else {
+		if (2 == muxmode) {
+			common->set_addr = ch2_set_videobuf_addr_yc_nmux;
+		} else {
+			common->set_addr = ch2_set_videobuf_addr;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_config_addr>");
+}
+
+static void vpif_config_addr_vbi(struct channel_obj *channel,
+				 int channel_id, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_config_addr_vbi>");
+	if (VPIF_CHANNEL3_VIDEO == channel_id) {
+		common->set_addr = ch3_set_vbi_addr;
+	} else {
+		common->set_addr = ch2_set_vbi_addr;
+	}
+	dev_dbg(vpif_dev, "</vpif_config_addr_vbi>");
+}
+
+static int vpif_try_raw_format(struct channel_obj *channel,
+			       struct v4l2_vbi_format *fmt, u8 index)
+{
+	struct video_obj *vid_ch = &(channel->video);
+	struct v4l2_vbi_format *raw_vbi;
+	if (0 == strcmp(vid_ch->mode_info.name, "NTSC")) {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[0]) :
+		    &(vpif_raw_hbi_formats[0]);
+	} else {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[1]) :
+		    &(vpif_raw_hbi_formats[1]);
+	}
+
+	if ((fmt->sampling_rate != raw_vbi->sampling_rate) ||
+	    (fmt->samples_per_line != raw_vbi->samples_per_line) ||
+	    (fmt->start[0] != raw_vbi->start[0]) ||
+	    (fmt->count[0] != raw_vbi->count[0]) ||
+	    (fmt->start[1] != raw_vbi->start[1]) ||
+	    (fmt->count[1] != raw_vbi->count[1]) ||
+	    (fmt->flags != raw_vbi->flags)) {
+		dev_err(vpif_dev, "invalid parameters\n");
+		*fmt = *raw_vbi;
+		return -EINVAL;
+	}
+	return 0;
+}
+int vpif_try_sliced_vbi(struct v4l2_format *fmt,
+			struct vid_enc_sliced_vbi_service *service)
+{
+	u16 serv = 0;
+	if (service->service_set & VID_ENC_SLICED_VBI_CGMS_NTSC)
+		serv |= V4L2_SLICED_CGMS_525;
+	if (service->service_set & VID_ENC_SLICED_VBI_CC_NTSC)
+		serv |= V4L2_SLICED_CAPTION_525;
+	if (service->service_set & VID_ENC_SLICED_VBI_WSS_PAL)
+		serv |= V4L2_SLICED_WSS_625;
+	if (fmt->fmt.sliced.service_set & (~serv)) {
+		fmt->fmt.sliced.service_set = serv;
+		return -EINVAL;
+	}
+	return 0;
+}
+int vpif_convert_vbi_services(struct v4l2_format *fmt,
+			      struct vid_enc_sliced_vbi_service *service)
+{
+	service->service_set = 0;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_CGMS_525)
+		service->service_set |= VID_ENC_SLICED_VBI_CGMS_NTSC;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_CAPTION_525)
+		service->service_set |= VID_ENC_SLICED_VBI_CC_NTSC;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_WSS_625)
+		service->service_set |= VID_ENC_SLICED_VBI_WSS_PAL;
+	if (0 == service->service_set && 0 != fmt->fmt.sliced.service_set)
+		return -EINVAL;
+	return 0;
+}
+
+/*
+ * vpif_doioctl: This function will provide different V4L2 commands.This
+ * function can be used to configure driver or get status of driver as per
+ * command passed by application */
+static int vpif_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct vpif_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct video_obj *vid_ch = &(channel->video);
+	unsigned int index = 0;
+	unsigned long addr = 0, flags;
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+
+	/* This file handle has not initialized the channel, 
+	   It is not allowed to do settings */
+	if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_FMT:
+		case VIDIOC_REQBUFS:
+		case VPIF_S_VPIF_PARAMS:
+		case VPIF_CMD_S_ENCODER_PARAMS:
+			if (!fh->initialized) {
+				dev_err(vpif_dev, "Channel Busy\n");
+				return -EBUSY;
+			}
+		}
+	}
+	/* Check for the priority */
+	if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_FMT:
+			ret = v4l2_prio_check(&channel->prio, &fh->prio);
+			if (0 != ret)
+				return ret;
+			fh->initialized = 1;
+			break;
+		}
+	}
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(vpif_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCAP\n");
+			memset(cap, 0, sizeof(*cap));
+			if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+			    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+				*cap = vpif_videocap;
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUM_FMT\n");
+			if (fmt->index != 0) {
+				dev_err(vpif_dev, "Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			strcpy(fmt->description, "YCbCr4:2:2 YC Planar");
+			fmt->pixelformat = V4L2_PIX_FMT_YUV422UVP;
+			break;
+		}
+
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_G_FMT\n");
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != fmt->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If buffer type is not video output */
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {
+				if (vid_ch->std_info.vbi_supported == 0)
+					return -EINVAL;
+			}
+			/* Fill in the information about
+			 * format */
+			down_interruptible(&(common->lock));
+			ret = davinci_enc_get_mode(channel->channel_id,
+						   &channel->video.mode_info);
+			if (ret < 0)
+				return ret;
+
+			vpif_get_std_info(channel);
+			*fmt = common->fmt;
+			up(&(common->lock));
+			dev_dbg(vpif_dev, "SUCCESS.\n");
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_S_FMT\n");
+
+			/* If streaming is started, return error */
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+
+				if (ret) {
+					return ret;
+				}
+
+				/* store the pixel format in the channel
+				 * object */
+				common->fmt.fmt.pix = *pixfmt;
+				dev_dbg(vpif_dev, "Success.\n");
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err
+					    (vpif_dev,
+					     "standard doesn't support\n");
+					return -EINVAL;
+				}
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == fmt->type) {
+					struct vid_enc_sliced_vbi_service
+					    service;
+					ret =
+					    vpif_convert_vbi_services(fmt,
+								      &service);
+					if (ret < 0)
+						return ret;
+					ret =
+					    davinci_enc_enable_sliced_vbi
+					    (channel->channel_id, &service);
+					if (ret >= 0) {
+						common->height = 1;
+						common->width =
+						    VPIF_SLICED_BUF_SIZE;
+						channel->vbi.num_services = ret;
+					}
+				} else if ((V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_OUTPUT ==
+					    fmt->type)) {
+					index =
+					    (V4L2_BUF_TYPE_VBI_OUTPUT ==
+					     fmt->
+					     type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret =
+					    vpif_try_raw_format(channel,
+								&(fmt->fmt.
+								  vbi), index);
+					if (ret < 0)
+						return ret;
+					if (V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type)
+						ret =
+						    davinci_enc_enable_vbi
+						    (channel->channel_id, 1);
+					else
+						ret =
+						    davinci_enc_enable_hbi
+						    (channel->channel_id, 1);
+					if (ret < 0)
+						return ret;
+					common->height =
+					    common->fmt.fmt.vbi.count[0] +
+					    common->fmt.fmt.vbi.count[1];
+					common->width = common->fmt.
+					    fmt.vbi.samples_per_line;
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+
+			/* store the format in the channel
+			 * object */
+			down_interruptible(&common->lock);
+			common->fmt = *fmt;
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt = NULL;
+			struct common_obj *common = NULL;
+			fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_TRY_FMT\n");
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+				if (ret) {
+					*pixfmt = common->fmt.fmt.pix;
+					pixfmt->sizeimage =
+					    pixfmt->width * pixfmt->height * 2;
+				}
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev,
+						"standard doesn't support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == fmt->type) {
+					struct vid_enc_sliced_vbi_service
+					    service;
+					ret =
+					    davinci_enc_get_sliced_cap
+					    (channel->channel_id, &service);
+					if (ret < 0)
+						return ret;
+					ret = vpif_try_sliced_vbi(fmt,
+								  &service);
+				} else if ((V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_OUTPUT ==
+					    fmt->type)) {
+					index =
+					    (V4L2_BUF_TYPE_VBI_OUTPUT ==
+					     fmt->
+					     type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret |=
+					    vpif_try_raw_format(channel,
+								&(fmt->fmt.
+								  vbi), index);
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+			break;
+		}
+
+		/* If the case is for getting encoder parameters */
+	case VPIF_CMD_G_ENCODER_PARAMS:
+		{
+			dev_dbg(vpif_dev, "VPIF_CMD_G_ENCODER_PARAMS\n");
+			ret = davinci_enc_getparams(channel->channel_id,
+						    (void *)arg);
+			break;
+		}
+
+		/* If the case is for setting encoder parameters */
+	case VPIF_CMD_S_ENCODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_S_ENCODER_PARAMS\n");
+			down_interruptible(&common->lock);
+			/* If channel is already started, return
+			 * error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				up(&common->lock);
+				return -EBUSY;
+			}
+			ret = davinci_enc_setparams(channel->channel_id,
+						    (void *)arg);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *reqbuf =
+			    (struct v4l2_requestbuffers *)arg;
+			enum v4l2_field field;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_REQBUFS\n");
+
+			if ((V4L2_BUF_TYPE_VIDEO_OUTPUT != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_VBI_OUTPUT != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != reqbuf->type)
+			    && (V4L2_BUF_TYPE_HBI_OUTPUT != reqbuf->type))
+				return -EINVAL;
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == reqbuf->type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == reqbuf->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != reqbuf->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* Only mmap is supported for sliced VBI */
+			if ((V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == reqbuf->type)
+			    && (V4L2_MEMORY_MMAP != reqbuf->memory)) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If io users of the channel is not zero,
+			   return error */
+			if (0 != common->io_usrs) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (reqbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				if (common->fmt.fmt.pix.field == V4L2_FIELD_ANY)
+					field = V4L2_FIELD_INTERLACED;
+				else
+					field = common->fmt.fmt.pix.field;
+			} else {
+				field = V4L2_VBI_INTERLACED;
+			}
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&common->buffer_queue,
+					    &video_qops, NULL,
+					    &common->irqlock,
+					    reqbuf->type,
+					    field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&common->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed[index] = 1;
+			/* Increment io usrs member of channel object
+			   to 1 */
+			common->io_usrs = 1;
+			/* Store type of memory requested in channel
+			   object */
+			common->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&common->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&common->buffer_queue, reqbuf);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			struct videobuf_buffer *buf1;
+			dev_dbg(vpif_dev, "VIDIOC_QBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == tbuf.type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != tbuf.type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (!(list_empty(&common->dma_queue)) ||
+			    (common->curFrm != common->nextFrm) ||
+			    !(common->started) ||
+			    (common->started && (0 == channel->field_id))) {
+				ret =
+				    videobuf_qbuf(&common->buffer_queue,
+						  (struct v4l2_buffer *)
+						  arg);
+				break;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != common->fmt.type) {
+				ret = videobuf_qbuf(&common->buffer_queue,
+						    (struct v4l2_buffer *)
+						    arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 *  in VPIF registers */
+			down(&common->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = common->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(vpif_dev, "invalid buffer" " type\n");
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				dev_err(vpif_dev, "invalid state\n");
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					up(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					up(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					vpif_buffer_release(&common->
+							    buffer_queue, buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    vpif_buffer_prepare(&common->buffer_queue,
+						buf1,
+						common->buffer_queue.field);
+			if (ret < 0) {
+				local_irq_restore(flags);
+				up(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			common->nextFrm = buf1;
+			if (tbuf.type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+			}
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(common->buffer_queue.stream));
+			up(&common->buffer_queue.lock);
+			break;
+
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VIDIOC_DQBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+				 ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == tbuf.type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != tbuf.type) {
+				ret = -EINVAL;
+				break;
+			}
+
+			if (tbuf.memory != V4L2_MEMORY_MMAP)
+				return -EINVAL;
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&common->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			enum v4l2_buf_type buftype = *(enum v4l2_buf_type *)arg;
+			u8 index =
+			    (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+			     buftype) ? (VPIF_VIDEO_INDEX)
+			    : ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+				buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			struct common_obj *common = &(channel->common[index]);
+			struct channel_obj *oth_ch =
+			    vpif_obj.dev[!channel->channel_id];
+			struct vpif_params *vpif = &channel->vpifparams;
+			dev_dbg(vpif_dev, "VIDIOC_STREAMON\n");
+			/* If file handle is not allowed IO,
+			 * return error */
+
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EBUSY;
+				break;
+			}
+			if ((channel->channel_id == VPIF_CHANNEL2_VIDEO
+			     && oth_ch->common[VPIF_VIDEO_INDEX].started &&
+			     channel->video.std_info.ycmux_mode == 0)
+			    || ((channel->channel_id == VPIF_CHANNEL3_VIDEO)
+				&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].
+				    started))) {
+				dev_err(vpif_dev, "other channel is using\n");
+				ret = -EBUSY;
+				break;
+			}
+			if (index == VPIF_VIDEO_INDEX) {
+				ret = vpif_check_format
+				    (channel, &(common->fmt.fmt.pix));
+				if (ret < 0) {
+					return ret;
+				}
+			} else {
+				if (!channel->common[VPIF_VIDEO_INDEX].started)
+					return -EINVAL;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&common->buffer_queue);
+			if (ret < 0) {
+				dev_err(vpif_dev, "videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&common->lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&common->dma_queue)) {
+				dev_err(vpif_dev, "buffer queue is empty\n");
+				ret = -EIO;
+				up(&common->lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			common->nextFrm = common->curFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&common->curFrm->queue);
+			/* Mark state of the current frame to active */
+			common->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+			channel->field_id = 0;
+			common->started = 1;
+
+			if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				addr = common->curFrm->boff;
+				/* Calculate the offset for Y and C data
+				   in the buffer */
+				vpif_calculate_offsets(channel);
+
+				if ((vid_ch->std_info.frame_format &&
+				     ((common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_NONE)
+				      && (common->fmt.fmt.pix.field !=
+					  V4L2_FIELD_ANY)))
+				    || (!vid_ch->std_info.frame_format
+					&& (common->fmt.fmt.pix.field ==
+					    V4L2_FIELD_NONE))) {
+					dev_err(vpif_dev,
+						"conflict in field format \
+							and std format\n");
+					up(&common->lock);
+					return -EINVAL;
+				}
+				/* if single channel is needed */
+				if (vid_ch->std_info.ycmux_mode == 1) {
+					ret = set_vid_out_mode_for_sd();
+				} else {
+					ret = set_vid_out_mode_for_hd();
+				}
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set vid out bit\n");
+					up(&common->lock);
+					return ret;
+				}
+				/* Set clock settings */
+				ret = set_vid_clock(vid_ch->std_info.hd_sd);
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret = vpif_set_video_params(vpif,
+							    channel->
+							    channel_id + 2);
+				if (ret < 0) {
+					up(&common->lock);
+					return ret;
+				}
+				common->started = ret;
+				vpif_config_addr(channel, ret);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				/* Set interrupt for both the fields in
+				   VPIF Register enable channel in
+				   VPIF register */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					channel2_intr_assert();
+					channel2_intr_enable(1);
+					enable_channel2(1);
+				}
+				if ((VPIF_CHANNEL3_VIDEO == channel->channel_id)
+				    || (common->started == 2)) {
+					channel3_intr_assert();
+					channel3_intr_enable(1);
+					enable_channel3(1);
+				}
+				channel_first_int[VPIF_VIDEO_INDEX]
+				    [channel->channel_id] = 1;
+			} else if ((V4L2_BUF_TYPE_VBI_OUTPUT == buftype)
+				   || (V4L2_BUF_TYPE_HBI_OUTPUT == buftype)) {
+				if (V4L2_BUF_TYPE_VBI_OUTPUT == buftype)
+					index = VPIF_VBI_INDEX;
+				else
+					index = VPIF_HBI_INDEX;
+				/* Calculate the offset for vbi data
+				   in the buffer */
+				vpif_calculate_offsets_vbi(channel, index);
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret = vpif_set_vbi_display_params
+				    (&channel->vpifparams.params.
+				     vbi_params, channel->channel_id);
+				if (ret < 0) {
+					up(&(common->lock));
+					return ret;
+				}
+				vpif_config_addr_vbi(channel,
+						     channel->channel_id,
+						     index);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id)
+					channel2_raw_enable(1, index);
+
+				if (VPIF_CHANNEL3_VIDEO == channel->channel_id)
+					channel3_raw_enable(1, index);
+
+				channel_first_int[index][channel->channel_id]
+				    = 1;
+			} else {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+				channel_first_int
+				    [VPIF_VBI_INDEX][channel->channel_id]
+				    = 1;
+			}
+			up(&(common->lock));
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			enum v4l2_buf_type buftype = *(enum v4l2_buf_type *)arg;
+			u8 index =
+			    (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+			     buftype) ? (VPIF_VIDEO_INDEX)
+			    : ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+				buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			struct common_obj *common = &(channel->common[index]);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMOFF\n");
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				/* disable channel */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					enable_channel2(0);
+					channel2_intr_enable(0);
+				}
+				if ((VPIF_CHANNEL3_VIDEO ==
+				     channel->channel_id) ||
+				    (2 == common->started)) {
+					enable_channel3(0);
+					channel3_intr_enable(0);
+				}
+			} else if (buftype == V4L2_BUF_TYPE_VBI_OUTPUT) {
+				/* disable raw vbi channel */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					channel2_raw_enable(0, index);
+				} else {
+					channel3_raw_enable(0, index);
+				}
+			} else {
+				/* disabel sliced vbi channel */
+				struct vid_enc_sliced_vbi_service services;
+				services.service_set = 0;
+				ret =
+				    davinci_enc_enable_sliced_vbi(channel->
+								  channel_id,
+								  &services);
+			}
+			common->started = 0;
+			up(&common->lock);
+			ret = videobuf_streamoff(&common->buffer_queue);
+			break;
+		}
+
+		/* If the case is for setting VPIF parameters */
+	case VPIF_S_VPIF_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct vpif_params *params = (struct vpif_params *)arg;
+			dev_dbg(vpif_dev, "VPIF_S_PARAMS\n");
+			/* If streaming is not started, return error */
+			if (common->started) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&common->lock);
+			channel->vpifparams = *params;
+			up(&common->lock);
+			common = &(channel->common[VPIF_VBI_INDEX]);
+			break;
+		}
+
+		/* If the case is for getting VPIF Parameters */
+	case VPIF_G_VPIF_PARAMS:
+		{
+			struct vpif_params *params = (struct vpif_params *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_G_PARAMS\n");
+			down_interruptible(&common->lock);
+			*params = channel->vpifparams;
+			up(&common->lock);
+			common = &(channel->common[VPIF_VBI_INDEX]);
+			break;
+		}
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			ret = v4l2_prio_change(&channel->prio, &fh->prio, *p);
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			*p = v4l2_prio_max(&channel->prio);
+			break;
+		}
+		/* If the case is for getting sliced vbi capabilites */
+	case VIDIOC_G_SLICED_VBI_CAP:
+		{
+			struct vid_enc_sliced_vbi_service service;
+			struct v4l2_sliced_vbi_cap *cap =
+			    (struct v4l2_sliced_vbi_cap *)arg;
+			ret =
+			    davinci_enc_get_sliced_cap(channel->channel_id,
+						       &service);
+			cap->service_set = 0;
+			if (service.service_set & VID_ENC_SLICED_VBI_CGMS_NTSC)
+				cap->service_set |= V4L2_SLICED_CGMS_525;
+			if (service.service_set & VID_ENC_SLICED_VBI_CC_NTSC)
+				cap->service_set |= V4L2_SLICED_CAPTION_525;
+			if (service.service_set & VID_ENC_SLICED_VBI_WSS_PAL)
+				cap->service_set |= V4L2_SLICED_WSS_625;
+			break;
+		}
+		/* If the case if for getting cropping parameters */
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *crop = (struct v4l2_cropcap *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != crop->type)
+				return -EINVAL;
+			crop->bounds.left = crop->bounds.top = 0;
+			crop->defrect.left = crop->defrect.top = 0;
+			crop->defrect.height = crop->bounds.height =
+			    common->height;
+			crop->defrect.width = crop->bounds.width =
+			    common->width;
+			break;
+		}
+	default:
+		dev_dbg(vpif_dev, "Invalid command\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+	return ret;
+}
+
+/*
+ * vpif_ioctl: Calls vpif_doioctl function */
+static int vpif_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	char sbuf[128];
+	void *mbuf = NULL;
+	void *parg = NULL;
+
+	dev_dbg(vpif_dev, "Start of vpif ioctl\n");
+
+	if (ISENCODERCMD(cmd)) {
+		ret = vpif_doioctl(inode, file, cmd, (unsigned long)arg);
+		if (ret == -ENOIOCTLCMD)
+			ret = -EINVAL;
+		goto out;
+	}
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		parg = NULL;
+		break;
+	case _IOC_READ:
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		ret = -EFAULT;
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(parg, (void __user *)arg,
+					   _IOC_SIZE(cmd)))
+				goto out;
+		break;
+	}
+
+	/* call driver */
+	ret = vpif_doioctl(inode, file, cmd, (unsigned long)parg);
+	if (ret == -ENOIOCTLCMD)
+		ret = -EINVAL;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			ret = -EFAULT;
+		break;
+	}
+out:
+	if (mbuf)
+		kfree(mbuf);
+
+	dev_dbg(vpif_dev, "</vpif_ioctl>\n");
+	return ret;
+}
+
+/*
+ * vpif_mmap: It is used to map kernel space buffers into user spaces */
+static int vpif_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	int err = 0, i, found = 0;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	dev_dbg(vpif_dev, "<vpif_mmap>\n");
+	for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+		if (common->buffer_queue.bufs[i]->boff == offset)
+			found = 1;
+	}
+	if (found == 0) {
+		common = &(channel->common[VPIF_HBI_INDEX]);
+		for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+			if (common->buffer_queue.bufs[i]->boff == offset)
+				found = 1;
+		}
+	}
+	if (0 == found)
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+	dev_dbg(vpif_dev, "</vpif_mmap>\n");
+	return err;
+}
+
+/* vpif_poll: It is used for select/poll system call
+ */
+static unsigned int vpif_poll(struct file *filep, poll_table * wait)
+{
+	int err = 0;
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	dev_dbg(vpif_dev, "<vpif_poll>");
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	common = &(channel->common[VPIF_VBI_INDEX]);
+	if (common->started)
+		err |= videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	if (err & POLLIN) {
+		err &= (~POLLIN);
+		err |= POLLOUT;
+	}
+	if (err & POLLRDNORM) {
+		err &= (~POLLRDNORM);
+		err |= POLLWRNORM;
+	}
+
+	dev_dbg(vpif_dev, "</vpif_poll>");
+	return err;
+}
+
+/*
+ * vpif_open: It creates object of file handle structure and stores it in
+ * private_data member of filepointer */
+static int vpif_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0, err = 0;
+	struct channel_obj *channel;
+	struct vpif_fh *fh = NULL;
+
+	dev_dbg(vpif_dev, "<vpif open>\n");
+
+	/* Check for valid minor number */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		if (minor == channel->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(vpif_dev, "device not found\n");
+		return -ENODEV;
+	}
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpif_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(vpif_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = channel;
+	fh->initialized = 0;
+	/* If encoder is not initialized. initialize it */
+	if (!channel->initialized) {
+		fh->initialized = 1;
+		channel->initialized = 1;
+		/* increment module usage counter */
+		/* Get the default standard and info about standard */
+		err = davinci_enc_get_mode(channel->channel_id,
+					   &channel->video.mode_info);
+		if (err < 0)
+			goto vpif_open_out;
+
+		vpif_get_std_info(channel);
+		channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.
+		    bytesperline =
+		    channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.width;
+		/* Configure the default format information */
+		vpif_config_format(channel);
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+	}
+vpif_open_out:
+	if (err < 0) {
+		if (fh->initialized) {
+			channel->initialized = 0;
+		}
+		filep->private_data = NULL;
+		fh->initialized = 0;
+		/* Free memory allocated to file handle object */
+		if (!ISNULL(fh))
+			kfree(fh);
+		return err;
+	}
+	/* Increment channel usrs counter */
+	channel->usrs++;
+	/* Set io_allowed[VPIF_VIDEO_INDEX] member to false */
+	fh->io_allowed[VPIF_VIDEO_INDEX] = 0;
+	/* Set io_allowed[VPIF_VBI_INDEX] member to false */
+	fh->io_allowed[VPIF_VBI_INDEX] = 0;
+	fh->io_allowed[VPIF_HBI_INDEX] = 0;
+
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+
+	v4l2_prio_open(&channel->prio, &fh->prio);
+
+	dev_dbg(vpif_dev, "</vpif_open>\n");
+	return err;
+}
+
+static void vpif_free_vbibuffers(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = NULL;
+	u32 bufsize, i;
+	common = &(channel->common[index]);
+	if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == common->buffer_queue.type) {
+		bufsize = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		bufsize = ((common->fmt.fmt.vbi.count[0]) +
+			   (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+	for (i = 0; i < common->numbuffers; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+	common->numbuffers = 0;
+}
+
+static void vpif_free_allbuffers(struct channel_obj *channel)
+{
+	int i;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 start = config_params.numbuffers[channel->channel_id];
+	u32 end = common->numbuffers;
+	u32 bufsize = config_params.channel_bufsize[channel->channel_id];
+	for (i = start; i < end; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+}
+
+/*
+ * vpif_release: This function deletes buffer queue, frees the buffers and
+ * the vpif file handle */
+static int vpif_release(struct inode *inode, struct file *filep)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	int i;
+
+	dev_dbg(vpif_dev, "<vpif_release>\n");
+	/* If this is doing IO and other channels are not closed */
+	if ((channel->usrs != 1) && fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		dev_err(vpif_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on channel object */
+	down_interruptible(&common->lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		common->io_usrs = 0;
+		/* Disable channel/vbi as per its device type 
+		   and channel id */
+		if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+			enable_channel2(0);
+			channel2_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL3_VIDEO == channel->channel_id) ||
+		    (2 == common->started)) {
+			enable_channel3(0);
+			channel3_intr_enable(0);
+		}
+		common->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&common->buffer_queue);
+		vpif_free_allbuffers(channel);
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+
+	}
+	/* unlock semaphore on channel object */
+	up(&common->lock);
+
+	for (i = VPIF_VBI_INDEX; i <= VPIF_HBI_INDEX; i++) {
+		down_interruptible(&(channel->common[i].lock));
+		if (fh->io_allowed[i]) {
+			/* Reset io_usrs member of channel object */
+			channel->common[i].io_usrs = 0;
+			/* Disable channel/vbi as per its device type 
+			   and channel id */
+			if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+				channel2_raw_enable(0, i);
+			} else {
+				channel3_raw_enable(0, i);
+			}
+			channel->common[i].started = 0;
+			/* Free buffers allocated */
+			videobuf_queue_cancel
+			    (&channel->common[VPIF_VBI_INDEX].buffer_queue);
+			vpif_free_vbibuffers(channel, i);
+			common->numbuffers = 0;
+		}
+		up(&(channel->common[i].lock));
+	}
+	/* Decrement channel usrs counter */
+	channel->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (fh->initialized) {
+		channel->initialized = 0;
+	}
+	/* Close the priority */
+	v4l2_prio_close(&channel->prio, &fh->prio);
+	filep->private_data = NULL;
+	fh->initialized = 0;
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+	dev_dbg(vpif_dev, "</vpif_release>\n");
+	return 0;
+}
+
+static void vpif_platform_release(struct device
+				  *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct file_operations vpif_fops = {
+	.owner = THIS_MODULE,
+	.open = vpif_open,
+	.release = vpif_release,
+	.ioctl = vpif_ioctl,
+	.mmap = vpif_mmap,
+	.poll = vpif_poll
+};
+static struct video_device vpif_video_template = {
+	.name = "vpif",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &vpif_fops,
+	.minor = -1
+};
+
+/*
+ * vpif_probe: This function creates device entries by register itself to the
+ * V4L2 driver and initializes fields of each channel objects */
+static __init int vpif_probe(struct device *device)
+{
+	int i, j = 0, k, err = 0;
+	struct video_device *vfd = NULL;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	vpif_dev = device;
+	dev_dbg(vpif_dev, "<vpif_probe>\n");
+
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Allocate memory for video device */
+		vfd = video_device_alloc();
+		if (ISNULL(vfd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release
+				    (vpif_obj.dev[j]->video_dev);
+			}
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vfd = vpif_video_template;
+		vfd->dev = device;
+		vfd->release = video_device_release;
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "DaVinciHD_VPIFDisplay_DRIVER_V%d.%d.%d",
+			 (VPIF_DISPLAY_VERSION_CODE >> 16)
+			 & 0xff,
+			 (VPIF_DISPLAY_VERSION_CODE >> 8) &
+			 0xff, (VPIF_DISPLAY_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		channel->video_dev = vfd;
+	}
+
+	for (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {
+		channel = vpif_obj.dev[j];
+		/* Initialize field of the channel objects */
+		channel->usrs = 0;
+		for (k = 0; k < VPIF_NUMOBJECTS; k++) {
+			channel->common[k].numbuffers = 0;
+			common = &(channel->common[k]);
+			common->io_usrs = 0;
+			common->started = 0;
+			common->irqlock = SPIN_LOCK_UNLOCKED;
+			init_MUTEX(&common->lock);
+			common->numbuffers = 0;
+			common->set_addr = NULL;
+			common->ytop_off = common->ybtm_off = 0;
+			common->ctop_off = common->cbtm_off = 0;
+			common->curFrm = common->nextFrm = NULL;
+			memset(&common->fmt, 0, sizeof(struct v4l2_format));
+
+		}
+		channel->initialized = 0;
+		channel->channel_id = j;
+		if (j < 2)
+			channel->common[VPIF_VIDEO_INDEX].numbuffers =
+			    config_params.numbuffers[channel->channel_id];
+		else
+			channel->common[VPIF_VIDEO_INDEX].numbuffers = 0;
+
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+
+		/* Initialize prio member of channel object */
+		v4l2_prio_init(&channel->prio);
+
+		/* Initialize the work structure */
+		INIT_WORK(&vbi_work[channel->channel_id],
+			  (void (*)(void *))vbi_work_handler, (void *)channel);
+
+		channel->common[VPIF_VIDEO_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		channel->common[VPIF_VBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;
+		channel->common[VPIF_HBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_HBI_OUTPUT;
+		/* register video device */
+		dev_dbg(vpif_dev, "trying to register vpif device.\n");
+		dev_dbg(vpif_dev,
+			"channel=%x,channel->video_dev=%x\n",
+			(int)channel, (int)&channel->video_dev);
+
+		err =
+		    video_register_device(channel->
+					  video_dev,
+					  VFL_TYPE_GRABBER, vpif_nr[j]);
+		if (err < 0)
+			goto probe_out;
+	}
+	return 0;
+
+probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[k];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		/* Release video device */
+		video_device_release(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_probe>\n");
+	return err;
+}
+
+/*
+ * vpif_remove: It un-register channels from V4L2 driver */
+static int vpif_remove(struct device *device)
+{
+	int i;
+	struct channel_obj *channel;
+	dev_dbg(vpif_dev, "<vpif_remove>\n");
+	/* un-register device */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_remove>\n");
+	return 0;
+}
+
+static struct device_driver vpif_driver = {
+	.name = "vpif display",
+	.bus = &platform_bus_type,
+	.probe = vpif_probe,
+	.remove = vpif_remove,
+};
+static struct platform_device _vpif_device = {
+	.name = "vpif display",
+	.id = 1,
+	.dev = {
+		.release = vpif_platform_release,
+		}
+};
+
+/*
+ * vpif_init: This function registers device and driver to the kernel,
+* requests irq handler and allocates memory for channel objects */
+static __init int vpif_init(void)
+{
+	int err = 0, i, j;
+	int free_channel_objects_index;
+	int free_irq_no_index;
+	int free_buffer_channel_index;
+	int free_buffer_index;
+	u32 addr;
+	int size;
+
+	/* Default number of buffers should be 3 */
+	if ((channel2_numbuffers > 0) &&
+	    (channel2_numbuffers < config_params.min_numbuffers))
+		channel2_numbuffers = config_params.min_numbuffers;
+	if ((channel3_numbuffers > 0) &&
+	    (channel3_numbuffers < config_params.min_numbuffers))
+		channel3_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (channel2_bufsize < config_params.min_bufsize[VPIF_CHANNEL2_VIDEO])
+		channel2_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL2_VIDEO];
+	if (channel3_bufsize < config_params.min_bufsize[VPIF_CHANNEL3_VIDEO])
+		channel3_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL3_VIDEO];
+
+	config_params.numbuffers[VPIF_CHANNEL2_VIDEO] = channel2_numbuffers;
+
+	if (channel2_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL2_VIDEO]
+		    = channel2_bufsize;
+	}
+	config_params.numbuffers[VPIF_CHANNEL3_VIDEO] = channel3_numbuffers;
+
+	if (channel3_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL3_VIDEO]
+		    = channel3_bufsize;
+	}
+
+	/* Allocate memory for six channel objects */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		vpif_obj.dev[i] =
+		    kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!vpif_obj.dev[i]) {
+			free_channel_objects_index = i;
+			err = -ENOMEM;
+			goto vpif_init_free_channel_objects;
+		}
+	}
+	free_channel_objects_index = VPIF_DISPLAY_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		size = config_params.channel_bufsize[i];
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = vpif_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_channel_index = i;
+				free_buffer_index = j;
+				err = -ENOMEM;
+				goto vpif_init_free_buffers;
+			}
+			vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j] = (u8 *) addr;
+		}
+	}
+	free_buffer_channel_index = VPIF_DISPLAY_NUM_CHANNELS;
+	free_buffer_index = config_params.numbuffers[i - 1];
+
+	/* Create the workqueue */
+	vbi_workqueue = create_singlethread_workqueue("vbi");
+	if (!vbi_workqueue) {
+		err = -ENOMEM;
+		goto vpif_init_free_buffers;
+	}
+
+	/* Register driver to the kernel */
+	err = driver_register(&vpif_driver);
+	if (0 != err) {
+		goto vpif_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_vpif_device);
+	if (0 != err) {
+		goto vpif_init_unregister_vpif_driver;
+	}
+	for (j = 0; j < VPIF_DISPLAY_NUM_CHANNELS; j++) {
+		err =
+		    request_irq(vpif_get_irq_number(j + 2),
+				vpif_channel_isr,
+				SA_INTERRUPT, "DaVinciHD_Display",
+				(void *)(&(vpif_obj.dev[j]->channel_id)));
+		if (0 != err) {
+			free_irq_no_index = j;
+			goto vpif_init_free_irq;
+
+		}
+	}
+	free_irq_no_index = VPIF_DISPLAY_NUM_CHANNELS;
+
+	/* Set pinmux settings */
+	set_vpif_pinmux();
+
+	return 0;
+vpif_init_free_irq:
+	for (j = 0; j < free_irq_no_index; j++) {
+		free_irq(vpif_get_irq_number(j + 2),
+			 (void *)(&(vpif_obj.dev[j]->channel_id)));
+	}
+	platform_device_unregister(&_vpif_device);
+
+vpif_init_unregister_vpif_driver:
+	driver_unregister(&vpif_driver);
+
+vpif_init_free_buffers:
+	for (i = 0; i < free_buffer_channel_index; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (unsigned long)vpif_obj.dev[i]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = 0;
+			}
+		}
+	}
+	for (j = 0; j < free_buffer_index; j++) {
+		addr = (unsigned long)vpif_obj.
+		    dev[free_buffer_channel_index]->
+		    common[VPIF_VIDEO_INDEX].fbuffers[j];
+		if (addr) {
+			vpif_free_buffer(addr,
+					 config_params.channel_bufsize[i]);
+			vpif_obj.dev[free_buffer_channel_index]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j] = 0;
+		}
+
+	}
+
+vpif_init_free_channel_objects:
+	for (j = 0; j < free_channel_objects_index; j++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[j]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* vpif_cleanup: This function un-registers device and driver to the kernel,
+ * frees requested irq handler and de-allocates memory allocated for channel
+ * objects.
+ * */
+static void vpif_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		free_irq(vpif_get_irq_number(i + 2),
+			 (void *)(&(vpif_obj.dev[i]->channel_id)));
+	}
+	/* Flush and destroy the workqueue */
+	flush_workqueue(vbi_workqueue);
+	destroy_workqueue(vbi_workqueue);
+
+	platform_device_unregister(&_vpif_device);
+	driver_unregister(&vpif_driver);
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (unsigned long)vpif_obj.dev[i]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = 0;
+			}
+		}
+	}
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[i]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+}
+
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(vpif_init);
+module_exit(vpif_cleanup);
Index: linux-2.6.10/drivers/media/video/davinci/davincihd_platform.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davincihd_platform.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/davinci_platform.h>
+
+/* Function: davinci_enc_set_mode_platform
+ * @channel: channel number, starting index 0.
+ * @mgr: encoder device structure
+ * Returns: None
+ *
+ * Description:
+ *   This function does platform specific settings for the current mode.
+ *
+ */
+struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
+	{VID_ENC_OUTPUT_COMPOSITE,
+	 VID_ENC_STD_NTSC}
+};
+char *davinci_outputs[] = {
+	VID_ENC_OUTPUT_COMPOSITE,
+	VID_ENC_OUTPUT_COMPOSITE1,
+	VID_ENC_OUTPUT_SVIDEO,
+	VID_ENC_OUTPUT_SVIDEO1,
+	VID_ENC_OUTPUT_COMPONENT,
+	VID_ENC_OUTPUT_COMPONENT1,
+	VID_ENC_OUTPUT_LCD,
+	VID_ENC_OUTPUT_LCD1,
+	""
+};
+
+char *davinci_modes[] = {
+	VID_ENC_STD_NTSC,
+	VID_ENC_STD_NTSC_RGB,
+	VID_ENC_STD_PAL,
+	VID_ENC_STD_PAL_RGB,
+	VID_ENC_STD_720P_25,
+	VID_ENC_STD_720P_30,
+	VID_ENC_STD_720P_50,
+	VID_ENC_STD_720P_60,
+	VID_ENC_STD_1080I_25,
+	VID_ENC_STD_1080I_30,
+	VID_ENC_STD_1080P_24,
+	VID_ENC_STD_1080P_25,
+	VID_ENC_STD_1080P_30,
+	VID_ENC_STD_1080P_50,
+	VID_ENC_STD_1080P_60,
+	VID_ENC_STD_480P_60,
+	VID_ENC_STD_576P_50,
+	VID_ENC_STD_640x480,
+	VID_ENC_STD_640x400,
+	VID_ENC_STD_640x350,
+	""
+};
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
+{
+}
+
+/*
+ * davinci_enc_set_display_timing
+ */
+/* This function sets the display timing from the fb_info structure*/
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
+{
+};
Index: linux-2.6.10/drivers/media/video/davinci/tvp5147.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/tvp5147.c
@@ -0,0 +1,1654 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp5147.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <media/davinci/tvp5147.h>
+#include <asm/arch/video_hdevm.h>
+
+/* Prototypes */
+static int tvp5147_initialize(void *dec, int flag);
+static int tvp5147_deinitialize(void *dec);
+static int tvp5147_setcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp5147_getcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp5147_querycontrol(struct v4l2_queryctrl *queryctrl, void *dec);
+static int tvp5147_setstd(v4l2_std_id * id, void *dec);
+static int tvp5147_getstd(v4l2_std_id * id, void *dec);
+static int tvp5147_enumstd(struct v4l2_standard *std, void *dec);
+static int tvp5147_querystd(v4l2_std_id * id, void *dec);
+static int tvp5147_setinput(int *index, void *dec);
+static int tvp5147_getinput(int *index, void *dec);
+static int tvp5147_enuminput(struct v4l2_input *input, void *dec);
+static int tvp5147_setformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_tryformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_getformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_setparams(void *params, void *dec);
+static int tvp5147_getparams(void *params, void *dec);
+static int tvp5147_i2c_read_reg(struct i2c_client *client, u8 reg, u8 *val);
+static int tvp5147_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int tvp5147_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr);
+static int tvp5147_i2c_detach_client(struct i2c_client *client);
+static int tvp5147A_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp5147B_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp5147_i2c_init(void);
+static void tvp5147_i2c_cleanup(void);
+static int tvp5147_get_sliced_vbi_cap(struct v4l2_sliced_vbi_cap *cap,
+				      void *dec);
+static int tvp5147_read_vbi_data(struct v4l2_sliced_vbi_data *data, void *dec);
+
+static struct v4l2_standard tvp5147_standards[TVP5147_MAX_NO_STANDARDS] = {
+	{
+	 .index = 0,
+	 .id = V4L2_STD_525_60,
+	 .name = "NTSC",
+	 .frameperiod = {1001, 30000},
+	 .framelines = 525},
+	{
+	 .index = 1,
+	 .id = V4L2_STD_625_50,
+	 .name = "PAL",
+	 .frameperiod = {1, 25},
+	 .framelines = 625},
+	{
+	 .index = 2,
+	 .id = VPFE_STD_AUTO,
+	 .name = "auto detect",
+	 .frameperiod = {1, 1},
+	 .framelines = 1},
+	{
+	 .index = 3,
+	 .id = VPFE_STD_525_60_SQP,
+	 .name = "NTSC-SQP",
+	 .frameperiod = {1001, 30000},
+	 .framelines = 525},
+	{
+	 .index = 4,
+	 .id = VPFE_STD_625_50_SQP,
+	 .name = "PAL-SQP",
+	 .frameperiod = {1, 25},
+	 .framelines = 625},
+	{
+	 .index = 5,
+	 .id = VPFE_STD_AUTO_SQP,
+	 .name = "auto detect sqp pixel",
+	 .frameperiod = {1, 1},
+	 .framelines = 1}
+};
+
+static tvp5147_mode
+    tvp5147_modes[TVP5147_MAX_NO_STANDARDS][TVP5147_MAX_NO_MODES] = {
+	{TVP5147_MODE_NTSC, TVP5147_MODE_NTSC_443, 0xFF},
+	{TVP5147_MODE_PAL, TVP5147_MODE_PAL_M, TVP5147_MODE_PAL_CN},
+	{TVP5147_MODE_AUTO, 0xFF, 0xFF},
+	{TVP5147_MODE_NTSC_SQP, TVP5147_MODE_NTSC_443_SQP, 0xFF},
+	{TVP5147_MODE_PAL_SQP, TVP5147_MODE_PAL_M_SQP,
+	 TVP5147_MODE_PAL_CN_SQP},
+	{TVP5147_MODE_AUTO_SQP, 0xFF, 0xFF}
+};
+
+static struct tvp5147_control_info
+    tvp5147_control_information[TVP5147_MAX_NO_CONTROLS]
+    = {
+	{
+	 .register_address = TVP5147_BRIGHTNESS,
+	 .query_control = {
+			   .id = V4L2_CID_BRIGHTNESS,
+			   .name = "BRIGHTNESS",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+	 },
+	{
+	 .register_address = TVP5147_CONTRAST,
+	 .query_control = {
+			   .id = V4L2_CID_CONTRAST,
+			   .name = "CONTRAST",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+
+	 },
+	{
+	 .register_address = TVP5147_SATURATION,
+	 .query_control = {
+			   .id = V4L2_CID_SATURATION,
+			   .name = "SATURATION",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+	 },
+	{
+	 .register_address = TVP5147_HUE,
+	 .query_control = {
+			   .id = V4L2_CID_HUE,
+			   .name = "HUE",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = -128,
+			   .maximum = 127,
+			   .step = 1,
+			   .default_value = 0}
+	 },
+	{
+	 .register_address = TVP5147_AFE_GAIN_CTRL,
+	 .query_control = {
+			   .id = V4L2_CID_AUTOGAIN,
+			   .name = "Automatic Gain Control",
+			   .type = V4L2_CTRL_TYPE_BOOLEAN,
+			   .minimum = 0,
+			   .maximum = 1,
+			   .step = 1,
+			   .default_value = 1}
+	 }
+};
+
+static struct tvp5147_config tvp5147_configuration[TVP5147_NUM_CHANNELS] = {
+	{
+	 .no_of_inputs = TVP5147_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP5147_COMPOSITE_INPUT,
+		      .lock_mask = 0x0E,
+		      .input_info = {
+				     .index = 0,
+				     .name = "COMPOSITE",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP5147_ALL},
+		      .no_of_standard = TVP5147_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)tvp5147_standards,
+		      .def_std = VPFE_STD_AUTO,
+		      .mode = (tvp5147_mode(*)[]) & tvp5147_modes,
+		      .no_of_controls = TVP5147_MAX_NO_CONTROLS,
+		      .controls = (struct tvp5147_control_info *)
+		      &tvp5147_control_information},
+	 .sliced_cap = {
+			.service_set = (V4L2_SLICED_CAPTION_525 |
+					V4L2_SLICED_WSS_625 |
+					V4L2_SLICED_CGMS_525),
+			},
+	 .num_services = 0},
+	{
+	 .no_of_inputs = TVP5147_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP5147_SVIDEO_INPUT,
+		      .lock_mask = 0x06,
+		      .input_info = {
+				     .index = 0,
+				     .name = "SVIDEO",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP5147_ALL},
+		      .no_of_standard = TVP5147_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)tvp5147_standards,
+		      .def_std = VPFE_STD_AUTO,
+		      .mode = (tvp5147_mode(*)[]) & tvp5147_modes,
+		      .no_of_controls = TVP5147_MAX_NO_CONTROLS,
+		      .controls = (struct tvp5147_control_info *)
+		      &tvp5147_control_information},
+	 .sliced_cap = {.service_set = (V4L2_SLICED_CAPTION_525 |
+					V4L2_SLICED_WSS_625 |
+					V4L2_SLICED_CGMS_525),
+			},
+	 .num_services = 0}
+};
+
+static struct tvp5147_service_data_reg tvp5147_services_regs
+    [TVP5147_VBI_NUM_SERVICES] = {
+	{
+	 .service = V4L2_SLICED_WSS_625,
+	 .field[0].addr = {0x20, 0x05, 0x80},
+	 .field[1].addr = {0x24, 0x05, 0x80},
+	 .bytestoread = 2},
+	{
+	 .service = V4L2_SLICED_CAPTION_525,
+	 .field[0].addr = {0x1C, 0x05, 0x80},
+	 .field[1].addr = {0x1E, 0x05, 0x80},
+	 .bytestoread = 2},
+	{
+	 .service = V4L2_SLICED_CGMS_525,
+	 .field[0].addr = {0x20, 0x05, 0x80},
+	 .field[1].addr = {0x24, 0x05, 0x80},
+	 .bytestoread = 3},
+};
+
+static struct tvp5147_sliced_reg tvp5147_sliced_regs[TVP5147_VBI_NUM_SERVICES] = {
+	{
+	 .service = V4L2_SLICED_CAPTION_525,
+	 .std = V4L2_STD_525_60,
+	 .line_addr_value = 0x15,
+	 .line_start = 19,
+	 .line_end = 23,
+	 .field[0] = {
+		      .fifo_line_addr = {0x00, 0x06, 0x80},
+		      .fifo_mode_value = 0x01},
+	 .field[1] = {
+		      .fifo_line_addr = {0x02, 0x06, 0x80},
+		      .fifo_mode_value = 0x09},
+	 .service_line = {{21, 21}, {21, 284} }
+	 },
+	{
+	 .service = V4L2_SLICED_WSS_625,
+	 .std = V4L2_STD_625_50,
+	 .line_addr_value = 0x17,
+	 .line_start = 21,
+	 .line_end = 25,
+	 .field[0] = {
+		      .fifo_line_addr = {0x04, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .field[1] = {
+		      .fifo_line_addr = {0x04, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .service_line = {{23, 23}, {0, 0} }
+	 },
+	{
+	 .service = V4L2_SLICED_CGMS_525,
+	 .std = V4L2_STD_525_60,
+	 .line_addr_value = 0x14,
+	 .line_start = 18,
+	 .line_end = 22,
+	 .field[0] = {
+		      .fifo_line_addr = {0x08, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .field[1] = {
+		      .fifo_line_addr = {0x06, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .service_line = {{20, 20}, {20, 283} }
+	 }
+};
+
+static struct tvp5147_channel tvp5147_channel_info[TVP5147_NUM_CHANNELS] = {
+	{
+	 .params.inputidx = 0,
+	 .params.std = VPFE_STD_AUTO,
+	 .i2c_dev = {
+		     .i2c_addr = (0xBA >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL},
+	{
+	 .params.inputidx = 0,
+	 .params.std = VPFE_STD_AUTO,
+	 .i2c_dev = {
+		     .i2c_addr = (0xB8 >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL}
+};
+
+/* Global variables */
+static struct param_ops params_ops = {
+	.setparams = tvp5147_setparams,
+	.getparams = tvp5147_getparams
+};
+static struct control_ops controls_ops = {
+	.count = TVP5147_MAX_NO_CONTROLS,
+	.queryctrl = tvp5147_querycontrol,
+	.setcontrol = tvp5147_setcontrol,
+	.getcontrol = tvp5147_getcontrol
+};
+
+static struct input_ops inputs_ops = {
+	.count = TVP5147_MAX_NO_INPUTS,
+	.enuminput = tvp5147_enuminput,
+	.setinput = tvp5147_setinput,
+	.getinput = tvp5147_getinput
+};
+static struct standard_ops standards_ops = {
+	.count = TVP5147_MAX_NO_STANDARDS,
+	.setstd = tvp5147_setstd,
+	.getstd = tvp5147_getstd,
+	.enumstd = tvp5147_enumstd,
+	.querystd = tvp5147_querystd,
+};
+static struct format_ops formats_ops = {
+	.count = 0,
+	.enumformat = NULL,
+	.setformat = tvp5147_setformat,
+	.getformat = tvp5147_getformat,
+	.tryformat = tvp5147_tryformat,
+};
+
+static struct device *tvp5147_i2c_dev[TVP5147_NUM_CHANNELS];
+static struct decoder_device dec_dev[TVP5147_NUM_CHANNELS] = {
+	{
+	 .name = "TVP5147",
+	 .if_type = INTERFACE_TYPE_BT656,
+	 .channel_id = 0,
+	 .capabilities = V4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_VBI_CAPTURE,
+	 .initialize = tvp5147_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = &formats_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp5147_deinitialize,
+	 .get_sliced_vbi_cap = tvp5147_get_sliced_vbi_cap,
+	 .read_vbi_data = tvp5147_read_vbi_data},
+	{
+	 .name = "TVP5147",
+	 .if_type = INTERFACE_TYPE_BT656,
+	 .channel_id = 1,
+	 .capabilities = V4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_VBI_CAPTURE,
+	 .initialize = tvp5147_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = &formats_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp5147_deinitialize,
+	 .get_sliced_vbi_cap = tvp5147_get_sliced_vbi_cap,
+	 .read_vbi_data = tvp5147_read_vbi_data}
+};
+
+static u8 tvp5147_after_reset_reg[][2] = {
+	{0xE8, 0x02},
+	{0xE9, 0x00},
+	{0xEA, 0x80},
+	{0xE0, 0x01},
+	{0xE8, 0x60},
+	{0xE9, 0x00},
+	{0xEA, 0xB0},
+	{0xE0, 0x01},
+	{0xE8, 0x16},
+	{0xE9, 0x00},
+	{0xEA, 0xA0},
+	{0xE0, 0x16},
+	{0xE8, 0x60},
+	{0xE9, 0x00},
+	{0xEA, 0xB0},
+	{0xE0, 0x00}
+};
+
+/* tvp5147_init :
+ * This function called by vpif driver to initialize the decoder with default
+ * values
+ */
+static int tvp5147_initialize(void *dec, int flag)
+{
+	int err = 0, i;
+	int ch_id;
+	int index;
+	struct i2c_client *i2c_client;
+	v4l2_std_id std;
+	if (NULL == dec) {
+		printk("dec:NULL pointer");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk("tvp5147 driver is already initialized..\n");
+		err = -EINVAL;
+		return err;
+	}
+	i2c_client = &tvp5147_channel_info[ch_id].i2c_dev.client;
+
+	/* Register tvp5147 I2C client */
+	err = i2c_add_driver(&tvp5147_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk("Failed to register TVP5147 I2C client.\n");
+		return -EINVAL;
+	}
+	try_module_get(THIS_MODULE);
+	tvp5147_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	tvp5147_channel_info[ch_id].dec_device = (struct decoder_device *)dec;
+	if (DECODER_I2C_BIND_FLAG == flag) {
+		/* check that decoder is set with default values once or not,
+		 * if yes return, if not continue */
+		if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x02)
+			return err;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"Starting default settings tvp5147..\n");
+
+	/* Reset TVP5147 */
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OPERATION_MODE,
+				     TVP5147_OPERATION_MODE_RESET);
+
+	/*Put _tvp5147 in normal power mode */
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OPERATION_MODE,
+				     TVP5147_OPERATION_MODE_DEFAULT);
+
+	for (i = 0; i < 16; i++) {
+		err |= tvp5147_i2c_write_reg(i2c_client,
+					     tvp5147_after_reset_reg[i][0],
+					     tvp5147_after_reset_reg[i]
+					     [1]);
+	}
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_AFE_GAIN_CTRL,
+				     TVP5147_AFE_GAIN_CTRL_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_COLOR_KILLER,
+				     TVP5147_COLOR_KILLER_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL1,
+				     TVP5147_LUMA_CONTROL1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL2,
+				     TVP5147_LUMA_CONTROL2_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL3,
+				     TVP5147_LUMA_CONTROL3_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_BRIGHTNESS,
+				     TVP5147_BRIGHTNESS_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CONTRAST,
+				     TVP5147_CONTRAST_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_SATURATION,
+				     TVP5147_SATURATION_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_HUE,
+				     TVP5147_HUE_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CHROMA_CONTROL1,
+				     TVP5147_CHROMA_CONTROL1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CHROMA_CONTROL2,
+				     TVP5147_CHROMA_CONTROL2_DEFAULT);
+
+	/* Configuration for 8-bit BT656 mode */
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT5,
+				     TVP5147_OUTPUT5_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT6,
+				     TVP5147_OUTPUT6_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT1,
+				     TVP5147_OUTPUT1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT2,
+				     TVP5147_OUTPUT2_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT3,
+				     TVP5147_OUTPUT3_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT4,
+				     TVP5147_OUTPUT4_DEFAULT);
+
+	/* Call setinput for setting default input */
+	index = 0;
+	err |= tvp5147_setinput(&index, dec);
+	if (err < 0) {
+		err = -EINVAL;
+		tvp5147_deinitialize(dec);
+		return err;
+	}
+
+	/* call set standard to set default standard */
+	std = tvp5147_configuration[ch_id].input[index].def_std;
+	err |= tvp5147_setstd(&std, dec);
+	err = tvp5147_querystd(&std, dec);
+	if (err < 0) {
+		err = -EINVAL;
+		tvp5147_deinitialize(dec);
+		return err;
+	}
+	tvp5147_channel_info[ch_id].i2c_dev.i2c_registration |= 0x2;
+	return err;
+}
+static int tvp5147_deinitialize(void *dec)
+{
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Tvp5147 ch deinitialization"
+		" called\n");
+	if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&tvp5147_channel_info[ch_id].i2c_dev.driver);
+		module_put(THIS_MODULE);
+		tvp5147_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		tvp5147_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		tvp5147_channel_info[ch_id].dec_device = NULL;
+	}
+	return 0;
+}
+
+/* tvp5147_setcontrol :
+ * Function to set the control parameters
+ */
+static int tvp5147_setcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int value;
+	int ch_id;
+	int i = 0;
+	int input_idx;
+	struct tvp5147_control_info *control = NULL;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+
+	/* check for null pointer */
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting setctrl...\n");
+	value = (__s32) ctrl->value;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls)
+		return -EINVAL;
+
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if (value == 1) {
+			value = 0xF;
+		} else if (value == 0) {
+			value = 0xC;
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		if (((control->query_control).minimum > value)
+		    || ((control->query_control).maximum < value)) {
+			return -EINVAL;
+		}
+	}
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, control->register_address, value);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"TVP5147 set control fails...\n");
+		return err;
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of setcontrol...\n");
+	return err;
+}
+
+/* tvp5147_getcontrol :
+ * Function to get the control parameters
+ */
+static int tvp5147_getcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct tvp5147_control_info *control = NULL;
+	int input_idx;
+	u8 val;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting getctrl of TVP5147...\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+
+	/* check for null pointer */
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	err = tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				   client, control->register_address, &val);
+	ctrl->value = (int)val;
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"TVP5147 get control fails...\n");
+		return err;
+	}
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if ((ctrl->value & 0x3) == 3) {
+			ctrl->value = 1;
+		} else {
+			ctrl->value = 0;
+		}
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getcontrol...\n");
+	return err;
+}
+
+/* This function is used to write the vbi data to the decoder device */
+static int tvp5147_read_vbi_data(struct v4l2_sliced_vbi_data *data, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0, j, k;
+	unsigned char value;
+	u8 num_services;
+
+	if (NULL == dec) {
+		printk("tvp5147_write_vbi_data:NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_write_vbi_data:"
+		"Start of tvp5147_write_vbi_data..\n");
+	if (data == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_write_vbi_data:"
+			"NULL pointer.\n");
+		return -EINVAL;
+	}
+	num_services = tvp5147_configuration[ch_id].num_services;
+	for (i = 0; i < num_services; i++) {
+		if (0 == data[i].id)
+			continue;
+		if ((data[i].id | tvp5147_channel_info[ch_id].
+		     params.fmt.fmt.sliced.service_set) !=
+		    tvp5147_channel_info[ch_id].
+		    params.fmt.fmt.sliced.service_set) {
+			return -EINVAL;
+		}
+
+		for (j = 0; j < TVP5147_VBI_NUM_SERVICES; j++) {
+			if (!(tvp5147_services_regs[j].service & data[i].id))
+				continue;
+			for (k = 0; k < 3; k++)
+				tvp5147_i2c_write_reg(&tvp5147_channel_info
+						      [ch_id].i2c_dev.client,
+						      TVP5147_VBUS_ADDRESS_ACCESS0
+						      + k,
+						      tvp5147_services_regs[j].
+						      field[data[i].field].
+						      addr[k]);
+
+			for (k = 0; k <
+			     tvp5147_services_regs[j].bytestoread; k++) {
+				tvp5147_i2c_read_reg(&tvp5147_channel_info
+						     [ch_id].i2c_dev.client,
+						     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+						     &value);
+				data[i].data[k] = value;
+			}
+		}
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "</tvp5147_write_vbi_data>\n");
+	return err;
+}
+
+/* This function is used to get the sliced vbi services supported 
+   by the decoder device */
+static int tvp5147_get_sliced_vbi_cap(struct v4l2_sliced_vbi_cap *cap,
+				      void *dec)
+{
+	int ch_id;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of "
+		"tvp5147_get_sliced_vbi_cap\n");
+	if (cap == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"tvp5147_get_sliced_vbi_cap:" "NULL pointer\n");
+		return -EINVAL;
+	}
+	*cap = tvp5147_configuration[ch_id].sliced_cap;
+	return 0;
+}
+
+/* tvp5147_querycontrol :
+ * Function to query control parameters
+ */
+static int tvp5147_querycontrol(struct v4l2_queryctrl *ctrl, void *dec)
+{
+	int err = 0;
+	int id;
+	int ch_id;
+	int i = 0;
+	struct tvp5147_control_info *control = NULL;
+	int input_idx;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting tvp5147_queryctrl...\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	id = ctrl->id;
+	memset(ctrl, 0, sizeof(struct v4l2_queryctrl));
+	ctrl->id = id;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	memcpy(ctrl, &control->query_control, sizeof(struct v4l2_queryctrl));
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_querycontrol...\n");
+	return err;
+}
+
+static int tvp5147_raw_vbi_setformat(struct v4l2_vbi_format *fmt)
+{
+	/* TBD */
+}
+
+static int tvp5147_sliced_vbi_setformat(struct v4l2_sliced_vbi_format *fmt,
+					void *dec)
+{
+	int ch_id, i, j, k, index;
+	u16 val;
+	u8 num_services = 0;
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if ((fmt->service_set |
+	     tvp5147_configuration[ch_id].sliced_cap.service_set) !=
+	    tvp5147_configuration[ch_id].sliced_cap.service_set) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_setformat:"
+			"Invalid service\n");
+		return -EINVAL;
+	}
+	memset(fmt->service_lines, 0, 2 * 24 * 2);
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if ((fmt->service_set & tvp5147_sliced_regs[i].service) &&
+		    !(tvp5147_sliced_regs[i].std &
+		      tvp5147_channel_info[ch_id].params.std)) {
+			dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_setformat:"
+				"Invalid service for this standard\n");
+			return -EINVAL;
+		}
+
+		if (tvp5147_sliced_regs[i].std &
+		    tvp5147_channel_info[ch_id].params.std) {
+			for (j = 0; j < 2; j++) {
+				for (k = 0; k < 3; k++)
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_ADDRESS_ACCESS0 + k,
+					     tvp5147_sliced_regs[i].field[j].
+					     fifo_line_addr[k]);
+
+				if (fmt->service_set &
+				    tvp5147_sliced_regs[i].service) {
+					num_services++;
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     tvp5147_sliced_regs[i].
+					     line_addr_value);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     tvp5147_sliced_regs[i].field[j].
+					     fifo_mode_value);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VDP_LINE_START,
+					     tvp5147_sliced_regs[i].line_start);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VDP_LINE_STOP,
+					     tvp5147_sliced_regs[i].line_end);
+					for (k = 0; k < 2; k++) {
+						index = tvp5147_sliced_regs[i].
+						    service_line[k].index;
+						val = tvp5147_sliced_regs[i].
+						    service_line[k].value;
+						fmt->service_lines[k][index] =
+						    val;
+					}
+				} else {
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     TVP5147_LINE_ADDRESS_DEFAULT);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     TVP5147_LINE_MODE_DEFAULT);
+				}
+			}
+		}
+	}
+	fmt->io_size = (TVP5147_SLICED_BUF_SIZE * num_services) / 2;
+	tvp5147_configuration[ch_id].num_services = num_services / 2;
+	return num_services / 2;
+}
+
+/*  tvp5147_setformat :
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_setformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0, ch_id;
+	struct v4l2_sliced_vbi_format fmta;
+	struct v4l2_vbi_format fmtb;
+	if (NULL == dec || NULL == fmtp) {
+		printk("tvp5147_setformat:NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((V4L2_BUF_TYPE_VIDEO_CAPTURE != fmtp->type) &&
+	    (V4L2_BUF_TYPE_VBI_CAPTURE != fmtp->type) &&
+	    (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != fmtp->type))
+		return -EINVAL;
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == fmtp->type) {
+		fmta = fmtp->fmt.sliced;
+		err = tvp5147_sliced_vbi_setformat(&fmta, dec);
+	} else {
+		fmtb = fmtp->fmt.vbi;
+		err = tvp5147_raw_vbi_setformat(&fmtb);
+	}
+
+	tvp5147_channel_info[ch_id].params.fmt = *fmtp;
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"tvp5147_setformat:End of" " tvp5147_querycontrol...\n");
+	return err;
+}
+
+/* tvp5147_getformat: 
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_getformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0;
+	int ch_id;
+
+	if (NULL == dec || NULL == fmtp) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_getformat:"
+		"Starting getformat function.\n");
+
+	/* Read sliced vbi format */
+	fmtp->fmt.sliced = tvp5147_channel_info[ch_id].params.fmt.fmt.sliced;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_getformat:"
+		"End of getformat function.\n");
+	return err;
+}
+
+/* tvp5147_tryformat:
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_tryformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct v4l2_sliced_vbi_format *fmt;
+	int num_services = 0;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_tryformat:"
+		"Start of tvp5147_tryformat..\n");
+	if (fmtp == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_tryformat:"
+			"NULL pointer\n");
+		return -EINVAL;
+	}
+	fmt = &(fmtp->fmt.sliced);
+	if ((fmt->service_set |
+	     tvp5147_configuration[ch_id].sliced_cap.service_set) !=
+	    tvp5147_configuration[ch_id].sliced_cap.service_set) {
+		fmt->service_set =
+		    tvp5147_configuration[ch_id].sliced_cap.service_set;
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid service\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if (((tvp5147_sliced_regs[i].service & fmt->service_set) ==
+		     tvp5147_sliced_regs[i].service) &&
+		    (tvp5147_channel_info[ch_id].params.std
+		     != tvp5147_sliced_regs[i].std)) {
+			dev_err(tvp5147_i2c_dev[ch_id],
+				"service not supported for the standard\n");
+			return -EINVAL;
+		}
+	}
+	num_services = 0;
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if (tvp5147_sliced_regs[i].service & fmt->service_set)
+			num_services++;
+	}
+	fmt->io_size = num_services * TVP5147_SLICED_BUF_SIZE;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "</tvp5147_tryformat>\n");
+	return err;
+}
+
+/* tvp5147_setstd :
+ * This function is used to configure TVP5147 for video standard passed
+ * by application
+ */
+static int tvp5147_setstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	unsigned char output1;
+	int ch_id;
+	int i = 0;
+	struct v4l2_standard *standard;
+	int input_idx;
+	struct v4l2_sliced_vbi_format fmt;
+
+	tvp5147_mode mode = TVP5147_MODE_INV;
+	v4l2_std_id std;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of tvp5147_setstd..\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	std = *id;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		standard = &(tvp5147_configuration[ch_id].input[input_idx].
+			     standard[i]);
+		if (standard->id & std) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_standard) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	mode = tvp5147_configuration[ch_id].input[input_idx].mode[i][0];
+
+	/* for square pixel */
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_OUTPUT1, &output1);
+	if (err < 0) {
+		return err;
+	}
+	output1 |= ((mode & 0x8) << 4);
+	err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				     client, TVP5147_OUTPUT1, output1);
+
+	/* setup the video standard */
+	err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				     client, TVP5147_VIDEO_STD, (mode & 0x07));
+
+	/* if autoswitch mode, enable all modes for autoswitch */
+	if ((mode & 0x07) == TVP5147_MODE_AUTO) {
+		err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_AUTOSWT_MASK,
+					     TVP5147_AUTOSWITCH_MASK);
+	}
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	tvp5147_channel_info[ch_id].params.std = *id;
+	if (*id == VPFE_STD_AUTO || *id == VPFE_STD_AUTO_SQP) {
+		err = tvp5147_querystd(id, dec);
+	}
+	/* disable all vbi services */
+	fmt.service_set = 0;
+	tvp5147_sliced_vbi_setformat(&fmt, dec);
+
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147 set standard...\n");
+	return err;
+}
+
+/* tvp5147_getstd :
+ * Function to get the video standard
+ */
+static int tvp5147_getstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting getstd function..\n");
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	*id = tvp5147_channel_info[ch_id].params.std;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getstd function\n");
+	return err;
+}
+
+/* tvp5147_enumstd :
+ * Function to enumerate standards supported
+ */
+static int tvp5147_enumstd(struct v4l2_standard *std, void *dec)
+{
+	int index, index1;
+	int err = 0;
+	int ch_id;
+	int input_idx, sumstd = 0;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (std == NULL) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	index = std->index;
+	index1 = index;
+	/* Check for valid value of index */
+	for (input_idx = 0;
+	     input_idx < tvp5147_configuration[ch_id].no_of_inputs;
+	     input_idx++) {
+		sumstd +=
+		    tvp5147_configuration[ch_id].input[input_idx].
+		    no_of_standard;
+		if (index < sumstd) {
+			sumstd -= tvp5147_configuration[ch_id].
+			    input[input_idx].no_of_standard;
+			break;
+		}
+	}
+	if (input_idx == tvp5147_configuration[ch_id].no_of_inputs)
+		return -EINVAL;
+	index -= sumstd;
+	memset(std, 0, sizeof(*std));
+	memcpy(std, &tvp5147_configuration[ch_id].input[input_idx].
+	       standard[index], sizeof(struct v4l2_standard));
+	std->index = index1;
+	return err;
+}
+
+/* tvp5147_querystd :
+ *
+ * Function to return standard detected by decoder
+ */
+static int tvp5147_querystd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+
+	unsigned char std;
+	int ch_id;
+	unsigned char output1 = 0;
+	int i = 0, j = 0;
+	unsigned char lock_status = 0xFF;
+	int input_idx, flag = 1;
+	struct v4l2_sliced_vbi_format fmt;
+
+	tvp5147_mode mode;
+	u8 lock_mask;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"Start of tvp5147 standard detection.\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	err = tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				   client, TVP5147_VIDEO_STD, &std);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Standard detection failed\n");
+		return err;
+	}
+
+	std &= 0x7;
+	if (std == TVP5147_MODE_AUTO) {
+
+		err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].
+					    i2c_dev.client,
+					    TVP5147_VID_STD_STATUS, &std);
+	}
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Standard detection failed\n");
+		return err;
+	}
+
+	/* to keep standard without square pixel */
+	std &= 0x7;
+
+	/* for square pixel */
+	err |=
+	    tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				 client, TVP5147_OUTPUT1, &output1);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"Setting square pixel failed.\n");
+		return err;
+	}
+	mode = std | ((output1 & 0x80) >> 4);	/* square pixel status */
+
+	/* check lock status */
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &lock_status);
+	if (err < 0) {
+		return err;
+	}
+	err = -EAGAIN;
+	lock_mask = tvp5147_configuration[ch_id].input[input_idx].lock_mask;
+	if (lock_mask != (lock_status & lock_mask)) {
+		return err;
+	}
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		for (j = 0; j < TVP5147_MAX_NO_MODES; j++) {
+			if (mode == tvp5147_configuration[ch_id].
+			    input[input_idx].mode[i][j]) {
+				flag = 0;
+				break;
+			}
+		}
+		if (!flag)
+			break;
+	}
+
+	if ((i == tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard) && (TVP5147_MAX_NO_MODES == j)) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"tvp5147_querystd:Invalid std\n");
+		return -EINVAL;
+	}
+	*id = tvp5147_configuration[ch_id].input[input_idx].standard[i].id;
+	tvp5147_channel_info[ch_id].params.std = *id;
+
+	/* disable all vbi services */
+	fmt.service_set = 0;
+	tvp5147_sliced_vbi_setformat(&fmt, dec);
+
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of detection...\n");
+	return 0;
+}
+
+/* tvp5147_setinput:
+ * Function to set the input
+ */
+static int tvp5147_setinput(int *index, void *dec)
+{
+	int err = 0;
+	unsigned char input_sel;
+	int ch_id;
+	u8 status;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of set input function\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((*index >= tvp5147_configuration[ch_id].no_of_inputs)
+	    || (*index < 0)) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid Index.\n");
+		return -EINVAL;
+	}
+	input_sel = tvp5147_configuration[ch_id].input[*index].input_type;
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_INPUT_SEL, input_sel);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Set input failed\n");
+		return -EINVAL;
+	}
+	mdelay(500);
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_CLEAR_LOST_LOCK, 0x01);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"writing  clear lost lock register\n");
+		return err;
+	}
+
+	/* wait here so that if lock is lost, it can be detected */
+	mdelay(500);
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &status);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"reading status register\n");
+		return -EINVAL;
+	}
+	if (TVP5147_LOST_LOCK_MASK == (status & TVP5147_LOST_LOCK_MASK)) {
+		return -EINVAL;
+	}
+	tvp5147_channel_info[ch_id].params.inputidx = *index;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of set input function\n");
+	return err;
+}
+
+/* tvp5147_getinput :
+ * Function to get the input
+ */
+static int tvp5147_getinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	unsigned char input_sel;
+
+	unsigned char status;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of get input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	input_sel = tvp5147_configuration[ch_id].input[0].input_type;
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_INPUT_SEL, input_sel);
+	mdelay(500);
+	if (err < 0) {
+		return err;
+	}
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_CLEAR_LOST_LOCK, 0x01);
+	if (err < 0) {
+		return err;
+	}
+
+	/* wait here so that if lock is lost, it can be detected */
+	mdelay(500);
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &status);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"reading status register\n");
+		return -EINVAL;
+	}
+	if (TVP5147_LOST_LOCK_MASK == (status & TVP5147_LOST_LOCK_MASK)) {
+		return -EINVAL;
+	}
+	*index = 0;
+
+	/* Store the input type in index */
+	tvp5147_channel_info[ch_id].params.inputidx = *index;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getinput.\n");
+	return 0;
+}
+
+/* tvp5147_enuminput :
+ * Function to enumerate the input
+ */
+static int tvp5147_enuminput(struct v4l2_input *input, void *dec)
+{
+	int err = 0;
+	int index = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	/* check for null pointer */
+	if (input == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* Only one input is available */
+	if (input->index >= tvp5147_configuration[ch_id].no_of_inputs) {
+		return -EINVAL;
+	}
+	index = input->index;
+	memset(input, 0, sizeof(*input));
+	input->index = index;
+	memcpy(input,
+	       &tvp5147_configuration[ch_id].input[index].input_info,
+	       sizeof(struct v4l2_input));
+	return err;
+}
+
+/* tvp5147_setparams :
+ * Function to set the parameters for tvp5147
+ */
+static int tvp5147_setparams(void *params, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	tvp5147_params tvp5147params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&tvp5147params, (tvp5147_params *) params,
+			   sizeof(tvp5147params)))
+		return -EFAULT;
+
+	if (0 == ((struct decoder_device *)dec)->channel_id)
+		err |= set_cpld_for_tvp5147();
+
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	err |= tvp5147_setinput(&(tvp5147params.inputidx), dec);
+	if (err < 0) {
+		return err;
+	}
+	err |= tvp5147_setstd(&(tvp5147params.std), dec);
+	if (err < 0) {
+		return err;
+	}
+	err |= tvp5147_setformat(&(tvp5147params.fmt), dec);
+	if (err < 0) {
+		return err;
+	}
+	tvp5147_channel_info[ch_id].params = tvp5147params;
+	return err;
+}
+
+/*  tvp5147_getparams :
+ *  Function to get the parameters for tvp5147
+ */
+static int tvp5147_getparams(void *params, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	tvp5147_params *tvp5147params = (tvp5147_params *) params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	if (copy_to_user(tvp5147params, &(tvp5147_channel_info[ch_id].params),
+			 sizeof(*tvp5147params)))
+		return -EFAULT;
+
+	return err;
+}
+
+/* tvp5147_i2c_read_reg :This function is used to read value from
+ * register for i2c client.
+ */
+static int tvp5147_i2c_read_reg(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp5147_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int tvp5147_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp5147_i2c_attach_client : This function is used to attach i2c client
+ */
+static int tvp5147_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* tvp5147_i2c_detach_client:
+ * This function is used to detach i2c client
+ */
+static int tvp5147_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/* tvp5147A_i2c_probe_adapter : This function is used to probe i2c adapter
+ */
+static int tvp5147A_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp5147_i2c_dev[0] = &(adap->dev);
+	dev_dbg(tvp5147_i2c_dev[0], "Tvp5147A i2c probe adapter called...\n");
+	err = tvp5147_i2c_attach_client(&tvp5147_channel_info[0].i2c_dev.
+					client,
+					&tvp5147_channel_info[0].i2c_dev.
+					driver, adap,
+					tvp5147_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp5147_i2c_dev[0], "Tvp5147A i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp5147B_i2c_probe_adapter: This function is used to probe i2c adapter
+ */
+static int tvp5147B_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp5147_i2c_dev[1] = &(adap->dev);
+	dev_dbg(tvp5147_i2c_dev[1], "Tvp5147B i2c probe adapter called...\n");
+	err = tvp5147_i2c_attach_client(&tvp5147_channel_info[1].i2c_dev.
+					client,
+					&tvp5147_channel_info[1].i2c_dev.
+					driver, adap,
+					tvp5147_channel_info[1].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp5147_i2c_dev[1], "Tvp5147B i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp5147_i2c_init : This function is used initialize TVP5147 i2c client
+ */
+static int tvp5147_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j = 0;
+
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+	char strings[TVP5147_NUM_CHANNELS][80] =
+	    { "TVP5147 channel0 Video Decoder I2C driver",
+		"TVP5147 channel1 Video Decoder I2C driver"
+	};
+	for (i = 0; i < TVP5147_NUM_CHANNELS; i++) {
+		driver = &tvp5147_channel_info[i].i2c_dev.driver;
+		driver->owner = THIS_MODULE;
+		strlcpy(driver->name, strings[i], sizeof(strings[i]));
+		driver->id = I2C_DRIVERID_EXP0;
+		driver->flags = I2C_DF_NOTIFY;
+		if (0 == i) {
+			driver->attach_adapter = tvp5147A_i2c_probe_adapter;
+		} else {
+			driver->attach_adapter = tvp5147B_i2c_probe_adapter;
+		}
+		driver->detach_client = tvp5147_i2c_detach_client;
+		err = vpif_register_decoder(&dec_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vpif_unregister_decoder(&dec_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* tvp5147_i2c_cleanup : This function is used detach TVP5147 i2c client
+ */
+static void tvp5147_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < TVP5147_NUM_CHANNELS; i++) {
+		if (tvp5147_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&tvp5147_channel_info[i].i2c_dev.driver);
+			tvp5147_channel_info[i].i2c_dev.client.adapter = NULL;
+			tvp5147_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+		vpif_unregister_decoder(&dec_dev[i]);
+	}
+}
+
+module_init(tvp5147_i2c_init);
+module_exit(tvp5147_i2c_cleanup);
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/tvp7002.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/tvp7002.c
@@ -0,0 +1,1327 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp7002.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <media/davinci/tvp7002.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/arch/video_hdevm.h>
+
+/* Function Prototypes */
+static int tvp7002_initialize(void *dec, int flag);
+static int tvp7002_deinitialize(void *dec);
+static int tvp7002_setcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp7002_getcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp7002_querycontrol(struct v4l2_queryctrl *ctrl, void *dec);
+static int tvp7002_setstd(v4l2_std_id * id, void *dec);
+static int tvp7002_getstd(v4l2_std_id * id, void *dec);
+static int tvp7002_querystd(v4l2_std_id * id, void *dec);
+static int tvp7002_enumstd(struct v4l2_standard *std, void *dec);
+static int tvp7002_setinput(int *index, void *dec);
+static int tvp7002_getinput(int *index, void *dec);
+static int tvp7002_enuminput(struct v4l2_input *input, void *dec);
+static int tvp7002_set_format_params(struct tvp7002_format_params
+				     *tvpformats, void *dec);
+static int tvp7002_setparams(void *params, void *dec);
+static int tvp7002_getparams(void *params, void *dec);
+static int tvp7002_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int tvp7002_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int tvp7002_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr);
+static int tvp7002_i2c_detach_client(struct i2c_client *client);
+static int tvp7002_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp7002_i2c_init(void);
+static void tvp7002_i2c_cleanup(void);
+
+static int ths7353_setvalue(void);
+
+static struct v4l2_standard tvp7002_standards[TVP7002_MAX_NO_STANDARDS] = {
+	{
+	 .index = 0,
+	 .id = V4L2_STD_720P_60,
+	 .name = "720P-60",
+	 .frameperiod = {1, 60},
+	 .framelines = 720},
+	{
+	 .index = 1,
+	 .id = V4L2_STD_1080I_60,
+	 .name = "1080I-30",
+	 .frameperiod = {1, 30},
+	 .framelines = 1080},
+	{
+	 .index = 2,
+	 .id = V4L2_STD_1080I_50,
+	 .name = "1080I-25",
+	 .frameperiod = {1, 25},
+	 .framelines = 1080},
+	{
+	 .index = 3,
+	 .id = V4L2_STD_720P_50,
+	 .name = "720P-50",
+	 .frameperiod = {1, 50},
+	 .framelines = 720},
+	{
+	 .index = 4,
+	 .id = V4L2_STD_525P_60,
+	 .name = "480P-60",
+	 .frameperiod = {1, 60},
+	 .framelines = 525},
+	{
+	 .index = 5,
+	 .id = V4L2_STD_625P_50,
+	 .name = "576P-50",
+	 .frameperiod = {1, 50},
+	 .framelines = 625},
+};
+
+static struct tvp7002_format_params tvp7002_formats[TVP7002_MAX_NO_STANDARDS] = {
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p,
+	 .hpll_vco_control = VCO_CONTROL_720p,
+	 .hpll_cp_current = CP_CURRENT_720p,
+	 .hpll_phase_select = PHASE_SELECT_720p,
+	 .hpll_post_divider = POST_DIVIDER_720p,
+	 .hpll_control = HPLL_CONTROL_720p,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_720p,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_720p,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_720p,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p,
+	 .vblk_f0_duration = VBLK_F0_DURATION_720p,
+	 .vblk_f1_duration = VBLK_F1_DURATION_720p,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i,
+	 .hpll_vco_control = VCO_CONTROL_1080i,
+	 .hpll_cp_current = CP_CURRENT_1080i,
+	 .hpll_phase_select = PHASE_SELECT_1080i,
+	 .hpll_post_divider = POST_DIVIDER_1080i,
+	 .hpll_control = HPLL_CONTROL_1080i,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_1080i,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_1080i,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i,
+	 .vblk_f0_duration = VBLK_F0_DURATION_1080i,
+	 .vblk_f1_duration = VBLK_F1_DURATION_1080i,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_1080i},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i_50,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i_50,
+	 .hpll_vco_control = VCO_CONTROL_1080i_50,
+	 .hpll_cp_current = CP_CURRENT_1080i_50,
+	 .hpll_phase_select = PHASE_SELECT_1080i_50,
+	 .hpll_post_divider = POST_DIVIDER_1080i_50,
+	 .hpll_control = HPLL_CONTROL_1080i_50,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_1080i_50,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_1080i_50,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i_50,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i_50,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i_50,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i_50,
+	 .vblk_f0_duration = VBLK_F0_DURATION_1080i_50,
+	 .vblk_f1_duration = VBLK_F1_DURATION_1080i_50,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_1080i_50},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p_50,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p_50,
+	 .hpll_vco_control = VCO_CONTROL_720p_50,
+	 .hpll_cp_current = CP_CURRENT_720p_50,
+	 .hpll_phase_select = PHASE_SELECT_720p_50,
+	 .hpll_post_divider = POST_DIVIDER_720p_50,
+	 .hpll_control = HPLL_CONTROL_720p_50,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_720p_50,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_720p_50,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p_50,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_720p_50,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p_50,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p_50,
+	 .vblk_f0_duration = VBLK_F0_DURATION_720p_50,
+	 .vblk_f1_duration = VBLK_F1_DURATION_720p_50,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_480P,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_480P,
+	 .hpll_vco_control = VCO_CONTROL_480P,
+	 .hpll_cp_current = CP_CURRENT_480P,
+	 .hpll_phase_select = PHASE_SELECT_480P,
+	 .hpll_post_divider = POST_DIVIDER_480P,
+	 .hpll_control = HPLL_CONTROL_480P,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_480P,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_480P,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_480P,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_480P,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_480P,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_480P,
+	 .vblk_f0_duration = VBLK_F0_DURATION_480P,
+	 .vblk_f1_duration = VBLK_F1_DURATION_480P,
+	 .alc_placement = TVP7002_ED_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_ED_CLAMP_START,
+	 .clamp_width = TVP7002_ED_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_ED_PRE_COAST,
+	 .hpll_post_coast = TVP7002_ED_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_576P,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_576P,
+	 .hpll_vco_control = VCO_CONTROL_576P,
+	 .hpll_cp_current = CP_CURRENT_576P,
+	 .hpll_phase_select = PHASE_SELECT_576P,
+	 .hpll_post_divider = POST_DIVIDER_576P,
+	 .hpll_control = HPLL_CONTROL_576P,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_576P,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_576P,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_576P,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_576P,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_576P,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_576P,
+	 .vblk_f0_duration = VBLK_F0_DURATION_576P,
+	 .vblk_f1_duration = VBLK_F1_DURATION_576P,
+	 .alc_placement = TVP7002_ED_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_ED_CLAMP_START,
+	 .clamp_width = TVP7002_ED_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_ED_PRE_COAST,
+	 .hpll_post_coast = TVP7002_ED_POST_COAST,
+	 .reserved = RESERVED_720p}
+};
+
+static struct tvp7002_config tvp7002_configuration[TVP7002_NUM_CHANNELS] = {
+	{
+	 .no_of_inputs = TVP7002_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP7002_HD_INPUT,
+		      .input_info = {
+				     .index = 0,
+				     .name = "COMPONENT",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP7002_ALL},
+		      .no_of_standard = TVP7002_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)&tvp7002_standards,
+		      .def_std = V4L2_STD_720P_60,
+		      .format =
+		      (struct tvp7002_format_params *)&tvp7002_formats,
+		      .no_of_controls = TVP7002_MAX_NO_CONTROLS,
+		      .controls = NULL},
+	 .def_params = {V4L2_STD_720P_60, 0, {1, 0xa, 0x6}, {0, 0, 0, 7, 7, 7},
+			{0x80, 0x80, 0x80, 0, 0, 0, 0x10, 0x10, 0x10}}
+	 }
+};
+
+static struct tvp7002_channel tvp7002_channel_info[TVP7002_NUM_CHANNELS] = {
+	{
+	 .params.inputidx = 0,
+	 .params.std = V4L2_STD_720P_60,
+	 .i2c_dev = {
+		     .i2c_addr = (0xBA >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL}
+};
+
+/* Global variables */
+static struct device *tvp7002_i2c_dev[TVP7002_NUM_CHANNELS];
+static struct param_ops params_ops = {
+	.setparams = tvp7002_setparams,
+	.getparams = tvp7002_getparams
+};
+static struct control_ops controls_ops = {
+	.count = TVP7002_MAX_NO_CONTROLS,
+	.queryctrl = tvp7002_querycontrol,
+	.setcontrol = tvp7002_setcontrol,
+	.getcontrol = tvp7002_getcontrol
+};
+static struct input_ops inputs_ops = {
+	.count = TVP7002_MAX_NO_INPUTS,
+	.enuminput = tvp7002_enuminput,
+	.setinput = tvp7002_setinput,
+	.getinput = tvp7002_getinput
+};
+static struct standard_ops standards_ops = {
+	.count = TVP7002_MAX_NO_STANDARDS,
+	.enumstd = tvp7002_enumstd,
+	.setstd = tvp7002_setstd,
+	.getstd = tvp7002_getstd,
+	.querystd = tvp7002_querystd,
+};
+static struct decoder_device tvp7002_dev[TVP7002_NUM_CHANNELS] = {
+	{
+	 .name = "TVP7002",
+	 .if_type = INTERFACE_TYPE_BT1120,
+	 .channel_id = 0,
+	 .capabilities = 0,
+	 .initialize = tvp7002_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = NULL,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp7002_deinitialize}
+};
+
+/* tvp7002_initialize :
+ * This function will set the video format standard
+ */
+static int tvp7002_initialize(void *dec, int flag)
+{
+	int err = 0;
+	int ch_id;
+	v4l2_std_id std;
+	struct i2c_client *ch_client;
+	int index;
+	if (NULL == dec) {
+		printk("dec:NULL pointer");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	ch_client = &tvp7002_channel_info[ch_id].i2c_dev.client;
+	if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk("tvp7002 driver is already initialized..\n");
+		err = -EINVAL;
+		return err;
+	}
+
+	/* Register TVP7002 I2C client */
+	err = i2c_add_driver(&tvp7002_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk("Failed to register TVP7002 I2C client.\n");
+		return -EINVAL;
+	}
+	try_module_get(THIS_MODULE);
+	tvp7002_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	tvp7002_channel_info[ch_id].dec_device = (struct decoder_device *)dec;
+	if (DECODER_I2C_BIND_FLAG == flag) {
+		/* check that decoder is set with default values once or not,
+		 * if yes return, if not continue */
+		if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x02)
+			return err;
+
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Tvp7002 driver registered\n");
+	/*Configure the TVP7002 in default 720p 60 Hz standard for normal
+	   power up mode */
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_DIVIDER_MSB,
+				     TVP7002_HPLL_MSB_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_DIVIDER_LSB,
+				     TVP7002_HPLL_LSB_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_CONTROL,
+				     TVP7002_HPLL_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_PHASE_SELECT,
+				     TVP7002_HPLL_PHASE_SEL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_CLAMP_START,
+				     TVP7002_CLAMP_START_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_CLAMP_WIDTH,
+				     TVP7002_CLAMP_WIDTH_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HSYNC_OUTPUT_WIDTH,
+				     TVP7002_HSYNC_OUTWIDTH_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_CONTROL_1,
+				     TVP7002_SYNC_CONTROL1_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_CLAMP_CONTROL,
+				     TVP7002_HPLL_CLAMP_CTRL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_ON_GREEN_THLD,
+				     TVP7002_SYNC_GREEN_THLD_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_SEPARATER_THLD,
+				  TVP7002_SYNC_SEP_THLD_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_PRE_COAST,
+				  TVP7002_HPLL_PRE_COAST_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_POST_COAST,
+				  TVP7002_HPLL_POST_COAST_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_OUTPUT_FORMATTER,
+				  TVP7002_OUTPUT_FORMATTER_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_1,
+				  TVP7002_MISC_CONTROL1_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_3,
+				  TVP7002_MISC_CONTROL3_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_2,
+				  TVP7002_MISC_CONTROL2_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_INPUT_MUX_SELECT_1,
+				  TVP7002_INPUT_MUX_SELECT1_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_INPUT_MUX_SELECT_2,
+				  TVP7002_INPUT_MUX_SELECT2_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HSOUT_OUTPUT_START,
+				     TVP7002_HSOUT_OUTPUT_START_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_4,
+				     TVP7002_MISC_CONTROL4_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE,
+				     TVP7002_ALC_ENABLE_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_FILTER,
+				     TVP7002_ALC_FILTER_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_FINE_CLAMP_CONTROL,
+				     TVP7002_FINE_CLAMP_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_POWER_CONTROL,
+				     TVP7002_POWER_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ADC_SETUP,
+				     TVP7002_ADC_SETUP_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client,
+				     TVP7002_COARSE_CLAMP_CONTROL,
+				     TVP7002_COARSE_CLAMP_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SOG_CLAMP,
+				     TVP7002_SOG_CLAMP_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_PLACEMENT,
+				     TVP7002_ALC_PLACEMENT_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client,
+				  TVP7002_VIDEO_BANDWIDTH_CONTROL,
+				  TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_AVID_START_PIXEL_HIGH,
+				  TVP7002_AVID_START_PIXEL_DEFAULT);
+
+	if (err < 0) {
+		err = -EINVAL;
+		tvp7002_deinitialize(dec);
+		return err;
+	} else {
+
+		memcpy(&tvp7002_channel_info[ch_id].params,
+		       &tvp7002_configuration[ch_id].def_params,
+		       sizeof(tvp7002_params));
+		/* Configure for default video standard */
+		/* call set standard */
+		index = tvp7002_channel_info[ch_id].params.inputidx;
+		std = tvp7002_configuration[ch_id].input[index].def_std;
+		err |= tvp7002_setstd(&std, dec);
+
+		if (err < 0) {
+			err = -EINVAL;
+			tvp7002_deinitialize(dec);
+			return err;
+		}
+	}
+	tvp7002_channel_info[ch_id].i2c_dev.i2c_registration |= 0x2;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of tvp7002_init.\n");
+	return err;
+}
+static int tvp7002_deinitialize(void *dec)
+{
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Tvp7002 ch deinitialization"
+		" called\n");
+	if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&tvp7002_channel_info[ch_id].i2c_dev.driver);
+		module_put(THIS_MODULE);
+		tvp7002_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		tvp7002_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		tvp7002_channel_info[ch_id].dec_device = NULL;
+	}
+	return 0;
+}
+
+/* tvp7002_setcontrol : Function to set the control parameter
+ */
+static int tvp7002_setcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 supports no control parameter to be set..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* tvp7002_getcontrol :
+ * Function to get the control parameter
+ */
+static int tvp7002_getcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 supports no control parameters..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* tvp7002_querycontrol :
+ * Function to query control parameter
+ */
+static int tvp7002_querycontrol(struct v4l2_queryctrl *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 has no control parameters to return..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* following function is used to set THS7353 */
+static int ths7353_setvalue(void)
+{
+	int err = 0;
+	u8 val[2];
+	u16 ths7353_i2c_addr = 0x5C >> 1;
+	val[1] = 0x95;
+
+	val[0] = 0x01;
+	val[1] = 0x94;
+	err = davinci_i2c_write(2, val, ths7353_i2c_addr);
+	val[0] = 0x02;
+	val[1] = 0x95;
+	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
+	val[0] = 0x03;
+	val[1] = 0x94;
+	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
+	if (err) {
+		printk("THS7353\n");
+	}
+	return err;
+}
+
+/* tvp7002_setstd :
+ * Function to set the video standard
+ */
+static int tvp7002_setstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	struct tvp7002_format_params *tvp7002formats;
+	int ch_id;
+	int i = 0;
+	struct v4l2_standard *standard;
+	int input_idx;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of tvp7002_setstd..\n");
+	input_idx = tvp7002_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < tvp7002_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		standard = &tvp7002_configuration[ch_id].input[input_idx].
+		    standard[i];
+		if (standard->id & *id) {
+			break;
+		}
+	}
+	if (i == tvp7002_configuration[ch_id].input[input_idx].no_of_standard) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	ths7353_setvalue();
+
+	tvp7002formats =
+	    &tvp7002_configuration[ch_id].input[input_idx].format[i];
+
+	err = tvp7002_set_format_params(tvp7002formats, dec);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+
+	/* Lock the structure variable and assign std to the member
+	   variable */
+	tvp7002_channel_info[ch_id].params.std = *id;
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of tvp7002 set standard...\n");
+	return err;
+}
+
+/* tvp7002_getstd :
+ * Function to get the video standard
+ */
+static int tvp7002_getstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting getstd function.\n");
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Read the video standard */
+	*id = tvp7002_channel_info[ch_id].params.std;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of getstd function.\n");
+	return err;
+}
+
+/* tvp7002_querystd :
+ * Function to return standard detected by decoder
+ */
+static int tvp7002_querystd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	unsigned short val1;
+	int ch_id;
+	unsigned char val_t;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting querystd function...\n");
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	mdelay(100);
+	/* Query the standards */
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_LINES_PER_FRAME_STATUS_LOW, &val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C read fails...Lines per frame low\n");
+		return err;
+	}
+	val1 = val;
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_LINES_PER_FRAME_STATUS_HIGH, &val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C read fails...Lines per frame high\n");
+		return err;
+	}
+	val1 |= (val << LINES_PER_FRAME_MSB_SHIFT) & LINES_PER_FRAME_MSB_MASK;
+	val = (val & VIDEO_DETECTION_MASK) >> VIDEO_DETECTION_SHIFT;
+
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_CLOCK_PER_LINE_STATUS_LSB, &val_t);
+
+	if ((INTERLACED_VIDEO == val)
+	    && (TVP7002_LINES_1080_60 == val1) && (val_t > 180 && val_t < 190)) {
+		*id = V4L2_STD_1080I_60;
+	} else if ((INTERLACED_VIDEO == val)
+		   && (TVP7002_LINES_1080_50 == val1)) {
+		*id = V4L2_STD_1080I_50;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (TVP7002_LINES_720 == val1) &&
+		   (val_t > 160 && val_t < 170)) {
+		*id = V4L2_STD_720P_50;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (TVP7002_LINES_720 == val1)) {
+		*id = V4L2_STD_720P_60;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (525 == val1)) {
+		*id = V4L2_STD_525P_60;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (625 == val1)) {
+		*id = V4L2_STD_625P_50;
+	} else {
+		return -EINVAL;
+	}
+
+	tvp7002_channel_info[ch_id].params.std = *id;
+	err = tvp7002_setstd(id, dec);
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of querystd function.\n");
+	return err;
+}
+
+/* tvp7002_enumstd : Function to enumerate standards supported
+ */
+static int tvp7002_enumstd(struct v4l2_standard *std, void *dec)
+{
+	int index, index1;
+	int err = 0;
+	int ch_id;
+	int input_idx, sumstd = 0;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (std == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = std->index;
+	index1 = index;
+	/* Check for valid value of index */
+	for (input_idx = 0;
+	     input_idx < tvp7002_configuration[ch_id].no_of_inputs;
+	     input_idx++) {
+		sumstd += tvp7002_configuration[ch_id].input[input_idx]
+		    .no_of_standard;
+		if (index < sumstd) {
+			sumstd -= tvp7002_configuration[ch_id]
+			    .input[input_idx].no_of_standard;
+			break;
+		}
+	}
+	if (input_idx == tvp7002_configuration[ch_id].no_of_inputs)
+		return -EINVAL;
+	index -= sumstd;
+
+	memset(std, 0, sizeof(*std));
+
+	memcpy(std, &tvp7002_configuration[ch_id].input[input_idx].
+	       standard[index], sizeof(struct v4l2_standard));
+	std->index = index1;
+	return err;
+}
+
+/* tvp7002_setinput :
+ * Function to set the input
+ */
+static int tvp7002_setinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of set input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	if ((*index >= tvp7002_configuration[ch_id].no_of_inputs)
+	    || (*index < 0)) {
+		return -EINVAL;
+	}
+	if (*index == 0) {	/* HD */
+		tvp7002_channel_info[ch_id].params.inputidx = *index;
+	} else {
+		dev_err(tvp7002_i2c_dev[ch_id], "Invalid index.\n");
+		return -EINVAL;
+	}
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of set input function.\n");
+	return err;
+}
+
+/* tvp7002_getinput : Function to get the input
+ */
+static int tvp7002_getinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	v4l2_std_id id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of get input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	err |= tvp7002_querystd(&id, dec);
+	if (err < 0) {
+		return err;
+	}
+	*index = 0;
+	*index = tvp7002_channel_info[ch_id].params.inputidx;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of get input function.\n");
+	return err;
+}
+
+/* tvp7002_enuminput :
+ * Function to enumerate the input
+ */
+static int tvp7002_enuminput(struct v4l2_input *input, void *dec)
+{
+	int err = 0;
+	int index = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	/* check for null pointer */
+	if (input == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Only one input is available */
+	if (input->index >= tvp7002_configuration[ch_id].no_of_inputs) {
+		return -EINVAL;
+	}
+	index = input->index;
+	memset(input, 0, sizeof(*input));
+	input->index = index;
+	memcpy(input,
+	       &tvp7002_configuration[ch_id].input[index].input_info,
+	       sizeof(struct v4l2_input));
+	return err;
+}
+
+/* tvp7002_set_format_params :
+ * Function to set the format parameters
+ */
+static int tvp7002_set_format_params(struct tvp7002_format_params
+				     *tvpformats, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"Tvp7002 set format params started...\n");
+	if (tvpformats == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Write the HPLL related registers */
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_DIVIDER_MSB,
+				    tvpformats->hpll_divider_msb);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C write fails...Divider MSB\n");
+		return err;
+	}
+
+	val = ((tvpformats->
+		hpll_divider_lsb & HPLL_DIVIDER_LSB_MASK) <<
+	       HPLL_DIVIDER_LSB_SHIFT);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_HPLL_DIVIDER_LSB, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C write fails...Divider LSB.\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_CONTROL,
+				    tvpformats->hpll_control);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_START_PIXEL_LOW,
+				    tvpformats->avid_start_lsb);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_START_PIXEL_HIGH,
+				    tvpformats->avid_start_msb);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_STOP_PIXEL_LOW,
+				    tvpformats->avid_stop_lsb);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_AVID_STOP_PIXEL_HIGH,
+				  tvpformats->avid_stop_msb);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD0_START_OFFSET,
+				  tvpformats->vblk_start_f0_line_offset);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD1_START_OFFSET,
+				  tvpformats->vblk_start_f1_line_offset);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD0_DURATION,
+				  tvpformats->vblk_f0_duration);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_VBLK_FIELD1_DURATION,
+				    tvpformats->vblk_f1_duration);
+
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_ALC_PLACEMENT,
+				    tvpformats->alc_placement);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_CLAMP_START,
+				    tvpformats->clamp_start);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_CLAMP_WIDTH,
+				    tvpformats->clamp_width);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_PRE_COAST,
+				    tvpformats->hpll_pre_coast);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_POST_COAST,
+				    tvpformats->hpll_post_coast);
+
+	tvp7002_channel_info[ch_id].params.format = *tvpformats;
+
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"End of tvp7002 set format params...\n");
+	return err;
+}
+
+/* tvp7002_setparams : This function will set parameters for tvp7002
+ */
+static int tvp7002_setparams(void *params, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	struct i2c_client *ch_client;
+	tvp7002_params tvp7002params;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	if (copy_from_user(&tvp7002params, (tvp7002_params *) params,
+			   sizeof(tvp7002params))) {
+		return -EFAULT;
+	}
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	ch_client = &tvp7002_channel_info[ch_id].i2c_dev.client;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"Start of tvp7002 set params function.\n");
+
+	/* check for null pointer */
+	err |= tvp7002_setinput(&(tvp7002params.inputidx), dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+	err |= tvp7002_setstd(&(tvp7002params.std), dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+
+	/* set video format related parameters */
+	err = tvp7002_set_format_params(&tvp7002params.format, dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+
+	/* Write the gain information */
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_BLUE_FINE_GAIN,
+				    tvp7002params.gain.blue_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_GREEN_FINE_GAIN,
+				    tvp7002params.gain.green_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_FINE_GAIN,
+				    tvp7002params.gain.red_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	/* Write coarse gain information */
+	val = 0;
+	val = tvp7002params.gain.blue_coarse_gain & BLUE_COARSE_GAIN_MASK;
+	tvp7002params.gain.blue_coarse_gain = val;
+
+	val |= ((tvp7002params.gain.green_coarse_gain &
+		 GREEN_COARSE_GAIN_MASK) << GREEN_COARSE_GAIN_SHIFT);
+	tvp7002params.gain.green_coarse_gain =
+	    tvp7002params.gain.green_coarse_gain & GREEN_COARSE_GAIN_MASK;
+
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_BLUE_GREEN_COARSE_GAIN, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	val = tvp7002params.gain.red_coarse_gain & RED_COARSE_GAIN_MASK;
+	tvp7002params.gain.red_coarse_gain = val;
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_COARSE_GAIN, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	/*Write the offset value in register */
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_BLUE_FINE_OFFSETMSB,
+				    tvp7002params.offset.blue_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_GREEN_FINE_OFFSETMSB,
+				    tvp7002params.offset.green_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_FINE_OFFSETMSB,
+				    tvp7002params.offset.red_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = 0;
+	val = tvp7002params.offset.blue_fine_offset_lsb & FINE_OFFSET_LSB_MASK;
+	tvp7002params.offset.blue_fine_offset_lsb = val;
+
+	val |= ((tvp7002params.
+		 offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
+		FINE_OFFSET_LSB_SHIFT_GREEN);
+	tvp7002params.offset.green_fine_offset_lsb =
+	    (tvp7002params.offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
+
+	val |= ((tvp7002params.
+		 offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
+		FINE_OFFSET_LSB_SHIFT_RED);
+	tvp7002params.offset.red_fine_offset_lsb =
+	    (tvp7002params.offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_FINE_OFFSET_LSBS, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.blue_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.blue_coarse_offset = val;
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_BLUE_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.green_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.green_coarse_offset = val;
+
+	err =
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_GREEN_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.red_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.red_coarse_offset = val;
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	if (tvp7002params.alc.alc_enable) {
+		err =
+		    tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x80);
+	} else {
+		err =
+		    tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x00);
+	}
+	val = (tvp7002params.alc.vcoeff << TVP7002_ALC_VCOEFF_SHIFT) |
+	    (tvp7002params.alc.hcoeff);
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_FILTER, val);
+	if (err < 0)
+		return err;
+
+	tvp7002_channel_info[ch_id].params = tvp7002params;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of configTVP7002...\n");
+	return err;
+}
+
+/* tvp7002_getparams : This function will get parameters for tvp7002
+ */
+static int tvp7002_getparams(void *params, void *dec)
+{
+	int ch_id;
+	int err = 0;
+	tvp7002_params *tvp7002params = (tvp7002_params *) params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting tvp7002_getparams\n");
+
+	/* check for null pointer */
+	if (tvp7002params == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Null pointer\n");
+		return -EINVAL;
+	}
+	if (copy_to_user(tvp7002params, &(tvp7002_channel_info[ch_id].params),
+			 sizeof(*tvp7002params))) {
+		return -EFAULT;
+	}
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of getparamsTVP7002...\n");
+	return err;
+}
+
+/* tvp7002_i2c_read_reg :This function is used to read value from register
+ * for i2c client.
+ */
+static int tvp7002_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp7002_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int tvp7002_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp7002_i2c_attach_client : This function is used to attach i2c client
+ */
+static int tvp7002_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* tvp7002_i2c_detach_client : This function is used to detach i2c client
+ */
+static int tvp7002_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/* tvp7002_i2c_probe_adapter : This function is used to probe i2c adapter
+ */
+static int tvp7002_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp7002_i2c_dev[0] = &(adap->dev);
+	dev_dbg(tvp7002_i2c_dev[0], "Tvp7002 i2c probe adapter called...\n");
+
+	/* Attach the client */
+	err = tvp7002_i2c_attach_client(&tvp7002_channel_info[0].i2c_dev.
+					client,
+					&tvp7002_channel_info[0].i2c_dev.
+					driver, adap,
+					tvp7002_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp7002_i2c_dev[0], "Tvp7002 i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp7002_i2c_init : This function is used initialize tvp7002 i2c client
+ */
+static int tvp7002_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j = 0;
+
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+	char strings[TVP7002_NUM_CHANNELS][80] =
+	    { "TVP channel0 Video Decoder I2C driver"
+	};
+	for (i = 0; i < TVP7002_NUM_CHANNELS; i++) {
+		driver = &tvp7002_channel_info[i].i2c_dev.driver;
+		driver->owner = THIS_MODULE;
+		strlcpy(driver->name, strings[i], sizeof(strings[i]));
+		driver->id = I2C_DRIVERID_EXP0;
+		driver->flags = I2C_DF_NOTIFY;
+		if (0 == i) {
+			driver->attach_adapter = tvp7002_i2c_probe_adapter;
+		}
+		driver->detach_client = tvp7002_i2c_detach_client;
+		err = vpif_register_decoder(&tvp7002_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vpif_unregister_decoder(&tvp7002_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* tvp7002_i2c_cleanup : This function is used detach tvp7002 i2c client
+ */
+static void tvp7002_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < TVP7002_NUM_CHANNELS; i++) {
+		if (tvp7002_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&tvp7002_channel_info[i].i2c_dev.driver);
+			tvp7002_channel_info[i].i2c_dev.client.adapter = NULL;
+			tvp7002_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+		vpif_unregister_decoder(&tvp7002_dev[i]);
+	}
+}
+
+module_init(tvp7002_i2c_init);
+module_exit(tvp7002_i2c_cleanup);
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/vpif.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/vpif.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpif.c */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <media/davinci/vpif.h>
+
+#define VPIF_CH0_MAX_MODES	(22)
+#define VPIF_CH1_MAX_MODES	2
+#define VPIF_CH2_MAX_MODES	15
+#define VPIF_CH3_MAX_MODES	2
+
+/* This structure is used to keep track of VPIF size register's offsets */
+struct vpif_registers {
+	u32 h_cfg, v_cfg_00, v_cfg_01, v_cfg_02, v_cfg, ch_ctrl;
+	u32 line_offset, vanc0_strt, vanc0_size, vanc1_strt;
+	u32 vanc1_size, width_mask, len_mask;
+	u8 max_modes;
+};
+
+static struct vpif_registers vpifregs[VPIF_NUM_CHANNELS] = {
+	/* Channel0 registers offsets */
+	{VPIF_CH0_H_CFG, VPIF_CH0_V_CFG_00, VPIF_CH0_V_CFG_01,
+	 VPIF_CH0_V_CFG_02, VPIF_CH0_V_CFG_03, VPIF_CH0_CTRL,
+	 VPIF_CH0_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF, VPIF_CH0_MAX_MODES},
+	/* Channel1 registers offsets */
+	{VPIF_CH1_H_CFG, VPIF_CH1_V_CFG_00, VPIF_CH1_V_CFG_01,
+	 VPIF_CH1_V_CFG_02, VPIF_CH1_V_CFG_03, VPIF_CH1_CTRL,
+	 VPIF_CH1_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF, VPIF_CH1_MAX_MODES},
+	/* Channel2 registers offsets */
+	{VPIF_CH2_H_CFG, VPIF_CH2_V_CFG_00, VPIF_CH2_V_CFG_01,
+	 VPIF_CH2_V_CFG_02, VPIF_CH2_V_CFG_03, VPIF_CH2_CTRL,
+	 VPIF_CH2_IMG_ADD_OFST, VPIF_CH2_VANC0_STRT, VPIF_CH2_VANC0_SIZE,
+	 VPIF_CH2_VANC1_STRT, VPIF_CH2_VANC1_SIZE, 0x7FF, 0x7FF,
+	 VPIF_CH2_MAX_MODES},
+	/* Channel3 registers offsets */
+	{VPIF_CH3_H_CFG, VPIF_CH3_V_CFG_00, VPIF_CH3_V_CFG_01,
+	 VPIF_CH3_V_CFG_02, VPIF_CH3_V_CFG_03, VPIF_CH3_CTRL,
+	 VPIF_CH3_IMG_ADD_OFST, VPIF_CH3_VANC0_STRT, VPIF_CH3_VANC0_SIZE,
+	 VPIF_CH3_VANC1_STRT, VPIF_CH3_VANC1_SIZE, 0x7FF, 0x7FF,
+	 VPIF_CH3_MAX_MODES}
+};
+
+int vpif_channel_getfid(u8 channel_id)
+{
+	return (((regr(vpifregs[channel_id].ch_ctrl) & VPIF_CH_FID_MASK) >>
+		 VPIF_CH_FID_SHIFT));
+}
+
+EXPORT_SYMBOL(vpif_channel_getfid);
+
+#define VPIF_SD_PARAMS \
+	{"NTSC", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266, \
+	 286, 525, 525, 0, 1, 0}, \
+	{"PAL", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313, \
+	 336, 624, 625, 0, 1, 0}
+
+#define VPIF_SD_16BIT_OUTPUT_PARAMS \
+        {"NTSC-16Bit", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266, \
+	 286, 525, 525, 0, 0, 0}, \
+	{"PAL-16Bit", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313, \
+	 336, 624, 625, 0, 0, 0}
+
+#define VPIF_HD_PARAMS	\
+	{"720P-60", 1280, 720, 60, 1, 0, 362, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"1080I-30", 1920, 1080, 30, 0, 0, 272, 1920, 1, 21, 561, 564, \
+	 584, 1124, 1125, 0, 0, 1}, \
+	{"1080I-25", 1920, 1080, 25, 0, 0, 712, 1920, 1, 21, 561, 564, \
+	 584, 1124, 1125, 0, 0, 1}
+
+#define VPIF_720P_PARAMS \
+	{"720P-25", 1280, 720, 25, 1, 0, 2672, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"720P-30", 1280, 720, 30, 1, 0, 2012, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"720P-50", 1280, 720, 50, 1, 0, 692, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}
+
+#define VPIF_1080P_PARAMS  \
+	{"1080P-24", 1920, 1080, 24, 1, 0, 822, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1}, \
+	{"1080P-25", 1920, 1080, 25, 1, 0, 712, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1}, \
+	{"1080P-30", 1920, 1080, 30, 1, 0, 272, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1},
+
+#define VPIF_ED_PARAMS	\
+	{"480P-60", 720, 480, 60, 1, 0, 130, 720, 1, 43, 525, \
+	 0, 0, 0, 525, 0, 0, 0}, \
+	{"576P-50", 720, 576, 50, 1, 0, 136, 720, 1, 45, 621, \
+	 0, 0, 0, 625, 0, 0, 0}
+
+#define VPIF_MT9T001_PARAMS \
+	{"VGA-30", 640, 480, 30, 1, 0, 2068, 1320, 1, 31, 522, 0, \
+	 0, 0, 490, 1, 0, 0}, \
+	{"VGA-60", 640, 480, 60, 1, 0, 1432, 1320, 1, 31, 522, 0, \
+	 0, 0, 490, 1, 0, 0}, \
+	{"SVGA-30", 800, 600, 30, 1, 0, 1432, 1640, 1, 31, 652, 0, \
+	 0, 0, 620, 1, 0, 0}, \
+	{"SVGA-60", 800, 600, 60, 1, 0, 780, 1640, 1, 31, 652, 0, \
+	 0, 0, 620, 1, 0, 0}, \
+	{"XGA", 1024, 768, 30, 1, 0, 938, 2080, 1, 283, 806, 0, \
+	 0, 0, 776, 1, 0, 0}, \
+	{"480P-MT-30", 720, 480, 30, 1, 0, 2090, 1472, 1, 350, 839, 0, \
+	 0, 0, 488, 1, 0, 0}, \
+	{"480P-MT-60", 720, 480, 60, 1, 0, 1494, 1472, 1, 50, 539, 0, \
+	 0, 0, 488, 1, 0, 0}, \
+	{"576P-MT-25", 720, 576, 25, 1, 0, 2238, 1472, 1, 450, 1035, 0, \
+	 0, 0, 584, 1, 0, 0}, \
+	{"576P-MT-50", 720, 576, 50, 1, 0, 1558, 1472, 1, 48, 663, 0, \
+	 0, 0, 584, 1, 0, 0}, \
+	{"720P-MT-24", 1280, 720, 24, 1, 0, 1338, 2600, 1, 282, 1013, 0, \
+	 0, 0, 730, 1, 0, 0}, \
+	{"720P-MT-30", 1280, 720, 30, 1, 0, 782, 2600, 1, 220, 951, 0, \
+	 0, 0, 730, 1, 0, 0}, \
+	{"1080P-MT-18", 1920, 1080, 18, 1, 0, 954, 3840, 1, 31, 1112, 0, \
+	 0, 0, 1080, 1, 0, 0}
+
+static struct vpif_channel_config_params ch0_params[VPIF_CH0_MAX_MODES] = {
+	VPIF_SD_PARAMS, VPIF_HD_PARAMS, VPIF_MT9T001_PARAMS, VPIF_720P_PARAMS,
+	VPIF_ED_PARAMS
+};
+
+static struct vpif_channel_config_params ch1_params[VPIF_CH1_MAX_MODES] = {
+	VPIF_SD_PARAMS
+};
+static struct vpif_channel_config_params ch2_params[VPIF_CH2_MAX_MODES] = {
+	VPIF_SD_PARAMS, VPIF_HD_PARAMS, VPIF_ED_PARAMS,
+	VPIF_SD_16BIT_OUTPUT_PARAMS, VPIF_720P_PARAMS, VPIF_1080P_PARAMS
+};
+
+static struct vpif_channel_config_params *vpif_config_params
+    [VPIF_NUM_CHANNELS] = {
+	ch0_params,
+	ch1_params,
+	ch2_params,
+	ch1_params
+};
+static u8 irq_vpif_channel[VPIF_NUM_CHANNELS] = { 0, 1, 2, 3 };
+int vpif_get_irq_number(int ch_id)
+{
+	return irq_vpif_channel[ch_id];
+}
+
+EXPORT_SYMBOL(vpif_get_irq_number);
+
+/* Function to set vpif parameters */
+static void vpif_set_mode_info(u8 index, u8 channel_id, u8 config_channel_id);
+
+/* vpif_set_mode_info: This function is used to set horizontal and
+ * vertical config parameters in VPIF registers */
+static void vpif_set_mode_info(u8 index, u8 channel_id, u8 config_channel_id)
+{
+	u32 value;
+
+	/* As per the standard in the channel, configure the values of L1, L3,
+	   L5, L7  L9, L11 in VPIF Register */
+	/* Write width of the image */
+	value = (vpif_config_params[config_channel_id][index].eav2sav &
+		 vpifregs[config_channel_id].width_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].sav2eav &
+		  vpifregs[config_channel_id].width_mask);
+
+	regw(value, vpifregs[channel_id].h_cfg);
+
+	/* Write the L1 and L3 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l1 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l3 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_00);
+
+	/* Write the L5 and L6 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l5 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l7 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_01);
+
+	/* Write the L9 and L11 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l9 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l11 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_02);
+
+	/* Write the image height in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].vsize &
+		 vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg);
+}
+
+/* vpif_set_video_capture_params: This function is used to set video
+ * parameters in VPIF register. It sets size parameters, frame format
+ * and yc mux mode */
+int vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id)
+{
+	int index, found = -1, i;
+	u8 max_modes = vpifregs[channel_id].max_modes;
+	u32 value, ch_nip;
+	u8 start, end;
+
+	/* loop on the number of mode supported per channel */
+	for (index = 0; index < max_modes; index++) {
+
+		/* If the mode is found, set the parameter in VPIF register */
+		if (0 == strcmp(vpif_config_params[channel_id][index].name,
+				vpifparams->video_params.name)) {
+
+			found = 1;
+			/* Set the size parameteres in the VPIF registers */
+			vpif_set_mode_info(index, channel_id, channel_id);
+
+			if (!(vpif_config_params[channel_id][index].ycmux_mode)) {
+				vpif_set_mode_info(index,
+						   channel_id + 1, channel_id);
+				found = 2;
+			}
+			start = channel_id;
+			end = channel_id + found;
+
+			for (i = start; i < end; i++) {
+				value = regr(vpifregs[i].ch_ctrl);
+
+				if (channel_id < 2)
+					ch_nip = VPIF_CAPTURE_CH_NIP;
+				else
+					ch_nip = VPIF_DISPLAY_CH_NIP;
+
+				/* Set the frame format in the 
+				 * control register */
+				if (vpif_config_params[channel_id][index].
+				    frm_fmt) {
+					/* Progressive Frame Format */
+					SETBIT(value, ch_nip);
+				} else {
+					/* Interlaced Frame Format */
+					RESETBIT(value, ch_nip);
+				}
+
+				/* Set YC mux mode in the control register */
+				if (vpif_config_params[channel_id][index].
+				    ycmux_mode) {
+					/* YC Mux mode */
+					SETBIT(value, VPIF_CH_YC_MUX_BIT);
+				} else {
+					/* YC Non Mux mode */
+					RESETBIT(value, VPIF_CH_YC_MUX_BIT);
+				}
+				/* Set field/frame mode in control register */
+				if (vpifparams->video_params.storage_mode) {
+					SETBIT(value,
+					       VPIF_CH_INPUT_FIELD_FRAME_BIT);
+				} else {
+					RESETBIT(value,
+						 VPIF_CH_INPUT_FIELD_FRAME_BIT);
+				}
+
+				/* Set raster scanning SDR Format */
+				RESETBIT(value, VPIF_CH_SDR_FMT_BIT);
+
+				/* Set the capture format */
+				if (vpif_config_params[channel_id][index].
+				    capture_format) {
+					SETBIT(value, VPIF_CH_DATA_MODE_BIT);
+				} else {
+					RESETBIT(value, VPIF_CH_DATA_MODE_BIT);
+				}
+
+				if (channel_id > 1) {
+					/* Set the Pixel enable bit */
+					SETBIT(value, VPIF_DISPLAY_PIX_EN_BIT);
+				} else {
+					/* Set the polarity of various pins */
+					if (vpif_config_params[channel_id]
+					    [index].capture_format) {
+						if (vpifparams->params.
+						    raw_params.fid_pol) {
+							SETBIT(value,
+							       VPIF_CH_FID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_FID_POLARITY_BIT);
+						}
+						if (vpifparams->params.
+						    raw_params.vd_pol) {
+							SETBIT(value,
+							       VPIF_CH_V_VALID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_V_VALID_POLARITY_BIT);
+						}
+						if (vpifparams->params.
+						    raw_params.hd_pol) {
+							SETBIT(value,
+							       VPIF_CH_H_VALID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_H_VALID_POLARITY_BIT);
+						}
+						/* Set data width */
+						value &=
+						    ((~(unsigned int)(0x3)) <<
+						     VPIF_CH_DATA_WIDTH_BIT);
+						value |=
+						    ((vpifparams->params.
+						      raw_params.
+						      data_sz) <<
+						     VPIF_CH_DATA_WIDTH_BIT);
+					}
+				}
+				regw(value, vpifregs[i].ch_ctrl);
+
+				/* Write the pitch in the driver */
+				regw((vpifparams->video_params.hpitch),
+				     vpifregs[i].line_offset);
+			}
+			break;
+		}
+	}
+	regw(0x80, VPIF_REQ_SIZE);
+	regw(0x01, VPIF_EMULATION_CTRL);
+	return found;
+}
+
+EXPORT_SYMBOL(vpif_set_video_params);
+
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+				u8 channel_id)
+{
+	u32 value;
+
+	value = 0x3F8 & (vbiparams->hstart0);
+	value |= 0x3FFFFFF & ((vbiparams->vstart0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_strt);
+
+	value = 0x3F8 & (vbiparams->hstart1);
+	value |= 0x3FFFFFF & ((vbiparams->vstart1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_strt);
+
+	value = 0x3F8 & (vbiparams->hsize0);
+	value |= 0x3FFFFFF & ((vbiparams->vsize0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_size);
+
+	value = 0x3F8 & (vbiparams->hsize1);
+	value |= 0x3FFFFFF & ((vbiparams->vsize1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_size);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(vpif_set_vbi_display_params);
+
+int vpif_get_mode_info(struct vpif_stdinfo *std_info)
+{
+	int index, found = -1;
+	u8 channel_id;
+	u8 max_modes;
+
+	if (!std_info)
+		return found;
+
+	channel_id = std_info->channel_id;
+
+	if (channel_id != 0 && channel_id != 1 && channel_id != 2 &&
+	    channel_id != 3) {
+		return found;
+	}
+
+	max_modes = vpifregs[channel_id].max_modes;
+
+	/* loop on the number of mode supported per channel */
+	for (index = 0; index < max_modes; index++) {
+
+		/* If the mode is found, set the parameter in VPIF register */
+		if (0 == strcmp(vpif_config_params[channel_id][index].name,
+				std_info->name)) {
+			std_info->activelines =
+			    vpif_config_params[channel_id][index].height;
+			std_info->activepixels =
+			    vpif_config_params[channel_id][index].width;
+			std_info->fps =
+			    vpif_config_params[channel_id][index].fps;
+			std_info->frame_format =
+			    vpif_config_params[channel_id][index].frm_fmt;
+			std_info->ycmux_mode =
+			    vpif_config_params[channel_id][index].ycmux_mode;
+			std_info->vbi_supported = vpif_config_params
+			    [channel_id][index].vbi_supported;
+			std_info->hd_sd =
+			    vpif_config_params[channel_id][index].hd_sd;
+			found = 1;
+			break;
+		}
+	}
+	return found;
+}
+
+EXPORT_SYMBOL(vpif_get_mode_info);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/include/media/davinci/adv7343.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/adv7343.h
@@ -0,0 +1,768 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*adv7343.h*/
+
+#ifndef ADV7343_H
+#define ADV7343_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <media/davinci/vid_encoder_types.h>
+
+#endif				/* __KERNEL__ */
+
+/* Macros */
+#define ADV7343_MAX_GAMMA_COEFFS	10	/* Maximum Gamma Coefficients */
+
+/* Enums */
+/* Enum for type of parameters */
+enum adv7343_params_type {
+	ADV7343_SDPARAMS = 0,	/* Indicates SD parameters */
+	ADV7343_HDPARAMS	/* Indicates HD parameters */
+};
+
+/* Enum for DNR modes */
+enum adv7343_dnr_mode {
+	ADV7343_MODE_DNR = 0,	/* Indicates DNR Mode */
+	ADV7343_MODE_DNR_SHARPNESS	/* Indicates DNR Sharpness Mode */
+};
+
+/* Enum for DNR block size */
+enum adv7343_dnr_blocksize {
+	ADV7343_DNR_BLOCK_8 = 0,	/* Indicates DNR block of 8x8 */
+	ADV7343_DNR_BLOCK_16	/* Indicates DNR block of 16x16 */
+};
+
+/* Enum for SD Luma filters */
+enum adv7343_sd_luma_filter {
+	ADV7343_LUMA_LPF_NTSC = 0,	/* HD Luma LPF Filter for NTSC */
+	ADV7343_LUMA_LPF_PAL,	/* HD Luma LPF Filter for PAL */
+	ADV7343_LUMA_NOTCH_NTSC,	/* HD Luma Notch Filter for NTSC */
+	ADV7343_LUMA_NOTCH_PAL,	/* HD Luma Notch Filter for NTSC */
+	ADV7343_LUMA_SSAF,	/* HD Luma SSAF Filter */
+	ADV7343_LUMA_CIF,	/* HD Luma CIF Filter */
+	ADV7343_LUMA_QCIF	/* HD Luma QCIF Filter */
+};
+
+/* Enum for SD Chroma filters */
+enum adv7343_sd_chroma_filter {
+	ADV7343_CHROMA_0_65 = 0,	/* SD Chroma 0.65MHz LPF */
+	ADV7343_CHROMA_1_0,	/* SD Chroma 1.0MHz LPF */
+	ADV7343_CHROMA_1_3,	/* SD Chroma 1.3MHz LPF */
+	ADV7343_CHROMA_2_0,	/* SD Chroma 2.0MHz LPF */
+	ADV7343_CHROMA_2_3,	/* SD Chroma 2.3MHz LPF */
+	ADV7343_CHROMA_CIF,	/* SD Chroma CIF Response LPF */
+	ADV7343_CHROMA_QCIF,	/* SD Chroma QCIF Response LPF */
+	ADV7343_CHROMA_SSAF,	/* SD SSAF Color difference filter */
+};
+
+/* Enum for HD Filters */
+enum adv7343_hd_filter {
+	ADV7343_SINC_FILTER = 1,	/* HD Sync filter on DAC D,E,F */
+	ADV7343_HD_CHROMA_SSAF = 2	/* HD Chroma SSAF filter */
+};
+
+/* Enum for selecting DNR filter */
+enum adv7343_dnr_filter {
+	ADV7343_DNR_FILTER_A = 0,	/* DNR Filter A */
+	ADV7343_DNR_FILTER_B,	/* DNR Filter B */
+	ADV7343_DNR_FILTER_C,	/* DNR Filter C */
+	ADV7343_DNR_FILTER_D	/* DNR Filter D */
+};
+
+/* Enum for selecting adaptive filter modes */
+enum adv7343_filter_mode {
+	ADV7343_FILTER_MODE_SHARPNESS = 0,	/* Adaptive Filter Sharpness
+						   mode */
+	ADV7343_FILTER_MODE_A,	/* Adaptive Filter Mode A */
+	ADV7343_FILTER_MODE_B	/* Adaptive Filter Mode B */
+};
+
+/* Enum for Border AREA DNR */
+enum adv7343_dnr_border_area {
+	ADV7343_BORDER_AREA_2 = 0,	/* Border area size is 2 pixels */
+	ADV7343_BORDER_AREA_4	/* Border area size is 4 pixels */
+};
+
+/* Enum for feature control */
+enum adv7343_feature {
+	ADV7343_DISABLE = 0,
+	ADV7343_ENABLE
+};
+/* structure */
+/* RGB Matrix for HD */
+struct adv7343_rgb_matrix {
+	enum adv7343_feature en_rgb_matrix;	/* Enables/Disabled 
+						   RGB matrix */
+	unsigned short gy;	/* RGB Coeffs */
+	unsigned short gu;
+	unsigned short gv;
+	unsigned short bu;
+	unsigned short rv;
+};
+
+/* Filter parameters for HD */
+struct adv7343_filter_params {
+	enum adv7343_feature en_filter;	/* Used to enable/disable filters */
+	enum adv7343_filter_mode mode;	/* mode of the sharpness and adaptive 
+					   filter */
+	unsigned char threshold_a;	/* Adaptive filter threshold A */
+	unsigned char threshold_b;	/* Adaptive filter threshold B */
+	unsigned char threshold_c;	/* Adaptive filter threshold C */
+	unsigned char gain1_vala;	/* Adaptive filter Gain1 Value A */
+	unsigned char gain1_valb;	/* Adaptive filter Gain1 Value B */
+	unsigned char gain2_vala;	/* Adaptive filter Gain2 Value A */
+	unsigned char gain2_valb;	/* Adaptive filter Gain2 Value B */
+	unsigned char gain3_vala;	/* Adaptive filter Gain3 Value A */
+	unsigned char gain3_valb;	/* Adaptive filter Gain3 Value B */
+	unsigned char sharpness;	/* Sharpness value */
+};
+
+/* DNR parameters structure */
+struct adv7343_dnr_params {
+	enum adv7343_feature en_dnr;	/* enables/disables DNR */
+	enum adv7343_dnr_mode mode;	/* Selects DNR Mode */
+	enum adv7343_dnr_blocksize block_size;	/* block size for DNR */
+	enum adv7343_dnr_border_area area;	/* Block size */
+	unsigned char border_gain;	/* Gain for the border of 
+					   block */
+	unsigned char data_gain;	/* Gain for data except 
+					   border of block */
+	enum adv7343_dnr_filter filt_select;	/* Selects on filter */
+	unsigned char block_offset;	/* Block offset */
+	unsigned char threshold;	/* DNR threshold */
+};
+
+/* SSAF Parameters structure */
+struct adv7343_ssaf_params {
+	enum adv7343_feature en_gain;	/* Enables/disables gain */
+	unsigned char gain;	/* Value of Gain */
+};
+
+/* SD Y and PbPr scaling parameters */
+struct adv7343_scale_params {
+	enum adv7343_feature en_scale;	/* This enabled/disabled scaling */
+	unsigned short y_scale;	/* Value of scaling for Y data */
+	unsigned short pb_scale;	/* Value of scaling for Pb data */
+	unsigned short pr_scale;	/* Value of scaling for Pr data */
+};
+
+/* Used to select gamma curve */
+enum adv7343_gamma_curve {
+	ADV7343_GAMMA_CURVE_A = 0,
+	ADV7343_GAMMA_CURVE_B
+};
+
+struct adv7343_gamma_params {
+	enum adv7343_feature en_gamma;	/* enables/disables 
+					   gamma correction */
+	enum adv7343_gamma_curve curve;	/* Selects gamma 
+					   correction curve */
+	unsigned char coeff[ADV7343_MAX_GAMMA_COEFFS];	/* Gamma correction 
+							   coefficients */
+};
+
+/* SD Parameters structure */
+struct adv7343_sd_params {
+	enum adv7343_sd_luma_filter luma_filter;	/* SD Luma Filter */
+	enum adv7343_sd_chroma_filter chroma_filter;	/* SD Chroma Filter */
+	struct adv7343_ssaf_params ssaf;	/* SSAF Parameters */
+	struct adv7343_scale_params scale;	/* scaling parameters */
+	struct adv7343_dnr_params dnr;	/* DNR Parameters */
+	enum adv7343_feature active_step_edge_scale;	/* Enabled/disables 
+							   active edge and 
+							   step edge scale */
+	struct adv7343_gamma_params gamma;	/* gamma parameters */
+};
+
+/* HD Parameter structure */
+struct adv7343_hd_params {
+	enum adv7343_feature sinc_filter;	/* HD Sinc Filter */
+	enum adv7343_feature ssaf_filter;	/* HD ssaf Filter */
+	struct adv7343_rgb_matrix rgb;	/* RGB Matrix coefficients */
+	struct adv7343_filter_params filt_params;	/* Filter parameters */
+	struct adv7343_gamma_params gamma;	/* Gamma parameters */
+};
+
+/* ADV7343 parameters structure */
+typedef struct {
+	enum adv7343_params_type type;	/* Type of parameters SD or 
+					   HD */
+	union {
+		struct adv7343_sd_params sd;	/* SD Parameters */
+		struct adv7343_hd_params hd;	/* HD Parameters */
+	} params;
+} adv7343_params;
+
+#ifdef __KERNEL__
+
+#define ADV7343_COMPOSITE_OUTPUT_NAME  	"COMPOSITE"
+#define ADV7343_COMPONENT_OUTPUT_NAME  	"COMPONENT"
+#define ADV7343_SVIDEO_OUTPUT_NAME	"SVIDEO"
+
+#define ADV7343_COMPOSITE_ID		0
+#define ADV7343_COMPONENT_ID		1
+#define ADV7343_SVIDEO_ID		2
+
+#define ADV7343_COMPOSITE_NO_CONTROLS		(3)
+#define ADV7343_COMPONENT_NO_CONTROLS		(1)
+#define ADV7343_SVIDEO_NO_CONTROLS		(3)
+
+#define ADV7343_NUM_CHANNELS			(1)
+
+/* encoder standard related strctures */
+#define ADV7343_MAX_NO_OUTPUTS			(3)
+#define ADV7343_COMPOSITE_NUM_STD		(2)
+#define ADV7343_COMPONENT_NUM_STD		(7+3+3)
+#define ADV7343_SVIDEO_NUM_STD			(2)
+#define ADV7343_MAX_NO_CONTROLS			(3)
+#define ADV7343_VBI_NUM_SERVICES		(3)
+
+struct adv7343_std_info {
+	unsigned char set_std_register;
+	volatile unsigned char *value;
+	u32 outputmode_val1;
+	u32 standard_val2;
+	u32 standard_val3;
+	u8 fsc0_reg, fsc0_val;
+	u8 fsc1_reg, fsc1_val;
+	u8 fsc2_reg, fsc2_val;
+	u8 fsc3_reg, fsc3_val;
+};
+
+struct adv7343_control_info {
+	int register_address;
+	int value;
+	enum vid_enc_ctrl_id id;
+	int minimum, maximum;
+};
+
+struct adv7343_config {
+	int no_of_outputs;
+	struct {
+		unsigned char power_val;
+		int output_type;
+		char output_name[VID_ENC_NAME_MAX_CHARS];
+		int no_of_standard;
+		struct vid_enc_mode_info *standard;
+		struct vid_enc_mode_info *def_std;
+		struct adv7343_std_info *std_info;
+		int no_of_controls;
+		struct adv7343_control_info *controls;
+	} output[ADV7343_MAX_NO_OUTPUTS];
+	unsigned short services_set;
+	u8 num_services;
+};
+
+struct adv7343_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u8 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct vid_encoder_device *enc_device;
+	u8 current_output;
+	struct vid_enc_mode_info *mode_info;
+	unsigned short services_set;
+	adv7343_params params;
+};
+
+struct adv7343_service_data_reg {
+	u32 service_set;
+	struct {
+		u8 addr[2];
+	} field[2];
+	u8 bytestowrite;
+};
+
+struct adv7343_service_reg {
+	u32 service;
+	u8 reg;
+	u8 *reg_val;
+	u8 enable_val;
+	u8 disable_val;
+	struct vid_enc_mode_info *std;
+};
+
+#define ADV7343_VALID_FEATURE_VAL(val) ((ADV7343_DISABLE == (val))|| \
+					(ADV7343_ENABLE == (val)))
+#define ADV7343_VALID_GAMMA_CURVE(val) ((ADV7343_GAMMA_CURVE_A == (val))|| \
+					(ADV7343_GAMMA_CURVE_B == (val)))
+
+/* Register Macros */
+#define ADV7343_POWER_MODE_REG			0x00
+#define ADV7343_MODE_SELECT_REG			0X01
+#define ADV7343_MODE_REG0			0x02
+#define ADV7343_CSC_MATRIX0			0x03
+#define ADV7343_CSC_MATRIX1			0x04
+#define ADV7343_CSC_MATRIX2			0x05
+#define ADV7343_CSC_MATRIX3			0x06
+#define ADV7343_CSC_MATRIX4			0x07
+#define ADV7343_CSC_MATRIX5			0x08
+#define ADV7343_CSC_MATRIX6			0x09
+#define ADV7343_DAC1_OUTPUT_LEVEL		0x0a
+#define ADV7343_DAC2_OUTPUT_LEVEL		0x0b
+#define ADV7343_DAC_POWER_MODE			0x0d
+#define ADV7343_CABLE_DETECTION			0x10
+#define ADV7343_SBUS_READ			0x12
+#define ADV7343_YBUS_READ			0x13
+#define ADV7343_CBUS_READ			0x14
+#define ADV7343_CONTROL_READ			0x16
+#define ADV7343_SOFT_RESET			0x17
+#define ADV7343_HD_MODE_REG1			0x30
+#define ADV7343_HD_MODE_REG2			0x31
+#define ADV7343_HD_MODE_REG3			0x32
+#define ADV7343_HD_MODE_REG4			0x33
+#define ADV7343_HD_MODE_REG5			0x34
+#define ADV7343_HD_MODE_REG6			0x35
+#define ADV7343_HD_Y_LEVEL			0x36
+#define ADV7343_HD_CR_LEVEL			0x37
+#define ADV7343_HD_CB_LEVEL			0x38
+#define ADV7343_HD_MODE_REG7			0x39
+#define ADV7343_HD_SHARPNESS_FLTR_GAIN		0x40
+#define ADV7343_HD_CGMS_DATA_0			0x41
+#define ADV7343_HD_CGMS_DATA_1			0x42
+#define ADV7343_HD_CGMS_DATA_2			0x43
+#define ADV7343_HD_GAMMA_A0			0x44
+#define ADV7343_HD_GAMMA_A1			0x45
+#define ADV7343_HD_GAMMA_A2			0x46
+#define ADV7343_HD_GAMMA_A3			0x47
+#define ADV7343_HD_GAMMA_A4			0x48
+#define ADV7343_HD_GAMMA_A5			0x49
+#define ADV7343_HD_GAMMA_A6			0x4a
+#define ADV7343_HD_GAMMA_A7			0x4b
+#define ADV7343_HD_GAMMA_A8			0x4c
+#define ADV7343_HD_GAMMA_A9			0x4d
+#define ADV7343_HD_GAMMA_B0			0x4E
+#define ADV7343_HD_GAMMA_B1			0x4F
+#define ADV7343_HD_GAMMA_B2			0x50
+#define ADV7343_HD_GAMMA_B3			0x51
+#define ADV7343_HD_GAMMA_B4			0x52
+#define ADV7343_HD_GAMMA_B5			0x53
+#define ADV7343_HD_GAMMA_B6			0x54
+#define ADV7343_HD_GAMMA_B7			0x55
+#define ADV7343_HD_GAMMA_B8			0x56
+#define ADV7343_HD_GAMMA_B9			0x57
+#define ADV7343_HD_ADPT_FLTR_GAIN1		0x58
+#define ADV7343_HD_ADPT_FLTR_GAIN2		0x59
+#define ADV7343_HD_ADPT_FLTR_GAIN3		0x5a
+#define ADV7343_HD_ADPT_FLTR_THRLDA		0x5b
+#define ADV7343_HD_ADPT_FLTR_THRLDB		0x5c
+#define ADV7343_HD_ADPT_FLTR_THRLDC		0x5d
+#define ADV7343_HD_CGMS_B0			0x5E
+#define ADV7343_HD_CGMS_B1			0x5F
+#define ADV7343_HD_CGMS_B2			0x60
+#define ADV7343_HD_CGMS_B3			0x61
+#define ADV7343_HD_CGMS_B4			0x62
+#define ADV7343_HD_CGMS_B5			0x63
+#define ADV7343_HD_CGMS_B6			0x64
+#define ADV7343_HD_CGMS_B7			0x65
+#define ADV7343_HD_CGMS_B8			0x66
+#define ADV7343_HD_CGMS_B9			0x67
+#define ADV7343_HD_CGMS_B10			0x68
+#define ADV7343_HD_CGMS_B11			0x69
+#define ADV7343_HD_CGMS_B12			0x6A
+#define ADV7343_HD_CGMS_B13			0x6B
+#define ADV7343_HD_CGMS_B14			0x6C
+#define ADV7343_HD_CGMS_B15			0x6D
+#define ADV7343_HD_CGMS_B16			0x6E
+
+#define ADV7343_SD_MODE_REG1			0x80
+#define ADV7343_SD_MODE_REG2			0x82
+#define ADV7343_SD_MODE_REG3			0x83
+#define ADV7343_SD_MODE_REG4			0x84
+#define ADV7343_SD_MODE_REG5			0x86
+#define ADV7343_SD_MODE_REG6			0x87
+#define ADV7343_SD_MODE_REG7			0x88
+#define ADV7343_SD_MODE_REG8			0x89
+#define ADV7343_SD_TIMING_REG0			0x8A
+#define ADV7343_SD_TIMING_REG1			0x8B
+#define ADV7343_SD_FSC_REG0			0x8C
+#define ADV7343_SD_FSC_REG1			0x8D
+#define ADV7343_SD_FSC_REG2			0x8E
+#define ADV7343_SD_FSC_REG3			0x8F
+#define ADV7343_SD_FSC_PHASE			0x90
+#define ADV7343_SD_CLOSE_CAPTION_EVEN0		0x91
+#define ADV7343_SD_CLOSE_CAPTION_EVEN1		0x92
+#define ADV7343_SD_CLOSE_CAPTION_ODD0		0x93
+#define ADV7343_SD_CLOSE_CAPTION_ODD1		0x94
+#define ADV7343_SD_PEDESTAL_REG0		0x95
+#define ADV7343_SD_PEDESTAL_REG1		0x96
+#define ADV7343_SD_PEDESTAL_REG2		0x97
+#define ADV7343_SD_PEDESTAL_REG3		0x98
+#define ADV7343_SD_CGMS_WSS0			0x99
+#define ADV7343_SD_CGMS_WSS1			0x9A
+#define ADV7343_SD_CGMS_WSS2			0x9B
+
+#define ADV7343_SD_SCALE_LSB			0x9C
+#define ADV7343_SD_Y_SCALE			0x9D
+#define ADV7343_SD_CB_SCALE			0x9E
+#define ADV7343_SD_CR_SCALE			0x9F
+
+#define ADV7343_SD_HUE_REG			0xA0
+#define ADV7343_SD_BRIGHTNESS_WSS		0xA1
+#define ADV7343_SD_LUMA_SSAF			0xA2
+#define ADV7343_SD_DNR0				0xA3
+#define ADV7343_SD_DNR1				0xA4
+#define ADV7343_SD_DNR2				0xA5
+
+#define ADV7343_SD_GAMMA_A0			0xA6
+#define ADV7343_SD_GAMMA_A1			0xA7
+#define ADV7343_SD_GAMMA_A2			0xA8
+#define ADV7343_SD_GAMMA_A3			0xA9
+#define ADV7343_SD_GAMMA_A4			0xAA
+#define ADV7343_SD_GAMMA_A5			0xAB
+#define ADV7343_SD_GAMMA_A6			0xAC
+#define ADV7343_SD_GAMMA_A7			0xAD
+#define ADV7343_SD_GAMMA_A8			0xAE
+#define ADV7343_SD_GAMMA_A9			0xAF
+#define ADV7343_SD_GAMMA_B0			0xB0
+#define ADV7343_SD_GAMMA_B1			0xB1
+#define ADV7343_SD_GAMMA_B2			0xB2
+#define ADV7343_SD_GAMMA_B3			0xB3
+#define ADV7343_SD_GAMMA_B4			0xB4
+#define ADV7343_SD_GAMMA_B5			0xB5
+#define ADV7343_SD_GAMMA_B6			0xB6
+#define ADV7343_SD_GAMMA_B7			0xB7
+#define ADV7343_SD_GAMMA_B8			0xB8
+#define ADV7343_SD_GAMMA_B9			0xB9
+#define ADV7343_SD_BRIGHTNESS_DETECT		0xBA
+#define ADV7343_FIELD_COUNT_REG			0xBB
+#define ADV7343_10_BIT_INPUT			0x7C
+
+/* Default values for the registers */
+#define ADV7343_POWER_MODE_REG_DEFAULT		0x10	/* Changed */
+#define ADV7343_MODE_SELECT_REG_DEFAULT		0X00
+#define ADV7343_MODE_REG0_DEFAULT		0x20	/* Doubt on Sync 
+							   signals */
+#define ADV7343_DAC1_OUTPUT_LEVEL_DEFAULT	0x00
+#define ADV7343_DAC2_OUTPUT_LEVEL_DEFAULT	0x00
+#define ADV7343_HD_MODE_REG1_DEFAULT		0x3C	/* Changed Default 
+							   720p and EAV/SAV 
+							   code */
+#define ADV7343_HD_MODE_REG2_DEFAULT		0x01	/* Changed Pixel data 
+							   valid */
+#define ADV7343_HD_MODE_REG3_DEFAULT		0x00	/* Color delay is 0 
+							   clks */
+#define ADV7343_HD_MODE_REG4_DEFAULT		0xE8	/* Changed */
+#define ADV7343_HD_MODE_REG5_DEFAULT		0x08
+#define ADV7343_HD_MODE_REG6_DEFAULT		0x00
+#define ADV7343_HD_MODE_REG7_DEFAULT		0x00
+
+#define ADV7343_SD_MODE_REG1_DEFAULT		0x00
+#define ADV7343_SD_MODE_REG2_DEFAULT		0xC9	/* Changed */
+#define ADV7343_SD_MODE_REG3_DEFAULT		0x10	/* Changed */
+#define ADV7343_SD_MODE_REG4_DEFAULT		0x01
+#define ADV7343_SD_MODE_REG5_DEFAULT		0x02
+#define ADV7343_SD_MODE_REG6_DEFAULT		0x0C	/*0x00 */
+#define ADV7343_SD_MODE_REG7_DEFAULT		0x04
+#define ADV7343_SD_MODE_REG8_DEFAULT		0x00
+#define ADV7343_SD_TIMING_REG0_DEFAULT		0x08
+#define ADV7343_SD_TIMING_REG1_DEFAULT		0x00
+#define ADV7343_SOFT_RESET_DEFAULT		0x02
+#define ADV7343_COMPOSITE_POWER_VALUE		0x80
+#define ADV7343_COMPONENT_POWER_VALUE		0x1C
+#define ADV7343_SVIDEO_POWER_VALUE		0x60
+#define ADV7343_SD_HUE_REG_DEFAULT		127
+#define ADV7343_SD_BRIGHTNESS_WSS_DEFAULT	0x03
+#define ADV7343_SD_CGMS_WSS0_DEFAULT		0x10
+
+#define ADV7343_SLICED_BUF_SIZE			256
+#define ADV7343_SERVICE_LINES_SIZE		(2*24*2)
+
+/* Macros for the Mode Select Register */
+#ifdef GENERATE_MASK
+#undef GENERATE_MASK
+#endif
+#define GENERATE_MASK(bits, pos)		((((0xFF) << (8-bits)) >> \
+		(8-bits)) << pos)
+
+/* Bit masks for Mode Select Register */
+#define YC_Y_BUS				0x80
+#define YC_S_BUS				0x7F
+#define INPUT_MODE_MASK				0x70
+#define SD_INPUT_MODE				0x00
+#define HD_720P_INPUT_MODE			0x10
+#define HD_1080I_INPUT_MODE			0x10
+#define HD_DDR_INPUT_MODE			0x20
+#define SD_HD_SDR_INPUT_MODE			0x30
+#define SD_HD_DDR_INPUT_MODE			0x40
+#define ED_INPUT_MODE				0x70
+
+/* Bit masks for Mode Register 0 */
+#define TEST_PATTERN_BLACK_BAR_EN		0x04
+#define TEST_PATTERN_BLACK_BAR_DI		0xFB
+#define YUV_OUTPUT_SELECT			0x20
+#define RGB_OUTPUT_SELECT			0xDF
+#define SD_SYNC_OUTPUT_EN			0x40
+#define SD_SYNC_OUTPUT_DI			0xBF
+#define HD_SYNC_OUTPUT_EN			0x80
+#define HD_SYNC_OUTPUT_DI			0x7F
+#define CSC_MATRIX_EN				0x08
+#define CSC_MATRIX_DI				0xF7
+
+/* Bit masks for CSC matrices */
+#define CSC_LSB_MASK				0x03
+#define CSC_MSB_MASK				0xFF
+#define CSC_SHIFT				2
+#define CSC_MATRIX_MASK				0x3FF
+
+/* Bit masks for DAC output levels */
+#define DAC_OUTPUT_LEVEL_MASK			0xFF
+#define POSITIVE_GAIN_MAX			0x40
+#define POSITIVE_GAIN_MIN			0x00
+#define NEGATIVE_GAIN_MAX			0xFF
+#define NEGATIVE_GAIN_MIN			0xC0
+
+/* Bit masks for soft reset register */
+#define SOFT_RESET				0x02
+
+/* Bit masks for HD Mode Register 1 */
+#define OUTPUT_STD_MASK				0x03
+#define OUTPUT_STD_SHIFT			0
+#define OUTPUT_STD_EIA0_2			0x00
+#define OUTPUT_STD_EIA0_1			0x01
+#define OUTPUT_STD_FULL				0x02
+#define EMBEDDED_SYNC				0x04
+#define EXTERNAL_SYNC				0xFB
+#define STD_MODE_SHIFT				3
+#define STD_MODE_MASK				0x1F
+#define STD_MODE_720P				0x05
+#define STD_MODE_720P_25			0x08
+#define STD_MODE_720P_30			0x07
+#define STD_MODE_720P_50			0x06
+#define STD_MODE_1080I				0x0D
+#define STD_MODE_1080I_25fps			0x0E
+#define STD_MODE_1080P_24			0x12
+#define STD_MODE_1080P_25			0x10
+#define STD_MODE_1080P_30			0x0F
+#define STD_MODE_525P				0x00
+#define STD_MODE_625P				0x03
+
+/* Bit masks for HD Mode Register 2 */
+#define HD_PIXEL_DATA_VALID			0x01
+#define HD_TEST_PATTERN_EN			0x04
+#define HD_TEST_PATTERN_DI			0xFB
+#define HD_TEST_PATTERN_HATCH			0xF7
+#define HD_TEST_PATTERN_FRAME			0x08
+#define HD_VBI_EN				0x10
+#define HD_VBI_DI				0xEF
+#define HD_UNDERSHOOTER_DI			0x9F
+#define HD_UNDERSHOOTER_11IRE			0x20
+#define HD_UNDERSHOOTER_6IRE			0x40
+#define HD_UNDERSHOOTER_1_5IRE			0x60
+#define HD_SHARPNESS_FLTR_EN			0x80
+#define HD_SHARPNESS_FLTR_DI			0x7F
+
+/* Bit masks for HD Mode Register 3 */
+#define HD_HSYNC_Y_DELAY_SHIFT			0
+#define HD_HSYNC_Y_DELAY_MASK			0x07
+#define HD_HSYNC_C_DELAY_SHIFT			3
+#define HD_HSYNC_C_DELAY_MASK			0x38
+#define HD_CGMS_EN				0x40
+#define HD_CGMS_DI				0xBF
+#define HD_CGMS_CRC_EN				0x80
+#define HD_CGMS_CRC_DI				0x7F
+
+/* Bit masks for HD Mode Register 4 */
+#define HD_HSYNC_CR				0x01
+#define HD_HSYNC_CB				0xFE
+#define HD_SYNC_FLTR_EN				0x08
+#define HD_SYNC_FLTR_DI				0xF7
+#define HD_CHROMA_SSAF_EN			0x20
+#define HD_CHROMA_SSAF_DI			0xDF
+#define HD_CHROMA_INPUT_422			0x40
+#define HD_CHROMA_INPUT_444			0xBF
+#define HD_DOUBLE_BUFFERING_EN			0x80
+#define HD_DOUBLE_BUFFERING_DI			0x7F
+
+/* Bit masks for HD Mode Register 5 */
+#define HD_MACROVISION_EN			0x10
+#define HD_MACROVISION_DI			0xEF
+
+/* Bit masks for HD Mode Register 6 */
+#define HD_RGB_INPUT_EN				0x02
+#define HD_RGB_INPUT_DI				0xFD
+#define HD_PBPR_SYNC_EN				0x04
+#define HD_PBPR_SYNC_DI				0xFB
+#define HD_DAC_SWAP_EN				0x08
+#define HD_DAC_SWAP_DI				0xF7
+#define HD_GAMMA_CURVE_A			0xEF
+#define HD_GAMMA_CURVE_B			0x10
+#define HD_GAMMA_EN				0x20
+#define HD_GAMMA_DI				0xDF
+#define HD_ADPT_FLTR_MODEB			0x40
+#define HD_ADPT_FLTR_MODEA			0xBF
+#define HD_ADPT_FLTR_EN				0x80
+#define HD_ADPT_FLTR_DI				0x7F
+
+/* Bit masks for HD Sharpness filter */
+#define HD_SHARPNESS_FLTR_A_SHIFT		0
+#define HD_SHARPNESS_FLTR_A_MASK		0x0F
+#define HD_SHARPNESS_FLTR_B_SHIFT		4
+#define HD_SHARPNESS_FLTR_B_MASK		0x0F
+
+#define GAMMA_MASK				0xFF
+
+#define HD_ADPT_FLTR_GAIN_A_SHIFT		0
+#define HD_ADPT_FLTR_GAIN_A_MASK		0x0F
+#define HD_ADPT_FLTR_GAIN_B_SHIFT		4
+#define HD_ADPT_FLTR_GAIN_B_MASK		0x0F
+#define HD_ADPT_FLTR_THRLD_MASK			0xFF
+
+/* Bit masks for SD Mode Register 1 */
+#define SD_STD_MASK				0x03
+#define SD_STD_NTSC				0x00
+#define SD_STD_PAL_BDGHI			0x01
+#define SD_STD_PAL_M				0x02
+#define SD_STD_PAL_N				0x03
+#define SD_LUMA_FLTR_MASK			0x7
+#define SD_LUMA_FLTR_SHIFT			0x2
+#define SD_CHROMA_FLTR_MASK			0x7
+#define SD_CHROMA_FLTR_SHIFT			0x5
+
+/* Bit masks for SD Mode Register 2 */
+#define SD_PBPR_SSAF_EN				0x01
+#define SD_PBPR_SSAF_DI				0xFE
+#define SD_DAC_1_DI				0xFD
+#define SD_DAC_2_DI				0xFB
+#define SD_PEDESTAL_EN				0x08
+#define SD_PEDESTAL_DI				0xF7
+#define SD_SQUARE_PIXEL_EN			0x10
+#define SD_SQUARE_PIXEL_DI			0xEF
+#define SD_PIXEL_DATA_VALID			0x40
+#define SD_ACTIVE_EDGE_EN			0x80
+#define SD_ACTIVE_EDGE_DI			0x7F
+
+/* Bit masks for SD Mode Register 3 */
+#define SD_CLOSE_CAPTION_DI			0x9F
+#define SD_CLOSE_CAPTION_EVEN			0x40
+#define SD_CLOSE_CAPTION_ODD			0x20
+#define SD_CLOSE_CAPTION_BOTH			0x60
+#define SD_VBI_EN				0x10
+#define SD_VBI_DI				0xEF
+#define SD_PEDESTAL_YPBPR_EN			0X01
+#define SD_PEDESTAL_YPBPR_DI			0xFE
+
+/* Bit masks for SD Mode Register 4 */
+#define SD_CHROMA_EN				0x10
+#define SD_CHROMA_DI				0xEF
+#define SD_BURST_EN				0x20
+#define SD_BURST_DI				0xDF
+#define SD_COLOR_BARS_EN			0x40
+#define SD_COLOR_BARS_DI			0xBF
+
+/* Bit masks for SD Mode Register 6 */
+#define SD_PBPR_SCALE_EN			0x01
+#define SD_PBPR_SCALE_DI			0xFE
+#define SD_Y_SCALE_EN				0x02
+#define SD_Y_SCALE_DI				0xFD
+#define SD_HUE_ADJST_EN				0x04
+#define SD_HUE_ADJST_DI				0xFB
+#define SD_BRIGHTNESS_EN			0x08
+#define SD_BRIGHTNESS_DI			0xF7
+#define SD_LUMA_SSAF_GAIN_EN			0x10
+#define SD_LUMA_SSAF_GAIN_DI			0xEF
+#define SD_AUTO_DETECT_EN			0x40
+#define SD_AUTO_DETECT_DI			0xBF
+#define SD_RGB_INPUT_EN				0x80
+#define SD_RGB_INPUT_DI				0x7F
+
+/* Bit masks for SD Mode Register 7 */
+#define SD_NON_INTERLACED_EN			0x02
+#define SD_NON_INTERLACED_DI			0xFD
+#define SD_DOUBLE_BUFFERING_EN			0x04
+#define SD_DOUBLE_BUFFERING_DI			0xFB
+#define SD_DNR_EN				0x20
+#define SD_DNR_DI				0xDF
+#define SD_GAMMA_EN				0x40
+#define SD_GAMMA_DI				0xBF
+#define SD_GAMMA_CURVE_B			0x80
+#define SD_GAMMA_CURVE_A			0x7F
+#define SD_INPUT_FORMAT_8BIT			0x00
+#define SD_INPUT_FORMAT_16BIT			0x08
+
+/* Bit masks for SD Timing Register 0 */
+#define SD_MASTER_MODE				0x01
+#define SD_SLAVE_MODE				0xFE
+#define SD_TIMING_MODE_SHIFT			1
+#define SD_TIMING_MODE_MASK			0x03
+#define SD_TIMING_MODE0				0xFC
+#define SD_TIMING_MODE1				0x01
+#define SD_TIMING_MODE2				0x02
+#define SD_TIMING_MODE3				0x03
+#define SD_LUMA_DELAY				0
+#define SD_MIN_LUMA_VAL_7_5IRE			0x40
+#define SD_MIN_LUMA_VAL_40IRE			0xBF
+#define SD_TIMING_RESET				0x80
+
+/* Macros for Timing Mode Register 1 */
+#define SD_HSYNC_DELAY				0
+#define SD_HSYNC2VSYNC_DELAY			0
+#define SD_HSYNC2DATA_DELAY			0
+#define SD_HSYNC2PIXELDATA_ADJUST		0
+
+#define SD_FSC_REG_MASK				0xFF
+#define SD_CLOSED_CAPT_MASK			0xFF
+#define SD_PEDESTAL_MASK			0xFF
+
+#define SD_CGMS_CRC_EN				0x10
+#define SD_CGMS_CRC_DI				0xEF
+#define SD_CGMS_EN				0x60
+#define SD_CGMS_ODD_FIELD_EN			0x20
+#define SD_CGMS_ODD_FIELD_DI			0xDF
+#define SD_CGMS_EVEN_FIELD_EN			0x40
+#define SD_CGMS_EVEN_FIELD_DI			0xBF
+#define SD_CGMS_DI				0x9F
+#define SD_WSS_EN				0x80
+#define SD_WSS_DI				0x7F
+
+#define SD_BRIGHTNESS_MASK			0x7F
+
+#define SD_DNR_BORDER_GAIN_MASK			0x0F
+#define SD_DNR_BORDER_GAIN_SHIFT		0x0
+#define SD_DNR_DATA_GAIN_MASK			0x0F
+#define SD_DNR_DATA_GAIN_SHIFT			0x4
+
+#define SD_DNR_THRESHOLD_MASK			0x3F
+#define SD_DNR_THRESHOLD_MAX			0x3F
+#define SD_BORDER_AREA_4PIXELS			0x40
+#define SD_BORDER_AREA_2PIXELS			0xBF
+#define SD_BLOCK_SIZE_16x16			0x80
+#define SD_BLOCK_SIZE_8x8			0x7F
+#define SD_DNR_INPUT_SELECT_MASK		0x07
+#define SD_DNR_SHARPNESS_MODE			0x08
+#define SD_DNR_MODE				0xF7
+#define SD_DNR_BLOCK_OFFSET_MASK		0x0F
+#define SD_DNR_BLOCK_OFFSET_SHIFT		0x04
+#define SD_DNR_GAIN_MAX				0x08
+
+#define SD_YPBPR_SCALE_SHIFT			0x02
+#define SD_YPBPR_SCALE_LMASK			0x03
+#define SD_YPBPR_SCALE_HMASK			0x3FC
+#define SD_YPBPR_SCALE_MASK			0x3FF
+
+#define SD_LUMA_SSAF_GAIN_MAX			0x0C
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef ADV7343_H */
Index: linux-2.6.10/include/media/davinci/davincihd_capture.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davincihd_capture.h
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_capture.h */
+
+#ifndef DAVINCIHD_CAPTURE_H
+#define DAVINCIHD_CAPTURE_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/video-buf.h>
+#include <media/davinci/vid_decoder_if.h>
+#include <media/davinci/vpif.h>
+
+#define VPIF_CAPTURE_NUM_DECODERS        4
+
+/* Macros */
+#define VPIF_MAJOR_RELEASE              0
+#define VPIF_MINOR_RELEASE              0
+#define VPIF_BUILD                      1
+#define VPIF_CAPTURE_VERSION_CODE       ((VPIF_MAJOR_RELEASE<<16) | \
+	(VPIF_MINOR_RELEASE<<8)  | \
+	VPIF_BUILD)
+
+#define VPIF_VALID_FIELD(field)         (((V4L2_FIELD_ANY == field) || \
+	(V4L2_FIELD_NONE == field)) || \
+	(((V4L2_FIELD_INTERLACED == field) || \
+	(V4L2_FIELD_SEQ_TB == field)) || \
+	(V4L2_FIELD_SEQ_BT == field)))
+
+#define VPIF_VALID_BUFFER_TYPE(buftype)	{ \
+			(V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_VBI_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_HBI_CAPTURE == buftype)}
+
+#define VPIF_CAPTURE_MAX_DEVICES	2
+#define VPIF_MAX_DECODER_STD		50
+#define VPIF_TIMER_COUNT		5
+#define VPIF_SLICED_BUF_SIZE		256
+#define VPIF_SLICED_MAX_SERVICES	3
+#define VPIF_HBI_INDEX			2
+#define VPIF_VBI_INDEX			1
+#define VPIF_VIDEO_INDEX		0
+
+#define VPIF_NUMBER_OF_OBJECTS		3
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+#define ISDECODERCMD(cmd)       ((VPIF_CMD_S_DECODER_PARAMS==cmd) || \
+                                        (VPIF_CMD_G_DECODER_PARAMS==cmd))
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpif_channel_id {
+	VPIF_CHANNEL0_VIDEO = 0,	/* Channel0 Video */
+	VPIF_CHANNEL1_VIDEO,	/* Channel1 Video */
+};
+
+/* structures */
+/* Table to keep track of the standards supported in all the decoders */
+struct vpif_decoder_std_tbl {
+	u8 dec_idx;
+	u8 std_idx;
+	v4l2_std_id std;
+};
+
+struct video_obj {
+	v4l2_std_id std;	/* Currently selected or default
+				   standard */
+	enum v4l2_field buf_field;
+
+	u32 latest_only;	/* indicate whether to return
+				   most recent displayed frame
+				   only */
+	struct vpif_stdinfo std_info;	/*Keeps track of the information
+					   about the standard */
+	u32 input_idx;		/* This is to track the last
+				   input that is passed to 
+				   application */
+	struct vpif_decoder_std_tbl std_tbl[VPIF_MAX_DECODER_STD];
+	int count_std;
+};
+
+struct vbi_obj {
+	u8 timer_counter;	/* Counter to synchronize 
+				   access to the timer */
+	struct tasklet_struct vbi_tasklet;	/* An object of tasklets 
+						   structure which is used 
+						   for read  sliced vbi data 
+						   from decoders */
+	u8 num_services;
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	u8 *fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   v4l2_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   v4l2_buffer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism 
+					   user has selected */
+	struct v4l2_format fmt;	/* Used to store pixel format */
+
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* channel specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u8 started;		/* Indicates whether streaming
+				   started */
+	void (*set_addr) (unsigned long, unsigned long, unsigned long, unsigned long);	/* Function pointer to set 
+											   the addresses */
+	u32 ytop_off;		/* offset where Y top starts
+				   from the starting of the
+				   buffer */
+	u32 ybtm_off;		/* offset where Y bottom starts
+				   from the starting of the
+				   buffer */
+	u32 ctop_off;		/* offset where C top starts
+				   from the starting of the
+				   buffer */
+	u32 cbtm_off;		/* offset where C bottom starts
+				   from the starting of the
+				   buffer */
+	u32 width;		/* Indicates width of the image 
+				   data or width of the vbi data */
+	u32 height;		/* Indicates height of the image 
+				   data or height of the vbi data */
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this channel */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	u32 usrs;		/* number of open instances of
+				   the channel */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+	u8 initialized;		/* flag to indicate whether
+				   decoder is initialized */
+
+	enum vpif_channel_id channel_id;	/* Identifies channel */
+
+	struct decoder_device *decoder[VPIF_CAPTURE_NUM_DECODERS];
+	/* pointer to decoder device
+	   structures for this channel */
+	u8 numdecoders;		/* indicates number of decoders
+				   registered to VPIF-V4L2 */
+	u8 current_decoder;	/* Index of the currently
+				   selected decoder */
+	u8 default_decoder;	/* Index of the defalut decoder,
+				   set as per boot args at 
+				   channel creation time */
+	struct vpif_params vpifparams;
+	struct common_obj common[VPIF_NUMBER_OF_OBJECTS];
+	struct video_obj video;
+	struct vbi_obj vbi;
+};
+
+/* File handle structure */
+struct vpif_fh {
+	struct channel_obj *channel;	/* pointer to channel object for
+					   opened device */
+	u8 io_allowed[VPIF_NUMBER_OF_OBJECTS];	/* Indicates whether this 
+						   file handle is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+	u8 initialized;		/* Used to indicate channel is 
+				   initialize or not */
+};
+
+/* vpif device structure */
+struct vpif_device {
+	struct channel_obj *dev[VPIF_CAPTURE_NUM_CHANNELS];
+};
+
+struct vpif_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[VPIF_CAPTURE_NUM_CHANNELS];
+	s8 device_type;
+	u32 min_bufsize[VPIF_CAPTURE_NUM_CHANNELS];
+	u32 channel_bufsize[VPIF_CAPTURE_NUM_CHANNELS];
+	u8 default_device[VPIF_CAPTURE_NUM_CHANNELS];
+	u8 max_device_type;
+};
+/* Struct which keeps track of the line numbers for the sliced vbi service */
+struct vpif_service_line {
+	u16 service_id;
+	u16 service_line[2];
+};
+#endif				/* End of __KERNEL__ */
+
+/* IOCTLs */
+#define VPIF_S_VPIF_PARAMS   _IOW('V', BASE_VIDIOC_PRIVATE+1, \
+					struct vpif_params)
+#define VPIF_G_VPIF_PARAMS   _IOR('V', BASE_VIDIOC_PRIVATE+2, \
+					struct vpif_params)
+#define VPFE_S_MT9T001_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE+3, \
+					void *)
+#define VPFE_G_MT9T001_PARAMS _IOR('V', BASE_VIDIOC_PRIVATE+4, \
+					void *)
+#define VPFE_CMD_CONFIG_TVP5146 _IOW('V',BASE_VIDIOC_PRIVATE + 5, \
+					void *)
+#define VPIF_CMD_G_DECODER_PARAMS _IOR('V',BASE_VIDIOC_PRIVATE+8, \
+					void *)
+#define VPIF_CMD_S_DECODER_PARAMS _IOW('V',BASE_VIDIOC_PRIVATE+9, \
+					void *)
+
+#endif				/* DAVINCIHD_CAPTURE_H */
Index: linux-2.6.10/include/media/davinci/davincihd_display.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davincihd_display.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_display_new.h */
+
+#ifndef DAVINCIHD_DISPLAY_H
+#define DAVINCIHD_DISPLAY_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/video-buf.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/vpif.h>
+#endif
+
+#ifdef __KERNEL__
+
+/* Macros */
+#define VPIF_MAJOR_RELEASE              0
+#define VPIF_MINOR_RELEASE              0
+#define VPIF_BUILD                      1
+#define VPIF_DISPLAY_VERSION_CODE       ((VPIF_MAJOR_RELEASE<<16) | \
+	(VPIF_MINOR_RELEASE<<8)  | \
+	VPIF_BUILD)
+
+#define VPIF_VALID_FIELD(field)         (((V4L2_FIELD_ANY == field) || \
+	(V4L2_FIELD_NONE == field)) || \
+	(((V4L2_FIELD_INTERLACED == field) || \
+	(V4L2_FIELD_SEQ_TB == field)) || \
+	(V4L2_FIELD_SEQ_BT == field)))
+
+#define VPIF_DISPLAY_MAX_DEVICES        2
+#define VPIF_SLICED_BUF_SIZE 	 	256
+#define VPIF_SLICED_MAX_SERVICES	3
+#define VPIF_VIDEO_INDEX                0
+#define VPIF_VBI_INDEX			1
+#define VPIF_HBI_INDEX			2
+
+#define VPIF_NUMOBJECTS			3
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpif_channel_id {
+	VPIF_CHANNEL2_VIDEO = 0,	/* Channel2 Video */
+	VPIF_CHANNEL3_VIDEO,	/* Channel3 Video */
+};
+
+/* structures */
+
+struct video_obj {
+	struct vid_enc_mode_info mode_info;
+	enum v4l2_field buf_field;
+
+	u32 latest_only;	/* indicate whether to return
+				   most recent displayed frame
+				   only */
+	struct vpif_stdinfo std_info;	/*Keeps track of the information
+					   about the standard */
+};
+
+struct vbi_obj {
+	struct vpif_vbi_params vbiparams;	/* Structure storing 
+						   vpif parameters
+						   for the raw vbi data */
+	int num_services;
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	u8 *fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   videobuf_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   videobuf_buffer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism 
+					   user has selected */
+	struct v4l2_format fmt;	/* Used to store the format */
+
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* channel specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u8 started;		/* Indicates whether streaming
+				   started */
+
+	u32 ytop_off;		/* offset where Y top starts
+				   from the starting of the
+				   buffer */
+	u32 ybtm_off;		/* offset where Y bottom starts
+				   from the starting of the
+				   buffer */
+	u32 ctop_off;		/* offset where C top starts
+				   from the starting of the
+				   buffer */
+	u32 cbtm_off;		/* offset where C bottom starts
+				   from the starting of the
+				   buffer */
+	void (*set_addr) (unsigned long, unsigned long, unsigned long, unsigned long);	/* Function pointer to set 
+											   the addresses */
+	u32 height;
+	u32 width;
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this channel */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	u32 usrs;		/* number of open instances of
+				   the channel */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+	u8 initialized;		/* flag to indicate whether
+				   encoder is initialized */
+
+	enum vpif_channel_id channel_id;	/* Identifies channel */
+
+	struct vpif_params vpifparams;
+	struct common_obj common[VPIF_NUMOBJECTS];
+	struct video_obj video;
+	struct vbi_obj vbi;
+};
+
+/* File handle structure */
+struct vpif_fh {
+	struct channel_obj *channel;	/* pointer to channel object for
+					   opened device */
+	u8 io_allowed[VPIF_NUMOBJECTS];	/* Indicates whether this file handle
+					   is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+	u8 initialized;		/* Used to keep track of whether this 
+				   file handle has initialized 
+				   channel or not */
+};
+
+/* vpif device structure */
+struct vpif_device {
+	struct channel_obj *dev[VPIF_DISPLAY_NUM_CHANNELS];
+};
+
+struct vpif_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[VPIF_DISPLAY_NUM_CHANNELS];
+	u32 min_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+	u32 channel_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+};
+
+/* Struct which keeps track of the line numbers for the sliced vbi service */
+struct vpif_service_line {
+	u16 service_id;
+	u16 service_line[2];
+	u16 enc_service_id;
+	u8 bytestowrite;
+};
+
+#endif				/* End of __KERNEL__ */
+
+/* IOCTLs */
+
+#define VPIF_S_VPIF_PARAMS   _IOW('V', BASE_VIDIOC_PRIVATE+1, \
+					struct vpif_params)
+#define VPIF_G_VPIF_PARAMS   _IOR('V', BASE_VIDIOC_PRIVATE+2, \
+					struct vpif_params)
+
+#define VPIF_CMD_S_ENCODER_PARAMS _IOW('V',BASE_VIDIOC_PRIVATE+12, \
+					void *)
+#define VPIF_CMD_G_ENCODER_PARAMS _IOR('V',BASE_VIDIOC_PRIVATE+13, \
+					void *)
+
+#ifdef __KERNEL__
+#define ISENCODERCMD(cmd)	((VPIF_CMD_S_ENCODER_PARAMS==cmd) || \
+					(VPIF_CMD_G_ENCODER_PARAMS==cmd))
+#endif
+
+#endif				/* DAVINCIHD_DISPLAY_H */
Index: linux-2.6.10/include/media/davinci/tvp5147.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/tvp5147.h
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp5147.h file */
+
+#ifndef TVP5147_H
+#define TVP5147_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/davinci/vid_decoder_if.h>
+
+#endif				/* __KERNEL__ */
+
+#define VPFE_STD_625_50_SQP ((v4l2_std_id)0x0000000100000000ULL)
+#define VPFE_STD_525_60_SQP ((v4l2_std_id)0x0000000200000000ULL)
+#define VPFE_STD_AUTO       ((v4l2_std_id)0x0000000400000000ULL)
+#define VPFE_STD_AUTO_SQP   ((v4l2_std_id)0x0000000800000000ULL)
+
+#define V4L2_STD_TVP5147_ALL         (V4L2_STD_525_60 | V4L2_STD_625_50 |\
+	VPFE_STD_AUTO | VPFE_STD_625_50_SQP |\
+	VPFE_STD_525_60_SQP | VPFE_STD_AUTO_SQP)
+
+typedef struct {
+	v4l2_std_id std;
+	int inputidx;
+	struct v4l2_format fmt;
+} tvp5147_params;
+
+#ifdef __KERNEL__
+
+#define TVP5147_NUM_CHANNELS                    2
+
+#define TVP5147_MAX_VBI_SERVICES		2	/* This gives maximum 
+							   number of VBI service 
+							   supported */
+
+typedef enum {
+	TVP5147_MODE_INV = -1,
+	TVP5147_MODE_AUTO = 0,	/* autoswitch mode (default)   */
+	TVP5147_MODE_NTSC = 1,	/* (M, J) NTSC      525-line   */
+	TVP5147_MODE_PAL = 2,	/* (B, D, G, H, I, N) PAL      */
+	TVP5147_MODE_PAL_M = 3,	/* (M) PAL          525-line   */
+	TVP5147_MODE_PAL_CN = 4,	/* (Combination-N) PAL         */
+	TVP5147_MODE_NTSC_443 = 5,	/* NTSC 4.43        525-line   */
+	TVP5147_MODE_SECAM = 6,	/* SECAM                       */
+	TVP5147_MODE_PAL_60 = 7,	/* PAL 60          525-line    */
+	TVP5147_MODE_AUTO_SQP = 8,	/* autoswitch mode (default)   */
+	TVP5147_MODE_NTSC_SQP = 9,	/* (M, J) NTSC      525-line   */
+	TVP5147_MODE_PAL_SQP = 0xA,	/* (B, D, G, H, I, N) PAL      */
+	TVP5147_MODE_PAL_M_SQP = 0xB,	/* (M) PAL          525-line   */
+	TVP5147_MODE_PAL_CN_SQP = 0xC,	/* (Combination-N) PAL         */
+	TVP5147_MODE_NTSC_443_SQP = 0xD,	/* NTSC 4.43 525-line          */
+	TVP5147_MODE_SECAM_SQP = 0xE,	/* SECAM                       */
+	TVP5147_MODE_PAL_60_SQP = 0xF,	/* PAL 60          525-line    */
+} tvp5147_mode;
+
+/* decoder standard related strctures */
+#define TVP5147_MAX_NO_INPUTS           (1)
+#define TVP5147_MAX_NO_STANDARDS        (6)
+#define TVP5147_MAX_NO_CONTROLS         (5)
+/* for AUTO mode, stdinfo structure will not be filled */
+#define TVP5147_STANDARD_INFO_SIZE      (TVP5147_MAX_NO_STANDARDS - 2)
+
+#define TVP5147_MAX_NO_MODES           (3)
+
+struct tvp5147_control_info {
+	int register_address;
+	struct v4l2_queryctrl query_control;
+};
+
+struct tvp5147_config {
+	int no_of_inputs;
+	struct {
+		int input_type;
+		u8 lock_mask;
+		struct v4l2_input input_info;
+		int no_of_standard;
+		struct v4l2_standard *standard;
+		v4l2_std_id def_std;
+		 tvp5147_mode(*mode)[TVP5147_MAX_NO_MODES];
+		int no_of_controls;
+		struct tvp5147_control_info *controls;
+	} input[TVP5147_MAX_NO_INPUTS];
+	struct v4l2_sliced_vbi_cap sliced_cap;
+	u8 num_services;
+};
+
+struct tvp5147_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u32 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct decoder_device *dec_device;
+	tvp5147_params params;
+};
+
+struct tvp5147_service_data_reg {
+	u32 service;
+	struct {
+		u8 addr[3];
+	} field[2];
+	u8 bytestoread;
+};
+
+struct tvp5147_sliced_reg {
+	u32 service;
+	u8 line_addr_value;
+	u16 line_start, line_end;
+	struct {
+		u8 fifo_line_addr[3];
+		u8 fifo_mode_value;
+	} field[2];
+	v4l2_std_id std;
+	struct {
+		u8 index;
+		u16 value;
+	} service_line[2];
+};
+
+/* Defines for TVP5147 register address */
+
+#define TVP5147_INPUT_SEL                                       (0x00)
+#define TVP5147_AFE_GAIN_CTRL                                   (0x01)
+#define TVP5147_VIDEO_STD                                       (0x02)
+#define TVP5147_OPERATION_MODE                                  (0x03)
+#define TVP5147_AUTOSWT_MASK                                    (0x04)
+#define TVP5147_COLOR_KILLER                                    (0x05)
+#define TVP5147_LUMA_CONTROL1                                   (0x06)
+#define TVP5147_LUMA_CONTROL2                                   (0x07)
+#define TVP5147_LUMA_CONTROL3                                   (0x08)
+#define TVP5147_BRIGHTNESS                                      (0x09)
+#define TVP5147_CONTRAST                                        (0x0A)
+#define TVP5147_SATURATION                                      (0x0B)
+#define TVP5147_HUE                                             (0x0C)
+#define TVP5147_CHROMA_CONTROL1                                 (0x0D)
+#define TVP5147_CHROMA_CONTROL2                                 (0x0E)
+#define TVP5147_OUTPUT1                                         (0x33)
+#define TVP5147_OUTPUT2                                         (0x34)
+#define TVP5147_OUTPUT3                                         (0x35)
+#define TVP5147_OUTPUT4                                         (0x36)
+#define TVP5147_OUTPUT5                                         (0x37)
+#define TVP5147_OUTPUT6                                         (0x38)
+#define TVP5147_CLEAR_LOST_LOCK                                 (0x39)
+#define TVP5147_STATUS1                                         (0x3A)
+#define TVP5147_VID_STD_STATUS                                  (0x3F)
+#define TVP5147_FIFO_OUTPUT_CTRL				(0xC0)
+
+/* masks */
+
+#define TVP5147_LOST_LOCK_MASK                                  (0x10)
+/* mask to enable autoswitch for all standards*/
+
+#define TVP5147_AUTOSWITCH_MASK                                 (0x7F)
+#define TVP5147_COMPOSITE_INPUT                                 (0x05)
+#define TVP5147_SVIDEO_INPUT                                    (0x46)
+
+/* DEFAULTS */
+
+#define TVP5147_OPERATION_MODE_RESET				(0x1)
+#define TVP5147_OPERATION_MODE_DEFAULT                          (0x0)
+#define TVP5147_AFE_GAIN_CTRL_DEFAULT                           (0x0F)
+#define TVP5147_COLOR_KILLER_DEFAULT                            (0x10)
+#define TVP5147_LUMA_CONTROL1_DEFAULT                           (0x10)
+#define TVP5147_LUMA_CONTROL2_DEFAULT                           (0x00)
+#define TVP5147_LUMA_CONTROL3_DEFAULT                           (0x02)
+#define TVP5147_BRIGHTNESS_DEFAULT                              (0x80)
+#define TVP5147_CONTRAST_DEFAULT                                (0x80)
+#define TVP5147_SATURATION_DEFAULT                              (0x80)
+#define TVP5147_HUE_DEFAULT                                     (0x00)
+#define TVP5147_CHROMA_CONTROL1_DEFAULT                         (0x00)
+#define TVP5147_CHROMA_CONTROL2_DEFAULT                         (0x0E)
+#define TVP5147_OUTPUT1_DEFAULT					(0x40)
+#define TVP5147_OUTPUT2_DEFAULT					(0x11)
+#define TVP5147_OUTPUT3_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT4_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT5_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT6_DEFAULT					(0xFF)
+#define TVP5147_FIFO_OUTPUT_CTRL_DEFAULT			(0x01)
+
+#define TVP5147_VBUS_ADDRESS_ACCESS0				(0xE8)
+#define TVP5147_VBUS_ADDRESS_ACCESS1				(0xE9)
+#define TVP5147_VBUS_ADDRESS_ACCESS2				(0xEA)
+#define TVP5147_VBUS_DATA_ACCESS				(0xE0)
+#define TVP5147_VBUS_DATA_ACCESS_AUTO_INCR			(0xE1)
+
+#define TVP5147_LINE_ADDRESS_START				(0x80)
+#define TVP5147_LINE_ADDRESS_MIDDLE				(0x06)
+#define TVP5147_LINE_ADDRESS_END				(0x00)
+
+#define TVP5147_LINE_ADDRESS_DEFAULT				(0x00)
+#define TVP5147_LINE_MODE_DEFAULT				(0xFF)
+
+#define TVP5147_VDP_LINE_START					(0xD6)
+#define TVP5147_VDP_LINE_STOP					(0xD7)
+
+#define TVP5147_VBI_NUM_SERVICES				(3)
+#define TVP5147_SLICED_BUF_SIZE					(128)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* TVP5147_H */
Index: linux-2.6.10/include/media/davinci/tvp7002.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/tvp7002.h
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp7002.h file */
+#ifndef TVP7002_H
+#define TVP7002_H
+
+#ifdef __KERNEL__
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/davinci/vid_decoder_if.h>
+#endif				/* __KERNEL__ */
+
+#define V4L2_STD_TVP7002_ALL        (V4L2_STD_720P_60 | \
+					V4L2_STD_720P_50 | \
+					V4L2_STD_1080I_60 | \
+					V4L2_STD_1080I_50 | \
+					V4L2_STD_525P_60)
+
+/* enum */
+typedef enum {
+	TVP7002_MODE_480i_30FPS = 0,
+	TVP7002_MODE_576i_25FPS,
+	TVP7002_MODE_480p_30FPS,
+	TVP7002_MODE_576p_25FPS,
+	TVP7002_MODE_720p_30FPS,
+	TVP7002_MODE_1080i_30FPS,
+	TVP7002_MODE_1080p_30FPS,
+	TVP7002_MODE_1080i_25FPS
+} tvp7002_mode;
+
+typedef enum {
+	TVP7002_VCOEFF_1,
+	TVP7002_VCOEFF_2,
+	TVP7002_VCOEFF_4,
+	TVP7002_VCOEFF_8,
+	TVP7002_VCOEFF_16,
+	TVP7002_VCOEFF_32,
+	TVP7002_VCOEFF_64,
+	TVP7002_VCOEFF_128,
+	TVP7002_VCOEFF_256,
+	TVP7002_VCOEFF_512,
+	TVP7002_VCOEFF_1024
+} tvp7002_alc_vertical_coeff;
+
+typedef enum {
+	TVP7002_HCOEFF_2,
+	TVP7002_HCOEFF_4,
+	TVP7002_HCOEFF_8,
+	TVP7002_HCOEFF_16,
+	TVP7002_HCOEFF_32,
+	TVP7002_HCOEFF_64,
+	TVP7002_HCOEFF_128,
+	TVP7002_HCOEFF_256,
+	TVP7002_HCOEFF_512
+} tvp7002_alc_horizontal_coeff;
+
+typedef enum {
+	HPLL_POST_DIVIDE_1 = 0,
+	HPLL_POST_DIVIDE_2
+} tvp7002_post_divider;
+
+typedef enum {
+	VCO_GAIN_ULTRA_LOW = 0,
+	VCO_GAIN_LOW,
+	VCO_GAIN_MEDIUM,
+	VCO_GAIN_HIGH
+} tvp7002_vco_gain;
+
+typedef enum {
+	CP_CURRENT_SMALL,
+	CP_CURRENT_DEFAULT,
+	CP_CURRENT_LARGE
+} tvp7002_cp_current;
+
+/*structures*/
+
+struct alc_filter {
+	int alc_enable;
+	tvp7002_alc_vertical_coeff vcoeff;
+	tvp7002_alc_horizontal_coeff hcoeff;
+};
+
+struct tvp7002_format_params {
+	unsigned char hpll_divider_msb;
+	unsigned char hpll_divider_lsb;
+	tvp7002_vco_gain hpll_vco_control;
+	tvp7002_cp_current hpll_cp_current;
+	unsigned char hpll_phase_select;
+	tvp7002_post_divider hpll_post_divider;
+	unsigned char hpll_control;
+	unsigned char avid_start_msb;
+	unsigned char avid_start_lsb;
+	unsigned char avid_stop_msb;
+	unsigned char avid_stop_lsb;
+	unsigned char vblk_start_f0_line_offset;
+	unsigned char vblk_start_f1_line_offset;
+	unsigned char vblk_f0_duration;
+	unsigned char vblk_f1_duration;
+	unsigned char alc_placement;
+	unsigned char clamp_start, clamp_width;
+	unsigned char hpll_pre_coast;
+	unsigned char hpll_post_coast;
+	unsigned char reserved;
+};
+
+struct tvp7002_offset {
+	unsigned char blue_fine_offset;
+	unsigned char green_fine_offset;
+	unsigned char red_fine_offset;
+	unsigned char blue_fine_offset_lsb;
+	unsigned char green_fine_offset_lsb;
+	unsigned char red_fine_offset_lsb;
+	unsigned char blue_coarse_offset;
+	unsigned char green_coarse_offset;
+	unsigned char red_coarse_offset;
+};
+
+struct tvp7002_gain {
+	unsigned char blue_fine_gain;
+	unsigned char green_fine_gain;
+	unsigned char red_fine_gain;
+	unsigned char blue_coarse_gain;
+	unsigned char green_coarse_gain;
+	unsigned char red_coarse_gain;
+};
+
+typedef struct {
+	v4l2_std_id std;
+	int inputidx;
+	struct alc_filter alc;
+	struct tvp7002_gain gain;
+	struct tvp7002_offset offset;
+	struct tvp7002_format_params format;
+} tvp7002_params;
+
+#ifdef __KERNEL__
+
+#define TVP7002_NUM_CHANNELS                    1
+
+/* Macros */
+#define TVP7002_LINES_720       0x2EE
+#define TVP7002_LINES_1080_60   0x465
+#define TVP7002_LINES_1080_50   0x465
+#define TVP7002_CLOCKS_PER_LINE_1080_60 188
+#define TVP7002_CLOCKS_PER_LINE_1080_50 226
+
+#define INTERLACED_VIDEO                         (0)
+#define PROGRESSIVE_VIDEO                        (1)
+
+#define GENERATE_MASK(bits, pos) ((((0xFFFFFFFF) << (32-bits)) >> \
+		(32-bits)) << pos)
+
+/* Defines for input supported */
+#define TVP7002_HD (0)
+
+/* Macros for default register values */
+#define TVP7002_HPLL_MSB_DEFAULT                (0x67)
+#define TVP7002_HPLL_LSB_DEFAULT                (0x20)
+#define TVP7002_HPLL_CONTROL_DEFAULT            (0xA0)
+#define TVP7002_HPLL_PHASE_SEL_DEFAULT          (0x80)
+#define TVP7002_CLAMP_START_DEFAULT             (0x32)
+#define TVP7002_CLAMP_WIDTH_DEFAULT             (0x20)
+#define TVP7002_HSYNC_OUTWIDTH_DEFAULT          (0x60)
+#define TVP7002_BLUE_FINE_GAIN_DEFAULT          (0x00)
+#define TVP7002_GREEN_FINE_GAIN_DEFAULT         (0x00)
+#define TVP7002_RED_FINE_GAIN_DEFAULT           (0x00)
+#define TVP7002_BLUEF_OFFSETMSB_DEFAULT         (0x80)
+#define TVP7002_GREENF_OFFSETMSB_DEFAULT        (0x80)
+#define TVP7002_REDF_OFFSETMSB_DEFAULT          (0x80)
+#define TVP7002_SYNC_CONTROL1_DEFAULT           (0x20)
+#define TVP7002_HPLL_CLAMP_CTRL_DEFAULT         (0x2E)
+#define TVP7002_SYNC_GREEN_THLD_DEFAULT         (0x5D)
+#define TVP7002_SYNC_SEP_THLD_DEFAULT           (0x47)
+#define TVP7002_HPLL_PRE_COAST_DEFAULT          (0x00)
+#define TVP7002_HPLL_POST_COAST_DEFAULT         (0x00)
+#define TVP7002_OUTPUT_FORMATTER_DEFAULT        (0x47)
+#define TVP7002_MISC_CONTROL1_DEFAULT           (0x01)
+#define TVP7002_MISC_CONTROL2_DEFAULT           (0x00)
+#define TVP7002_MISC_CONTROL3_DEFAULT           (0x01)
+#define TVP7002_INPUT_MUX_SELECT1_DEFAULT       (0x00)
+#define TVP7002_INPUT_MUX_SELECT2_DEFAULT       (0x67)
+#define TVP7002_BLUE_GREEN_COARSE_GAIN_DEFAULT  (0x77)
+#define TVP7002_RED_COARSE_GAIN_DEFAULT         (0x07)
+#define TVP7002_FINE_OFFSET_LSBS_DEFAULT        (0x00)
+#define TVP7002_BLUE_COARSE_OFFSET_DEFUALT      (0x10)
+#define TVP7002_GREEN_COARSE_OFFSET_DEFAULT     (0x10)
+#define TVP7002_RED_COARSE_OFFSET_DEFAULT       (0x10)
+#define TVP7002_RED_COARSE_OFFSET_DEFAULT       (0x10)
+#define TVP7002_HSOUT_OUTPUT_START_DEFAULT      (0x08)
+#define TVP7002_MISC_CONTROL4_DEFAULT           (0x00)
+#define TVP7002_ALC_ENABLE_DEFAULT              (0x80)
+#define TVP7002_ALC_FILTER_DEFAULT              (0x53)
+#define TVP7002_FINE_CLAMP_CONTROL_DEFAULT      (0x07)
+#define TVP7002_POWER_CONTROL_DEFAULT           (0x00)
+#define TVP7002_ADC_SETUP_DEFAULT               (0x50)
+#define TVP7002_COARSE_CLAMP_CONTROL_DEFAULT    (0x00)
+#define TVP7002_SOG_CLAMP_DEFAULT               (0x80)
+#define TVP7002_ALC_PLACEMENT_DEFAULT           (0x5A)
+#define TVP7002_VSYNC_ALIGNMENT_DEFAULT         (0x10)
+#define TVP7002_SYNC_BYPASS_DEFAULT             (0x00)
+#define TVP7002_LINE_LENGTH_TOLERENCE_DEFAULT   (0x03)
+#define TVP7002_ADC_REF_SETUP_DEFAULT           (0x04)
+#define TVP7002_POWER_DOWN			(0x7F)
+#define TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT	(0x01)
+#define TVP7002_AVID_START_PIXEL_DEFAULT	(0x01)
+
+/* Macros for horizontal PLL */
+#define FEEDBACK_DIVIDER_MSB_720p               (0x67)
+#define FEEDBACK_DIVIDER_LSB_720p               (0x02)
+#define VCO_CONTROL_720p                        (0x02)
+#define CP_CURRENT_720p                         (0x04)
+#define PHASE_SELECT_720p                       (0x16)
+#define POST_DIVIDER_720p                       (0x0)
+#define HPLL_CONTROL_720p			(0xA0)
+#define AVID_START_PIXEL_LSB_720p		(0x47)
+#define AVID_START_PIXEL_MSB_720p		(0x01)
+#define AVID_STOP_PIXEL_LSB_720p		(0x4B)
+#define AVID_STOP_PIXEL_MSB_720p		(0x06)
+#define VBLK_F0_START_LINE_OFFSET_720p		(0x05)
+#define VBLK_F1_START_LINE_OFFSET_720p		(0x00)
+#define VBLK_F0_DURATION_720p			(0x2D)
+#define VBLK_F1_DURATION_720p			(0x00)
+#define RESERVED_720p				(0x03)
+
+#define FEEDBACK_DIVIDER_MSB_720p_50            (0x7B)
+#define FEEDBACK_DIVIDER_LSB_720p_50            (0x0C)
+#define VCO_CONTROL_720p_50                     (0x02)
+#define CP_CURRENT_720p_50                      (0x03)
+#define PHASE_SELECT_720p_50                    (0x16)
+#define POST_DIVIDER_720p_50                    (0x0)
+#define HPLL_CONTROL_720p_50			(0x98)
+#define AVID_START_PIXEL_LSB_720p_50		(0x47)
+#define AVID_START_PIXEL_MSB_720p_50		(0x01)
+#define AVID_STOP_PIXEL_LSB_720p_50		(0x4B)
+#define AVID_STOP_PIXEL_MSB_720p_50		(0x06)
+#define VBLK_F0_START_LINE_OFFSET_720p_50	(0x05)
+#define VBLK_F1_START_LINE_OFFSET_720p_50	(0x00)
+#define VBLK_F0_DURATION_720p_50		(0x2D)
+#define VBLK_F1_DURATION_720p_50		(0x00)
+#define RESERVED_720p				(0x03)
+
+#define FEEDBACK_DIVIDER_MSB_1080i              (0x89)
+#define FEEDBACK_DIVIDER_LSB_1080i              (0x08)
+#define VCO_CONTROL_1080i                       (0x02)
+#define CP_CURRENT_1080i                        (0x03)
+#define PHASE_SELECT_1080i                      (0x14)
+#define POST_DIVIDER_1080i                      (0x0)
+#define HPLL_CONTROL_1080i			(0x98)
+#define AVID_START_PIXEL_LSB_1080i		(0x06)
+#define AVID_START_PIXEL_MSB_1080i		(0x01)
+#define AVID_STOP_PIXEL_LSB_1080i		(0x8A)
+#define AVID_STOP_PIXEL_MSB_1080i		(0x08)
+#define VBLK_F0_START_LINE_OFFSET_1080i		(0x02)
+#define VBLK_F1_START_LINE_OFFSET_1080i		(0x02)
+#define VBLK_F0_DURATION_1080i			(0x16)
+#define VBLK_F1_DURATION_1080i			(0x17)
+#define RESERVED_1080i				(0x02)
+
+#define FEEDBACK_DIVIDER_MSB_1080i_50           (0xA5)
+#define FEEDBACK_DIVIDER_LSB_1080i_50           (0x00)
+#define VCO_CONTROL_1080i_50                    (0x02)
+#define CP_CURRENT_1080i_50                     (0x02)
+#define PHASE_SELECT_1080i_50                   (0x14)
+#define POST_DIVIDER_1080i_50                   (0x0)
+#define HPLL_CONTROL_1080i_50			(0x90)
+#define AVID_START_PIXEL_LSB_1080i_50		(0x06)
+#define AVID_START_PIXEL_MSB_1080i_50		(0x01)
+#define AVID_STOP_PIXEL_LSB_1080i_50		(0x8A)
+#define AVID_STOP_PIXEL_MSB_1080i_50		(0x08)
+#define VBLK_F0_START_LINE_OFFSET_1080i_50	(0x02)
+#define VBLK_F1_START_LINE_OFFSET_1080i_50	(0x02)
+#define VBLK_F0_DURATION_1080i_50		(0x16)
+#define VBLK_F1_DURATION_1080i_50		(0x17)
+#define RESERVED_1080i_50			(0x02)
+
+#define FEEDBACK_DIVIDER_MSB_480P		(0x35)
+#define FEEDBACK_DIVIDER_LSB_480P		(0x0A)
+#define VCO_CONTROL_480P			(0x02)
+#define CP_CURRENT_480P				(0x02)
+#define PHASE_SELECT_480P			(0x14)
+#define POST_DIVIDER_480P			(0x0)
+#define HPLL_CONTROL_480P			(0x18)
+#define AVID_START_PIXEL_LSB_480P		(0x91)
+#define AVID_START_PIXEL_MSB_480P		(0x00)
+#define AVID_STOP_PIXEL_LSB_480P		(0x0B)
+#define AVID_STOP_PIXEL_MSB_480P		(0x00)
+#define VBLK_F0_START_LINE_OFFSET_480P		(0x03)
+#define VBLK_F1_START_LINE_OFFSET_480P		(0x01)
+#define VBLK_F0_DURATION_480P			(0x13)
+#define VBLK_F1_DURATION_480P			(0x13)
+#define RESERVED_1080i_50                       (0x02)
+
+#define FEEDBACK_DIVIDER_MSB_576P               (0x36)
+#define FEEDBACK_DIVIDER_LSB_576P               (0x00)
+#define VCO_CONTROL_576P                        (0x02)
+#define CP_CURRENT_576P                         (0x02)
+#define PHASE_SELECT_576P                       (0x14)
+#define POST_DIVIDER_576P                       (0x0)
+#define HPLL_CONTROL_576P                       (0x18)
+#define AVID_START_PIXEL_LSB_576P               (0x9B)
+#define AVID_START_PIXEL_MSB_576P               (0x00)
+#define AVID_STOP_PIXEL_LSB_576P                (0x0F)
+#define AVID_STOP_PIXEL_MSB_576P                (0x00)
+#define VBLK_F0_START_LINE_OFFSET_576P          (0x00)
+#define VBLK_F1_START_LINE_OFFSET_576P          (0x00)
+#define VBLK_F0_DURATION_576P                   (0x2D)
+#define VBLK_F1_DURATION_576P                   (0x00)
+#define RESERVED_1080i_50                       (0x02)
+
+#define TVP7002_HD_ALC_PLACEMENT		(0x5A)
+#define TVP7002_ED_ALC_PLACEMENT		(0x18)
+
+#define TVP7002_HD_CLAMP_START			(0x32)
+#define TVP7002_ED_CLAMP_START			(0x06)
+
+#define TVP7002_HD_CLAMP_WIDTH			(0x20)
+#define TVP7002_ED_CLAMP_WIDTH			(0x10)
+
+#define TVP7002_HD_PRE_COAST			(0x0)
+#define TVP7002_ED_PRE_COAST			(0x03)
+
+#define TVP7002_HD_POST_COAST			(0x0)
+#define TVP7002_ED_POST_COAST			(0x0C)
+
+/* HPLL masks and shifts */
+#define HPLL_DIVIDER_LSB_MASK                   GENERATE_MASK(4, 0)
+#define HPLL_DIVIDER_LSB_SHIFT                  4
+#define VCO_CONTROL_MASK                        GENERATE_MASK(2, 0)
+#define CP_CURRENT_MASK                         GENERATE_MASK(3, 0)
+#define VCO_CONTROL_SHIFT                       6
+#define CP_CURRENT_SHIFT                        3
+#define PHASE_SELECT_MASK                       GENERATE_MASK(5, 0)
+#define PHASE_SELECT_SHIFT                      3
+
+#define POST_DIVIDER_MASK                       GENERATE_MASK(1, 0)
+
+#define LINES_PER_FRAME_MSB_MASK                GENERATE_MASK(4, 8)
+#define LINES_PER_FRAME_MSB_SHIFT               8
+
+#define VIDEO_DETECTION_MASK                    GENERATE_MASK(1, 5)
+#define VIDEO_DETECTION_SHIFT			5
+
+/* Gain and offset masks */
+
+#define BLUE_COARSE_GAIN_MASK                   GENERATE_MASK(4, 0)
+#define GREEN_COARSE_GAIN_MASK                  GENERATE_MASK(4, 0)
+#define RED_COARSE_GAIN_MASK                    GENERATE_MASK(4, 0)
+#define GREEN_COARSE_GAIN_SHIFT                 4
+
+#define FINE_OFFSET_LSB_MASK                    0x03
+
+#define FINE_OFFSET_LSB_SHIFT_GREEN             2
+#define FINE_OFFSET_LSB_SHIFT_RED               4
+
+#define COARSE_OFFSET_MASK                      GENERATE_MASK(6, 0)
+
+/* Defines for TVP7002 register address */
+#define TVP7002_HPLL_DIVIDER_MSB                (0x01)
+#define TVP7002_HPLL_DIVIDER_LSB                (0x02)
+#define TVP7002_HPLL_CONTROL                    (0x03)
+#define TVP7002_HPLL_PHASE_SELECT               (0x04)
+#define TVP7002_CLAMP_START                     (0x05)
+#define TVP7002_CLAMP_WIDTH                     (0x06)
+#define TVP7002_HSYNC_OUTPUT_WIDTH              (0x07)
+
+#define TVP7002_BLUE_FINE_GAIN                  (0x08)
+#define TVP7002_GREEN_FINE_GAIN                 (0x09)
+#define TVP7002_RED_FINE_GAIN                   (0x0A)
+#define TVP7002_BLUE_FINE_OFFSETMSB             (0x0B)
+#define TVP7002_GREEN_FINE_OFFSETMSB            (0x0C)
+#define TVP7002_RED_FINE_OFFSETMSB              (0x0D)
+
+#define TVP7002_SYNC_CONTROL_1                  (0x0E)
+#define TVP7002_HPLL_CLAMP_CONTROL              (0x0F)
+#define TVP7002_SYNC_ON_GREEN_THLD              (0x10)
+#define TVP7002_SYNC_SEPARATER_THLD             (0x11)
+#define TVP7002_HPLL_PRE_COAST                  (0x12)
+#define TVP7002_HPLL_POST_COAST                 (0x13)
+
+#define TVP7002_OUTPUT_FORMATTER                (0x15)
+#define TVP7002_MISC_CONTROL_1                  (0x16)
+#define TVP7002_MISC_CONTROL_2                  (0x17)
+#define TVP7002_MISC_CONTROL_3                  (0x18)
+#define TVP7002_INPUT_MUX_SELECT_1              (0x19)
+#define TVP7002_INPUT_MUX_SELECT_2              (0x1A)
+#define TVP7002_BLUE_GREEN_COARSE_GAIN          (0x1B)
+#define TVP7002_RED_COARSE_GAIN                 (0x1C)
+#define TVP7002_FINE_OFFSET_LSBS                (0x1D)
+#define TVP7002_BLUE_COARSE_OFFSET              (0x1E)
+#define TVP7002_GREEN_COARSE_OFFSET             (0x1F)
+#define TVP7002_RED_COARSE_OFFSET               (0x20)
+#define TVP7002_HSOUT_OUTPUT_START              (0x21)
+#define TVP7002_MISC_CONTROL_4                  (0x22)
+#define TVP7002_ALC_ENABLE                      (0x26)
+#define TVP7002_ALC_FILTER                      (0x28)
+#define TVP7002_FINE_CLAMP_CONTROL              (0x2A)
+#define TVP7002_POWER_CONTROL                   (0x2B)
+#define TVP7002_ADC_SETUP                       (0x2C)
+#define TVP7002_COARSE_CLAMP_CONTROL            (0x2D)
+#define TVP7002_SOG_CLAMP                       (0x2E)
+#define TVP7002_ALC_PLACEMENT                   (0x31)
+#define TVP7002_VSYNC_ALIGNMENT                 (0x35)
+#define TVP7002_SYNC_BYPASS                     (0x36)
+#define TVP7002_LINES_PER_FRAME_STATUS_LOW      (0x37)
+#define TVP7002_LINES_PER_FRAME_STATUS_HIGH     (0x38)
+#define TVP7002_CLOCK_PER_LINE_STATUS_LSB	(0x39)
+#define TVP7002_CLOCK_PER_LINE_STATUS_MSB	(0x3A)
+
+#define TVP7002_LINE_LENGTH_TOLERENCE           (0x3D)
+#define TVP7002_ADC_REF_SETUP                   (0x3E)
+#define TVP7002_VIDEO_BANDWIDTH_CONTROL		(0x3F)
+#define TVP7002_AVID_START_PIXEL_LOW            (0x40)
+#define TVP7002_AVID_START_PIXEL_HIGH           (0x41)
+#define TVP7002_AVID_STOP_PIXEL_LOW             (0x42)
+#define TVP7002_AVID_STOP_PIXEL_HIGH            (0x43)
+#define TVP7002_VBLK_FIELD0_START_OFFSET        (0x44)
+#define TVP7002_VBLK_FIELD1_START_OFFSET        (0x45)
+#define TVP7002_VBLK_FIELD0_DURATION            (0x46)
+#define TVP7002_VBLK_FIELD1_DURATION            (0x47)
+#define TVP7002_FBIT_FIELD0_START_OFFSET        (0x48)
+#define TVP7002_FBIT_FIELD1_START_OFFSET        (0x49)
+
+#define TVP7002_HD_INPUT                        (0x00)
+
+/* decoder standard related strctures */
+#define TVP7002_MAX_NO_INPUTS           (1)
+#define TVP7002_MAX_NO_STANDARDS        (4+1+1)
+#define TVP7002_MAX_NO_CONTROLS         (0)
+
+#define TVP7002_ALC_VCOEFF_SHIFT	(4)
+
+#define TVP7002_STANDARD_INFO_SIZE      (TVP7002_MAX_NO_STANDARDS)
+
+struct tvp7002_control_info {
+	int register_address;
+	struct v4l2_queryctrl query_control;
+};
+
+struct tvp7002_config {
+	int no_of_inputs;
+	struct {
+		int input_type;
+		struct v4l2_input input_info;
+		int no_of_standard;
+		struct v4l2_standard *standard;
+		v4l2_std_id def_std;
+		struct tvp7002_format_params *format;
+		int no_of_controls;
+		struct tvp7002_control_info *controls;
+	} input[TVP7002_MAX_NO_INPUTS];
+	tvp7002_params def_params;
+};
+
+struct tvp7002_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u32 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct decoder_device *dec_device;
+	tvp7002_params params;
+};
+
+#endif				/* __KERNEL__ */
+
+#endif
Index: linux-2.6.10/include/media/davinci/vid_decoder_if.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/vid_decoder_if.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vid_decoder_if.h */
+
+/* This file contains data structure which will be used as the interface
+ * between vpif and decoder */
+
+#ifndef VID_DECODER_IF_H
+#define VID_DECODER_IF_H
+
+#ifdef __KERNEL__
+
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+
+#define DECODER_MAX_NAME		(50)
+
+#define FRAME_FORMAT_PROGRESSIVE        (1)
+#define FRAME_FORMAT_INTERLACED         (0)
+
+#define DECODER_I2C_BIND_FLAG		(0)
+#define DECODER_FULL_INIT_FLAG		(1)
+
+typedef enum {
+	INTERFACE_TYPE_BT656 = 1,
+	INTERFACE_TYPE_BT1120 = 2,
+	INTERFACE_TYPE_RAW = 4
+} vid_capture_interface_type;
+
+/* structures */
+
+/* Parameters ops structure */
+struct param_ops {
+	int (*setparams) (void *params, void *dec);	/* Pointer to function
+							   to set parameters */
+	int (*getparams) (void *params, void *dec);	/* Pointer to function
+							   to get parameters */
+};
+
+/* standard ops structure */
+struct standard_ops {
+	int count;		/* Indicates number of standards
+				   supported */
+	int (*enumstd) (struct v4l2_standard *argp, void *dec);	/* Pointer to
+									   function to
+									   enumerate                                                                     standard */
+	int (*querystd) (v4l2_std_id *argp, void *dec);	/* Pointer to function
+								   to query standard */
+	int (*setstd) (v4l2_std_id *argp, void *dec);	/* Pointer to
+							   function to set
+							   standard */
+	int (*getstd) (v4l2_std_id *argp, void *dec);	/* Pointer to
+							   function to get
+							   standard */
+};
+
+/* format ops structure */
+struct format_ops {
+	int count;		/* Indicats number of formats
+				   supported */
+	int (*enumformat) (struct v4l2_fmtdesc *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to
+									   enumerate
+									   formats */
+	int (*tryformat) (struct v4l2_format *argp, void *dec);	/* Pointer to
+									   function
+									   to try
+									   format */
+	int (*setformat) (struct v4l2_format *argp, void *dec);	/* Pointer
+									   to function
+									   to set
+									   formats */
+	int (*getformat) (struct v4l2_format *argp, void *dec);	/* Pointer
+									   to function
+									   to get
+									   formats */
+};
+
+/* control ops structure */
+struct control_ops {
+	int count;		/* Indicats number of controls
+				   supported */
+	int (*queryctrl) (struct v4l2_queryctrl *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to
+									   enumerate
+									   controls */
+	int (*setcontrol) (struct v4l2_control *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to set
+									   controls */
+	int (*getcontrol) (struct v4l2_control *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to get
+									   controls */
+};
+
+/* input ops structure */
+struct input_ops {
+	int count;		/* Indicats number of
+				   inputs supported */
+	int (*enuminput) (struct v4l2_input *argp, void *dec);	/* Pointer to
+								   function to
+								   query
+								   inputs */
+	int (*setinput) (int *argp, void *dec);	/* Pointer to function
+						   to set inputs */
+	int (*getinput) (int *argp, void *dec);	/* Pointer to function
+						   to get inputs */
+};
+
+/* decoder device structure */
+struct decoder_device {
+	u8 name[DECODER_MAX_NAME];	/* Name of the
+					   decoder device */
+	vid_capture_interface_type if_type;	/* Decoder interface
+						   type i.e. BT656 */
+	int channel_id;		/* Id of the channel
+				   to which decoder
+				   is connected */
+	u32 capabilities;	/* decoder
+				   capabilities */
+	int (*initialize) (void *dec, int flag);	/* Pointer to
+							   initialize
+							   function to
+							   initialize
+							   decoder */
+	struct standard_ops *std_ops;	/* Set of functions
+					   pointers for
+					   standard related
+					   functions */
+	struct control_ops *ctrl_ops;	/* Set of functions
+					   pointers for
+					   control related
+					   functions */
+	struct input_ops *input_ops;	/* Set of functions
+					   pointers for input
+					   related
+					   functions */
+	struct format_ops *fmt_ops;	/* Set of functions
+					   pointers for
+					   format related
+					   functions */
+	struct param_ops *params_ops;	/* Set of functions
+					   pointers for
+					   device specific
+					   configs */
+	int (*deinitialize) (void *dec);	/* Pointer to
+						   deinitialize
+						   function */
+	int (*read_vbi_data) (struct v4l2_sliced_vbi_data *data, void *dec);
+	/* This function
+	   will be called
+	   whenever the
+	   sliced vbi data
+	   has to be get
+	   from the decoder */
+	int (*get_sliced_vbi_cap) (struct v4l2_sliced_vbi_cap *cap, void *dec);
+	/* This function
+	   will be called
+	   whenver all the
+	   sliced vbi
+	   services needs
+	   to be get from
+	   the decoder */
+
+};
+
+int vpif_register_decoder(struct decoder_device
+			  *decoder);	/* Function to register decoder to the
+					   VPIF-V4L2 layer */
+int vpif_unregister_decoder(struct decoder_device
+			    *decoder);	/* Function to un-register decoder 
+					   to the
+					   VPIF-V4L2 layer */
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_DECODER_IF_H */
Index: linux-2.6.10/include/media/davinci/vpif.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/vpif.h
@@ -0,0 +1,727 @@
+/*
+ *
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpif_capture.h */
+
+#ifndef VPIF_H
+#define VPIF_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+/* Registers Base Address */
+#define VPIF_IOBASE_ADDR                	IO_ADDRESS(0x01C12000)
+
+/* Maximum channel allowed */
+#define VPIF_NUM_CHANNELS               	4
+#define VPIF_CAPTURE_NUM_CHANNELS		2
+#define VPIF_DISPLAY_NUM_CHANNELS		2
+
+/* Macros to read/write registers */
+#define regr(reg)               inl((reg) + VPIF_IOBASE_ADDR)
+#define regw(value, reg)        outl(value, (reg) + VPIF_IOBASE_ADDR)
+
+
+/* Register Addresss */
+#define VPIF_PID                                (0x0000)
+#define VPIF_CH0_CTRL                           (0x0004)
+#define VPIF_CH1_CTRL                           (0x0008)
+#define VPIF_CH2_CTRL                           (0x000C)
+#define VPIF_CH3_CTRL                           (0x0010)
+
+#define VPIF_INTEN                              (0x0020)
+#define VPIF_INTEN_SET                          (0x0024)
+#define VPIF_INTEN_CLR                          (0x0028)
+#define VPIF_STATUS                             (0x002C)
+#define VPIF_STATUS_CLR                         (0x0030)
+#define VPIF_EMULATION_CTRL                     (0x0034)
+#define VPIF_REQ_SIZE                           (0x0038)
+
+#define VPIF_CH0_TOP_STRT_ADD_LUMA              (0x0040)
+#define VPIF_CH0_BTM_STRT_ADD_LUMA              (0x0044)
+#define VPIF_CH0_TOP_STRT_ADD_CHROMA            (0x0048)
+#define VPIF_CH0_BTM_STRT_ADD_CHROMA            (0x004c)
+#define VPIF_CH0_TOP_STRT_ADD_HANC              (0x0050)
+#define VPIF_CH0_BTM_STRT_ADD_HANC              (0x0054)
+#define VPIF_CH0_TOP_STRT_ADD_VANC              (0x0058)
+#define VPIF_CH0_BTM_STRT_ADD_VANC              (0x005c)
+#define VPIF_CH0_SP_CFG                         (0x0060)
+#define VPIF_CH0_IMG_ADD_OFST                   (0x0064)
+#define VPIF_CH0_HANC_ADD_OFST                  (0x0068)
+#define VPIF_CH0_H_CFG                          (0x006c)
+#define VPIF_CH0_V_CFG_00                       (0x0070)
+#define VPIF_CH0_V_CFG_01                       (0x0074)
+#define VPIF_CH0_V_CFG_02                       (0x0078)
+#define VPIF_CH0_V_CFG_03                       (0x007c)
+
+#define VPIF_CH1_TOP_STRT_ADD_LUMA              (0x0080)
+#define VPIF_CH1_BTM_STRT_ADD_LUMA              (0x0084)
+#define VPIF_CH1_TOP_STRT_ADD_CHROMA            (0x0088)
+#define VPIF_CH1_BTM_STRT_ADD_CHROMA            (0x008c)
+#define VPIF_CH1_TOP_STRT_ADD_HANC              (0x0090)
+#define VPIF_CH1_BTM_STRT_ADD_HANC              (0x0094)
+#define VPIF_CH1_TOP_STRT_ADD_VANC              (0x0098)
+#define VPIF_CH1_BTM_STRT_ADD_VANC              (0x009c)
+#define VPIF_CH1_SP_CFG                         (0x00a0)
+#define VPIF_CH1_IMG_ADD_OFST                   (0x00a4)
+#define VPIF_CH1_HANC_ADD_OFST                  (0x00a8)
+#define VPIF_CH1_H_CFG                          (0x00ac)
+#define VPIF_CH1_V_CFG_00                       (0x00b0)
+#define VPIF_CH1_V_CFG_01                       (0x00b4)
+#define VPIF_CH1_V_CFG_02                       (0x00b8)
+#define VPIF_CH1_V_CFG_03                       (0x00bc)
+
+#define VPIF_CH2_TOP_STRT_ADD_LUMA              (0x00c0)
+#define VPIF_CH2_BTM_STRT_ADD_LUMA              (0x00c4)
+#define VPIF_CH2_TOP_STRT_ADD_CHROMA            (0x00c8)
+#define VPIF_CH2_BTM_STRT_ADD_CHROMA            (0x00cc)
+#define VPIF_CH2_TOP_STRT_ADD_HANC		(0x00d0)
+#define VPIF_CH2_BTM_STRT_ADD_HANC              (0x00d4)
+#define VPIF_CH2_TOP_STRT_ADD_VANC              (0x00d8)
+#define VPIF_CH2_BTM_STRT_ADD_VANC              (0x00dc)
+#define VPIF_CH2_SP_CFG                         (0x00e0)
+#define VPIF_CH2_IMG_ADD_OFST                   (0x00e4)
+#define VPIF_CH2_HANC_ADD_OFST                  (0x00e8)
+#define VPIF_CH2_H_CFG                          (0x00ec)
+#define VPIF_CH2_V_CFG_00                       (0x00f0)
+#define VPIF_CH2_V_CFG_01                       (0x00f4)
+#define VPIF_CH2_V_CFG_02                       (0x00f8)
+#define VPIF_CH2_V_CFG_03                       (0x00fc)
+#define VPIF_CH2_HANC0_STRT                     (0x0100)
+#define VPIF_CH2_HANC0_SIZE                     (0x0104)
+#define VPIF_CH2_HANC1_STRT                     (0x0108)
+#define VPIF_CH2_HANC1_SIZE                     (0x010c)
+#define VPIF_CH2_VANC0_STRT                     (0x0110)
+#define VPIF_CH2_VANC0_SIZE                     (0x0114)
+#define VPIF_CH2_VANC1_STRT                     (0x0118)
+#define VPIF_CH2_VANC1_SIZE                     (0x011c)
+
+#define VPIF_CH3_TOP_STRT_ADD_LUMA              (0x0140)
+#define VPIF_CH3_BTM_STRT_ADD_LUMA              (0x0144)
+#define VPIF_CH3_TOP_STRT_ADD_CHROMA            (0x0148)
+#define VPIF_CH3_BTM_STRT_ADD_CHROMA            (0x014c)
+#define VPIF_CH3_TOP_STRT_ADD_HANC              (0x0150)
+#define VPIF_CH3_BTM_STRT_ADD_HANC              (0x0154)
+#define VPIF_CH3_TOP_STRT_ADD_VANC              (0x0158)
+#define VPIF_CH3_BTM_STRT_ADD_VANC              (0x015c)
+#define VPIF_CH3_SP_CFG                         (0x0160)
+#define VPIF_CH3_IMG_ADD_OFST                   (0x0164)
+#define VPIF_CH3_HANC_ADD_OFST                  (0x0168)
+#define VPIF_CH3_H_CFG                          (0x016c)
+#define VPIF_CH3_V_CFG_00                       (0x0170)
+#define VPIF_CH3_V_CFG_01                       (0x0174)
+#define VPIF_CH3_V_CFG_02                       (0x0178)
+#define VPIF_CH3_V_CFG_03                       (0x017c)
+#define VPIF_CH3_HANC0_STRT                     (0x0180)
+#define VPIF_CH3_HANC0_SIZE                     (0x0184)
+#define VPIF_CH3_HANC1_STRT                     (0x0188)
+#define VPIF_CH3_HANC1_SIZE                     (0x018c)
+#define VPIF_CH3_VANC0_STRT                     (0x0190)
+#define VPIF_CH3_VANC0_SIZE                     (0x0194)
+#define VPIF_CH3_VANC1_STRT                     (0x0198)
+#define VPIF_CH3_VANC1_SIZE                     (0x019c)
+
+#define VPIF_IODFT_CTRL                         (0x01c0)
+
+/* Macros for BIT Manipulation */
+#define SETBIT(reg, bit)                ((reg) |= ((0x00000001)<<bit))
+#define RESETBIT(reg, bit)              ((reg) &= (~((0x00000001)<<bit)))
+
+/* Macros */
+/* Macro for Generating mask */
+#ifdef GENERATE_MASK
+#undef GENERATE_MASK
+#endif
+
+#define GENERATE_MASK(bits, pos)        ((((0xFFFFFFFF) << (32-bits)) >> \
+		(32-bits)) << pos)
+
+/* Bit positions in the channel control registers */
+#define VPIF_CH_DATA_MODE_BIT                   (2)
+#define VPIF_CH_YC_MUX_BIT                      (3)
+#define VPIF_CH_SDR_FMT_BIT                     (4)
+#define VPIF_CH_HANC_EN_BIT                     (8)
+#define VPIF_CH_VANC_EN_BIT                     (9)
+
+#define VPIF_CAPTURE_CH_NIP			(10)
+#define VPIF_DISPLAY_CH_NIP			(11)
+
+#define VPIF_DISPLAY_PIX_EN_BIT			(10)
+
+#define VPIF_CH_INPUT_FIELD_FRAME_BIT           (12)
+
+#define VPIF_CH_FID_POLARITY_BIT		(15)
+#define VPIF_CH_V_VALID_POLARITY_BIT		(14)
+#define VPIF_CH_H_VALID_POLARITY_BIT		(13)
+#define VPIF_CH_DATA_WIDTH_BIT			(28)
+
+#define VPIF_CH_CLK_EDGE_CTRL_BIT               (31)
+
+/* Mask various length */
+#define VPIF_CH_EAVSAV_MASK             GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_MASK                GENERATE_MASK(12, 0)
+#define VPIF_CH_WIDTH_MASK              GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_SHIFT               (16)
+
+/* VPIF masks for registers */
+#define VPIF_REQ_SIZE_MASK              (0x1ff)
+
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH0		(0x00000001)
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH1		(0x00000002)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH0_CLK_EN		        (0x00000002)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH0_EN		        (0x00000001)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH1_EN		        (0x00000001)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH1_CLK_EN			(0x00000002)
+
+#define VPIF_CH_CLK_EN			(0x00000002)
+#define VPIF_CH_EN		        (0x00000001)
+
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH2		(0x00000004)
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH3		(0x00000008)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH2_CLK_EN		        (0x00000002)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH2_EN		        (0x00000001)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH3_EN		        (0x00000001)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH3_CLK_EN			(0x00000002)
+
+
+#define VPIF_INT_TOP			(0x00) 
+#define VPIF_INT_BOTTOM			(0x01)
+#define VPIF_INT_BOTH			(0x02)
+
+#define VPIF_CH0_INT_CTRL_SHIFT		6
+#define VPIF_CH1_INT_CTRL_SHIFT		6
+#define VPIF_CH2_INT_CTRL_SHIFT		6
+#define VPIF_CH3_INT_CTRL_SHIFT		6
+#define VPIF_CH_INT_CTRL_SHIFT		6
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel0_intr_assert() 		(regw((regr(VPIF_CH0_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH0_INT_CTRL_SHIFT)), \
+					VPIF_CH0_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel1_intr_assert() 		(regw((regr(VPIF_CH1_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH1_INT_CTRL_SHIFT)), \
+					VPIF_CH1_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel2_intr_assert() 		(regw((regr(VPIF_CH2_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH2_INT_CTRL_SHIFT)), \
+					VPIF_CH2_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel3_intr_assert() 		(regw((regr(VPIF_CH3_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH3_INT_CTRL_SHIFT)), \
+					VPIF_CH3_CTRL))
+
+
+#define VPIF_CH_FID_MASK		0x20
+#define VPIF_CH_FID_SHIFT		5
+
+#define VPIF_NTSC_VBI_START_FIELD0	1
+#define VPIF_NTSC_VBI_START_FIELD1	263
+#define VPIF_PAL_VBI_START_FIELD0	624
+#define VPIF_PAL_VBI_START_FIELD1	311
+
+#define VPIF_NTSC_HBI_START_FIELD0	1
+#define VPIF_NTSC_HBI_START_FIELD1	263
+#define VPIF_PAL_HBI_START_FIELD0	624
+#define VPIF_PAL_HBI_START_FIELD1	311
+
+#define VPIF_NTSC_VBI_COUNT_FIELD0	20
+#define VPIF_NTSC_VBI_COUNT_FIELD1	19
+#define VPIF_PAL_VBI_COUNT_FIELD0	24
+#define VPIF_PAL_VBI_COUNT_FIELD1	25
+
+#define VPIF_NTSC_HBI_COUNT_FIELD0	263
+#define VPIF_NTSC_HBI_COUNT_FIELD1	262
+#define VPIF_PAL_HBI_COUNT_FIELD0	312
+#define VPIF_PAL_HBI_COUNT_FIELD1	313
+
+#define VPIF_NTSC_VBI_SAMPLES_PER_LINE	720
+#define VPIF_PAL_VBI_SAMPLES_PER_LINE	720
+#define VPIF_NTSC_HBI_SAMPLES_PER_LINE	268
+#define VPIF_PAL_HBI_SAMPLES_PER_LINE	280
+
+#define VPIF_CH_VANC_EN			0x20
+#define VPIF_DMA_REQ_SIZE		0x080
+#define VPIF_EMULATION_DISABLE		0x01
+
+extern u8 irq_vpif_capture_channel[VPIF_NUM_CHANNELS];
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel0(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel2 */
+		regw((regr(VPIF_CH0_CTRL) | (VPIF_CH0_EN)), VPIF_CH0_CTRL);
+	} else {
+		/* Disable clock and channel2 */
+		regw((regr(VPIF_CH0_CTRL) & (~VPIF_CH0_EN)),
+		     VPIF_CH0_CTRL);
+	}
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel1(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel3 */
+		regw((regr(VPIF_CH1_CTRL) | (VPIF_CH1_EN)), VPIF_CH1_CTRL);
+	} else {
+		/* Disable clock and channel3 */
+		regw((regr(VPIF_CH1_CTRL) & (~VPIF_CH1_EN)),
+		     VPIF_CH1_CTRL);
+	}
+}
+
+/* inline function to enable interrupt for channel 2 */
+static inline void channel0_intr_enable(int enable)
+{
+	if (enable) {
+
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH0)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel 3 */
+static inline void channel1_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH1)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* static inline function to set buffer addresses in in case of Y/C
+   non mux mode */
+static inline void ch0_set_videobuf_addr_yc_nmux(unsigned long
+						 top_strt_luma,
+						 unsigned long
+						 btm_strt_luma,
+						 unsigned long
+						 top_strt_chroma,
+						 unsigned long
+						 btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   video data */
+static inline void ch0_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH0_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH0_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch1_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+
+	regw(top_strt_luma, VPIF_CH1_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH1_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch0_set_vbi_addr(unsigned long top_vbi, 
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_VANC);
+}
+static inline void ch0_set_hbi_addr(unsigned long top_vbi, 
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_HANC);
+}
+
+static inline void ch1_set_vbi_addr(unsigned long top_vbi, 
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_VANC);
+}
+static inline void ch1_set_hbi_addr(unsigned long top_vbi, 
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_HANC);
+}
+/* Inline function to enable raw vbi in the given channel */
+static inline void disable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	u32 val;
+	if(0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+	val = regr(ctrl_reg);
+	if(1 == index)
+		RESETBIT(val, VPIF_CH_VANC_EN_BIT);
+	else
+		RESETBIT(val, VPIF_CH_HANC_EN_BIT);
+	regw(val, ctrl_reg);
+	
+}
+
+static inline void enable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	u32 val;
+	if(0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+	
+	val = regr(ctrl_reg);
+	if(1 == index)
+		SETBIT(val, VPIF_CH_VANC_EN_BIT);
+	else
+		SETBIT(val, VPIF_CH_HANC_EN_BIT);
+	regw(val, ctrl_reg);
+	
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel2(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel2 */
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_CLK_EN)),
+		     VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_EN)), VPIF_CH2_CTRL);
+	} else {
+		/* Disable clock and channel2 */
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_CLK_EN)),
+		     VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_EN)),
+		     VPIF_CH2_CTRL);
+	}
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel3(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel3 */
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_CLK_EN)),
+		     VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_EN)), VPIF_CH3_CTRL);
+	} else {
+		/* Disable clock and channel3 */
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_CLK_EN)),
+		     VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_EN)),
+		     VPIF_CH3_CTRL);
+	}
+}
+
+/* inline function to enable interrupt for channel 2 */
+static inline void channel2_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH2)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel 3 */
+static inline void channel3_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH3)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable raw vbi data for channel 2 */
+static inline void channel2_raw_enable(int enable, u8 index)
+{
+	u32 mask, val;
+	if(1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+	val = regr(VPIF_CH2_CTRL);
+	if (enable) {
+		/*regw((regr(VPIF_CH3_CTRL) | mask), VPIF_CH3_CTRL);*/
+		SETBIT(val, mask);
+	} else {
+		RESETBIT(val, mask);
+	}
+	regw(val, VPIF_CH2_CTRL);
+}
+
+/* inline function to enable raw vbi data for channel 3*/
+static inline void channel3_raw_enable(int enable, u8 index)
+{
+	u32 mask, val;
+	if(1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+	val = regr(VPIF_CH3_CTRL);
+	if (enable) {
+		/*regw((regr(VPIF_CH3_CTRL) | mask), VPIF_CH3_CTRL);*/
+		SETBIT(val, mask);
+	} else {
+		RESETBIT(val, mask);
+	}
+	regw(val, VPIF_CH3_CTRL);
+}
+
+/* static inline function to set buffer addresses in in case of Y/C
+   non mux mode */
+static inline void ch2_set_videobuf_addr_yc_nmux(unsigned long
+						 top_strt_luma,
+						 unsigned long
+						 btm_strt_luma,
+						 unsigned long
+						 top_strt_chroma,
+						 unsigned long
+						 btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   video data */
+static inline void ch2_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH2_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH2_BTM_STRT_ADD_CHROMA);
+
+}
+
+static inline void ch3_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   vbi data */
+static inline void ch2_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_VANC);	
+}
+
+static inline void ch3_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_VANC);
+}
+
+#define VPIF_MAX_NAME   30
+
+/* This structure will store size parameters as per the mode selected by
+   the user */
+struct vpif_channel_config_params {
+	char name[VPIF_MAX_NAME];	/* Name of the */
+	u16 width;		/* Indicates width of the image for
+				   this mode */
+	u16 height;		/* Indicates height of the image for
+				   this mode */
+	u8 fps;
+	u8 frm_fmt;		/* Indicates whether this is interlaced 
+				   or progressive format */
+	u8 ycmux_mode;		/* Indicates whether this mode requires
+				   single or two channels */
+	u16 eav2sav;		/* length of sav 2 eav */
+	u16 sav2eav;		/* length of sav 2 eav */
+	u16 l1, l3, l5, l7, l9, l11;	/* Other parameter configurations */
+	u16 vsize;		/* Vertical size of the image */
+	u8 capture_format;	/* Indicates whether capture format 
+				   is in BT or in CCD/CMOS */
+	u8  vbi_supported;	  /* Indicates whether this mode 
+				     supports capturing vbi or not */
+	u8 hd_sd;
+};
+
+struct vpif_stdinfo {
+	u8 channel_id;
+	u32 activepixels;
+	u32 activelines;
+	u16 fps;
+	u8 frame_format;
+	char name[VPIF_MAX_NAME];
+	u8 ycmux_mode;
+	u8 vbi_supported;	  /* Indicates whether this mode 
+				     supports capturing vbi or not */
+	u8 hd_sd;
+};
+
+struct vpif_interface;
+struct vpif_params;
+struct vpif_vbi_params;
+
+int vpif_get_mode_info(struct vpif_stdinfo *std_info);
+
+int vpif_set_video_params(struct vpif_params *, u8 channel_id);
+
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+	       	u8 channel_id);
+
+int vpif_channel_getfid(u8 channel_id);
+
+int vpif_get_irq_number(int);
+#endif				/* End of #ifdef __KERNEL__ */
+
+/* Enumerated data types */
+typedef enum {
+	VPIF_CAPTURE_PINPOL_SAME = 0,
+	VPIF_CAPTURE_PINPOL_INVERT = 1
+} vpif_capture_pinpol;
+
+typedef enum {
+	_8BITS = 0,
+	_10BITS,
+	_12BITS,
+} data_size;
+
+typedef struct {
+	data_size data_sz;
+	vpif_capture_pinpol fid_pol;
+	vpif_capture_pinpol vd_pol;
+	vpif_capture_pinpol hd_pol;
+} vpif_capture_params_raw;
+
+/* structure for vpif parameters */
+struct vpif_interface {
+	char name[25];
+	__u8 storage_mode;	/* Indicates whether it is field or field 
+				   based storage mode */
+	unsigned long hpitch;
+};
+
+/* Structure for vpif parameters for raw vbi data */
+struct vpif_vbi_params {
+	__u32 hstart0;  /* Horizontal start of raw vbi data for first field */
+	__u32 vstart0;  /* Vertical start of raw vbi data for first field */  
+	__u32 hsize0;   /* Horizontal size of raw vbi data for first field */
+	__u32 vsize0;   /* Vertical size of raw vbi data for first field */
+	__u32 hstart1;  /* Horizontal start of raw vbi data for second field */
+	__u32 vstart1;  /* Vertical start of raw vbi data for second field */
+	__u32 hsize1;   /* Horizontal size of raw vbi data for second field */
+	__u32 vsize1;   /* Vertical size of raw vbi data for second field */		
+};
+
+struct vpif_params {
+	struct vpif_interface video_params;
+	union param{
+		struct vpif_vbi_params      	vbi_params; 
+		vpif_capture_params_raw 	raw_params;
+	}params;
+};
+
+#endif				/* End of #ifndef VPIF_H */
+
Index: linux-2.6.10/arch/arm/mach-davinci/video_hdevm.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/arm/mach-davinci/video_hdevm.c
@@ -0,0 +1,245 @@
+/*
+ *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option)any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
+ */
+/* video_hdevm.h */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <asm/arch/video_hdevm.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#define CPLD_BASE_ADDRESS	(0x3A)
+#define CPLD_RESET_POWER_REG	(0)
+#define CPLD_VIDEO_REG		(0x3B)
+#define CDCE949			(0x6C)
+static int cpld_initialized = 0;
+
+
+int cpld_init() {
+	int err = 0;
+	/* power up tvp5147 and tvp7002 */
+	u8 val=0x0;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if (!err) {
+		cpld_initialized = 1;
+	}
+	return err;
+}
+void cpld_cleanup() {
+}
+int set_cpld_for_tvp5147() {
+	int err = 0;
+        u8 val;
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xEF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	return err;
+}
+
+int set_cpld_for_tvp7002() {
+	int err = 0;
+	u8 val;
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x10;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	return err;
+}
+
+int set_vid_in_mode_for_tvp5147() {
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	volatile unsigned int sys_vsclk =
+		(volatile unsigned int )IO_ADDRESS(0x01C40038);
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xDF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value |= (1<<4);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+int set_vid_in_mode_for_tvp7002() {
+
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	volatile unsigned int sys_vsclk =
+		(volatile unsigned int )IO_ADDRESS(0x01C40038);
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x20;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value &= ~(1<<4);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+int set_vid_out_mode_for_sd() {
+
+	int err = 0;
+	u8 val;
+
+	unsigned int value;
+	volatile unsigned int sys_vsclk =
+		(volatile unsigned int )IO_ADDRESS(0x01C40038);
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xBF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value &= ~(7<<8);
+	value |= (3<<8);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+int set_vid_clock(int hd) 
+{
+	int err = 0;
+	unsigned int value;
+	volatile unsigned int sys_vsclk =
+		(volatile unsigned int )IO_ADDRESS(0x01C40038);
+	if(hd >= 1) {
+		value = inl(sys_vsclk);
+		value &= ~(7<<8);
+		value &= ~(7<<12);
+		value |= (2<<8);
+		value |= (2<<12);
+		outl(value, sys_vsclk);
+	} else {
+		value = inl(sys_vsclk);
+		value &= ~(7<<8);
+		value |= (3<<8);
+		value |= (3<<12);
+		outl(value, sys_vsclk);
+	}
+	return err;
+}
+
+int set_vid_out_mode_for_hd() {
+
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	volatile unsigned int sys_vsclk =
+		(volatile unsigned int )IO_ADDRESS(0x01C40038);
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x40;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+        value = inl(sys_vsclk);
+        value &= ~(7<<8);
+        value &= ~(7<<12);
+	value |= (2<<8);
+	value |= (2<<12);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+/*
+Capture :: bits PTSIMUX = 0x, PTSOMUX = 0x, STSIMUX = 00
+Display :: bits STSOMUX = 0x, PTSOMUX = 0x, STSIMUX = 00
+
+bits
+17:16 PTSIMUX
+19:18 PTSOMUX
+21:20 STSIMUX
+23:22 STSOMUX
+
+*/
+void set_vpif_pinmux()
+{
+
+	volatile unsigned int pinmux0
+	       	= (volatile unsigned int )IO_ADDRESS(0x01C40000);
+	volatile unsigned int sys_vsclkdis =
+		(volatile unsigned int )IO_ADDRESS(0x01C4006C);
+	volatile unsigned int sys_vdd3p3vpwdn =
+		(volatile unsigned int )IO_ADDRESS(0x01C40048);
+	unsigned int value;
+
+	/* make 17th bit(PTSIMUX), 19th bit(PTSOMUX), 21:20 bits(STSIMUX), 23rd
+	 * bit(STSOMUX) to zero */
+	value = inl(pinmux0);
+	value &= ~(unsigned int)(0x00FF0000);
+	outl(value, pinmux0);
+
+	value = inl(sys_vsclkdis);
+	value &= ~(unsigned int)(0x00000F00);
+	outl(value, sys_vsclkdis);
+
+	value = inl(sys_vdd3p3vpwdn);
+	value &= ~(unsigned int)(0x0000000F);
+	outl(value, sys_vdd3p3vpwdn);
+	
+	return;
+}
+
+EXPORT_SYMBOL(set_cpld_for_tvp5147);
+EXPORT_SYMBOL(set_cpld_for_tvp7002);
+EXPORT_SYMBOL(set_vid_in_mode_for_tvp5147);
+EXPORT_SYMBOL(set_vid_in_mode_for_tvp7002);
+EXPORT_SYMBOL(set_vid_out_mode_for_sd);
+EXPORT_SYMBOL(set_vid_out_mode_for_hd);
+EXPORT_SYMBOL(set_vpif_pinmux);
+EXPORT_SYMBOL(set_vid_clock);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(cpld_init);
+module_exit(cpld_cleanup);
Index: linux-2.6.10/include/asm-arm/arch-davinci/video_hdevm.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/video_hdevm.h
@@ -0,0 +1,39 @@
+/* 
+ *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option)any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
+ */
+/* video_hdevm.c */
+#ifndef CPLD_FUNCTIONS_H
+#define CPLD_FUNCTIONS_H
+
+int cpld_init(void);
+void cpld_cleanup(void);
+
+int set_cpld_for_tvp5147(void);
+
+int set_cpld_for_tvp7002(void);
+
+int set_vid_in_mode_for_tvp5147(void);
+
+int set_vid_in_mode_for_tvp7002(void);
+
+int set_vid_out_mode_for_sd(void);
+
+int set_vid_out_mode_for_hd(void);
+void set_vpif_pinmux(void);
+int set_vid_clock(int);
+#endif /* CPLD_FUNCTIONS_H */
Index: linux-2.6.10/mvl_patches/pro-1696.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1696.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1696);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

