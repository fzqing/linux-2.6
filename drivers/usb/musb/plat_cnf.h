/******************************************************************
 * Copyright 2005 Mentor Graphics Corporation
 * Copyright (C) 2005-2006 by Texas Instruments
 *
 * This file is part of the Inventra Controller Driver for Linux.
 *
 * The Inventra Controller Driver for Linux is free software; you
 * can redistribute it and/or modify it under the terms of the GNU
 * General Public License version 2 as published by the Free Software
 * Foundation.
 *
 * The Inventra Controller Driver for Linux is distributed in
 * the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with The Inventra Controller Driver for Linux ; if not,
 * write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA  02111-1307  USA
 *
 * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
 * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
 * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
 * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
 * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
 * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
 * GRAPHICS SUPPORT CUSTOMER.
 ******************************************************************/

/*
 * Linux-specific platform configuration.
 */

#ifndef __MUSB_LINUX_CONFIG_H__
#define __MUSB_LINUX_CONFIG_H__

/*
 * Get core configuration from a header converted (by cfg_conv)
 * from the Verilog config file generated by the core config utility
 *
 * For now we assume that header is provided along with other
 * arch-specific files.  Discrete chips will need a build tweak.
 * So will using AHB IDs from silicon that provides them.
 */
#ifdef CONFIG_ARCH_DAVINCI
#include <asm/arch/hdrc_cnf.h>
#endif
/*
 * Handle dynamic FIFO sizing in a way that doesn't create more code
 * (but could make your brain hurt)
 *
 * FIXME simplify: just provide a handful of predefined configurations
 */
#ifdef MUSB_C_DYNFIFO_DEF
#define MGC_DFIFO_TOTAL (1 << (MUSB_C_RAM_BITS + 2))

/* values for the SZ field */
#define MGC_BLK_SZ 6		/* 512 bytes */
#define MGC_CTL_SZ 3		/* 64 bytes */
#define MGC_ALL_SZ 0		/* 8 bytes minimum for anything (hubs to 64 ports, most HIDs) */

#ifdef MUSB_C_HB_TX
#define MGC_ISO_TX_SZ 9		/* 4096 bytes for high-bandwidth (needs 3072) */
#else
#define MGC_ISO_TX_SZ 7		/* 1024 bytes for normal-bandwidth */
#endif

#ifdef MUSB_C_HB_RX
#define MGC_ISO_RX_SZ 9		/* 4096 bytes for high-bandwidth (needs 3072) */
#else
#define MGC_ISO_RX_SZ 7		/* 1024 bytes for normal-bandwidth */
#endif

/*
 * Define desires by subtracting all, so impossible ones become negatives
 */
#if MUSB_C_NUM_EPS > 2

#define MGC_BLK_DB 1
/* isoch Tx: try a double-buffered one with a double-buffered bulk */
#define MGC_ISO_TX_DB 1
#define MGC_DFIFO_ISO_TX (MGC_DFIFO_TOTAL - (1 << (MGC_ISO_TX_SZ+4)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#if MGC_DFIFO_ISO_TX < 0
/* no good; try with a single-buffered bulk */
#undef MGC_BLK_DB
#define MGC_BLK_DB 0
#undef MGC_DFIFO_ISO_TX
#define MGC_DFIFO_ISO_TX (MGC_DFIFO_TOTAL - (1 << (MGC_ISO_TX_SZ+4)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#endif
#if MGC_DFIFO_ISO_TX < 0
/* still no good; try single-buffered isoch Tx */
#undef MGC_DFIFO_ISO_TX
#undef MGC_ISO_TX_DB
#define MGC_ISO_TX_DB 0
#define MGC_DFIFO_ISO_TX (MGC_DFIFO_TOTAL - (1 << (MGC_ISO_TX_SZ+3)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#endif
/* actual isoch Tx size */
#define MGC_DFIFO_ISO_TX_SIZE ((MGC_DFIFO_ISO_TX < 0) ? 0 : (1 << (MGC_ISO_TX_SZ+3+MGC_ISO_TX_DB)))

/* isoch Rx: try a double-buffered one with a (current)-buffered bulk */
#define MGC_ISO_RX_DB 1
#define MGC_DFIFO_ISO_RX (MGC_DFIFO_TOTAL - MGC_DFIFO_ISO_TX_SIZE - (1 << (MGC_ISO_RX_SZ+4)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#if MGC_DFIFO_ISO_RX < 0
/* no good; try with a single-buffered bulk */
#undef MGC_BLK_DB
#define MGC_BLK_DB 0
#undef MGC_DFIFO_ISO_RX
#define MGC_DFIFO_ISO_RX (MGC_DFIFO_TOTAL - MGC_DFIFO_ISO_TX_SIZE - (1 << (MGC_ISO_RX_SZ+4)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#endif
#if MGC_DFIFO_ISO_RX < 0
/* still no good; try single-buffered isoch Rx */
#undef MGC_DFIFO_ISO_RX
#undef MGC_ISO_RX_DB
#define MGC_ISO_RX_DB 0
#define MGC_DFIFO_ISO_RX (MGC_DFIFO_TOTAL - MGC_DFIFO_ISO_TX_SIZE - (1 << (MGC_ISO_RX_SZ+3)) - (1 << (MGC_BLK_SZ+3+MGC_BLK_DB)) - (1 << (MGC_CTL_SZ+3)) - ((MUSB_C_NUM_EPS - 3) * (1 << (MGC_ALL_SZ+3))))
#endif
/* actual isoch Rx size */
#define MGC_DFIFO_ISO_RX_SIZE ((MGC_DFIFO_ISO_RX < 0) ? 0 : (1 << (MGC_ISO_RX_SZ+3+MGC_ISO_RX_DB)))

/* register values the code may use */
#define MGC_DFIFO_ISO_TX_VAL ((MGC_ISO_TX_DB << 4) | MGC_ISO_TX_SZ)
#define MGC_DFIFO_ISO_RX_VAL ((MGC_ISO_RX_DB << 4) | MGC_ISO_RX_SZ)
#define MGC_DFIFO_BLK_VAL ((MGC_BLK_DB << 4) | MGC_BLK_SZ)

#else				/* !(MUSB_C_NUM_EPS > 2) */

/* <= 2 endpoints; make one suitable for bulk */
#if MGC_DFIFO_TOTAL > 1024
#define MGC_BLK_DB 1
#else
#define MGC_BLK_DB 0
#endif
#define MGC_DFIFO_BLK_VAL ((MGC_BLK_DB << 4) | MGC_BLK_SZ)
#define MGC_DFIFO_ISO_TX -1
#define MGC_DFIFO_ISO_TX_SIZE 0
#define MGC_DFIFO_ISO_RX -1
#define MGC_DFIFO_ISO_RX_SIZE 0

#endif				/* MUSB_C_NUM_EPS > 2 */

/* now compute actual size per remaining end */
#define MGC_DFIFO_BLK_SIZE (1 << (MGC_BLK_SZ+3+MGC_BLK_DB))
#define MGC_DFIFO_CTL_SIZE (1 << (MGC_CTL_SZ+3))
#define MGC_DFIFO_REMAIN (MGC_DFIFO_TOTAL - MGC_DFIFO_ISO_TX_SIZE - MGC_DFIFO_ISO_RX_SIZE - MGC_DFIFO_BLK_SIZE - MGC_DFIFO_CTL_SIZE)

/* but, if there's a problem, throw out bulk and try again */
#if MGC_DFIFO_REMAIN < 0
#undef MGC_DFIFO_BLK_SIZE
#undef MGC_DFIFO_BLK_VAL
#define MGC_DFIFO_BLK_SIZE 0
#define MGC_DFIFO_BLK_VAL 0
#define MGC_DFIFO_REMAIN (MGC_DFIFO_TOTAL - MGC_DFIFO_ISO_TX_SIZE - MGC_DFIFO_ISO_RX_SIZE - MGC_DFIFO_BLK_SIZE - MGC_DFIFO_CTL_SIZE)
#endif

#define MGC_DFIFO_ALL_COUNT (MUSB_C_NUM_EPS - ((MGC_DFIFO_ISO_TX < 0) ? 0 : 1) - ((MGC_DFIFO_ISO_RX < 0) ? 0 : 1) - (MGC_DFIFO_BLK_SIZE ? 1 : 0) - 1)
#if MGC_DFIFO_ALL_COUNT > 0
#define MGC_DFIFO_ALL_SIZE (MGC_DFIFO_REMAIN / MGC_DFIFO_ALL_COUNT)
#else
#define MGC_DFIFO_ALL_SIZE 0
#endif
/* set value for remaining */
#if MGC_DFIFO_ALL_SIZE >= 4096
#define MGC_DFIFO_ALL_VAL 9
#elif MGC_DFIFO_ALL_SIZE >= 2048
#define MGC_DFIFO_ALL_VAL 8
#elif MGC_DFIFO_ALL_SIZE >= 1024
#define MGC_DFIFO_ALL_VAL 7
#elif MGC_DFIFO_ALL_SIZE >= 512
#define MGC_DFIFO_ALL_VAL 6
#elif MGC_DFIFO_ALL_SIZE >= 256
#define MGC_DFIFO_ALL_VAL 5
#elif MGC_DFIFO_ALL_SIZE >= 128
#define MGC_DFIFO_ALL_VAL 4
#elif MGC_DFIFO_ALL_SIZE >= 64
#define MGC_DFIFO_ALL_VAL 3
#elif MGC_DFIFO_ALL_SIZE >= 32
#define MGC_DFIFO_ALL_VAL 2
#elif MGC_DFIFO_ALL_SIZE >= 16
#define MGC_DFIFO_ALL_VAL 1
#else
#define MGC_DFIFO_ALL_VAL 0
#endif

#endif				/* MUSB_C_DYNFIFO_DEF */

#endif				/* __MUSB_LINUX_CONFIG_H__ */
